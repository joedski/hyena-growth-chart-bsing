{"version":3,"sources":["skywolf_files/node_modules/browser-pack/_prelude.js","skywolf_files/client/app/graph/curves.js","skywolf_files/client/app/graph/growth.js","skywolf_files/client/app/graph/index.js","skywolf_files/client/app/graph/utils.js","skywolf_files/client/app/growth-mass-chart.js","skywolf_files/client/app/index.js","skywolf_files/client/app/page.js","skywolf_files/client/pages/skywolf/growthFunctions.js","skywolf_files/client/pages/skywolf/index.js","skywolf_files/node_modules/core-js/index.js","skywolf_files/node_modules/core-js/modules/_a-function.js","skywolf_files/node_modules/core-js/modules/_a-number-value.js","skywolf_files/node_modules/core-js/modules/_add-to-unscopables.js","skywolf_files/node_modules/core-js/modules/_an-instance.js","skywolf_files/node_modules/core-js/modules/_an-object.js","skywolf_files/node_modules/core-js/modules/_array-copy-within.js","skywolf_files/node_modules/core-js/modules/_array-fill.js","skywolf_files/node_modules/core-js/modules/_array-from-iterable.js","skywolf_files/node_modules/core-js/modules/_array-includes.js","skywolf_files/node_modules/core-js/modules/_array-methods.js","skywolf_files/node_modules/core-js/modules/_array-reduce.js","skywolf_files/node_modules/core-js/modules/_array-species-constructor.js","skywolf_files/node_modules/core-js/modules/_array-species-create.js","skywolf_files/node_modules/core-js/modules/_bind.js","skywolf_files/node_modules/core-js/modules/_classof.js","skywolf_files/node_modules/core-js/modules/_cof.js","skywolf_files/node_modules/core-js/modules/_collection-strong.js","skywolf_files/node_modules/core-js/modules/_collection-to-json.js","skywolf_files/node_modules/core-js/modules/_collection-weak.js","skywolf_files/node_modules/core-js/modules/_collection.js","skywolf_files/node_modules/core-js/modules/_core.js","skywolf_files/node_modules/core-js/modules/_create-property.js","skywolf_files/node_modules/core-js/modules/_ctx.js","skywolf_files/node_modules/core-js/modules/_date-to-primitive.js","skywolf_files/node_modules/core-js/modules/_defined.js","skywolf_files/node_modules/core-js/modules/_descriptors.js","skywolf_files/node_modules/core-js/modules/_dom-create.js","skywolf_files/node_modules/core-js/modules/_enum-bug-keys.js","skywolf_files/node_modules/core-js/modules/_enum-keys.js","skywolf_files/node_modules/core-js/modules/_export.js","skywolf_files/node_modules/core-js/modules/_fails-is-regexp.js","skywolf_files/node_modules/core-js/modules/_fails.js","skywolf_files/node_modules/core-js/modules/_fix-re-wks.js","skywolf_files/node_modules/core-js/modules/_flags.js","skywolf_files/node_modules/core-js/modules/_for-of.js","skywolf_files/node_modules/core-js/modules/_global.js","skywolf_files/node_modules/core-js/modules/_has.js","skywolf_files/node_modules/core-js/modules/_hide.js","skywolf_files/node_modules/core-js/modules/_html.js","skywolf_files/node_modules/core-js/modules/_ie8-dom-define.js","skywolf_files/node_modules/core-js/modules/_inherit-if-required.js","skywolf_files/node_modules/core-js/modules/_invoke.js","skywolf_files/node_modules/core-js/modules/_iobject.js","skywolf_files/node_modules/core-js/modules/_is-array-iter.js","skywolf_files/node_modules/core-js/modules/_is-array.js","skywolf_files/node_modules/core-js/modules/_is-integer.js","skywolf_files/node_modules/core-js/modules/_is-object.js","skywolf_files/node_modules/core-js/modules/_is-regexp.js","skywolf_files/node_modules/core-js/modules/_iter-call.js","skywolf_files/node_modules/core-js/modules/_iter-create.js","skywolf_files/node_modules/core-js/modules/_iter-define.js","skywolf_files/node_modules/core-js/modules/_iter-detect.js","skywolf_files/node_modules/core-js/modules/_iter-step.js","skywolf_files/node_modules/core-js/modules/_iterators.js","skywolf_files/node_modules/core-js/modules/_keyof.js","skywolf_files/node_modules/core-js/modules/_library.js","skywolf_files/node_modules/core-js/modules/_math-expm1.js","skywolf_files/node_modules/core-js/modules/_math-log1p.js","skywolf_files/node_modules/core-js/modules/_math-sign.js","skywolf_files/node_modules/core-js/modules/_meta.js","skywolf_files/node_modules/core-js/modules/_metadata.js","skywolf_files/node_modules/core-js/modules/_microtask.js","skywolf_files/node_modules/core-js/modules/_object-assign.js","skywolf_files/node_modules/core-js/modules/_object-create.js","skywolf_files/node_modules/core-js/modules/_object-define.js","skywolf_files/node_modules/core-js/modules/_object-dp.js","skywolf_files/node_modules/core-js/modules/_object-dps.js","skywolf_files/node_modules/core-js/modules/_object-forced-pam.js","skywolf_files/node_modules/core-js/modules/_object-gopd.js","skywolf_files/node_modules/core-js/modules/_object-gopn-ext.js","skywolf_files/node_modules/core-js/modules/_object-gopn.js","skywolf_files/node_modules/core-js/modules/_object-gops.js","skywolf_files/node_modules/core-js/modules/_object-gpo.js","skywolf_files/node_modules/core-js/modules/_object-keys-internal.js","skywolf_files/node_modules/core-js/modules/_object-keys.js","skywolf_files/node_modules/core-js/modules/_object-pie.js","skywolf_files/node_modules/core-js/modules/_object-sap.js","skywolf_files/node_modules/core-js/modules/_object-to-array.js","skywolf_files/node_modules/core-js/modules/_own-keys.js","skywolf_files/node_modules/core-js/modules/_parse-float.js","skywolf_files/node_modules/core-js/modules/_parse-int.js","skywolf_files/node_modules/core-js/modules/_partial.js","skywolf_files/node_modules/core-js/modules/_path.js","skywolf_files/node_modules/core-js/modules/_property-desc.js","skywolf_files/node_modules/core-js/modules/_redefine-all.js","skywolf_files/node_modules/core-js/modules/_redefine.js","skywolf_files/node_modules/core-js/modules/_replacer.js","skywolf_files/node_modules/core-js/modules/_same-value.js","skywolf_files/node_modules/core-js/modules/_set-proto.js","skywolf_files/node_modules/core-js/modules/_set-species.js","skywolf_files/node_modules/core-js/modules/_set-to-string-tag.js","skywolf_files/node_modules/core-js/modules/_shared-key.js","skywolf_files/node_modules/core-js/modules/_shared.js","skywolf_files/node_modules/core-js/modules/_species-constructor.js","skywolf_files/node_modules/core-js/modules/_strict-method.js","skywolf_files/node_modules/core-js/modules/_string-at.js","skywolf_files/node_modules/core-js/modules/_string-context.js","skywolf_files/node_modules/core-js/modules/_string-html.js","skywolf_files/node_modules/core-js/modules/_string-pad.js","skywolf_files/node_modules/core-js/modules/_string-repeat.js","skywolf_files/node_modules/core-js/modules/_string-trim.js","skywolf_files/node_modules/core-js/modules/_string-ws.js","skywolf_files/node_modules/core-js/modules/_task.js","skywolf_files/node_modules/core-js/modules/_to-index.js","skywolf_files/node_modules/core-js/modules/_to-integer.js","skywolf_files/node_modules/core-js/modules/_to-iobject.js","skywolf_files/node_modules/core-js/modules/_to-length.js","skywolf_files/node_modules/core-js/modules/_to-object.js","skywolf_files/node_modules/core-js/modules/_to-primitive.js","skywolf_files/node_modules/core-js/modules/_typed-array.js","skywolf_files/node_modules/core-js/modules/_typed-buffer.js","skywolf_files/node_modules/core-js/modules/_typed.js","skywolf_files/node_modules/core-js/modules/_uid.js","skywolf_files/node_modules/core-js/modules/_wks-define.js","skywolf_files/node_modules/core-js/modules/_wks-ext.js","skywolf_files/node_modules/core-js/modules/_wks.js","skywolf_files/node_modules/core-js/modules/core.delay.js","skywolf_files/node_modules/core-js/modules/core.dict.js","skywolf_files/node_modules/core-js/modules/core.function.part.js","skywolf_files/node_modules/core-js/modules/core.get-iterator-method.js","skywolf_files/node_modules/core-js/modules/core.get-iterator.js","skywolf_files/node_modules/core-js/modules/core.is-iterable.js","skywolf_files/node_modules/core-js/modules/core.number.iterator.js","skywolf_files/node_modules/core-js/modules/core.object.classof.js","skywolf_files/node_modules/core-js/modules/core.object.define.js","skywolf_files/node_modules/core-js/modules/core.object.is-object.js","skywolf_files/node_modules/core-js/modules/core.object.make.js","skywolf_files/node_modules/core-js/modules/core.regexp.escape.js","skywolf_files/node_modules/core-js/modules/core.string.escape-html.js","skywolf_files/node_modules/core-js/modules/core.string.unescape-html.js","skywolf_files/node_modules/core-js/modules/es6.array.copy-within.js","skywolf_files/node_modules/core-js/modules/es6.array.every.js","skywolf_files/node_modules/core-js/modules/es6.array.fill.js","skywolf_files/node_modules/core-js/modules/es6.array.filter.js","skywolf_files/node_modules/core-js/modules/es6.array.find-index.js","skywolf_files/node_modules/core-js/modules/es6.array.find.js","skywolf_files/node_modules/core-js/modules/es6.array.for-each.js","skywolf_files/node_modules/core-js/modules/es6.array.from.js","skywolf_files/node_modules/core-js/modules/es6.array.index-of.js","skywolf_files/node_modules/core-js/modules/es6.array.is-array.js","skywolf_files/node_modules/core-js/modules/es6.array.iterator.js","skywolf_files/node_modules/core-js/modules/es6.array.join.js","skywolf_files/node_modules/core-js/modules/es6.array.last-index-of.js","skywolf_files/node_modules/core-js/modules/es6.array.map.js","skywolf_files/node_modules/core-js/modules/es6.array.of.js","skywolf_files/node_modules/core-js/modules/es6.array.reduce-right.js","skywolf_files/node_modules/core-js/modules/es6.array.reduce.js","skywolf_files/node_modules/core-js/modules/es6.array.slice.js","skywolf_files/node_modules/core-js/modules/es6.array.some.js","skywolf_files/node_modules/core-js/modules/es6.array.sort.js","skywolf_files/node_modules/core-js/modules/es6.array.species.js","skywolf_files/node_modules/core-js/modules/es6.date.now.js","skywolf_files/node_modules/core-js/modules/es6.date.to-iso-string.js","skywolf_files/node_modules/core-js/modules/es6.date.to-json.js","skywolf_files/node_modules/core-js/modules/es6.date.to-primitive.js","skywolf_files/node_modules/core-js/modules/es6.date.to-string.js","skywolf_files/node_modules/core-js/modules/es6.function.bind.js","skywolf_files/node_modules/core-js/modules/es6.function.has-instance.js","skywolf_files/node_modules/core-js/modules/es6.function.name.js","skywolf_files/node_modules/core-js/modules/es6.map.js","skywolf_files/node_modules/core-js/modules/es6.math.acosh.js","skywolf_files/node_modules/core-js/modules/es6.math.asinh.js","skywolf_files/node_modules/core-js/modules/es6.math.atanh.js","skywolf_files/node_modules/core-js/modules/es6.math.cbrt.js","skywolf_files/node_modules/core-js/modules/es6.math.clz32.js","skywolf_files/node_modules/core-js/modules/es6.math.cosh.js","skywolf_files/node_modules/core-js/modules/es6.math.expm1.js","skywolf_files/node_modules/core-js/modules/es6.math.fround.js","skywolf_files/node_modules/core-js/modules/es6.math.hypot.js","skywolf_files/node_modules/core-js/modules/es6.math.imul.js","skywolf_files/node_modules/core-js/modules/es6.math.log10.js","skywolf_files/node_modules/core-js/modules/es6.math.log1p.js","skywolf_files/node_modules/core-js/modules/es6.math.log2.js","skywolf_files/node_modules/core-js/modules/es6.math.sign.js","skywolf_files/node_modules/core-js/modules/es6.math.sinh.js","skywolf_files/node_modules/core-js/modules/es6.math.tanh.js","skywolf_files/node_modules/core-js/modules/es6.math.trunc.js","skywolf_files/node_modules/core-js/modules/es6.number.constructor.js","skywolf_files/node_modules/core-js/modules/es6.number.epsilon.js","skywolf_files/node_modules/core-js/modules/es6.number.is-finite.js","skywolf_files/node_modules/core-js/modules/es6.number.is-integer.js","skywolf_files/node_modules/core-js/modules/es6.number.is-nan.js","skywolf_files/node_modules/core-js/modules/es6.number.is-safe-integer.js","skywolf_files/node_modules/core-js/modules/es6.number.max-safe-integer.js","skywolf_files/node_modules/core-js/modules/es6.number.min-safe-integer.js","skywolf_files/node_modules/core-js/modules/es6.number.parse-float.js","skywolf_files/node_modules/core-js/modules/es6.number.parse-int.js","skywolf_files/node_modules/core-js/modules/es6.number.to-fixed.js","skywolf_files/node_modules/core-js/modules/es6.number.to-precision.js","skywolf_files/node_modules/core-js/modules/es6.object.assign.js","skywolf_files/node_modules/core-js/modules/es6.object.create.js","skywolf_files/node_modules/core-js/modules/es6.object.define-properties.js","skywolf_files/node_modules/core-js/modules/es6.object.define-property.js","skywolf_files/node_modules/core-js/modules/es6.object.freeze.js","skywolf_files/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","skywolf_files/node_modules/core-js/modules/es6.object.get-own-property-names.js","skywolf_files/node_modules/core-js/modules/es6.object.get-prototype-of.js","skywolf_files/node_modules/core-js/modules/es6.object.is-extensible.js","skywolf_files/node_modules/core-js/modules/es6.object.is-frozen.js","skywolf_files/node_modules/core-js/modules/es6.object.is-sealed.js","skywolf_files/node_modules/core-js/modules/es6.object.is.js","skywolf_files/node_modules/core-js/modules/es6.object.keys.js","skywolf_files/node_modules/core-js/modules/es6.object.prevent-extensions.js","skywolf_files/node_modules/core-js/modules/es6.object.seal.js","skywolf_files/node_modules/core-js/modules/es6.object.set-prototype-of.js","skywolf_files/node_modules/core-js/modules/es6.object.to-string.js","skywolf_files/node_modules/core-js/modules/es6.parse-float.js","skywolf_files/node_modules/core-js/modules/es6.parse-int.js","skywolf_files/node_modules/core-js/modules/es6.promise.js","skywolf_files/node_modules/core-js/modules/es6.reflect.apply.js","skywolf_files/node_modules/core-js/modules/es6.reflect.construct.js","skywolf_files/node_modules/core-js/modules/es6.reflect.define-property.js","skywolf_files/node_modules/core-js/modules/es6.reflect.delete-property.js","skywolf_files/node_modules/core-js/modules/es6.reflect.enumerate.js","skywolf_files/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js","skywolf_files/node_modules/core-js/modules/es6.reflect.get-prototype-of.js","skywolf_files/node_modules/core-js/modules/es6.reflect.get.js","skywolf_files/node_modules/core-js/modules/es6.reflect.has.js","skywolf_files/node_modules/core-js/modules/es6.reflect.is-extensible.js","skywolf_files/node_modules/core-js/modules/es6.reflect.own-keys.js","skywolf_files/node_modules/core-js/modules/es6.reflect.prevent-extensions.js","skywolf_files/node_modules/core-js/modules/es6.reflect.set-prototype-of.js","skywolf_files/node_modules/core-js/modules/es6.reflect.set.js","skywolf_files/node_modules/core-js/modules/es6.regexp.constructor.js","skywolf_files/node_modules/core-js/modules/es6.regexp.flags.js","skywolf_files/node_modules/core-js/modules/es6.regexp.match.js","skywolf_files/node_modules/core-js/modules/es6.regexp.replace.js","skywolf_files/node_modules/core-js/modules/es6.regexp.search.js","skywolf_files/node_modules/core-js/modules/es6.regexp.split.js","skywolf_files/node_modules/core-js/modules/es6.regexp.to-string.js","skywolf_files/node_modules/core-js/modules/es6.set.js","skywolf_files/node_modules/core-js/modules/es6.string.anchor.js","skywolf_files/node_modules/core-js/modules/es6.string.big.js","skywolf_files/node_modules/core-js/modules/es6.string.blink.js","skywolf_files/node_modules/core-js/modules/es6.string.bold.js","skywolf_files/node_modules/core-js/modules/es6.string.code-point-at.js","skywolf_files/node_modules/core-js/modules/es6.string.ends-with.js","skywolf_files/node_modules/core-js/modules/es6.string.fixed.js","skywolf_files/node_modules/core-js/modules/es6.string.fontcolor.js","skywolf_files/node_modules/core-js/modules/es6.string.fontsize.js","skywolf_files/node_modules/core-js/modules/es6.string.from-code-point.js","skywolf_files/node_modules/core-js/modules/es6.string.includes.js","skywolf_files/node_modules/core-js/modules/es6.string.italics.js","skywolf_files/node_modules/core-js/modules/es6.string.iterator.js","skywolf_files/node_modules/core-js/modules/es6.string.link.js","skywolf_files/node_modules/core-js/modules/es6.string.raw.js","skywolf_files/node_modules/core-js/modules/es6.string.repeat.js","skywolf_files/node_modules/core-js/modules/es6.string.small.js","skywolf_files/node_modules/core-js/modules/es6.string.starts-with.js","skywolf_files/node_modules/core-js/modules/es6.string.strike.js","skywolf_files/node_modules/core-js/modules/es6.string.sub.js","skywolf_files/node_modules/core-js/modules/es6.string.sup.js","skywolf_files/node_modules/core-js/modules/es6.string.trim.js","skywolf_files/node_modules/core-js/modules/es6.symbol.js","skywolf_files/node_modules/core-js/modules/es6.typed.array-buffer.js","skywolf_files/node_modules/core-js/modules/es6.typed.data-view.js","skywolf_files/node_modules/core-js/modules/es6.typed.float32-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.float64-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.int16-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.int32-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.int8-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.uint16-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.uint32-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.uint8-array.js","skywolf_files/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js","skywolf_files/node_modules/core-js/modules/es6.weak-map.js","skywolf_files/node_modules/core-js/modules/es6.weak-set.js","skywolf_files/node_modules/core-js/modules/es7.array.includes.js","skywolf_files/node_modules/core-js/modules/es7.asap.js","skywolf_files/node_modules/core-js/modules/es7.error.is-error.js","skywolf_files/node_modules/core-js/modules/es7.map.to-json.js","skywolf_files/node_modules/core-js/modules/es7.math.iaddh.js","skywolf_files/node_modules/core-js/modules/es7.math.imulh.js","skywolf_files/node_modules/core-js/modules/es7.math.isubh.js","skywolf_files/node_modules/core-js/modules/es7.math.umulh.js","skywolf_files/node_modules/core-js/modules/es7.object.define-getter.js","skywolf_files/node_modules/core-js/modules/es7.object.define-setter.js","skywolf_files/node_modules/core-js/modules/es7.object.entries.js","skywolf_files/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","skywolf_files/node_modules/core-js/modules/es7.object.lookup-getter.js","skywolf_files/node_modules/core-js/modules/es7.object.lookup-setter.js","skywolf_files/node_modules/core-js/modules/es7.object.values.js","skywolf_files/node_modules/core-js/modules/es7.observable.js","skywolf_files/node_modules/core-js/modules/es7.reflect.define-metadata.js","skywolf_files/node_modules/core-js/modules/es7.reflect.delete-metadata.js","skywolf_files/node_modules/core-js/modules/es7.reflect.get-metadata-keys.js","skywolf_files/node_modules/core-js/modules/es7.reflect.get-metadata.js","skywolf_files/node_modules/core-js/modules/es7.reflect.get-own-metadata-keys.js","skywolf_files/node_modules/core-js/modules/es7.reflect.get-own-metadata.js","skywolf_files/node_modules/core-js/modules/es7.reflect.has-metadata.js","skywolf_files/node_modules/core-js/modules/es7.reflect.has-own-metadata.js","skywolf_files/node_modules/core-js/modules/es7.reflect.metadata.js","skywolf_files/node_modules/core-js/modules/es7.set.to-json.js","skywolf_files/node_modules/core-js/modules/es7.string.at.js","skywolf_files/node_modules/core-js/modules/es7.string.match-all.js","skywolf_files/node_modules/core-js/modules/es7.string.pad-end.js","skywolf_files/node_modules/core-js/modules/es7.string.pad-start.js","skywolf_files/node_modules/core-js/modules/es7.string.trim-left.js","skywolf_files/node_modules/core-js/modules/es7.string.trim-right.js","skywolf_files/node_modules/core-js/modules/es7.symbol.async-iterator.js","skywolf_files/node_modules/core-js/modules/es7.symbol.observable.js","skywolf_files/node_modules/core-js/modules/es7.system.global.js","skywolf_files/node_modules/core-js/modules/web.dom.iterable.js","skywolf_files/node_modules/core-js/modules/web.immediate.js","skywolf_files/node_modules/core-js/modules/web.timers.js","skywolf_files/node_modules/core-js/shim.js","skywolf_files/node_modules/d3/d3.js","skywolf_files/node_modules/nvd3/build/nv.d3.js"],"names":[],"mappings":"AAAA;ACAA;;AAEA;;;;;;;;AAQA;;AAEA;AACA;AACA;;;;;QAEgB,Y,GAAA,Y;QAIA,M,GAAA,M;QAIA,I,GAAA,I;QAIA,I,GAAA,I;QAIA,K,GAAA,K;QASA,U,GAAA,U;QAMA,M,GAAA,M;QAOA,I,GAAA,I;QAIA,K,GAAA,K;QAKA,G,GAAA,G;QAMA,K,GAAA,K;QAMA,S,GAAA,S;QAYA,Q,GAAA,Q;QAYA,c,GAAA,c;AAnFT,SAAS,YAAT,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,EAAiC;AACvC,QAAO,CAAC,IAAI,CAAL,IAAU,CAAV,GAAc,IAAI,CAAzB;AACA;;AAEM,SAAS,MAAT,CAAiB,CAAjB,EAAqB;AAC3B,QAAO,CAAP;AACA;;AAEM,SAAS,IAAT,CAAe,CAAf,EAAmB;AACzB,QAAO,IAAI,CAAX;AACA;;AAEM,SAAS,IAAT,CAAe,CAAf,EAAmB;AACzB,QAAO,IAAI,CAAJ,GAAQ,CAAf;AACA;;AAEM,SAAS,KAAT,CAAgB,CAAhB,EAAoB;AAC1B,KAAI,KAAK,IAAI,CAAb;AACA,QAAO,KAAK,EAAZ;AACA;;AAID;;AAEO,SAAS,UAAT,CAAqB,GAArB,EAA2B;AACjC,QAAO,SAAS,SAAT,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,EAA8B;AACpC,SAAO,aAAc,CAAd,EAAiB,CAAjB,EAAoB,IAAK,CAAL,CAApB,CAAP;AACA,EAFD;AAGA;;AAEM,SAAS,MAAT,CAAiB,QAAjB,EAA2B,GAA3B,EAAgC,GAAhC,EAAsC;AAC5C,QAAO,SAAS,QAAT,CAAmB,CAAnB,EAAuB;AAC7B,SAAO,SAAU,IAAK,CAAL,CAAV,EAAoB,IAAK,CAAL,CAApB,EAA8B,CAA9B,CAAP;AACA;AACA,EAHD;AAIA;;AAEM,SAAS,IAAT,CAAe,GAAf,EAAoB,GAApB,EAA0B;AAChC,QAAO,OAAQ,YAAR,EAAsB,GAAtB,EAA2B,GAA3B,CAAP;AACA;;AAEM,SAAS,KAAT,CAAgB,GAAhB,EAAqB,GAArB,EAA2B;AACjC,KAAI,OAAO,KAAM,IAAN,EAAY,IAAK,IAAL,CAAZ,CAAX;AACA,QAAO,OAAQ,WAAY,IAAZ,CAAR,EAA4B,GAA5B,EAAiC,GAAjC,CAAP;AACA;;AAEM,SAAS,GAAT,CAAc,EAAd,EAAmB;AACzB,QAAO,SAAS,KAAT,CAAgB,CAAhB,EAAoB;AAC1B,SAAO,IAAI,GAAI,IAAI,CAAR,CAAX;AACA,EAFD;AAGA;;AAEM,SAAS,KAAT,CAAgB,CAAhB,EAAoB;AAC1B,QAAO,SAAS,OAAT,CAAkB,CAAlB,EAAsB;AAC5B,SAAO,KAAK,GAAL,CAAU,CAAV,EAAa,CAAb,CAAP;AACA,EAFD;AAGA;;AAEM,SAAS,SAAT,CAAoB,EAApB,EAAyB;AAC/B,QAAO,SAAS,WAAT,CAAsB,CAAtB,EAA0B;AAChC,MAAI,KAAK,CAAT,EAAa,OAAO,CAAP,CAAb,KACK,IAAI,KAAK,CAAT,EAAa,OAAO,CAAP,CAAb,KACA,OAAO,GAAI,CAAJ,CAAP;AACL,EAJD;AAKA;;AAID;;AAEO,SAAS,QAAT,CAAmB,EAAnB,EAAuB,EAAvB,EAA2B,EAA3B,EAA+B,EAA/B,EAAmC,EAAnC,EAAwC;AAC9C,KAAI,QAAQ,KAAK,EAAjB;AACA,KAAI,QAAQ,KAAK,EAAjB;AACA,KAAI,MAAM,UAAW,EAAX,CAAV;AACA,QAAO,SAAS,SAAT,CAAoB,CAApB,EAAwB;AAC9B,MAAI,UAAU,CAAC,IAAI,EAAL,IAAW,KAAzB;AACA,SAAO,IAAK,OAAL,IAAiB,KAAjB,GAAyB,EAAhC;AACA,EAHD;AAIA;;AAED;AACA;AACO,SAAS,cAAT,CAAyB,EAAzB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,EAArC,EAAyC,EAAzC,EAA6C,WAA7C,EAA2D;AACjE,KAAI,gBAAgB,KAAK,EAAzB;AACA,KAAI,QAAQ,gBAAgB,WAA5B;AACA,KAAI,YAAY,CAAC,QAAQ,aAAT,IAA0B,CAA1C;AACA,KAAI,MAAM,KAAK,SAAf;AACA,KAAI,MAAM,KAAK,SAAf;AACA,QAAO,SAAU,EAAV,EAAc,GAAd,EAAmB,GAAnB,EAAwB,EAAxB,EAA4B,EAA5B,CAAP;AACA;;;;;;;;QCjEe,a,GAAA,a;QAeA,iB,GAAA,iB;AAxDhB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS,EAAT,CAAa,CAAb,EAAgB,GAAhB,EAAqB,EAArB,EAA0B;AACzB,SAAO,IAAI,CAAC,KAAK,GAAN,KAAc,IAAI,GAAlB,CAAX;AACA;;AAED;;;;;;;;;;;;;;;;;;;;;;;AAuBO,SAAS,aAAT,CAAwB,CAAxB,EAA2B,GAA3B,EAAgC,EAAhC,EAAoC,CAApC,EAAuC,CAAvC,EAA2C;AACjD,MAAI,IAAI,GAAI,CAAJ,EAAO,GAAP,EAAY,EAAZ,CAAR;AACA,SAAO,SAAS,QAAT,CAAmB,CAAnB,EAAuB;AAC7B,WAAO,KAAK,IAAI,IAAI,KAAK,GAAL,CAAS,CAAC,CAAD,GAAK,CAAL,GAAS,CAAlB,CAAb,CAAP;AACA,GAFD;AAGA;;AAED;;;;;;AAMA,IAAM,wBAAwB,QAA9B;;AAEO,SAAS,iBAAT,CAA4B,CAA5B,EAA+B,GAA/B,EAAoC,EAApC,EAAwC,GAAxC,EAA8C;AACnD,SAAO,cAAe,CAAf,EAAkB,GAAlB,EAAuB,EAAvB,EAA2B,qBAA3B,EAAkD,MAAM,EAAxD,CAAP;AACD;;;;;;;;;;AC1DD;;IAAY,M;;AACZ;;IAAY,M;;AACZ;;IAAY,K;;;;QAGV,M,GAAA,M;QACA,M,GAAA,M;QACA,K,GAAA,K;;;;;;;;;;;;;;QCFc,G,GAAA,G;QASA,I,GAAA,I;QAwFA,U,GAAA,U;QA+BA,O,GAAA,O;;AArIhB;;IAAY,E;;AACZ;;;;;;;;AAEA;;AAEO,SAAS,GAAT,GAAuB;AAAA,oCAAN,GAAM;AAAN,OAAM;AAAA;;AAC7B,SAAO,SAAS,WAAT,CAAsB,CAAtB,EAA0B;AAChC,WAAO,IAAI,MAAJ,CACN,SAAS,KAAT,CAAgB,GAAhB,EAAqB,EAArB,EAA0B;AAAE,aAAO,MAAM,GAAI,CAAJ,CAAb;AAAuB,KAD7C,EAEN,CAFM,CAAP;AAIA,GALD;AAMA;;AAEM,SAAS,IAAT,GAAwB;AAAA,qCAAN,GAAM;AAAN,OAAM;AAAA;;AAC9B,SAAO,SAAS,YAAT,CAAuB,CAAvB,EAA2B;AACjC,WAAO,IAAI,WAAJ,CACN,SAAS,MAAT,CAAiB,GAAjB,EAAsB,EAAtB,EAA2B;AAAE,aAAO,GAAI,GAAJ,CAAP;AAAmB,KAD1C,EAEN,CAFM,CAAP;AAIA,GALD;AAMA;;AAID;;AAEA;;;;;;;;IAOa,U,WAAA,U;AACX,sBAAY,KAAZ,EAAmB;AAAA;;AACjB,QAAI,KAAJ,EAAW;AACT,cAAQ,IAAI,IAAJ,CAAS,KAAT,CAAR;AACD,KAFD,MAGK;AACH,cAAQ,IAAI,IAAJ,EAAR;AACD;;AAED,SAAK,MAAL,GAAc;AACZ,YAAM,MAAM,WAAN,EADM;AAEZ,aAAO,MAAM,QAAN,KAAmB,CAFd;AAGZ,WAAK,MAAM,OAAN;AAHO,KAAd;;AAMA,SAAK,MAAL,GAAc,GAAG,MAAH,CAAU,KAAV,CAAd;AACD;;;;iCAEY,M,EAAQ;AACnB;AACA;AACA,UAAM,aAAa,SAAS,EAA5B;;AAEA,UAAM,gBAAgB,KAAK,MAAL,CAAY,GAAZ,GAAkB,CAAlB,GAAsB,UAA5C;AACA,UAAM,kBAAkB,KAAK,MAAL,CAAY,KAAZ,GAAoB,CAApB,GAAwB,KAAK,KAAL,CAAW,gBAAgB,EAA3B,CAAhD;AACA,UAAM,iBAAiB,KAAK,MAAL,CAAY,IAAZ,GAAmB,KAAK,KAAL,CAAW,kBAAkB,EAA7B,CAA1C;;AAEA,aAAO;AACL;AACA,aAAM,gBAAgB,EAAjB,GAAuB,CAFvB;AAGL,eAAQ,kBAAkB,EAAnB,GAAyB,CAH3B;AAIL,cAAM;AAJD,OAAP;AAMD;;;wCAEmB;AAAA;;AAClB,aAAO,aAAK;AACV,YAAM,SAAS,MAAK,YAAL,CAAkB,CAAlB,CAAf;AACA,eAAU,OAAO,IAAjB,SAAyB,MAAK,MAAL,CAAY,OAAO,KAAnB,CAAzB,SAAsD,MAAK,MAAL,CAAY,OAAO,GAAnB,CAAtD;AACD,OAHD;AAID;;;;;;AAKH;;AAEA;;;;;;;AAKO,IAAM,sCAAe,GAAG,KAAH,CAAS,MAAT,GAAkB,MAAlB,CAAyB,CAAE,CAAF,EAAK,CAAL,CAAzB,EAAmC,KAAnC,CAAyC,CAAE,CAAF,EAAK,GAAL,CAAzC,CAArB;;AAEP;;;;;;;;;;;;;;AAcO,SAAS,UAAT,CAAqB,YAArB,EAAmC,SAAnC,EAA+C;AACpD,SAAO;AAEL;AACA,KAAG,KAAH,CAAS,MAAT,GACG,MADH,CACW,YADX,EAEG,KAFH,CAEU,UAAU,GAAV,CAAe;AAAA,WAAK,KAAK,GAAL,CAAU,CAAV,EAAa,IAAE,CAAf,CAAL;AAAA,GAAf,CAFV,CAHK,CAAP;AAOD;;AAID;;AAEA;;;;;;;;;;;;;;;;AAgBA;AACO,SAAS,OAAT,CAAkB,QAAlB,EAA6B;AAClC,MAAI,CAAE,QAAF,IAAc,CAAE,SAAS,MAA7B,EAAsC;AACpC,UAAM,IAAI,KAAJ,iDAAN;AACD;;AAED,6BACG,OAAO,QADV,cACsB;AAClB;AACA;AACA;;AAEA,QAAI,QAAQ;AACV,iBAAW,KADD;AAEV,eAAS,IAFC;AAGV;AACA,iBAAW,SAAS,MAAT,EAJD;AAKV;AACA,YAAM,IANI;AAOV;AACA,SAAG;AARO,KAAZ;;AAWA,aAAS,IAAT,GAAgB;AACd,UAAM,iBACJ,MAAM,OAAN,GACE,aAAc,KAAd,CADF,GAEE,KAHJ;;AAMA,UAAM,iBACJ,eAAe,OAAf,GACE,iBAAkB,cAAlB,CADF,GAEE,aAAc,cAAd,CAHJ;;AAMA,UAAM,YAAY;AAChB,cAAM,eAAe,OAAf,IAA0B,eAAe,SAD/B;AAEhB,eAAO,eAAe;AAFN,OAAlB;;AAKA,cAAQ,cAAR;AACA,aAAO,SAAP;AACD;;AAED,WAAO,EAAE,UAAF,EAAP;AACD,GAxCH;AA0CD;;AAED;AACA,SAAS,YAAT,CAAuB,KAAvB,EAA+B;AAC7B;AACA,MAAM,OAAO,MAAM,SAAN,CAAgB,KAAhB,EAAb;;AAEA,MAAI,CAAE,IAAN,EAAa,oBAAY,KAAZ,IAAmB,UAAnB,EAAyB,SAAS,IAAlC;;AAEb,sBACK,KADL;AAEE,cAFF;AAGE,aAAS,KAHX;AAIE,OAAG,KAAK,IAAL,IAAa,IAAb,GAAoB,KAAK,IAAzB,GAAgC,MAAM;AAJ3C;AAMD;;AAED,SAAS,wBAAT,CAAmC,IAAnC,EAA0C;AACxC,MAAI,KAAK,SAAL,IAAkB,IAAtB,EAA6B,OAAO,KAAK,SAAZ;AAC7B,SAAO,CAAP;AACD;;AAED,SAAS,YAAT,CAAuB,KAAvB,EAA+B;AAC7B,MAAM,QAAQ,MAAM,CAAN,GAAU,yBAA0B,MAAM,IAAhC,CAAxB;AACA,MAAM,aAAa,SAAS,MAAM,IAAN,CAAW,EAAvC;;AAEA,sBACK,KADL;AAEE,aAAS,UAFX;AAGE,UAAM,aAAa,IAAb,GAAoB,MAAM,IAHlC;AAIE,OAAG;AAJL;AAMD;;AAED,SAAS,gBAAT,CAA2B,KAA3B,EAAmC;AACjC,sBACK,KADL;AAEE,eAAW;AAFb;AAID;;;;;;;;;;;kBCrNuB,W;;AANxB;;IAAY,E;;AACZ;;IAAY,E;;;;AAEZ;AACA;;AAEe,SAAS,WAAT,CAAsB,OAAtB,EAAgC;AAC9C,WAAU,OAAO,MAAP,CAAc;AACvB;AACA,aAAW,IAFY;AAGvB,UAAQ,IAHe;AAIrB,SAAO;AACL,UAAO,cADF;AAEL,YAFK,uBAEO;AACV,WAAO,GAAG,MAAH,CAAW,MAAX,CAAP;AACD;AAJI,GAJc;AAUrB,aAAW;AACT,UAAO,uBADE;AAET,YAFS,uBAEG;AACV,QAAM,MAAM,GAAG,MAAH,CAAW,MAAX,CAAZ;AACA,WAAO;AAAA,YAAQ,IAAK,CAAL,CAAR;AAAA,KAAP;AACD;AALQ,GAVU;AAiBrB,eAAa;AACX,UAAO,4BADI;AAEX,YAFW,uBAEC;AACV,QAAM,MAAM,GAAG,MAAH,CAAW,MAAX,CAAZ;AACA,WAAO;AAAA,YAAQ,IAAK,CAAL,CAAR;AAAA,KAAP;AACD;AALU;AAjBQ,EAAd,EAwBP,OAxBO,CAAV;;AA0BA,KAAI,CAAE,QAAQ,SAAd,EAA0B;AACzB,QAAM,IAAI,KAAJ,uDAAN;AACA;;AAED,KAAI,QAAQ,IAAZ;AACA,KAAI,cAAc,EAAlB;;AAEA,KAAI,cAAc;AACjB,MADiB,kBACQ;AAAA,OAAnB,WAAmB,uEAAL,EAAK;;AACxB,OAAI,eAAe;AAClB;AACA,6BAAyB,IAFP;AAGlB,iBAAa,KAHK;AAIlB;AACA,YAAQ,EAAE,MAAM,EAAR,EAAY,OAAO,EAAnB,EAAuB,QAAQ,EAA/B;AALU,IAAnB;;AAQA,OAAI,QAAQ,MAAZ,EAAqB;AACpB,iBAAa,MAAb,GAAsB,QAAQ,MAA9B;AACA;;AAED,WAAQ,GAAG,MAAH,CAAU,gBAAV,GACN,OADM,CACG,YADH,CAAR;;AAIA,SAAM,KAAN,CACE,SADF,CACa,QAAQ,KAAR,CAAc,KAD3B,EAEE,UAFF,CAEc,QAAQ,KAAR,CAAc,SAAd,EAFd;;AAKA,SAAM,MAAN,CACE,SADF,CACa,QAAQ,KAAR,CAAc,KAD3B,EAEE,UAFF,CAEc,QAAQ,KAAR,CAAc,SAAd,EAFd;;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAM,MAAN,CACE,SADF,CACa,QAAQ,WAAR,CAAoB,KADjC,EAEE,UAFF,CAEc,QAAQ,WAAR,CAAoB,SAApB,EAFd;;AAKA,SAAM,MAAN,CACE,SADF,CACa,QAAQ,SAAR,CAAkB,KAD/B,EAEE,UAFF,CAEc,QAAQ,SAAR,CAAkB,SAAlB,EAFd;;AAKA,SAAM,IAAN,CACE,MADF,CACS,CAAE,CAAF,CADT,EAEE,OAFF,CAEW,KAFX;;AAKA,OAAI,YAAY,MAAhB,EAAyB;AACxB,SAAK,UAAL,CAAiB,WAAjB;AACA;;AAED,UAAO,IAAP;AACA,GAvDgB;AAyDjB,YAzDiB,sBAyDL,IAzDK,EAyDE;AAClB,iBAAc,IAAd;AACA,WAAQ,SAAR,CAAkB,KAAlB,CAAyB,WAAzB,EAAuC,IAAvC,CAA6C,KAA7C;AACA,QAAK,MAAL;AACA,UAAO,IAAP;AACA,GA9DgB;AAgEjB,QAhEiB,oBAgER;AACR,SAAM,MAAN;AACA,UAAO,IAAP;AACA,GAnEgB;AAqEjB,UArEiB,sBAqEN;AACV,UAAO,KAAP;AACA,GAvEgB;AAyEjB,SAzEiB,qBAyEP;AACT,UAAO;AACN,WAAO,WAAY,MAAM,KAAN,CAAa,OAAb,CAAZ,CADD;AAEN,YAAQ,WAAY,MAAM,KAAN,CAAa,QAAb,CAAZ;AAFF,IAAP;AAIA,GA9EgB;AAgFjB,kBAhFiB,8BAgFE;AAClB,OAAI,OAAO,KAAK,OAAL,EAAX;AACA,OAAI,sBAAc,MAAM,MAAN,EAAd,CAAJ;;AAEA,OAAI,gBAAgB;AACnB,OAAG,OAAO,IADS;AAEnB,OAAG,OAAO,GAFS;AAGnB,WAAO,KAAK,KAAL,GAAa,OAAO,IAApB,GAA2B,OAAO,KAHtB;AAInB,YAAQ,KAAK,MAAL,GAAc,OAAO,GAArB,GAA2B,OAAO;AAJvB,IAApB;;AAOA,iBAAc,EAAd,GAAmB,cAAc,CAAd,GAAkB,cAAc,KAAnD;AACA,iBAAc,EAAd,GAAmB,cAAc,CAAd,GAAkB,cAAc,MAAnD;;AAEA,UAAO,aAAP;AACA;AA/FgB,EAAlB;;AAkGA,QAAO,WAAP;AACA;;;;;;;;;;AC3ID;;AAEA;;IAAY,K;;AACZ;;;;AACA;;IAAY,I;;;;;;AAEZ,IAAM,QAAQ;AACZ;AADY,CAAd;;QAKE,K,GAAA,K;QACA,K,GAAA,K;QACA,I,GAAA,I;;;;;;;;QCbc,O,GAAA,O;AAAT,SAAS,OAAT,GAAmB;AACxB,MAAM,WAAW;AACf,qBAAiB,SAAS,cAAT,CAAwB,mBAAxB,CADF;AAEf,iBAAa,SAAS,cAAT,CAAwB,oBAAxB,CAFE;AAGf,sBAAkB,SAAS,cAAT,CAAwB,0BAAxB,CAHH;AAIf,iBAAa,SAAS,cAAT,CAAwB,oBAAxB,CAJE;AAKf,iBAAa,SAAS,cAAT,CAAwB,oBAAxB,CALE;AAMf,gBAAY,SAAS,cAAT,CAAwB,YAAxB;AANG,GAAjB;;AASA,SAAO;AACL,sBADK;;AAGL,mBAAe,oBAHV;;AAKL,YALK,oBAKI,SALJ,EAKe;AAClB,eAAS,KAAT,GAAiB,SAAjB;AACA,eAAS,eAAT,CAAyB,SAAzB,GAAqC,SAArC;AACD,KARI;AAUL,iBAVK,yBAUS,SAVT,EAUoB;AACvB,eAAS,gBAAT,CAA0B,SAA1B,GAAsC,SAAtC;AACD,KAZI;AAcL,yBAdK,iCAciB,IAdjB,EAcuB;AAC1B,eAAS,WAAT,CAAqB,SAArB,GAAiC,IAAjC;AACD;AAhBI,GAAP;AAkBD;;;;;;;;;QCNe,a,GAAA,a;QAKA,iB,GAAA,iB;QAQA,mB,GAAA,mB;;AAnChB;;AAMO,IAAM,oCAAc;AACzB,uBAAqB;AACnB;AACA,SAAK,CAFc,EAEX;AACR,OAAG,CAHgB,EAGb;AACN,SAAK,CAJc;AAKnB,QAAI,KAAG,EAAH,GAAQ,CALO,EAKJ;AACf,SAAK,CANc,EAMX;AACR,QAAI,CAPe,EAOZ;AACP;AACA;AACA,SAAK,GAVc,EAUT;AACV,SAAK,GAXc,CAWT;AAXS;AADI,CAApB;;AAgBA,SAAS,aAAT,CAAuB,OAAvB,EAAgC;AAAA,8BACT,QAAQ,mBADC;AAAA,MAC7B,GAD6B,yBAC7B,GAD6B;AAAA,MACxB,CADwB,yBACxB,CADwB;AAAA,MACrB,GADqB,yBACrB,GADqB;AAAA,MAChB,EADgB,yBAChB,EADgB;;AAErC,SAAO,WAAM,MAAN,CAAa,iBAAb,CAA+B,CAA/B,EAAkC,GAAlC,EAAuC,EAAvC,EAA2C,GAA3C,CAAP;AACD;;AAEM,SAAS,iBAAT,CAA2B,OAA3B,EAAoC;AAAA,+BACb,QAAQ,mBADK;AAAA,MACjC,CADiC,0BACjC,CADiC;AAAA,MAC9B,EAD8B,0BAC9B,EAD8B;AAAA,MAC1B,GAD0B,0BAC1B,GAD0B;AAAA,MACrB,GADqB,0BACrB,GADqB;;AAEzC,SAAO,WAAM,KAAN,CAAY,UAAZ,CACL,CAAC,EAAD,EAAK,CAAL,CADK,EAEL,CAAC,GAAD,EAAM,GAAN,CAFK,CAAP;AAID;;AAEM,SAAS,mBAAT,CAA6B,OAA7B,EAAsC;AAC3C,SAAO;AAAA,WAAK,IAAI,QAAQ,mBAAR,CAA4B,EAArC;AAAA,GAAP;AACD;;;;;ACrCD;;IAAY,E;;AACZ;;IAAY,E;;AAEZ;;AAMA;;IAAY,M;;;;;;AAGZ,IAAM,cAAc,UAAK,OAAL,EAApB;AACA,IAAM,wBAAsB,YAAY,aAAxC;AACA,IAAM,mBAAmB,GAAG,MAAH,CAAU,eAAV,CAAzB;;AAEA,IAAM,QAAQ,WAAM,KAAN,CAAY,OAAZ,CAAoB,CAChC,EAAE,MAAM,CAAR,EAAW,IAAI,KAAK,GAApB,EAAyB,WAAW,GAApC,EADgC,CAApB,CAAd;;AAIA,SAAS,SAAT,CAAmB,KAAnB,EAA0B,MAA1B,EAAkC;AAChC,SAAO,6BAAI,KAAJ,GAAW,GAAX,CAAe;AAAA,WAAM;AAC1B,SAAG,CADuB;AAE1B,SAAG,OAAO,CAAP;AAFuB,KAAN;AAAA,GAAf,CAAP;AAID;;AAED,IAAM,oBAAoB,OAAO,aAAP,CAAqB,OAAO,WAA5B,CAA1B;AACA,IAAM,uBAAuB,OAAO,iBAAP,CAAyB,OAAO,WAAhC,CAA7B;;AAEA,IAAM,YAAY,CAChB;AACE,UAAQ,UAAU,KAAV,EAAiB,WAAM,KAAN,CAAY,IAAZ,CACvB,OAAO,mBAAP,CAA2B,OAAO,WAAlC,CADuB,EAEvB,iBAFuB,CAAjB,CADV;AAKE,OAAK,QALP;AAME,SAAO;AANT,CADgB,EAShB;AACE,UAAQ,UAAU,KAAV,EAAiB,WAAM,KAAN,CAAY,GAAZ,CACvB,WAAM,KAAN,CAAY,IAAZ,CACE,oBADF,EAEE,iBAFF,CADuB;AAKvB;AACA,aAAM,MAAN,CAAa,cAAb,CACE,WAAM,MAAN,CAAa,KAAb,CACE,WAAM,MAAN,CAAa,IADf,EAEE,WAAM,MAAN,CAAa,GAAb,CAAiB,WAAM,MAAN,CAAa,IAA9B,CAFF,CADF,EAKE,CALF,EAKK,EALL,EAKS,CALT,EAKY,OAAO,WAAP,CAAmB,mBAAnB,CAAuC,GAAvC,GAA6C,OAAO,WAAP,CAAmB,mBAAnB,CAAuC,GALhG,EAME,GANF,CANuB,CAAjB,CADV;AAgBE,OAAK,IAhBP;AAiBE,OAAK,MAjBP;AAkBE,SAAO;AAlBT,CATgB,CAAlB;;AA+BA,IAAM,8BAA8B,IAAI,WAAM,KAAN,CAAY,UAAhB,CAA2B,YAA3B,CAApC;;AAEA,IAAM,cAAc,WAAM,qBAAN,CAA4B;AAC9C,aAAW,gBADmC;AAE9C,UAAQ,CAAC,CAAD,EAAI,GAAJ,CAFsC;AAG9C,SAAO;AACL,WAAO,MADF;AAEL,aAFK,uBAEO;AACV,UAAM,MAAM,GAAG,MAAH,CAAU,MAAV,CAAZ;AACA,UAAM,OAAO,4BAA4B,iBAA5B,EAAb;AACA,aAAO,aAAK;AACV,YAAM,OAAO,KAAK,KAAL,CAAW,IAAI,EAAf,CAAb;AACA,YAAM,OAAO,IAAI,EAAjB;AACA,eAAU,KAAK,CAAL,CAAV,WAAuB,IAAvB,UAAgC,IAAI,IAAJ,CAAhC;AACD,OAJD;AAKD;AAVI,GAHuC;AAe9C,aAAW;AACT,WAAO,uBADE;AAET,aAFS,uBAEG;AACV,UAAM,MAAM,GAAG,MAAH,CAAW,MAAX,CAAZ;AACA,aAAO;AAAA,eAAQ,IAAI,CAAJ,CAAR;AAAA,OAAP;AACD;AALQ,GAfmC;AAsB9C,eAAa;AACX,WAAO,oBADI;AAEX,aAFW,uBAEC;AACV,UAAM,MAAM,GAAG,MAAH,CAAW,MAAX,CAAZ;AACA,aAAO;AAAA,eAAQ,IAAI,CAAJ,CAAR;AAAA,OAAP;AACD;AALU;AAtBiC,CAA5B,CAApB;;AA+BA,GAAG,QAAH,CAAY,YAAM;AAChB,MAAM,YAAY,YAAY,IAAZ,CAAiB,SAAjB,EAA4B,QAA5B,EAAlB;AACA,KAAG,KAAH,CAAS,YAAT,CAAsB;AAAA,WAAM,YAAY,MAAZ,EAAN;AAAA,GAAtB;AACA,SAAO,SAAP;AACD,CAJD;;AAMA,YAAY,QAAZ,CAAqB,YAArB;AACA,YAAY,aAAZ,CAA0B,sBAA1B;AACA,YAAY,qBAAZ;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;;ACAA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;;ACFA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;;ACHA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;;ACHA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;;ACAA;;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACj1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\n/*\nTypical use of these functions:\n\nimport * as c from 'curves';\nlet sigmoid2 = c.lerp( c.quad, c.inv( c.quad ) );\nlet sigmoid2Piecewise = c.scaledFn( sigmoid2, 0, 25, 1, 13 );\n */\n\n//////// Basic Functions\n\n// These functions are all unscaled, and should all have:\n// - domain of [0, 1]\n// - range of [0, 1]\n\nexport function interpLinear( a, b, t ) {\n\treturn (1 - t) * a + t * b;\n}\n\nexport function linear( t ) {\n\treturn t;\n}\n\nexport function quad( t ) {\n\treturn t * t;\n}\n\nexport function cube( t ) {\n\treturn t * t * t;\n}\n\nexport function quart( t ) {\n\tlet t2 = t * t;\n\treturn t2 * t2;\n}\n\n\n\n//////// Higher Order Functions\n\nexport function interpWith( tfn ) {\n\treturn function interpArb( a, b, t ) {\n\t\treturn interpLinear( a, b, tfn( t ) );\n\t}\n}\n\nexport function interp( fnInterp, fnA, fnB ) {\n\treturn function interpAt( t ) {\n\t\treturn fnInterp( fnA( t ), fnB( t ), t );\n\t\t// return lerp( fnA( t ), fnB( t ), fnInterp( 0, 1, t ) );\n\t}\n}\n\nexport function lerp( fnA, fnB ) {\n\treturn interp( interpLinear, fnA, fnB );\n}\n\nexport function querp( fnA, fnB ) {\n\tlet iqfn = lerp( quad, inv( quad ) );\n\treturn interp( interpWith( iqfn ), fnA, fnB );\n}\n\nexport function inv( fn ) {\n\treturn function invFn( t ) {\n\t\treturn 1 - fn( 1 - t );\n\t};\n}\n\nexport function power( n ) {\n\treturn function powerOf( t ) {\n\t\treturn Math.pow( t, n );\n\t};\n}\n\nexport function piecewise( fn ) {\n\treturn function piecewiseAt( t ) {\n\t\tif( t <= 0 ) return 0;\n\t\telse if( t >= 1 ) return 1;\n\t\telse return fn( t );\n\t}\n}\n\n\n\n//////// Piecewise functions to use in graphs.\n\nexport function scaledFn( fn, t0, t1, f0, f1 ) {\n\tlet tSpan = t1 - t0;\n\tlet fSpan = f1 - f0;\n\tlet pfn = piecewise( fn );\n\treturn function sigmoidAt( t ) {\n\t\tlet tScaled = (t - t0) / tSpan;\n\t\treturn pfn( tScaled ) * fSpan + f0;\n\t}\n}\n\n// Padds the t-value out by the given proportion fracPadding.\n// fracPadding = 1.2 would scale the t domain by 1.2.\nexport function scaledPaddedFn( fn, t0, t1, f0, f1, fracPadding ) {\n\tlet tSpanUnscaled = t1 - t0;\n\tlet tSpan = tSpanUnscaled * fracPadding;\n\tlet tSpanDiff = (tSpan - tSpanUnscaled) / 2;\n\tlet t0d = t0 - tSpanDiff;\n\tlet t1d = t1 + tSpanDiff;\n\treturn scaledFn( fn, t0d, t1d, f0, f1 );\n}\n","// http://file.scirp.org/Html/2-2860008_38842.htm\n// http://file.scirp.org/Html/2-2860008/ce596e0b-c8d1-4209-990a-edb3fb5d8147.jpg\n\n// Monomolecular.  It's basically the lesser side of an exponential graph flipped upside down. (1 - exp(-t))\n// A - Top asymptote\n// k - ... something.  A tweak parameter I guess.\n// B - Derived value..?  For monomolecular it's in the domain of (0, 1)\n//     Looking at the math, if it's not 1 then we don't reach full growth of A.\n\n// From calc:\n// define B0( A, A_L, S ) = 1 - (S - A_L) / (A - A_L)\n// define k( t, S, A, A_L, B ) = (- ln( (1 - (S - A_L) / (A - A_L)) / B ) / t)\n// define monomolecular( t, A, A_L, B, k ) = A_L + (A - A_L) * (1 - B * exp(-k * t))\n\nfunction B0( A, A_L, S0 ) {\n\treturn 1 - (S0 - A_L) / (A - A_L);\n}\n\n/**\n * Create a function of time which returns the linear growth value at that\n * particular time using a basic monomolecular growth model, basically an upside\n * down backwards exponential graph.\n *\n * Note that time here is measured in months.\n *\n * @param  {number} A\n *         Top asymptote, the maximum value that the graph tends towards.\n *         Since this is a linear growth scale, it's useful to set it to 1.\n * @param  {number} A_L\n *         Lower bounds.  Usually 0.\n * @param  {number} S0\n *         Initial linear size, relative to A.\n * @param  {number} k\n *         Time scale.\n *         Given k=~0.135, S0=~0.205, A_L = 0, A = 1,\n *         then f(t=20)=~0.95 and f(t=35)=~0.99.\n * @param  {number} d\n *         Time dilation factor.\n * @return {Function} A function of time in months that returns a linear factor\n *                    of growth at that given time.\n */\nexport function monomolecular( A, A_L, S0, k, d ) {\n\tlet B = B0( A, A_L, S0 );\n\treturn function growthAt( t ) {\n\t\treturn A * (1 - B * Math.exp(-k * t / d));\n\t};\n}\n\n/**\n * A k value that, in the basic monomolecular function above,\n * Given k=~0.135, S0=~0.205, A_L = 0, A = 1,\n * then f(t=20)=~0.95 and f(t=35)=~0.99.\n * @type {Number}\n */\nconst MONOMOLECULAR_95_T1_K = 0.135662;\n\nexport function monomolecular95t1( A, A_L, S0, t95 ) {\n  return monomolecular( A, A_L, S0, MONOMOLECULAR_95_T1_K, t95 / 20 );\n}\n","import * as curves from './curves';\nimport * as growth from './growth';\nimport * as utils from './utils';\n\nexport {\n  curves,\n  growth,\n  utils,\n};\n","import * as d3 from 'd3';\nimport { cube } from './curves';\n\n//////// Composers\n\nexport function sum( ...fns ) {\n\treturn function summationAt( t ) {\n\t\treturn fns.reduce(\n\t\t\tfunction sumFn( res, fn ) { return res + fn( t ); },\n\t\t\t0\n\t\t);\n\t};\n}\n\nexport function comp( ...fns ) {\n\treturn function copositionAt( t ) {\n\t\treturn fns.reduceRight(\n\t\t\tfunction compFn( res, fn ) { return fn( res ); },\n\t\t\tt\n\t\t);\n\t}\n}\n\n\n\n//////// Date\n\n/**\n * Track normalized months and years,\n * more or less ignoring that months have different numbers of days\n * or that years are 365.25andchange days long, not 360 days.\n * Since graphs made in this package track by months after birth rather than\n * exact numbers of days, this is a reasonable compromise.\n */\nexport class PseudoDate {\n  constructor(start) {\n    if (start) {\n      start = new Date(start);\n    }\n    else {\n      start = new Date();\n    }\n\n    this._start = {\n      year: start.getFullYear(),\n      month: start.getMonth() + 1,\n      day: start.getDate(),\n    };\n\n    this._dmFmt = d3.format('02d');\n  }\n\n  offsetMonths(offset) {\n    // Since this is pseudotime, we can just freely convert to days by\n    // multiplying by a fixed factor of 30.\n    const offsetDays = offset * 30;\n\n    const dayWithExcess = this._start.day - 1 + offsetDays;\n    const monthWithExcess = this._start.month - 1 + Math.floor(dayWithExcess / 30);\n    const yearWithExcess = this._start.year + Math.floor(monthWithExcess / 12);\n\n    return {\n      // modulo after all carry-overs have been accounted for.\n      day: (dayWithExcess % 30) + 1,\n      month: (monthWithExcess % 12) + 1,\n      year: yearWithExcess,\n    };\n  }\n\n  relativeFormatter() {\n    return t => {\n      const offset = this.offsetMonths(t);\n      return `${offset.year}-${this._dmFmt(offset.month)}-${this._dmFmt(offset.day)}`;\n    };\n  }\n}\n\n\n\n//////// Some useful scales.\n\n/**\n * Convenience scale function to convert a progress ([0, 1])\n * to a percent. ([0, 100])\n * @type {Function}\n */\nexport const percentScale = d3.scale.linear().domain([ 0, 1 ]).range([ 0, 100 ]);\n\n/**\n * Simple function which takes a linear-dimension domain and a mass range\n * and returns a function which accepts a linear dimension and returns the\n * cubic mass for it.\n * @param  {Array<number>} linearDomain\n *         A two-element array where the first element is the lower bound of\n *         the input domain and the second element is the upper.\n *         You can still pass values outside of this domain and receive an\n *         appropriate value back.\n * @param  {Array<number>} massRange\n *         A two-element array where the first element is the lower bound of\n *         the output mass range and the second is the upper bound.\n * @return {Function} A linear-to-cubic scale.\n */\nexport function cubicScale( linearDomain, massRange ) {\n  return comp(\n    cube,\n    // C = ((L - L0) / (L1 - L0) * (C1^1/3 - C0^1/3))^3\n    d3.scale.linear()\n      .domain( linearDomain )\n      .range( massRange.map( r => Math.pow( r, 1/3 ) ) )\n  );\n}\n\n\n\n//////// Spans\n\n/*\ntype SpanDef = {\n  // Value this span starts from.\n  // At least the first span must have a value here or else\n  // all of the returned values will be NaN.\n  // For all spans after the first, this defaults to the last value\n  // yielded for the last span.\n  from?: number,\n  // Value this span runs until.\n  to: number,\n  // Size of each increment.\n  // defaults to 1.\n  increment?: number,\n};\n */\n\n// This is currently pretty crude, using it with float values may lead to oddities.\nexport function spanner( spanDefs ) {\n  if( ! spanDefs || ! spanDefs.length ) {\n    throw new Error( `spanner requires an array of span definitions` );\n  }\n\n  return {\n    [Symbol.iterator]() {\n      // init state here,\n      // create next() stepper.\n      // return first iteration. (by calling next() the first time if possible.)\n\n      let state = {\n        finalized: false,\n        stopped: true,\n        // Remaining spans to go through after the current one.\n        restSpans: spanDefs.concat(),\n        // Current span.\n        span: null,\n        // Next value.\n        t: undefined,\n      };\n\n      function next() {\n        const stateAfterInit = (\n          state.stopped\n          ? spanner_init( state )\n          : state\n        );\n\n        const stateAfterStep = (\n          stateAfterInit.stopped\n          ? spanner_finalize( stateAfterInit )\n          : spanner_step( stateAfterInit )\n        );\n\n        const iteration = {\n          done: stateAfterInit.stopped && stateAfterInit.finalized,\n          value: stateAfterInit.t,\n        };\n\n        state = stateAfterStep;\n        return iteration;\n      }\n\n      return { next };\n    },\n  };\n}\n\n// function spanner_init({ t, restSpans, finalized }) {\nfunction spanner_init( state ) {\n  // Mutation...\n  const span = state.restSpans.shift();\n\n  if( ! span ) return { ...state, span, stopped: true };\n\n  return {\n    ...state,\n    span,\n    stopped: false,\n    t: span.from != null ? span.from : state.t,\n  };\n}\n\nfunction spanner_getSpanIncrement( span ) {\n  if( span.increment != null ) return span.increment;\n  return 1;\n}\n\nfunction spanner_step( state ) {\n  const nextT = state.t + spanner_getSpanIncrement( state.span );\n  const spanIsDone = nextT >= state.span.to;\n\n  return {\n    ...state,\n    stopped: spanIsDone,\n    span: spanIsDone ? null : state.span,\n    t: nextT,\n  };\n}\n\nfunction spanner_finalize( state ) {\n  return {\n    ...state,\n    finalized: true,\n  };\n}\n","import * as d3 from 'd3';\nimport * as nv from 'nvd3';\n\n// This is a factory to gather all the nv related stuff into one place.\n// All the interaction is haldled elsewhere.\n\nexport default function growthChart( options ) {\n\toptions = Object.assign({\n\t\t// The element into which the chart will go.\n\t\tselection: null,\n\t\tforceY: null,\n    xAxis: {\n      label: \"Age (months)\",\n      formatter() {\n        return d3.format( '.02f' );\n      },\n    },\n    yAxisMass: {\n      label: \"Approximate Body Mass\",\n      formatter() {\n        const fmt = d3.format( '.01f' );\n        return v => `${fmt( v )}kg`;\n      },\n    },\n    yAxisLinear: {\n      label: \"Percent Linear Body Growth\",\n      formatter() {\n        const fmt = d3.format( '.01f' );\n        return v => `${fmt( v )}%`;\n      },\n    },\n\t}, options );\n\n\tif( ! options.selection ) {\n\t\tthrow new Error( `growthChart must be provided a d3 element selection` );\n\t}\n\n\tlet chart = null;\n\tlet currentData = [];\n\n\tlet chartObject = {\n\t\tinit( initialData = [] ) {\n\t\t\tlet chartOptions = {\n\t\t\t\t// duration: 250,\n\t\t\t\tuseInteractiveGuideline: true,\n\t\t\t\tfocusEnable: false,\n\t\t\t\t// margin: { right: 45, bottom: 40 },\n\t\t\t\tmargin: { left: 65, right: 80, bottom: 40 },\n\t\t\t};\n\n\t\t\tif( options.forceY ) {\n\t\t\t\tchartOptions.forceY = options.forceY;\n\t\t\t}\n\n\t\t\tchart = nv.models.linePlusBarChart()\n\t\t\t\t.options( chartOptions )\n\t\t\t\t;\n\n\t\t\tchart.xAxis\n\t\t\t\t.axisLabel( options.xAxis.label )\n\t\t\t\t.tickFormat( options.xAxis.formatter() )\n\t\t\t\t;\n\n\t\t\tchart.x2Axis\n\t\t\t\t.axisLabel( options.xAxis.label )\n\t\t\t\t.tickFormat( options.xAxis.formatter() )\n\t\t\t\t;\n\n\t\t\t// chart.yAxis\n\t\t\t// \t.axisLabel( 'Linear Dimension Growth' )\n\t\t\t// \t.tickFormat( d3.format( '.03f' ) )\n\t\t\t// \t;\n\n\t\t\t// TEMP: Just comparing percents.\n\t\t\t// let yAF = d3.format( '.01f' );\n\t\t\tchart.y2Axis\n\t\t\t\t.axisLabel( options.yAxisLinear.label )\n\t\t\t\t.tickFormat( options.yAxisLinear.formatter() )\n\t\t\t\t;\n\n\t\t\tchart.y1Axis\n\t\t\t\t.axisLabel( options.yAxisMass.label )\n\t\t\t\t.tickFormat( options.yAxisMass.formatter() )\n\t\t\t\t;\n\n\t\t\tchart.bars\n\t\t\t\t.forceY([ 0 ])\n\t\t\t\t.padData( false )\n\t\t\t\t;\n\n\t\t\tif( initialData.length ) {\n\t\t\t\tthis.updateData( initialData );\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\tupdateData( data ) {\n\t\t\tcurrentData = data;\n\t\t\toptions.selection.datum( currentData ).call( chart );\n\t\t\tthis.update();\n\t\t\treturn this;\n\t\t},\n\n\t\tupdate() {\n\t\t\tchart.update();\n\t\t\treturn this;\n\t\t},\n\n\t\tgetChart() {\n\t\t\treturn chart;\n\t\t},\n\n\t\tgetSize() {\n\t\t\treturn {\n\t\t\t\twidth: parseFloat( chart.style( 'width' ) ),\n\t\t\t\theight: parseFloat( chart.style( 'height' ) ),\n\t\t\t};\n\t\t},\n\n\t\tgetDrawingBounds() {\n\t\t\tlet size = this.getSize();\n\t\t\tlet margin = { ...chart.margin() };\n\n\t\t\tlet drawingBounds = {\n\t\t\t\tx: margin.left,\n\t\t\t\ty: margin.top,\n\t\t\t\twidth: size.width - margin.left - margin.right,\n\t\t\t\theight: size.height - margin.top - margin.bottom,\n\t\t\t};\n\n\t\t\tdrawingBounds.x2 = drawingBounds.x + drawingBounds.width;\n\t\t\tdrawingBounds.y2 = drawingBounds.y + drawingBounds.height;\n\n\t\t\treturn drawingBounds;\n\t\t},\n\t};\n\n\treturn chartObject;\n}\n","import 'core-js';\n\nimport * as graph from './graph';\nimport createGrowthMassChart from './growth-mass-chart';\nimport * as page from './page';\n\nconst chart = {\n  createGrowthMassChart,\n};\n\nexport {\n  graph,\n  chart,\n  page,\n};\n","export function getPage() {\n  const elements = {\n    pageHeaderTitle: document.getElementById('page-header-title'),\n    panelHeader: document.getElementById('chart-panel-header'),\n    panelHeaderTitle: document.getElementById('chart-panel-header-title'),\n    chartCanvas: document.getElementById('hyena-chart-canvas'),\n    panelFooter: document.getElementById('chart-panel-footer'),\n    pageFooter: document.getElementById('pageFooter'),\n  };\n\n  return {\n    elements,\n\n    chartCanvasId: 'hyena-chart-canvas',\n\n    setTitle(nextTitle) {\n      document.title = nextTitle;\n      elements.pageHeaderTitle.innerText = nextTitle;\n    },\n\n    setPanelTitle(nextTitle) {\n      elements.panelHeaderTitle.innerText = nextTitle;\n    },\n\n    setPanelFooterContent(html) {\n      elements.panelFooter.innerHTML = html;\n    },\n  };\n}\n","import {\n  graph,\n  // chart,\n  // page,\n} from '../../app';\n\nexport const baseSkywolf = {\n  monomolecularParams: {\n    // 95% linear growth at 12 months.\n    t95: 9, //months\n    A: 1, //relative progress\n    A_L: 0,\n    S0: 15/12 / 7, //ft\n    mt0: 5, //lbs\n    SA: 7, //ft\n    // NOTE: This is the body mass at the end of skeletal growth.\n    // After that, the body continues to build muscle mass.\n    mA1: 137, //lbs\n    mA2: 250, //lbs\n  },\n};\n\nexport function monomolecular(skywolf) {\n  const { t95, A, A_L, S0 } = skywolf.monomolecularParams;\n  return graph.growth.monomolecular95t1(A, A_L, S0, t95);\n}\n\nexport function linearToMassScale(skywolf) {\n  const { A, S0, mt0, mA1 } = skywolf.monomolecularParams;\n  return graph.utils.cubicScale(\n    [S0, A],\n    [mt0, mA1]\n  );\n}\n\nexport function linearToHeightScale(skywolf) {\n  return l => l * skywolf.monomolecularParams.SA;\n}\n","import * as d3 from 'd3';\nimport * as nv from 'nvd3';\n\nimport {\n  graph,\n  chart,\n  page,\n} from '../../app';\n\nimport * as growth from './growthFunctions';\n\n\nconst currentPage = page.getPage();\nconst CANVAS_SELECTOR = `#${currentPage.chartCanvasId}`;\nconst CANVAS_SELECTION = d3.select(CANVAS_SELECTOR);\n\nconst spans = graph.utils.spanner([\n  { from: 0, to: 12 * 2.5, increment: 0.5 },\n]);\n\nfunction reifyData(spans, dataFn) {\n  return [...spans].map(t => ({\n    x: t,\n    y: dataFn(t),\n  }));\n}\n\nconst baseSkywolfGrowth = growth.monomolecular(growth.baseSkywolf);\nconst baseSkywolfMassScale = growth.linearToMassScale(growth.baseSkywolf);\n\nconst chartData = [\n  {\n    values: reifyData(spans, graph.utils.comp(\n      growth.linearToHeightScale(growth.baseSkywolf),\n      baseSkywolfGrowth,\n    )),\n    key: \"Height\",\n    color: '#CE4050'\n  },\n  {\n    values: reifyData(spans, graph.utils.sum(\n      graph.utils.comp(\n        baseSkywolfMassScale,\n        baseSkywolfGrowth,\n      ),\n      // add any sigmoids here...\n      graph.curves.scaledPaddedFn(\n        graph.curves.querp(\n          graph.curves.quad,\n          graph.curves.inv(graph.curves.quad)\n        ),\n        6, 24, 0, growth.baseSkywolf.monomolecularParams.mA2 - growth.baseSkywolf.monomolecularParams.mA1,\n        1.5\n      )\n    )),\n    bar: true,\n    key: \"Mass\",\n    color: '#3390A5',\n  },\n];\n\nconst danAndXirahsBabbiesBirthDay = new graph.utils.PseudoDate('2017-04-01');\n\nconst growthChart = chart.createGrowthMassChart({\n  selection: CANVAS_SELECTION,\n  forceY: [0, 7.5],\n  xAxis: {\n    label: \"Date\",\n    formatter() {\n      const fmt = d3.format('.01f');\n      const dfmt = danAndXirahsBabbiesBirthDay.relativeFormatter();\n      return v => {\n        const yoff = Math.floor(v / 12);\n        const moff = v % 12;\n        return `${dfmt(v)} (+${yoff}y/${fmt(moff)}m)`;\n      };\n    },\n  },\n  yAxisMass: {\n    label: \"Approximate Body Mass\",\n    formatter() {\n      const fmt = d3.format( '.01f' );\n      return v => `${fmt(v)} lbs`;\n    },\n  },\n  yAxisLinear: {\n    label: \"Height Standing Up\",\n    formatter() {\n      const fmt = d3.format( '.01f' );\n      return v => `${fmt(v)} ft`;\n    },\n  },\n});\n\nnv.addGraph(() => {\n  const chartInst = growthChart.init(chartData).getChart();\n  nv.utils.windowResize(() => growthChart.update());\n  return chartInst;\n});\n\ncurrentPage.setTitle(\"Skywolves!\");\ncurrentPage.setPanelTitle(\"Dan and Xirah's Kids\");\ncurrentPage.setPanelFooterContent(`\n  <p>Their kids were born on April 1, 2017 our time, and the date values provided reflect that.\n    However, relative time-offsets are provided for more general reference.\n    Note that the calculated dates are themselves normalized approximations that are designed\n    to fit the yearly cycle more than exact months/days.</p>\n  <p>The values presented here are still a work in progress pending feedback and research.</p>\n  <p>The bars and left axis indicate the approximate body mass expected at a given age.\n    The line and right axis indicate the linear growth, expressed as their height in feet standing up.\n    The body mass is derived from the <em>un</em>normalized linear growth.</p>\n  <p>Age as indicated here is in months since birth, not conception.  This is why the numbers don't start at 0.</p>\n`);\n","require('./shim');\nrequire('./modules/core.dict');\nrequire('./modules/core.get-iterator-method');\nrequire('./modules/core.get-iterator');\nrequire('./modules/core.is-iterable');\nrequire('./modules/core.delay');\nrequire('./modules/core.function.part');\nrequire('./modules/core.object.is-object');\nrequire('./modules/core.object.classof');\nrequire('./modules/core.object.define');\nrequire('./modules/core.object.make');\nrequire('./modules/core.number.iterator');\nrequire('./modules/core.regexp.escape');\nrequire('./modules/core.string.escape-html');\nrequire('./modules/core.string.unescape-html');\nmodule.exports = require('./modules/_core');","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};","var cof = require('./_cof');\nmodule.exports = function(it, msg){\n  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);\n  return +it;\n};","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables')\n  , ArrayProto  = Array.prototype;\nif(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function(key){\n  ArrayProto[UNSCOPABLES][key] = true;\n};","module.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object')\n  , toIndex  = require('./_to-index')\n  , toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){\n  var O     = toObject(this)\n    , len   = toLength(O.length)\n    , to    = toIndex(target, len)\n    , from  = toIndex(start, len)\n    , end   = arguments.length > 2 ? arguments[2] : undefined\n    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)\n    , inc   = 1;\n  if(from < to && to < from + count){\n    inc  = -1;\n    from += count - 1;\n    to   += count - 1;\n  }\n  while(count-- > 0){\n    if(from in O)O[to] = O[from];\n    else delete O[to];\n    to   += inc;\n    from += inc;\n  } return O;\n};","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object')\n  , toIndex  = require('./_to-index')\n  , toLength = require('./_to-length');\nmodule.exports = function fill(value /*, start = 0, end = @length */){\n  var O      = toObject(this)\n    , length = toLength(O.length)\n    , aLen   = arguments.length\n    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)\n    , end    = aLen > 2 ? arguments[2] : undefined\n    , endPos = end === undefined ? length : toIndex(end, length);\n  while(endPos > index)O[index++] = value;\n  return O;\n};","var forOf = require('./_for-of');\n\nmodule.exports = function(iter, ITERATOR){\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx      = require('./_ctx')\n  , IObject  = require('./_iobject')\n  , toObject = require('./_to-object')\n  , toLength = require('./_to-length')\n  , asc      = require('./_array-species-create');\nmodule.exports = function(TYPE, $create){\n  var IS_MAP        = TYPE == 1\n    , IS_FILTER     = TYPE == 2\n    , IS_SOME       = TYPE == 3\n    , IS_EVERY      = TYPE == 4\n    , IS_FIND_INDEX = TYPE == 6\n    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX\n    , create        = $create || asc;\n  return function($this, callbackfn, that){\n    var O      = toObject($this)\n      , self   = IObject(O)\n      , f      = ctx(callbackfn, that, 3)\n      , length = toLength(self.length)\n      , index  = 0\n      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined\n      , val, res;\n    for(;length > index; index++)if(NO_HOLES || index in self){\n      val = self[index];\n      res = f(val, index, O);\n      if(TYPE){\n        if(IS_MAP)result[index] = res;            // map\n        else if(res)switch(TYPE){\n          case 3: return true;                    // some\n          case 5: return val;                     // find\n          case 6: return index;                   // findIndex\n          case 2: result.push(val);               // filter\n        } else if(IS_EVERY)return false;          // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};","var aFunction = require('./_a-function')\n  , toObject  = require('./_to-object')\n  , IObject   = require('./_iobject')\n  , toLength  = require('./_to-length');\n\nmodule.exports = function(that, callbackfn, aLen, memo, isRight){\n  aFunction(callbackfn);\n  var O      = toObject(that)\n    , self   = IObject(O)\n    , length = toLength(O.length)\n    , index  = isRight ? length - 1 : 0\n    , i      = isRight ? -1 : 1;\n  if(aLen < 2)for(;;){\n    if(index in self){\n      memo = self[index];\n      index += i;\n      break;\n    }\n    index += i;\n    if(isRight ? index < 0 : length <= index){\n      throw TypeError('Reduce of empty array with no initial value');\n    }\n  }\n  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){\n    memo = callbackfn(memo, self[index], index, O);\n  }\n  return memo;\n};","var isObject = require('./_is-object')\n  , isArray  = require('./_is-array')\n  , SPECIES  = require('./_wks')('species');\n\nmodule.exports = function(original){\n  var C;\n  if(isArray(original)){\n    C = original.constructor;\n    // cross-realm fallback\n    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;\n    if(isObject(C)){\n      C = C[SPECIES];\n      if(C === null)C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function(original, length){\n  return new (speciesConstructor(original))(length);\n};","'use strict';\nvar aFunction  = require('./_a-function')\n  , isObject   = require('./_is-object')\n  , invoke     = require('./_invoke')\n  , arraySlice = [].slice\n  , factories  = {};\n\nvar construct = function(F, len, args){\n  if(!(len in factories)){\n    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /*, args... */){\n  var fn       = aFunction(this)\n    , partArgs = arraySlice.call(arguments, 1);\n  var bound = function(/* args... */){\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if(isObject(fn.prototype))bound.prototype = fn.prototype;\n  return bound;\n};","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};","'use strict';\nvar dP          = require('./_object-dp').f\n  , create      = require('./_object-create')\n  , redefineAll = require('./_redefine-all')\n  , ctx         = require('./_ctx')\n  , anInstance  = require('./_an-instance')\n  , defined     = require('./_defined')\n  , forOf       = require('./_for-of')\n  , $iterDefine = require('./_iter-define')\n  , step        = require('./_iter-step')\n  , setSpecies  = require('./_set-species')\n  , DESCRIPTORS = require('./_descriptors')\n  , fastKey     = require('./_meta').fastKey\n  , SIZE        = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        anInstance(this, C, 'forEach');\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)dP(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = require('./_classof')\n  , from    = require('./_array-from-iterable');\nmodule.exports = function(NAME){\n  return function toJSON(){\n    if(classof(this) != NAME)throw TypeError(NAME + \"#toJSON isn't generic\");\n    return from(this);\n  };\n};","'use strict';\nvar redefineAll       = require('./_redefine-all')\n  , getWeak           = require('./_meta').getWeak\n  , anObject          = require('./_an-object')\n  , isObject          = require('./_is-object')\n  , anInstance        = require('./_an-instance')\n  , forOf             = require('./_for-of')\n  , createArrayMethod = require('./_array-methods')\n  , $has              = require('./_has')\n  , arrayFind         = createArrayMethod(5)\n  , arrayFindIndex    = createArrayMethod(6)\n  , id                = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function(that){\n  return that._l || (that._l = new UncaughtFrozenStore);\n};\nvar UncaughtFrozenStore = function(){\n  this.a = [];\n};\nvar findUncaughtFrozen = function(store, key){\n  return arrayFind(store.a, function(it){\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function(key){\n    var entry = findUncaughtFrozen(this, key);\n    if(entry)return entry[1];\n  },\n  has: function(key){\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function(key, value){\n    var entry = findUncaughtFrozen(this, key);\n    if(entry)entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function(key){\n    var index = arrayFindIndex(this.a, function(it){\n      return it[0] === key;\n    });\n    if(~index)this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function(key){\n        if(!isObject(key))return false;\n        var data = getWeak(key);\n        if(data === true)return uncaughtFrozenStore(this)['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key){\n        if(!isObject(key))return false;\n        var data = getWeak(key);\n        if(data === true)return uncaughtFrozenStore(this).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var data = getWeak(anObject(key), true);\n    if(data === true)uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};","'use strict';\nvar global            = require('./_global')\n  , $export           = require('./_export')\n  , redefine          = require('./_redefine')\n  , redefineAll       = require('./_redefine-all')\n  , meta              = require('./_meta')\n  , forOf             = require('./_for-of')\n  , anInstance        = require('./_an-instance')\n  , isObject          = require('./_is-object')\n  , fails             = require('./_fails')\n  , $iterDetect       = require('./_iter-detect')\n  , setToStringTag    = require('./_set-to-string-tag')\n  , inheritIfRequired = require('./_inherit-if-required');\n\nmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n  var Base  = global[NAME]\n    , C     = Base\n    , ADDER = IS_MAP ? 'set' : 'add'\n    , proto = C && C.prototype\n    , O     = {};\n  var fixMethod = function(KEY){\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a){\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n    new C().entries().next();\n  }))){\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance             = new C\n      // early implementations not supports chaining\n      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance\n      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })\n      // most early implementations doesn't supports iterables, most modern - not close it correctly\n      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new\n      // for early implementations -0 and +0 not the same\n      , BUGGY_ZERO = !IS_WEAK && fails(function(){\n        // V8 ~ Chromium 42- fails only with 5+ elements\n        var $instance = new C()\n          , index     = 5;\n        while(index--)$instance[ADDER](index, index);\n        return !$instance.has(-0);\n      });\n    if(!ACCEPT_ITERABLES){ \n      C = wrapper(function(target, iterable){\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base, target, C);\n        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if(IS_WEAK && proto.clear)delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef","'use strict';\nvar $defineProperty = require('./_object-dp')\n  , createDesc      = require('./_property-desc');\n\nmodule.exports = function(object, index, value){\n  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};","'use strict';\nvar anObject    = require('./_an-object')\n  , toPrimitive = require('./_to-primitive')\n  , NUMBER      = 'number';\n\nmodule.exports = function(hint){\n  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');\n  return toPrimitive(anObject(this), hint != NUMBER);\n};","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};","var global    = require('./_global')\n  , core      = require('./_core')\n  , hide      = require('./_hide')\n  , redefine  = require('./_redefine')\n  , ctx       = require('./_ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})\n    , key, own, out, exp;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if(target)redefine(target, key, out, type & $export.U);\n    // export\n    if(exports[key] != out)hide(exports, key, exp);\n    if(IS_PROTO && expProto[key] != out)expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;","var MATCH = require('./_wks')('match');\nmodule.exports = function(KEY){\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch(e){\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch(f){ /* empty */ }\n  } return true;\n};","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};","'use strict';\nvar hide     = require('./_hide')\n  , redefine = require('./_redefine')\n  , fails    = require('./_fails')\n  , defined  = require('./_defined')\n  , wks      = require('./_wks');\n\nmodule.exports = function(KEY, length, exec){\n  var SYMBOL   = wks(KEY)\n    , fns      = exec(defined, SYMBOL, ''[KEY])\n    , strfn    = fns[0]\n    , rxfn     = fns[1];\n  if(fails(function(){\n    var O = {};\n    O[SYMBOL] = function(){ return 7; };\n    return ''[KEY](O) != 7;\n  })){\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function(string, arg){ return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function(string){ return rxfn.call(string, this); }\n    );\n  }\n};","'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./_an-object');\nmodule.exports = function(){\n  var that   = anObject(this)\n    , result = '';\n  if(that.global)     result += 'g';\n  if(that.ignoreCase) result += 'i';\n  if(that.multiline)  result += 'm';\n  if(that.unicode)    result += 'u';\n  if(that.sticky)     result += 'y';\n  return result;\n};","var ctx         = require('./_ctx')\n  , call        = require('./_iter-call')\n  , isArrayIter = require('./_is-array-iter')\n  , anObject    = require('./_an-object')\n  , toLength    = require('./_to-length')\n  , getIterFn   = require('./core.get-iterator-method')\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};","module.exports = require('./_global').document && document.documentElement;","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});","var isObject       = require('./_is-object')\n  , setPrototypeOf = require('./_set-proto').set;\nmodule.exports = function(that, target, C){\n  var P, S = target.constructor;\n  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){\n    setPrototypeOf(that, P);\n  } return that;\n};","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};","// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};","// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./_is-object')\n  , floor    = Math.floor;\nmodule.exports = function isInteger(it){\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};","// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object')\n  , cof      = require('./_cof')\n  , MATCH    = require('./_wks')('match');\nmodule.exports = function(it){\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};","var ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};","module.exports = {};","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};","module.exports = false;","// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x){\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;","// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x){\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x){\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};","var Map     = require('./es6.map')\n  , $export = require('./_export')\n  , shared  = require('./_shared')('metadata')\n  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));\n\nvar getOrCreateMetadataMap = function(target, targetKey, create){\n  var targetMetadata = store.get(target);\n  if(!targetMetadata){\n    if(!create)return undefined;\n    store.set(target, targetMetadata = new Map);\n  }\n  var keyMetadata = targetMetadata.get(targetKey);\n  if(!keyMetadata){\n    if(!create)return undefined;\n    targetMetadata.set(targetKey, keyMetadata = new Map);\n  } return keyMetadata;\n};\nvar ordinaryHasOwnMetadata = function(MetadataKey, O, P){\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);\n};\nvar ordinaryGetOwnMetadata = function(MetadataKey, O, P){\n  var metadataMap = getOrCreateMetadataMap(O, P, false);\n  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\n};\nvar ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){\n  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);\n};\nvar ordinaryOwnMetadataKeys = function(target, targetKey){\n  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)\n    , keys        = [];\n  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });\n  return keys;\n};\nvar toMetaKey = function(it){\n  return it === undefined || typeof it == 'symbol' ? it : String(it);\n};\nvar exp = function(O){\n  $export($export.S, 'Reflect', O);\n};\n\nmodule.exports = {\n  store: store,\n  map: getOrCreateMetadataMap,\n  has: ordinaryHasOwnMetadata,\n  get: ordinaryGetOwnMetadata,\n  set: ordinaryDefineOwnMetadata,\n  keys: ordinaryOwnMetadataKeys,\n  key: toMetaKey,\n  exp: exp\n};","var global    = require('./_global')\n  , macrotask = require('./_task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./_cof')(process) == 'process';\n\nmodule.exports = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode && (parent = process.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode){\n    notify = function(){\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var dP        = require('./_object-dp')\n  , gOPD      = require('./_object-gopd')\n  , ownKeys   = require('./_own-keys')\n  , toIObject = require('./_to-iobject');\n\nmodule.exports = function define(target, mixin){\n  var keys   = ownKeys(toIObject(mixin))\n    , length = keys.length\n    , i = 0, key;\n  while(length > i)dP.f(target, key = keys[i++], gOPD.f(mixin, key));\n  return target;\n};","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};","// Forced replacement prototype accessors methods\nmodule.exports = require('./_library')|| !require('./_fails')(function(){\n  var K = Math.random();\n  // In FF throws only define methods\n  __defineSetter__.call(null, K, function(){ /* empty */});\n  delete require('./_global')[K];\n});","var pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = require('./_object-keys-internal')\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};","exports.f = Object.getOwnPropertySymbols;","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};","exports.f = {}.propertyIsEnumerable;","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export')\n  , core    = require('./_core')\n  , fails   = require('./_fails');\nmodule.exports = function(KEY, exec){\n  var fn  = (core.Object || {})[KEY] || Object[KEY]\n    , exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);\n};","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject')\n  , isEnum    = require('./_object-pie').f;\nmodule.exports = function(isEntries){\n  return function(it){\n    var O      = toIObject(it)\n      , keys   = getKeys(O)\n      , length = keys.length\n      , i      = 0\n      , result = []\n      , key;\n    while(length > i)if(isEnum.call(O, key = keys[i++])){\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};","// all object keys, includes non-enumerable and symbols\nvar gOPN     = require('./_object-gopn')\n  , gOPS     = require('./_object-gops')\n  , anObject = require('./_an-object')\n  , Reflect  = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it){\n  var keys       = gOPN.f(anObject(it))\n    , getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};","var $parseFloat = require('./_global').parseFloat\n  , $trim       = require('./_string-trim').trim;\n\nmodule.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){\n  var string = $trim(String(str), 3)\n    , result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;","var $parseInt = require('./_global').parseInt\n  , $trim     = require('./_string-trim').trim\n  , ws        = require('./_string-ws')\n  , hex       = /^[\\-+]?0[xX]/;\n\nmodule.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){\n  var string = $trim(String(str), 3);\n  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));\n} : $parseInt;","'use strict';\nvar path      = require('./_path')\n  , invoke    = require('./_invoke')\n  , aFunction = require('./_a-function');\nmodule.exports = function(/* ...pargs */){\n  var fn     = aFunction(this)\n    , length = arguments.length\n    , pargs  = Array(length)\n    , i      = 0\n    , _      = path._\n    , holder = false;\n  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;\n  return function(/* ...args */){\n    var that = this\n      , aLen = arguments.length\n      , j = 0, k = 0, args;\n    if(!holder && !aLen)return invoke(fn, pargs, that);\n    args = pargs.slice();\n    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];\n    while(aLen > k)args.push(arguments[k++]);\n    return invoke(fn, args, that);\n  };\n};","module.exports = require('./_global');","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};","var redefine = require('./_redefine');\nmodule.exports = function(target, src, safe){\n  for(var key in src)redefine(target, key, src[key], safe);\n  return target;\n};","var global    = require('./_global')\n  , hide      = require('./_hide')\n  , has       = require('./_has')\n  , SRC       = require('./_uid')('src')\n  , TO_STRING = 'toString'\n  , $toString = Function[TO_STRING]\n  , TPL       = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function(it){\n  return $toString.call(it);\n};\n\n(module.exports = function(O, key, val, safe){\n  var isFunction = typeof val == 'function';\n  if(isFunction)has(val, 'name') || hide(val, 'name', key);\n  if(O[key] === val)return;\n  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if(O === global){\n    O[key] = val;\n  } else {\n    if(!safe){\n      delete O[key];\n      hide(O, key, val);\n    } else {\n      if(O[key])O[key] = val;\n      else hide(O, key, val);\n    }\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString(){\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});","module.exports = function(regExp, replace){\n  var replacer = replace === Object(replace) ? function(part){\n    return replace[part];\n  } : replace;\n  return function(it){\n    return String(it).replace(regExp, replacer);\n  };\n};","// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y){\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};","'use strict';\nvar global      = require('./_global')\n  , dP          = require('./_object-dp')\n  , DESCRIPTORS = require('./_descriptors')\n  , SPECIES     = require('./_wks')('species');\n\nmodule.exports = function(KEY){\n  var C = global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./_an-object')\n  , aFunction = require('./_a-function')\n  , SPECIES   = require('./_wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};","var fails = require('./_fails');\n\nmodule.exports = function(method, arg){\n  return !!method && fails(function(){\n    arg ? method.call(null, function(){}, 1) : method.call(null);\n  });\n};","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};","// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp')\n  , defined  = require('./_defined');\n\nmodule.exports = function(that, searchString, NAME){\n  if(isRegExp(searchString))throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};","var $export = require('./_export')\n  , fails   = require('./_fails')\n  , defined = require('./_defined')\n  , quot    = /\"/g;\n// B.2.3.2.1 CreateHTML(string, tag, attribute, value)\nvar createHTML = function(string, tag, attribute, value) {\n  var S  = String(defined(string))\n    , p1 = '<' + tag;\n  if(attribute !== '')p1 += ' ' + attribute + '=\"' + String(value).replace(quot, '&quot;') + '\"';\n  return p1 + '>' + S + '</' + tag + '>';\n};\nmodule.exports = function(NAME, exec){\n  var O = {};\n  O[NAME] = exec(createHTML);\n  $export($export.P + $export.F * fails(function(){\n    var test = ''[NAME]('\"');\n    return test !== test.toLowerCase() || test.split('\"').length > 3;\n  }), 'String', O);\n};","// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = require('./_to-length')\n  , repeat   = require('./_string-repeat')\n  , defined  = require('./_defined');\n\nmodule.exports = function(that, maxLength, fillString, left){\n  var S            = String(defined(that))\n    , stringLength = S.length\n    , fillStr      = fillString === undefined ? ' ' : String(fillString)\n    , intMaxLength = toLength(maxLength);\n  if(intMaxLength <= stringLength || fillStr == '')return S;\n  var fillLen = intMaxLength - stringLength\n    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n","'use strict';\nvar toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n\nmodule.exports = function repeat(count){\n  var str = String(defined(this))\n    , res = ''\n    , n   = toInteger(count);\n  if(n < 0 || n == Infinity)throw RangeError(\"Count can't be negative\");\n  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\n  return res;\n};","var $export = require('./_export')\n  , defined = require('./_defined')\n  , fails   = require('./_fails')\n  , spaces  = require('./_string-ws')\n  , space   = '[' + spaces + ']'\n  , non     = '\\u200b\\u0085'\n  , ltrim   = RegExp('^' + space + space + '*')\n  , rtrim   = RegExp(space + space + '*$');\n\nvar exporter = function(KEY, exec, ALIAS){\n  var exp   = {};\n  var FORCE = fails(function(){\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if(ALIAS)exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function(string, TYPE){\n  string = String(defined(string));\n  if(TYPE & 1)string = string.replace(ltrim, '');\n  if(TYPE & 2)string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;","module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';","var ctx                = require('./_ctx')\n  , invoke             = require('./_invoke')\n  , html               = require('./_html')\n  , cel                = require('./_dom-create')\n  , global             = require('./_global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./_cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};","'use strict';\nif(require('./_descriptors')){\n  var LIBRARY             = require('./_library')\n    , global              = require('./_global')\n    , fails               = require('./_fails')\n    , $export             = require('./_export')\n    , $typed              = require('./_typed')\n    , $buffer             = require('./_typed-buffer')\n    , ctx                 = require('./_ctx')\n    , anInstance          = require('./_an-instance')\n    , propertyDesc        = require('./_property-desc')\n    , hide                = require('./_hide')\n    , redefineAll         = require('./_redefine-all')\n    , toInteger           = require('./_to-integer')\n    , toLength            = require('./_to-length')\n    , toIndex             = require('./_to-index')\n    , toPrimitive         = require('./_to-primitive')\n    , has                 = require('./_has')\n    , same                = require('./_same-value')\n    , classof             = require('./_classof')\n    , isObject            = require('./_is-object')\n    , toObject            = require('./_to-object')\n    , isArrayIter         = require('./_is-array-iter')\n    , create              = require('./_object-create')\n    , getPrototypeOf      = require('./_object-gpo')\n    , gOPN                = require('./_object-gopn').f\n    , getIterFn           = require('./core.get-iterator-method')\n    , uid                 = require('./_uid')\n    , wks                 = require('./_wks')\n    , createArrayMethod   = require('./_array-methods')\n    , createArrayIncludes = require('./_array-includes')\n    , speciesConstructor  = require('./_species-constructor')\n    , ArrayIterators      = require('./es6.array.iterator')\n    , Iterators           = require('./_iterators')\n    , $iterDetect         = require('./_iter-detect')\n    , setSpecies          = require('./_set-species')\n    , arrayFill           = require('./_array-fill')\n    , arrayCopyWithin     = require('./_array-copy-within')\n    , $DP                 = require('./_object-dp')\n    , $GOPD               = require('./_object-gopd')\n    , dP                  = $DP.f\n    , gOPD                = $GOPD.f\n    , RangeError          = global.RangeError\n    , TypeError           = global.TypeError\n    , Uint8Array          = global.Uint8Array\n    , ARRAY_BUFFER        = 'ArrayBuffer'\n    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER\n    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'\n    , PROTOTYPE           = 'prototype'\n    , ArrayProto          = Array[PROTOTYPE]\n    , $ArrayBuffer        = $buffer.ArrayBuffer\n    , $DataView           = $buffer.DataView\n    , arrayForEach        = createArrayMethod(0)\n    , arrayFilter         = createArrayMethod(2)\n    , arraySome           = createArrayMethod(3)\n    , arrayEvery          = createArrayMethod(4)\n    , arrayFind           = createArrayMethod(5)\n    , arrayFindIndex      = createArrayMethod(6)\n    , arrayIncludes       = createArrayIncludes(true)\n    , arrayIndexOf        = createArrayIncludes(false)\n    , arrayValues         = ArrayIterators.values\n    , arrayKeys           = ArrayIterators.keys\n    , arrayEntries        = ArrayIterators.entries\n    , arrayLastIndexOf    = ArrayProto.lastIndexOf\n    , arrayReduce         = ArrayProto.reduce\n    , arrayReduceRight    = ArrayProto.reduceRight\n    , arrayJoin           = ArrayProto.join\n    , arraySort           = ArrayProto.sort\n    , arraySlice          = ArrayProto.slice\n    , arrayToString       = ArrayProto.toString\n    , arrayToLocaleString = ArrayProto.toLocaleString\n    , ITERATOR            = wks('iterator')\n    , TAG                 = wks('toStringTag')\n    , TYPED_CONSTRUCTOR   = uid('typed_constructor')\n    , DEF_CONSTRUCTOR     = uid('def_constructor')\n    , ALL_CONSTRUCTORS    = $typed.CONSTR\n    , TYPED_ARRAY         = $typed.TYPED\n    , VIEW                = $typed.VIEW\n    , WRONG_LENGTH        = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function(O, length){\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function(){\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){\n    new Uint8Array(1).set({});\n  });\n\n  var strictToLength = function(it, SAME){\n    if(it === undefined)throw TypeError(WRONG_LENGTH);\n    var number = +it\n      , length = toLength(it);\n    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);\n    return length;\n  };\n\n  var toOffset = function(it, BYTES){\n    var offset = toInteger(it);\n    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function(it){\n    if(isObject(it) && TYPED_ARRAY in it)return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function(C, length){\n    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function(O, list){\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function(C, list){\n    var index  = 0\n      , length = list.length\n      , result = allocate(C, length);\n    while(length > index)result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function(it, key, internal){\n    dP(it, key, {get: function(){ return this._d[internal]; }});\n  };\n\n  var $from = function from(source /*, mapfn, thisArg */){\n    var O       = toObject(source)\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , iterFn  = getIterFn(O)\n      , i, length, values, result, step, iterator;\n    if(iterFn != undefined && !isArrayIter(iterFn)){\n      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){\n        values.push(step.value);\n      } O = values;\n    }\n    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);\n    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/*...items*/){\n    var index  = 0\n      , length = arguments.length\n      , result = allocate(this, length);\n    while(length > index)result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString(){\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /*, end */){\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /*, thisArg */){\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /*, thisArg */){\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /*, thisArg */){\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /*, thisArg */){\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /*, thisArg */){\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /*, fromIndex */){\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /*, fromIndex */){\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator){ // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /*, thisArg */){\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse(){\n      var that   = this\n        , length = validate(that).length\n        , middle = Math.floor(length / 2)\n        , index  = 0\n        , value;\n      while(index < middle){\n        value         = that[index];\n        that[index++] = that[--length];\n        that[length]  = value;\n      } return that;\n    },\n    some: function some(callbackfn /*, thisArg */){\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn){\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end){\n      var O      = validate(this)\n        , length = O.length\n        , $begin = toIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end){\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /*, offset */){\n    validate(this);\n    var offset = toOffset(arguments[1], 1)\n      , length = this.length\n      , src    = toObject(arrayLike)\n      , len    = toLength(src.length)\n      , index  = 0;\n    if(len + offset > length)throw RangeError(WRONG_LENGTH);\n    while(index < len)this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries(){\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys(){\n      return arrayKeys.call(validate(this));\n    },\n    values: function values(){\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function(target, key){\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key){\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc){\n    if(isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ){\n      target[key] = desc.value;\n      return target;\n    } else return dP(target, key, desc);\n  };\n\n  if(!ALL_CONSTRUCTORS){\n    $GOPD.f = $getDesc;\n    $DP.f   = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty:           $setDesc\n  });\n\n  if(fails(function(){ arrayToString.call({}); })){\n    arrayToString = arrayToLocaleString = function toString(){\n      return arrayJoin.call(this);\n    }\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice:          $slice,\n    set:            $set,\n    constructor:    function(){ /* noop */ },\n    toString:       arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function(){ return this[TYPED_ARRAY]; }\n  });\n\n  module.exports = function(KEY, BYTES, wrapper, CLAMPED){\n    CLAMPED = !!CLAMPED;\n    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'\n      , ISNT_UINT8 = NAME != 'Uint8Array'\n      , GETTER     = 'get' + KEY\n      , SETTER     = 'set' + KEY\n      , TypedArray = global[NAME]\n      , Base       = TypedArray || {}\n      , TAC        = TypedArray && getPrototypeOf(TypedArray)\n      , FORCED     = !TypedArray || !$typed.ABV\n      , O          = {}\n      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function(that, index){\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function(that, index, value){\n      var data = that._d;\n      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function(that, index){\n      dP(that, index, {\n        get: function(){\n          return getter(this, index);\n        },\n        set: function(value){\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if(FORCED){\n      TypedArray = wrapper(function(that, data, $offset, $length){\n        anInstance(that, TypedArray, NAME, '_d');\n        var index  = 0\n          , offset = 0\n          , buffer, byteLength, length, klass;\n        if(!isObject(data)){\n          length     = strictToLength(data, true)\n          byteLength = length * BYTES;\n          buffer     = new $ArrayBuffer(byteLength);\n        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if($length === undefined){\n            if($len % BYTES)throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if(byteLength < 0)throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if(TYPED_ARRAY in data){\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while(index < length)addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if(!$iterDetect(function(iter){\n      // V8 works with iterators, but fails in many other cases\n      // https://code.google.com/p/v8/issues/detail?id=4552\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)){\n      TypedArray = wrapper(function(that, data, $offset, $length){\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));\n        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if(TYPED_ARRAY in data)return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){\n        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator   = TypedArrayPrototype[ITERATOR]\n      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)\n      , $iterator         = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){\n      dP(TypedArrayPrototype, TAG, {\n        get: function(){ return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES,\n      from: $from,\n      of: $of\n    });\n\n    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});\n\n    $export($export.P + $export.F * fails(function(){\n      new TypedArray(1).slice();\n    }), NAME, {slice: $slice});\n\n    $export($export.P + $export.F * (fails(function(){\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()\n    }) || !fails(function(){\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, {toLocaleString: $toLocaleString});\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function(){ /* empty */ };","'use strict';\nvar global         = require('./_global')\n  , DESCRIPTORS    = require('./_descriptors')\n  , LIBRARY        = require('./_library')\n  , $typed         = require('./_typed')\n  , hide           = require('./_hide')\n  , redefineAll    = require('./_redefine-all')\n  , fails          = require('./_fails')\n  , anInstance     = require('./_an-instance')\n  , toInteger      = require('./_to-integer')\n  , toLength       = require('./_to-length')\n  , gOPN           = require('./_object-gopn').f\n  , dP             = require('./_object-dp').f\n  , arrayFill      = require('./_array-fill')\n  , setToStringTag = require('./_set-to-string-tag')\n  , ARRAY_BUFFER   = 'ArrayBuffer'\n  , DATA_VIEW      = 'DataView'\n  , PROTOTYPE      = 'prototype'\n  , WRONG_LENGTH   = 'Wrong length!'\n  , WRONG_INDEX    = 'Wrong index!'\n  , $ArrayBuffer   = global[ARRAY_BUFFER]\n  , $DataView      = global[DATA_VIEW]\n  , Math           = global.Math\n  , RangeError     = global.RangeError\n  , Infinity       = global.Infinity\n  , BaseBuffer     = $ArrayBuffer\n  , abs            = Math.abs\n  , pow            = Math.pow\n  , floor          = Math.floor\n  , log            = Math.log\n  , LN2            = Math.LN2\n  , BUFFER         = 'buffer'\n  , BYTE_LENGTH    = 'byteLength'\n  , BYTE_OFFSET    = 'byteOffset'\n  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER\n  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH\n  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar packIEEE754 = function(value, mLen, nBytes){\n  var buffer = Array(nBytes)\n    , eLen   = nBytes * 8 - mLen - 1\n    , eMax   = (1 << eLen) - 1\n    , eBias  = eMax >> 1\n    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0\n    , i      = 0\n    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0\n    , e, m, c;\n  value = abs(value)\n  if(value != value || value === Infinity){\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if(value * (c = pow(2, -e)) < 1){\n      e--;\n      c *= 2;\n    }\n    if(e + eBias >= 1){\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if(value * c >= 2){\n      e++;\n      c /= 2;\n    }\n    if(e + eBias >= eMax){\n      m = 0;\n      e = eMax;\n    } else if(e + eBias >= 1){\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n};\nvar unpackIEEE754 = function(buffer, mLen, nBytes){\n  var eLen  = nBytes * 8 - mLen - 1\n    , eMax  = (1 << eLen) - 1\n    , eBias = eMax >> 1\n    , nBits = eLen - 7\n    , i     = nBytes - 1\n    , s     = buffer[i--]\n    , e     = s & 127\n    , m;\n  s >>= 7;\n  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if(e === 0){\n    e = 1 - eBias;\n  } else if(e === eMax){\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n};\n\nvar unpackI32 = function(bytes){\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n};\nvar packI8 = function(it){\n  return [it & 0xff];\n};\nvar packI16 = function(it){\n  return [it & 0xff, it >> 8 & 0xff];\n};\nvar packI32 = function(it){\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n};\nvar packF64 = function(it){\n  return packIEEE754(it, 52, 8);\n};\nvar packF32 = function(it){\n  return packIEEE754(it, 23, 4);\n};\n\nvar addGetter = function(C, key, internal){\n  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});\n};\n\nvar get = function(view, bytes, index, isLittleEndian){\n  var numIndex = +index\n    , intIndex = toInteger(numIndex);\n  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b\n    , start = intIndex + view[$OFFSET]\n    , pack  = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n};\nvar set = function(view, bytes, index, conversion, value, isLittleEndian){\n  var numIndex = +index\n    , intIndex = toInteger(numIndex);\n  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b\n    , start = intIndex + view[$OFFSET]\n    , pack  = conversion(+value);\n  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n};\n\nvar validateArrayBufferArguments = function(that, length){\n  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);\n  var numberLength = +length\n    , byteLength   = toLength(numberLength);\n  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);\n  return byteLength;\n};\n\nif(!$typed.ABV){\n  $ArrayBuffer = function ArrayBuffer(length){\n    var byteLength = validateArrayBufferArguments(this, length);\n    this._b       = arrayFill.call(Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength){\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH]\n      , offset       = toInteger(byteOffset);\n    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if(DESCRIPTORS){\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset){\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset){\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /*, littleEndian */){\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /*, littleEndian */){\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /*, littleEndian */){\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /*, littleEndian */){\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /*, littleEndian */){\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /*, littleEndian */){\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value){\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value){\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /*, littleEndian */){\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /*, littleEndian */){\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if(!fails(function(){\n    new $ArrayBuffer;     // eslint-disable-line no-new\n  }) || !fails(function(){\n    new $ArrayBuffer(.5); // eslint-disable-line no-new\n  })){\n    $ArrayBuffer = function ArrayBuffer(length){\n      return new BaseBuffer(validateArrayBufferArguments(this, length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){\n      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);\n    };\n    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2))\n    , $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value){\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value){\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;","var global = require('./_global')\n  , hide   = require('./_hide')\n  , uid    = require('./_uid')\n  , TYPED  = uid('typed_array')\n  , VIEW   = uid('view')\n  , ABV    = !!(global.ArrayBuffer && global.DataView)\n  , CONSTR = ABV\n  , i = 0, l = 9, Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile(i < l){\n  if(Typed = global[TypedArrayConstructors[i++]]){\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV:    ABV,\n  CONSTR: CONSTR,\n  TYPED:  TYPED,\n  VIEW:   VIEW\n};","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};","var global         = require('./_global')\n  , core           = require('./_core')\n  , LIBRARY        = require('./_library')\n  , wksExt         = require('./_wks-ext')\n  , defineProperty = require('./_object-dp').f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};","exports.f = require('./_wks');","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;","var global  = require('./_global')\n  , core    = require('./_core')\n  , $export = require('./_export')\n  , partial = require('./_partial');\n// https://esdiscuss.org/topic/promise-returning-delay-function\n$export($export.G + $export.F, {\n  delay: function delay(time){\n    return new (core.Promise || global.Promise)(function(resolve){\n      setTimeout(partial.call(resolve, true), time);\n    });\n  }\n});","'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , createDesc     = require('./_property-desc')\n  , assign         = require('./_object-assign')\n  , create         = require('./_object-create')\n  , getPrototypeOf = require('./_object-gpo')\n  , getKeys        = require('./_object-keys')\n  , dP             = require('./_object-dp')\n  , keyOf          = require('./_keyof')\n  , aFunction      = require('./_a-function')\n  , forOf          = require('./_for-of')\n  , isIterable     = require('./core.is-iterable')\n  , $iterCreate    = require('./_iter-create')\n  , step           = require('./_iter-step')\n  , isObject       = require('./_is-object')\n  , toIObject      = require('./_to-iobject')\n  , DESCRIPTORS    = require('./_descriptors')\n  , has            = require('./_has');\n\n// 0 -> Dict.forEach\n// 1 -> Dict.map\n// 2 -> Dict.filter\n// 3 -> Dict.some\n// 4 -> Dict.every\n// 5 -> Dict.find\n// 6 -> Dict.findKey\n// 7 -> Dict.mapPairs\nvar createDictMethod = function(TYPE){\n  var IS_MAP   = TYPE == 1\n    , IS_EVERY = TYPE == 4;\n  return function(object, callbackfn, that /* = undefined */){\n    var f      = ctx(callbackfn, that, 3)\n      , O      = toIObject(object)\n      , result = IS_MAP || TYPE == 7 || TYPE == 2\n          ? new (typeof this == 'function' ? this : Dict) : undefined\n      , key, val, res;\n    for(key in O)if(has(O, key)){\n      val = O[key];\n      res = f(val, key, object);\n      if(TYPE){\n        if(IS_MAP)result[key] = res;            // map\n        else if(res)switch(TYPE){\n          case 2: result[key] = val; break;     // filter\n          case 3: return true;                  // some\n          case 5: return val;                   // find\n          case 6: return key;                   // findKey\n          case 7: result[res[0]] = res[1];      // mapPairs\n        } else if(IS_EVERY)return false;        // every\n      }\n    }\n    return TYPE == 3 || IS_EVERY ? IS_EVERY : result;\n  };\n};\nvar findKey = createDictMethod(6);\n\nvar createDictIter = function(kind){\n  return function(it){\n    return new DictIterator(it, kind);\n  };\n};\nvar DictIterator = function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._a = getKeys(iterated);   // keys\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n};\n$iterCreate(DictIterator, 'Dict', function(){\n  var that = this\n    , O    = that._t\n    , keys = that._a\n    , kind = that._k\n    , key;\n  do {\n    if(that._i >= keys.length){\n      that._t = undefined;\n      return step(1);\n    }\n  } while(!has(O, key = keys[that._i++]));\n  if(kind == 'keys'  )return step(0, key);\n  if(kind == 'values')return step(0, O[key]);\n  return step(0, [key, O[key]]);\n});\n\nfunction Dict(iterable){\n  var dict = create(null);\n  if(iterable != undefined){\n    if(isIterable(iterable)){\n      forOf(iterable, true, function(key, value){\n        dict[key] = value;\n      });\n    } else assign(dict, iterable);\n  }\n  return dict;\n}\nDict.prototype = null;\n\nfunction reduce(object, mapfn, init){\n  aFunction(mapfn);\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , i      = 0\n    , memo, key;\n  if(arguments.length < 3){\n    if(!length)throw TypeError('Reduce of empty object with no initial value');\n    memo = O[keys[i++]];\n  } else memo = Object(init);\n  while(length > i)if(has(O, key = keys[i++])){\n    memo = mapfn(memo, O[key], key, object);\n  }\n  return memo;\n}\n\nfunction includes(object, el){\n  return (el == el ? keyOf(object, el) : findKey(object, function(it){\n    return it != it;\n  })) !== undefined;\n}\n\nfunction get(object, key){\n  if(has(object, key))return object[key];\n}\nfunction set(object, key, value){\n  if(DESCRIPTORS && key in Object)dP.f(object, key, createDesc(0, value));\n  else object[key] = value;\n  return object;\n}\n\nfunction isDict(it){\n  return isObject(it) && getPrototypeOf(it) === Dict.prototype;\n}\n\n$export($export.G + $export.F, {Dict: Dict});\n\n$export($export.S, 'Dict', {\n  keys:     createDictIter('keys'),\n  values:   createDictIter('values'),\n  entries:  createDictIter('entries'),\n  forEach:  createDictMethod(0),\n  map:      createDictMethod(1),\n  filter:   createDictMethod(2),\n  some:     createDictMethod(3),\n  every:    createDictMethod(4),\n  find:     createDictMethod(5),\n  findKey:  findKey,\n  mapPairs: createDictMethod(7),\n  reduce:   reduce,\n  keyOf:    keyOf,\n  includes: includes,\n  has:      has,\n  get:      get,\n  set:      set,\n  isDict:   isDict\n});","var path    = require('./_path')\n  , $export = require('./_export');\n\n// Placeholder\nrequire('./_core')._ = path._ = path._ || {};\n\n$export($export.P + $export.F, 'Function', {part: require('./_partial')});","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};","var anObject = require('./_an-object')\n  , get      = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function(it){\n  var iterFn = get(it);\n  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').isIterable = function(it){\n  var O = Object(it);\n  return O[ITERATOR] !== undefined\n    || '@@iterator' in O\n    || Iterators.hasOwnProperty(classof(O));\n};","'use strict';\nrequire('./_iter-define')(Number, 'Number', function(iterated){\n  this._l = +iterated;\n  this._i = 0;\n}, function(){\n  var i    = this._i++\n    , done = !(i < this._l);\n  return {done: done, value: done ? undefined : i};\n});","var $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {classof: require('./_classof')});","var $export = require('./_export')\n  , define  = require('./_object-define');\n\n$export($export.S + $export.F, 'Object', {define: define});","var $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {isObject: require('./_is-object')});","var $export = require('./_export')\n  , define  = require('./_object-define')\n  , create  = require('./_object-create');\n\n$export($export.S + $export.F, 'Object', {\n  make: function(proto, mixin){\n    return define(create(proto), mixin);\n  }\n});","// https://github.com/benjamingr/RexExp.escape\nvar $export = require('./_export')\n  , $re     = require('./_replacer')(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});\n","'use strict';\nvar $export = require('./_export');\nvar $re = require('./_replacer')(/[&<>\"']/g, {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&apos;'\n});\n\n$export($export.P + $export.F, 'String', {escapeHTML: function escapeHTML(){ return $re(this); }});","'use strict';\nvar $export = require('./_export');\nvar $re = require('./_replacer')(/&(?:amp|lt|gt|quot|apos);/g, {\n  '&amp;':  '&',\n  '&lt;':   '<',\n  '&gt;':   '>',\n  '&quot;': '\"',\n  '&apos;': \"'\"\n});\n\n$export($export.P + $export.F, 'String', {unescapeHTML:  function unescapeHTML(){ return $re(this); }});","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});\n\nrequire('./_add-to-unscopables')('copyWithin');","'use strict';\nvar $export = require('./_export')\n  , $every  = require('./_array-methods')(4);\n\n$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {\n  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])\n  every: function every(callbackfn /* , thisArg */){\n    return $every(this, callbackfn, arguments[1]);\n  }\n});","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', {fill: require('./_array-fill')});\n\nrequire('./_add-to-unscopables')('fill');","'use strict';\nvar $export = require('./_export')\n  , $filter = require('./_array-methods')(2);\n\n$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: function filter(callbackfn /* , thisArg */){\n    return $filter(this, callbackfn, arguments[1]);\n  }\n});","'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./_export')\n  , $find   = require('./_array-methods')(6)\n  , KEY     = 'findIndex'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);","'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export')\n  , $find   = require('./_array-methods')(5)\n  , KEY     = 'find'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);","'use strict';\nvar $export  = require('./_export')\n  , $forEach = require('./_array-methods')(0)\n  , STRICT   = require('./_strict-method')([].forEach, true);\n\n$export($export.P + $export.F * !STRICT, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: function forEach(callbackfn /* , thisArg */){\n    return $forEach(this, callbackfn, arguments[1]);\n  }\n});","'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , toObject       = require('./_to-object')\n  , call           = require('./_iter-call')\n  , isArrayIter    = require('./_is-array-iter')\n  , toLength       = require('./_to-length')\n  , createProperty = require('./_create-property')\n  , getIterFn      = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar $export       = require('./_export')\n  , $indexOf      = require('./_array-includes')(false)\n  , $native       = [].indexOf\n  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? $native.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments[1]);\n  }\n});","// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = require('./_export');\n\n$export($export.S, 'Array', {isArray: require('./_is-array')});","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');","'use strict';\n// 22.1.3.13 Array.prototype.join(separator)\nvar $export   = require('./_export')\n  , toIObject = require('./_to-iobject')\n  , arrayJoin = [].join;\n\n// fallback for not array-like strings\n$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {\n  join: function join(separator){\n    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);\n  }\n});","'use strict';\nvar $export       = require('./_export')\n  , toIObject     = require('./_to-iobject')\n  , toInteger     = require('./_to-integer')\n  , toLength      = require('./_to-length')\n  , $native       = [].lastIndexOf\n  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])\n  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){\n    // convert -0 to +0\n    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;\n    var O      = toIObject(this)\n      , length = toLength(O.length)\n      , index  = length - 1;\n    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));\n    if(index < 0)index = length + index;\n    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;\n    return -1;\n  }\n});","'use strict';\nvar $export = require('./_export')\n  , $map    = require('./_array-methods')(1);\n\n$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {\n  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])\n  map: function map(callbackfn /* , thisArg */){\n    return $map(this, callbackfn, arguments[1]);\n  }\n});","'use strict';\nvar $export        = require('./_export')\n  , createProperty = require('./_create-property');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./_fails')(function(){\n  function F(){}\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */){\n    var index  = 0\n      , aLen   = arguments.length\n      , result = new (typeof this == 'function' ? this : Array)(aLen);\n    while(aLen > index)createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});","'use strict';\nvar $export = require('./_export')\n  , $reduce = require('./_array-reduce');\n\n$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {\n  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])\n  reduceRight: function reduceRight(callbackfn /* , initialValue */){\n    return $reduce(this, callbackfn, arguments.length, arguments[1], true);\n  }\n});","'use strict';\nvar $export = require('./_export')\n  , $reduce = require('./_array-reduce');\n\n$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {\n  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])\n  reduce: function reduce(callbackfn /* , initialValue */){\n    return $reduce(this, callbackfn, arguments.length, arguments[1], false);\n  }\n});","'use strict';\nvar $export    = require('./_export')\n  , html       = require('./_html')\n  , cof        = require('./_cof')\n  , toIndex    = require('./_to-index')\n  , toLength   = require('./_to-length')\n  , arraySlice = [].slice;\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * require('./_fails')(function(){\n  if(html)arraySlice.call(html);\n}), 'Array', {\n  slice: function slice(begin, end){\n    var len   = toLength(this.length)\n      , klass = cof(this);\n    end = end === undefined ? len : end;\n    if(klass == 'Array')return arraySlice.call(this, begin, end);\n    var start  = toIndex(begin, len)\n      , upTo   = toIndex(end, len)\n      , size   = toLength(upTo - start)\n      , cloned = Array(size)\n      , i      = 0;\n    for(; i < size; i++)cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});","'use strict';\nvar $export = require('./_export')\n  , $some   = require('./_array-methods')(3);\n\n$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {\n  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])\n  some: function some(callbackfn /* , thisArg */){\n    return $some(this, callbackfn, arguments[1]);\n  }\n});","'use strict';\nvar $export   = require('./_export')\n  , aFunction = require('./_a-function')\n  , toObject  = require('./_to-object')\n  , fails     = require('./_fails')\n  , $sort     = [].sort\n  , test      = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function(){\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function(){\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !require('./_strict-method')($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn){\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});","require('./_set-species')('Array');","// 20.3.3.1 / 15.9.4.4 Date.now()\nvar $export = require('./_export');\n\n$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});","'use strict';\n// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()\nvar $export = require('./_export')\n  , fails   = require('./_fails')\n  , getTime = Date.prototype.getTime;\n\nvar lz = function(num){\n  return num > 9 ? num : '0' + num;\n};\n\n// PhantomJS / old WebKit has a broken implementations\n$export($export.P + $export.F * (fails(function(){\n  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';\n}) || !fails(function(){\n  new Date(NaN).toISOString();\n})), 'Date', {\n  toISOString: function toISOString(){\n    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');\n    var d = this\n      , y = d.getUTCFullYear()\n      , m = d.getUTCMilliseconds()\n      , s = y < 0 ? '-' : y > 9999 ? '+' : '';\n    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +\n      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +\n      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +\n      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';\n  }\n});","'use strict';\nvar $export     = require('./_export')\n  , toObject    = require('./_to-object')\n  , toPrimitive = require('./_to-primitive');\n\n$export($export.P + $export.F * require('./_fails')(function(){\n  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;\n}), 'Date', {\n  toJSON: function toJSON(key){\n    var O  = toObject(this)\n      , pv = toPrimitive(O);\n    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();\n  }\n});","var TO_PRIMITIVE = require('./_wks')('toPrimitive')\n  , proto        = Date.prototype;\n\nif(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));","var DateProto    = Date.prototype\n  , INVALID_DATE = 'Invalid Date'\n  , TO_STRING    = 'toString'\n  , $toString    = DateProto[TO_STRING]\n  , getTime      = DateProto.getTime;\nif(new Date(NaN) + '' != INVALID_DATE){\n  require('./_redefine')(DateProto, TO_STRING, function toString(){\n    var value = getTime.call(this);\n    return value === value ? $toString.call(this) : INVALID_DATE;\n  });\n}","// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = require('./_export');\n\n$export($export.P, 'Function', {bind: require('./_bind')});","'use strict';\nvar isObject       = require('./_is-object')\n  , getPrototypeOf = require('./_object-gpo')\n  , HAS_INSTANCE   = require('./_wks')('hasInstance')\n  , FunctionProto  = Function.prototype;\n// 19.2.3.6 Function.prototype[@@hasInstance](V)\nif(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){\n  if(typeof this != 'function' || !isObject(O))return false;\n  if(!isObject(this.prototype))return O instanceof this;\n  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:\n  while(O = getPrototypeOf(O))if(this.prototype === O)return true;\n  return false;\n}});","var dP         = require('./_object-dp').f\n  , createDesc = require('./_property-desc')\n  , has        = require('./_has')\n  , FProto     = Function.prototype\n  , nameRE     = /^\\s*function ([^ (]*)/\n  , NAME       = 'name';\n\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function(){\n    try {\n      var that = this\n        , name = ('' + that).match(nameRE)[1];\n      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));\n      return name;\n    } catch(e){\n      return '';\n    }\n  }\n});","'use strict';\nvar strong = require('./_collection-strong');\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')('Map', function(get){\n  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key){\n    var entry = strong.getEntry(this, key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value){\n    return strong.def(this, key === 0 ? 0 : key, value);\n  }\n}, strong, true);","// 20.2.2.3 Math.acosh(x)\nvar $export = require('./_export')\n  , log1p   = require('./_math-log1p')\n  , sqrt    = Math.sqrt\n  , $acosh  = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN \n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x){\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});","// 20.2.2.5 Math.asinh(x)\nvar $export = require('./_export')\n  , $asinh  = Math.asinh;\n\nfunction asinh(x){\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0 \n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});","// 20.2.2.7 Math.atanh(x)\nvar $export = require('./_export')\n  , $atanh  = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0 \n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x){\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});","// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./_export')\n  , sign    = require('./_math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x){\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});","// 20.2.2.11 Math.clz32(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x){\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});","// 20.2.2.12 Math.cosh(x)\nvar $export = require('./_export')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x){\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});","// 20.2.2.14 Math.expm1(x)\nvar $export = require('./_export')\n  , $expm1  = require('./_math-expm1');\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});","// 20.2.2.16 Math.fround(x)\nvar $export   = require('./_export')\n  , sign      = require('./_math-sign')\n  , pow       = Math.pow\n  , EPSILON   = pow(2, -52)\n  , EPSILON32 = pow(2, -23)\n  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n  , MIN32     = pow(2, -126);\n\nvar roundTiesToEven = function(n){\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\n\n$export($export.S, 'Math', {\n  fround: function fround(x){\n    var $abs  = Math.abs(x)\n      , $sign = sign(x)\n      , a, result;\n    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n    a = (1 + EPSILON32 / EPSILON) * $abs;\n    result = a - (a - $abs);\n    if(result > MAX32 || result != result)return $sign * Infinity;\n    return $sign * result;\n  }\n});","// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\nvar $export = require('./_export')\n  , abs     = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars\n    var sum  = 0\n      , i    = 0\n      , aLen = arguments.length\n      , larg = 0\n      , arg, div;\n    while(i < aLen){\n      arg = abs(arguments[i++]);\n      if(larg < arg){\n        div  = larg / arg;\n        sum  = sum * div * div + 1;\n        larg = arg;\n      } else if(arg > 0){\n        div  = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});","// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./_export')\n  , $imul   = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./_fails')(function(){\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y){\n    var UINT16 = 0xffff\n      , xn = +x\n      , yn = +y\n      , xl = UINT16 & xn\n      , yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});","// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x){\n    return Math.log(x) / Math.LN10;\n  }\n});","// 20.2.2.20 Math.log1p(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {log1p: require('./_math-log1p')});","// 20.2.2.22 Math.log2(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x){\n    return Math.log(x) / Math.LN2;\n  }\n});","// 20.2.2.28 Math.sign(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {sign: require('./_math-sign')});","// 20.2.2.30 Math.sinh(x)\nvar $export = require('./_export')\n  , expm1   = require('./_math-expm1')\n  , exp     = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./_fails')(function(){\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x){\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});","// 20.2.2.33 Math.tanh(x)\nvar $export = require('./_export')\n  , expm1   = require('./_math-expm1')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x){\n    var a = expm1(x = +x)\n      , b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});","// 20.2.2.34 Math.trunc(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it){\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});","'use strict';\nvar global            = require('./_global')\n  , has               = require('./_has')\n  , cof               = require('./_cof')\n  , inheritIfRequired = require('./_inherit-if-required')\n  , toPrimitive       = require('./_to-primitive')\n  , fails             = require('./_fails')\n  , gOPN              = require('./_object-gopn').f\n  , gOPD              = require('./_object-gopd').f\n  , dP                = require('./_object-dp').f\n  , $trim             = require('./_string-trim').trim\n  , NUMBER            = 'Number'\n  , $Number           = global[NUMBER]\n  , Base              = $Number\n  , proto             = $Number.prototype\n  // Opera ~12 has broken Object#toString\n  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER\n  , TRIM              = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function(argument){\n  var it = toPrimitive(argument, false);\n  if(typeof it == 'string' && it.length > 2){\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0)\n      , third, radix, maxCode;\n    if(first === 43 || first === 45){\n      third = it.charCodeAt(2);\n      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if(first === 48){\n      switch(it.charCodeAt(1)){\n        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default : return +it;\n      }\n      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if(code < 48 || code > maxCode)return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){\n  $Number = function Number(value){\n    var it = arguments.length < 1 ? 0 : value\n      , that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for(var keys = require('./_descriptors') ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++){\n    if(has(Base, key = keys[j]) && !has($Number, key)){\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  require('./_redefine')(global, NUMBER, $Number);\n}","// 20.1.2.1 Number.EPSILON\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});","// 20.1.2.2 Number.isFinite(number)\nvar $export   = require('./_export')\n  , _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it){\n    return typeof it == 'number' && _isFinite(it);\n  }\n});","// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {isInteger: require('./_is-integer')});","// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number){\n    return number != number;\n  }\n});","// 20.1.2.5 Number.isSafeInteger(number)\nvar $export   = require('./_export')\n  , isInteger = require('./_is-integer')\n  , abs       = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number){\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});","// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});","var $export     = require('./_export')\n  , $parseFloat = require('./_parse-float');\n// 20.1.2.12 Number.parseFloat(string)\n$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});","var $export   = require('./_export')\n  , $parseInt = require('./_parse-int');\n// 20.1.2.13 Number.parseInt(string, radix)\n$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});","'use strict';\nvar $export      = require('./_export')\n  , toInteger    = require('./_to-integer')\n  , aNumberValue = require('./_a-number-value')\n  , repeat       = require('./_string-repeat')\n  , $toFixed     = 1..toFixed\n  , floor        = Math.floor\n  , data         = [0, 0, 0, 0, 0, 0]\n  , ERROR        = 'Number.toFixed: incorrect invocation!'\n  , ZERO         = '0';\n\nvar multiply = function(n, c){\n  var i  = -1\n    , c2 = c;\n  while(++i < 6){\n    c2 += n * data[i];\n    data[i] = c2 % 1e7;\n    c2 = floor(c2 / 1e7);\n  }\n};\nvar divide = function(n){\n  var i = 6\n    , c = 0;\n  while(--i >= 0){\n    c += data[i];\n    data[i] = floor(c / n);\n    c = (c % n) * 1e7;\n  }\n};\nvar numToString = function(){\n  var i = 6\n    , s = '';\n  while(--i >= 0){\n    if(s !== '' || i === 0 || data[i] !== 0){\n      var t = String(data[i]);\n      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;\n    }\n  } return s;\n};\nvar pow = function(x, n, acc){\n  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);\n};\nvar log = function(x){\n  var n  = 0\n    , x2 = x;\n  while(x2 >= 4096){\n    n += 12;\n    x2 /= 4096;\n  }\n  while(x2 >= 2){\n    n  += 1;\n    x2 /= 2;\n  } return n;\n};\n\n$export($export.P + $export.F * (!!$toFixed && (\n  0.00008.toFixed(3) !== '0.000' ||\n  0.9.toFixed(0) !== '1' ||\n  1.255.toFixed(2) !== '1.25' ||\n  1000000000000000128..toFixed(0) !== '1000000000000000128'\n) || !require('./_fails')(function(){\n  // V8 ~ Android 4.3-\n  $toFixed.call({});\n})), 'Number', {\n  toFixed: function toFixed(fractionDigits){\n    var x = aNumberValue(this, ERROR)\n      , f = toInteger(fractionDigits)\n      , s = ''\n      , m = ZERO\n      , e, z, j, k;\n    if(f < 0 || f > 20)throw RangeError(ERROR);\n    if(x != x)return 'NaN';\n    if(x <= -1e21 || x >= 1e21)return String(x);\n    if(x < 0){\n      s = '-';\n      x = -x;\n    }\n    if(x > 1e-21){\n      e = log(x * pow(2, 69, 1)) - 69;\n      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);\n      z *= 0x10000000000000;\n      e = 52 - e;\n      if(e > 0){\n        multiply(0, z);\n        j = f;\n        while(j >= 7){\n          multiply(1e7, 0);\n          j -= 7;\n        }\n        multiply(pow(10, j, 1), 0);\n        j = e - 1;\n        while(j >= 23){\n          divide(1 << 23);\n          j -= 23;\n        }\n        divide(1 << j);\n        multiply(1, 1);\n        divide(2);\n        m = numToString();\n      } else {\n        multiply(0, z);\n        multiply(1 << -e, 0);\n        m = numToString() + repeat.call(ZERO, f);\n      }\n    }\n    if(f > 0){\n      k = m.length;\n      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));\n    } else {\n      m = s + m;\n    } return m;\n  }\n});","'use strict';\nvar $export      = require('./_export')\n  , $fails       = require('./_fails')\n  , aNumberValue = require('./_a-number-value')\n  , $toPrecision = 1..toPrecision;\n\n$export($export.P + $export.F * ($fails(function(){\n  // IE7-\n  return $toPrecision.call(1, undefined) !== '1';\n}) || !$fails(function(){\n  // V8 ~ Android 4.3-\n  $toPrecision.call({});\n})), 'Number', {\n  toPrecision: function toPrecision(precision){\n    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');\n    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); \n  }\n});","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});","var $export = require('./_export')\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', {create: require('./_object-create')});","var $export = require('./_export');\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});","// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object')\n  , meta     = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function($freeze){\n  return function freeze(it){\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject                 = require('./_to-iobject')\n  , $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function(){\n  return function getOwnPropertyDescriptor(it, key){\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});","// 19.1.2.7 Object.getOwnPropertyNames(O)\nrequire('./_object-sap')('getOwnPropertyNames', function(){\n  return require('./_object-gopn-ext').f;\n});","// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject        = require('./_to-object')\n  , $getPrototypeOf = require('./_object-gpo');\n\nrequire('./_object-sap')('getPrototypeOf', function(){\n  return function getPrototypeOf(it){\n    return $getPrototypeOf(toObject(it));\n  };\n});","// 19.1.2.11 Object.isExtensible(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isExtensible', function($isExtensible){\n  return function isExtensible(it){\n    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;\n  };\n});","// 19.1.2.12 Object.isFrozen(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isFrozen', function($isFrozen){\n  return function isFrozen(it){\n    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;\n  };\n});","// 19.1.2.13 Object.isSealed(O)\nvar isObject = require('./_is-object');\n\nrequire('./_object-sap')('isSealed', function($isSealed){\n  return function isSealed(it){\n    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;\n  };\n});","// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./_export');\n$export($export.S, 'Object', {is: require('./_same-value')});","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object')\n  , $keys    = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function(){\n  return function keys(it){\n    return $keys(toObject(it));\n  };\n});","// 19.1.2.15 Object.preventExtensions(O)\nvar isObject = require('./_is-object')\n  , meta     = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('preventExtensions', function($preventExtensions){\n  return function preventExtensions(it){\n    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;\n  };\n});","// 19.1.2.17 Object.seal(O)\nvar isObject = require('./_is-object')\n  , meta     = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('seal', function($seal){\n  return function seal(it){\n    return $seal && isObject(it) ? $seal(meta(it)) : it;\n  };\n});","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});","'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = require('./_classof')\n  , test    = {};\ntest[require('./_wks')('toStringTag')] = 'z';\nif(test + '' != '[object z]'){\n  require('./_redefine')(Object.prototype, 'toString', function toString(){\n    return '[object ' + classof(this) + ']';\n  }, true);\n}","var $export     = require('./_export')\n  , $parseFloat = require('./_parse-float');\n// 18.2.4 parseFloat(string)\n$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});","var $export   = require('./_export')\n  , $parseInt = require('./_parse-int');\n// 18.2.5 parseInt(string, radix)\n$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});","'use strict';\nvar LIBRARY            = require('./_library')\n  , global             = require('./_global')\n  , ctx                = require('./_ctx')\n  , classof            = require('./_classof')\n  , $export            = require('./_export')\n  , isObject           = require('./_is-object')\n  , aFunction          = require('./_a-function')\n  , anInstance         = require('./_an-instance')\n  , forOf              = require('./_for-of')\n  , speciesConstructor = require('./_species-constructor')\n  , task               = require('./_task').set\n  , microtask          = require('./_microtask')()\n  , PROMISE            = 'Promise'\n  , TypeError          = global.TypeError\n  , process            = global.process\n  , $Promise           = global[PROMISE]\n  , process            = global.process\n  , isNode             = classof(process) == 'process'\n  , empty              = function(){ /* empty */ }\n  , Internal, GenericPromiseCapability, Wrapper;\n\nvar USE_NATIVE = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject  = aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(global, function(){\n    var handler;\n    if(isNode){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject  = ctx($reject, promise, 1);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});","// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export   = require('./_export')\n  , aFunction = require('./_a-function')\n  , anObject  = require('./_an-object')\n  , rApply    = (require('./_global').Reflect || {}).apply\n  , fApply    = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !require('./_fails')(function(){\n  rApply(function(){});\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList){\n    var T = aFunction(target)\n      , L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});","// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export    = require('./_export')\n  , create     = require('./_object-create')\n  , aFunction  = require('./_a-function')\n  , anObject   = require('./_an-object')\n  , isObject   = require('./_is-object')\n  , fails      = require('./_fails')\n  , bind       = require('./_bind')\n  , rConstruct = (require('./_global').Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function(){\n  function F(){}\n  return !(rConstruct(function(){}, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function(){\n  rConstruct(function(){});\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /*, newTarget*/){\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);\n    if(Target == newTarget){\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch(args.length){\n        case 0: return new Target;\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args));\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto    = newTarget.prototype\n      , instance = create(isObject(proto) ? proto : Object.prototype)\n      , result   = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});","// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP          = require('./_object-dp')\n  , $export     = require('./_export')\n  , anObject    = require('./_an-object')\n  , toPrimitive = require('./_to-primitive');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./_fails')(function(){\n  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes){\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});","// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export  = require('./_export')\n  , gOPD     = require('./_object-gopd').f\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey){\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});","'use strict';\n// 26.1.5 Reflect.enumerate(target)\nvar $export  = require('./_export')\n  , anObject = require('./_an-object');\nvar Enumerate = function(iterated){\n  this._t = anObject(iterated); // target\n  this._i = 0;                  // next index\n  var keys = this._k = []       // keys\n    , key;\n  for(key in iterated)keys.push(key);\n};\nrequire('./_iter-create')(Enumerate, 'Object', function(){\n  var that = this\n    , keys = that._k\n    , key;\n  do {\n    if(that._i >= keys.length)return {value: undefined, done: true};\n  } while(!((key = keys[that._i++]) in that._t));\n  return {value: key, done: false};\n});\n\n$export($export.S, 'Reflect', {\n  enumerate: function enumerate(target){\n    return new Enumerate(target);\n  }\n});","// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD     = require('./_object-gopd')\n  , $export  = require('./_export')\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});","// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export  = require('./_export')\n  , getProto = require('./_object-gpo')\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target){\n    return getProto(anObject(target));\n  }\n});","// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD           = require('./_object-gopd')\n  , getPrototypeOf = require('./_object-gpo')\n  , has            = require('./_has')\n  , $export        = require('./_export')\n  , isObject       = require('./_is-object')\n  , anObject       = require('./_an-object');\n\nfunction get(target, propertyKey/*, receiver*/){\n  var receiver = arguments.length < 3 ? target : arguments[2]\n    , desc, proto;\n  if(anObject(target) === receiver)return target[propertyKey];\n  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', {get: get});","// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey){\n    return propertyKey in target;\n  }\n});","// 26.1.10 Reflect.isExtensible(target)\nvar $export       = require('./_export')\n  , anObject      = require('./_an-object')\n  , $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target){\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});","// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});","// 26.1.12 Reflect.preventExtensions(target)\nvar $export            = require('./_export')\n  , anObject           = require('./_an-object')\n  , $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target){\n    anObject(target);\n    try {\n      if($preventExtensions)$preventExtensions(target);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});","// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export  = require('./_export')\n  , setProto = require('./_set-proto');\n\nif(setProto)$export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto){\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});","// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP             = require('./_object-dp')\n  , gOPD           = require('./_object-gopd')\n  , getPrototypeOf = require('./_object-gpo')\n  , has            = require('./_has')\n  , $export        = require('./_export')\n  , createDesc     = require('./_property-desc')\n  , anObject       = require('./_an-object')\n  , isObject       = require('./_is-object');\n\nfunction set(target, propertyKey, V/*, receiver*/){\n  var receiver = arguments.length < 4 ? target : arguments[3]\n    , ownDesc  = gOPD.f(anObject(target), propertyKey)\n    , existingDescriptor, proto;\n  if(!ownDesc){\n    if(isObject(proto = getPrototypeOf(target))){\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if(has(ownDesc, 'value')){\n    if(ownDesc.writable === false || !isObject(receiver))return false;\n    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);\n    existingDescriptor.value = V;\n    dP.f(receiver, propertyKey, existingDescriptor);\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', {set: set});","var global            = require('./_global')\n  , inheritIfRequired = require('./_inherit-if-required')\n  , dP                = require('./_object-dp').f\n  , gOPN              = require('./_object-gopn').f\n  , isRegExp          = require('./_is-regexp')\n  , $flags            = require('./_flags')\n  , $RegExp           = global.RegExp\n  , Base              = $RegExp\n  , proto             = $RegExp.prototype\n  , re1               = /a/g\n  , re2               = /a/g\n  // \"new\" creates a new object, old webkit buggy here\n  , CORRECT_NEW       = new $RegExp(re1) !== re1;\n\nif(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){\n  re2[require('./_wks')('match')] = false;\n  // RegExp constructor can alter flags and IsRegExp works correct with @@match\n  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';\n}))){\n  $RegExp = function RegExp(p, f){\n    var tiRE = this instanceof $RegExp\n      , piRE = isRegExp(p)\n      , fiU  = f === undefined;\n    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p\n      : inheritIfRequired(CORRECT_NEW\n        ? new Base(piRE && !fiU ? p.source : p, f)\n        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)\n      , tiRE ? this : proto, $RegExp);\n  };\n  var proxy = function(key){\n    key in $RegExp || dP($RegExp, key, {\n      configurable: true,\n      get: function(){ return Base[key]; },\n      set: function(it){ Base[key] = it; }\n    });\n  };\n  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);\n  proto.constructor = $RegExp;\n  $RegExp.prototype = proto;\n  require('./_redefine')(global, 'RegExp', $RegExp);\n}\n\nrequire('./_set-species')('RegExp');","// 21.2.5.3 get RegExp.prototype.flags()\nif(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./_flags')\n});","// @@match logic\nrequire('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});","// @@replace logic\nrequire('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue){\n    'use strict';\n    var O  = defined(this)\n      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});","// @@search logic\nrequire('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});","// @@split logic\nrequire('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){\n  'use strict';\n  var isRegExp   = require('./_is-regexp')\n    , _split     = $split\n    , $push      = [].push\n    , $SPLIT     = 'split'\n    , LENGTH     = 'length'\n    , LAST_INDEX = 'lastIndex';\n  if(\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ){\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function(separator, limit){\n      var string = String(this);\n      if(separator === undefined && limit === 0)return [];\n      // If `separator` is not a regex, use native split\n      if(!isRegExp(separator))return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while(match = separatorCopy.exec(string)){\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if(lastIndex > lastLastIndex){\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){\n            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;\n          });\n          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if(output[LENGTH] >= splitLimit)break;\n        }\n        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if(lastLastIndex === string[LENGTH]){\n        if(lastLength || !separatorCopy.test(''))output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){\n    $split = function(separator, limit){\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit){\n    var O  = defined(this)\n      , fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});","'use strict';\nrequire('./es6.regexp.flags');\nvar anObject    = require('./_an-object')\n  , $flags      = require('./_flags')\n  , DESCRIPTORS = require('./_descriptors')\n  , TO_STRING   = 'toString'\n  , $toString   = /./[TO_STRING];\n\nvar define = function(fn){\n  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);\n};\n\n// 21.2.5.14 RegExp.prototype.toString()\nif(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){\n  define(function toString(){\n    var R = anObject(this);\n    return '/'.concat(R.source, '/',\n      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);\n  });\n// FF44- RegExp#toString has a wrong name\n} else if($toString.name != TO_STRING){\n  define(function toString(){\n    return $toString.call(this);\n  });\n}","'use strict';\nvar strong = require('./_collection-strong');\n\n// 23.2 Set Objects\nmodule.exports = require('./_collection')('Set', function(get){\n  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value){\n    return strong.def(this, value = value === 0 ? 0 : value, value);\n  }\n}, strong);","'use strict';\n// B.2.3.2 String.prototype.anchor(name)\nrequire('./_string-html')('anchor', function(createHTML){\n  return function anchor(name){\n    return createHTML(this, 'a', 'name', name);\n  }\n});","'use strict';\n// B.2.3.3 String.prototype.big()\nrequire('./_string-html')('big', function(createHTML){\n  return function big(){\n    return createHTML(this, 'big', '', '');\n  }\n});","'use strict';\n// B.2.3.4 String.prototype.blink()\nrequire('./_string-html')('blink', function(createHTML){\n  return function blink(){\n    return createHTML(this, 'blink', '', '');\n  }\n});","'use strict';\n// B.2.3.5 String.prototype.bold()\nrequire('./_string-html')('bold', function(createHTML){\n  return function bold(){\n    return createHTML(this, 'b', '', '');\n  }\n});","'use strict';\nvar $export = require('./_export')\n  , $at     = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos){\n    return $at(this, pos);\n  }\n});","// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export   = require('./_export')\n  , toLength  = require('./_to-length')\n  , context   = require('./_string-context')\n  , ENDS_WITH = 'endsWith'\n  , $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /*, endPosition = @length */){\n    var that = context(this, searchString, ENDS_WITH)\n      , endPosition = arguments.length > 1 ? arguments[1] : undefined\n      , len    = toLength(that.length)\n      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)\n      , search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});","'use strict';\n// B.2.3.6 String.prototype.fixed()\nrequire('./_string-html')('fixed', function(createHTML){\n  return function fixed(){\n    return createHTML(this, 'tt', '', '');\n  }\n});","'use strict';\n// B.2.3.7 String.prototype.fontcolor(color)\nrequire('./_string-html')('fontcolor', function(createHTML){\n  return function fontcolor(color){\n    return createHTML(this, 'font', 'color', color);\n  }\n});","'use strict';\n// B.2.3.8 String.prototype.fontsize(size)\nrequire('./_string-html')('fontsize', function(createHTML){\n  return function fontsize(size){\n    return createHTML(this, 'font', 'size', size);\n  }\n});","var $export        = require('./_export')\n  , toIndex        = require('./_to-index')\n  , fromCharCode   = String.fromCharCode\n  , $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars\n    var res  = []\n      , aLen = arguments.length\n      , i    = 0\n      , code;\n    while(aLen > i){\n      code = +arguments[i++];\n      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});","// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export  = require('./_export')\n  , context  = require('./_string-context')\n  , INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /*, position = 0 */){\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});","'use strict';\n// B.2.3.9 String.prototype.italics()\nrequire('./_string-html')('italics', function(createHTML){\n  return function italics(){\n    return createHTML(this, 'i', '', '');\n  }\n});","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});","'use strict';\n// B.2.3.10 String.prototype.link(url)\nrequire('./_string-html')('link', function(createHTML){\n  return function link(url){\n    return createHTML(this, 'a', 'href', url);\n  }\n});","var $export   = require('./_export')\n  , toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite){\n    var tpl  = toIObject(callSite.raw)\n      , len  = toLength(tpl.length)\n      , aLen = arguments.length\n      , res  = []\n      , i    = 0;\n    while(len > i){\n      res.push(String(tpl[i++]));\n      if(i < aLen)res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});","var $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});","'use strict';\n// B.2.3.11 String.prototype.small()\nrequire('./_string-html')('small', function(createHTML){\n  return function small(){\n    return createHTML(this, 'small', '', '');\n  }\n});","// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export     = require('./_export')\n  , toLength    = require('./_to-length')\n  , context     = require('./_string-context')\n  , STARTS_WITH = 'startsWith'\n  , $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /*, position = 0 */){\n    var that   = context(this, searchString, STARTS_WITH)\n      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))\n      , search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});","'use strict';\n// B.2.3.12 String.prototype.strike()\nrequire('./_string-html')('strike', function(createHTML){\n  return function strike(){\n    return createHTML(this, 'strike', '', '');\n  }\n});","'use strict';\n// B.2.3.13 String.prototype.sub()\nrequire('./_string-html')('sub', function(createHTML){\n  return function sub(){\n    return createHTML(this, 'sub', '', '');\n  }\n});","'use strict';\n// B.2.3.14 String.prototype.sup()\nrequire('./_string-html')('sup', function(createHTML){\n  return function sup(){\n    return createHTML(this, 'sup', '', '');\n  }\n});","'use strict';\n// 21.1.3.25 String.prototype.trim()\nrequire('./_string-trim')('trim', function($trim){\n  return function trim(){\n    return $trim(this, 3);\n  };\n});","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);","'use strict';\nvar $export      = require('./_export')\n  , $typed       = require('./_typed')\n  , buffer       = require('./_typed-buffer')\n  , anObject     = require('./_an-object')\n  , toIndex      = require('./_to-index')\n  , toLength     = require('./_to-length')\n  , isObject     = require('./_is-object')\n  , ArrayBuffer  = require('./_global').ArrayBuffer\n  , speciesConstructor = require('./_species-constructor')\n  , $ArrayBuffer = buffer.ArrayBuffer\n  , $DataView    = buffer.DataView\n  , $isView      = $typed.ABV && ArrayBuffer.isView\n  , $slice       = $ArrayBuffer.prototype.slice\n  , VIEW         = $typed.VIEW\n  , ARRAY_BUFFER = 'ArrayBuffer';\n\n$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});\n\n$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {\n  // 24.1.3.1 ArrayBuffer.isView(arg)\n  isView: function isView(it){\n    return $isView && $isView(it) || isObject(it) && VIEW in it;\n  }\n});\n\n$export($export.P + $export.U + $export.F * require('./_fails')(function(){\n  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;\n}), ARRAY_BUFFER, {\n  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)\n  slice: function slice(start, end){\n    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix\n    var len    = anObject(this).byteLength\n      , first  = toIndex(start, len)\n      , final  = toIndex(end === undefined ? len : end, len)\n      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))\n      , viewS  = new $DataView(this)\n      , viewT  = new $DataView(result)\n      , index  = 0;\n    while(first < final){\n      viewT.setUint8(index++, viewS.getUint8(first++));\n    } return result;\n  }\n});\n\nrequire('./_set-species')(ARRAY_BUFFER);","var $export = require('./_export');\n$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {\n  DataView: require('./_typed-buffer').DataView\n});","require('./_typed-array')('Float32', 4, function(init){\n  return function Float32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Float64', 8, function(init){\n  return function Float64Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Int16', 2, function(init){\n  return function Int16Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Int32', 4, function(init){\n  return function Int32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Int8', 1, function(init){\n  return function Int8Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Uint16', 2, function(init){\n  return function Uint16Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Uint32', 4, function(init){\n  return function Uint32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Uint8', 1, function(init){\n  return function Uint8Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});","require('./_typed-array')('Uint8', 1, function(init){\n  return function Uint8ClampedArray(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n}, true);","'use strict';\nvar each         = require('./_array-methods')(0)\n  , redefine     = require('./_redefine')\n  , meta         = require('./_meta')\n  , assign       = require('./_object-assign')\n  , weak         = require('./_collection-weak')\n  , isObject     = require('./_is-object')\n  , getWeak      = meta.getWeak\n  , isExtensible = Object.isExtensible\n  , uncaughtFrozenStore = weak.ufstore\n  , tmp          = {}\n  , InternalMap;\n\nvar wrapper = function(get){\n  return function WeakMap(){\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key){\n    if(isObject(key)){\n      var data = getWeak(key);\n      if(data === true)return uncaughtFrozenStore(this).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value){\n    return weak.def(this, key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){\n  InternalMap = weak.getConstructor(wrapper);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function(key){\n    var proto  = $WeakMap.prototype\n      , method = proto[key];\n    redefine(proto, key, function(a, b){\n      // store frozen objects on internal weakmap shim\n      if(isObject(a) && !isExtensible(a)){\n        if(!this._f)this._f = new InternalMap;\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}","'use strict';\nvar weak = require('./_collection-weak');\n\n// 23.4 WeakSet Objects\nrequire('./_collection')('WeakSet', function(get){\n  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value){\n    return weak.def(this, value, true);\n  }\n}, weak, false, true);","'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export   = require('./_export')\n  , $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /*, fromIndex = 0 */){\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');","// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask\nvar $export   = require('./_export')\n  , microtask = require('./_microtask')()\n  , process   = require('./_global').process\n  , isNode    = require('./_cof')(process) == 'process';\n\n$export($export.G, {\n  asap: function asap(fn){\n    var domain = isNode && process.domain;\n    microtask(domain ? domain.bind(fn) : fn);\n  }\n});","// https://github.com/ljharb/proposal-is-error\nvar $export = require('./_export')\n  , cof     = require('./_cof');\n\n$export($export.S, 'Error', {\n  isError: function isError(it){\n    return cof(it) === 'Error';\n  }\n});","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = require('./_export');\n\n$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  iaddh: function iaddh(x0, x1, y0, y1){\n    var $x0 = x0 >>> 0\n      , $x1 = x1 >>> 0\n      , $y0 = y0 >>> 0;\n    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;\n  }\n});","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  imulh: function imulh(u, v){\n    var UINT16 = 0xffff\n      , $u = +u\n      , $v = +v\n      , u0 = $u & UINT16\n      , v0 = $v & UINT16\n      , u1 = $u >> 16\n      , v1 = $v >> 16\n      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);\n  }\n});","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  isubh: function isubh(x0, x1, y0, y1){\n    var $x0 = x0 >>> 0\n      , $x1 = x1 >>> 0\n      , $y0 = y0 >>> 0;\n    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;\n  }\n});","// https://gist.github.com/BrendanEich/4294d5c212a6d2254703\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  umulh: function umulh(u, v){\n    var UINT16 = 0xffff\n      , $u = +u\n      , $v = +v\n      , u0 = $u & UINT16\n      , v0 = $v & UINT16\n      , u1 = $u >>> 16\n      , v1 = $v >>> 16\n      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);\n    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);\n  }\n});","'use strict';\nvar $export         = require('./_export')\n  , toObject        = require('./_to-object')\n  , aFunction       = require('./_a-function')\n  , $defineProperty = require('./_object-dp');\n\n// B.2.2.2 Object.prototype.__defineGetter__(P, getter)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __defineGetter__: function __defineGetter__(P, getter){\n    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});\n  }\n});","'use strict';\nvar $export         = require('./_export')\n  , toObject        = require('./_to-object')\n  , aFunction       = require('./_a-function')\n  , $defineProperty = require('./_object-dp');\n\n// B.2.2.3 Object.prototype.__defineSetter__(P, setter)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __defineSetter__: function __defineSetter__(P, setter){\n    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});\n  }\n});","// https://github.com/tc39/proposal-object-values-entries\nvar $export  = require('./_export')\n  , $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it){\n    return $entries(it);\n  }\n});","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export        = require('./_export')\n  , ownKeys        = require('./_own-keys')\n  , toIObject      = require('./_to-iobject')\n  , gOPD           = require('./_object-gopd')\n  , createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){\n    var O       = toIObject(object)\n      , getDesc = gOPD.f\n      , keys    = ownKeys(O)\n      , result  = {}\n      , i       = 0\n      , key;\n    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));\n    return result;\n  }\n});","'use strict';\nvar $export                  = require('./_export')\n  , toObject                 = require('./_to-object')\n  , toPrimitive              = require('./_to-primitive')\n  , getPrototypeOf           = require('./_object-gpo')\n  , getOwnPropertyDescriptor = require('./_object-gopd').f;\n\n// B.2.2.4 Object.prototype.__lookupGetter__(P)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __lookupGetter__: function __lookupGetter__(P){\n    var O = toObject(this)\n      , K = toPrimitive(P, true)\n      , D;\n    do {\n      if(D = getOwnPropertyDescriptor(O, K))return D.get;\n    } while(O = getPrototypeOf(O));\n  }\n});","'use strict';\nvar $export                  = require('./_export')\n  , toObject                 = require('./_to-object')\n  , toPrimitive              = require('./_to-primitive')\n  , getPrototypeOf           = require('./_object-gpo')\n  , getOwnPropertyDescriptor = require('./_object-gopd').f;\n\n// B.2.2.5 Object.prototype.__lookupSetter__(P)\nrequire('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {\n  __lookupSetter__: function __lookupSetter__(P){\n    var O = toObject(this)\n      , K = toPrimitive(P, true)\n      , D;\n    do {\n      if(D = getOwnPropertyDescriptor(O, K))return D.set;\n    } while(O = getPrototypeOf(O));\n  }\n});","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export')\n  , $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it){\n    return $values(it);\n  }\n});","'use strict';\n// https://github.com/zenparsing/es-observable\nvar $export     = require('./_export')\n  , global      = require('./_global')\n  , core        = require('./_core')\n  , microtask   = require('./_microtask')()\n  , OBSERVABLE  = require('./_wks')('observable')\n  , aFunction   = require('./_a-function')\n  , anObject    = require('./_an-object')\n  , anInstance  = require('./_an-instance')\n  , redefineAll = require('./_redefine-all')\n  , hide        = require('./_hide')\n  , forOf       = require('./_for-of')\n  , RETURN      = forOf.RETURN;\n\nvar getMethod = function(fn){\n  return fn == null ? undefined : aFunction(fn);\n};\n\nvar cleanupSubscription = function(subscription){\n  var cleanup = subscription._c;\n  if(cleanup){\n    subscription._c = undefined;\n    cleanup();\n  }\n};\n\nvar subscriptionClosed = function(subscription){\n  return subscription._o === undefined;\n};\n\nvar closeSubscription = function(subscription){\n  if(!subscriptionClosed(subscription)){\n    subscription._o = undefined;\n    cleanupSubscription(subscription);\n  }\n};\n\nvar Subscription = function(observer, subscriber){\n  anObject(observer);\n  this._c = undefined;\n  this._o = observer;\n  observer = new SubscriptionObserver(this);\n  try {\n    var cleanup      = subscriber(observer)\n      , subscription = cleanup;\n    if(cleanup != null){\n      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };\n      else aFunction(cleanup);\n      this._c = cleanup;\n    }\n  } catch(e){\n    observer.error(e);\n    return;\n  } if(subscriptionClosed(this))cleanupSubscription(this);\n};\n\nSubscription.prototype = redefineAll({}, {\n  unsubscribe: function unsubscribe(){ closeSubscription(this); }\n});\n\nvar SubscriptionObserver = function(subscription){\n  this._s = subscription;\n};\n\nSubscriptionObserver.prototype = redefineAll({}, {\n  next: function next(value){\n    var subscription = this._s;\n    if(!subscriptionClosed(subscription)){\n      var observer = subscription._o;\n      try {\n        var m = getMethod(observer.next);\n        if(m)return m.call(observer, value);\n      } catch(e){\n        try {\n          closeSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      }\n    }\n  },\n  error: function error(value){\n    var subscription = this._s;\n    if(subscriptionClosed(subscription))throw value;\n    var observer = subscription._o;\n    subscription._o = undefined;\n    try {\n      var m = getMethod(observer.error);\n      if(!m)throw value;\n      value = m.call(observer, value);\n    } catch(e){\n      try {\n        cleanupSubscription(subscription);\n      } finally {\n        throw e;\n      }\n    } cleanupSubscription(subscription);\n    return value;\n  },\n  complete: function complete(value){\n    var subscription = this._s;\n    if(!subscriptionClosed(subscription)){\n      var observer = subscription._o;\n      subscription._o = undefined;\n      try {\n        var m = getMethod(observer.complete);\n        value = m ? m.call(observer, value) : undefined;\n      } catch(e){\n        try {\n          cleanupSubscription(subscription);\n        } finally {\n          throw e;\n        }\n      } cleanupSubscription(subscription);\n      return value;\n    }\n  }\n});\n\nvar $Observable = function Observable(subscriber){\n  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);\n};\n\nredefineAll($Observable.prototype, {\n  subscribe: function subscribe(observer){\n    return new Subscription(observer, this._f);\n  },\n  forEach: function forEach(fn){\n    var that = this;\n    return new (core.Promise || global.Promise)(function(resolve, reject){\n      aFunction(fn);\n      var subscription = that.subscribe({\n        next : function(value){\n          try {\n            return fn(value);\n          } catch(e){\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n    });\n  }\n});\n\nredefineAll($Observable, {\n  from: function from(x){\n    var C = typeof this === 'function' ? this : $Observable;\n    var method = getMethod(anObject(x)[OBSERVABLE]);\n    if(method){\n      var observable = anObject(method.call(x));\n      return observable.constructor === C ? observable : new C(function(observer){\n        return observable.subscribe(observer);\n      });\n    }\n    return new C(function(observer){\n      var done = false;\n      microtask(function(){\n        if(!done){\n          try {\n            if(forOf(x, false, function(it){\n              observer.next(it);\n              if(done)return RETURN;\n            }) === RETURN)return;\n          } catch(e){\n            if(done)throw e;\n            observer.error(e);\n            return;\n          } observer.complete();\n        }\n      });\n      return function(){ done = true; };\n    });\n  },\n  of: function of(){\n    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];\n    return new (typeof this === 'function' ? this : $Observable)(function(observer){\n      var done = false;\n      microtask(function(){\n        if(!done){\n          for(var i = 0; i < items.length; ++i){\n            observer.next(items[i]);\n            if(done)return;\n          } observer.complete();\n        }\n      });\n      return function(){ done = true; };\n    });\n  }\n});\n\nhide($Observable.prototype, OBSERVABLE, function(){ return this; });\n\n$export($export.G, {Observable: $Observable});\n\nrequire('./_set-species')('Observable');","var metadata                  = require('./_metadata')\n  , anObject                  = require('./_an-object')\n  , toMetaKey                 = metadata.key\n  , ordinaryDefineOwnMetadata = metadata.set;\n\nmetadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){\n  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));\n}});","var metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , toMetaKey              = metadata.key\n  , getOrCreateMetadataMap = metadata.map\n  , store                  = metadata.store;\n\nmetadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){\n  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])\n    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);\n  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;\n  if(metadataMap.size)return true;\n  var targetMetadata = store.get(target);\n  targetMetadata['delete'](targetKey);\n  return !!targetMetadata.size || store['delete'](target);\n}});","var Set                     = require('./es6.set')\n  , from                    = require('./_array-from-iterable')\n  , metadata                = require('./_metadata')\n  , anObject                = require('./_an-object')\n  , getPrototypeOf          = require('./_object-gpo')\n  , ordinaryOwnMetadataKeys = metadata.keys\n  , toMetaKey               = metadata.key;\n\nvar ordinaryMetadataKeys = function(O, P){\n  var oKeys  = ordinaryOwnMetadataKeys(O, P)\n    , parent = getPrototypeOf(O);\n  if(parent === null)return oKeys;\n  var pKeys  = ordinaryMetadataKeys(parent, P);\n  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;\n};\n\nmetadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){\n  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n}});","var metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , getPrototypeOf         = require('./_object-gpo')\n  , ordinaryHasOwnMetadata = metadata.has\n  , ordinaryGetOwnMetadata = metadata.get\n  , toMetaKey              = metadata.key;\n\nvar ordinaryGetMetadata = function(MetadataKey, O, P){\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;\n};\n\nmetadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});","var metadata                = require('./_metadata')\n  , anObject                = require('./_an-object')\n  , ordinaryOwnMetadataKeys = metadata.keys\n  , toMetaKey               = metadata.key;\n\nmetadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){\n  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));\n}});","var metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , ordinaryGetOwnMetadata = metadata.get\n  , toMetaKey              = metadata.key;\n\nmetadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryGetOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});","var metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , getPrototypeOf         = require('./_object-gpo')\n  , ordinaryHasOwnMetadata = metadata.has\n  , toMetaKey              = metadata.key;\n\nvar ordinaryHasMetadata = function(MetadataKey, O, P){\n  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);\n  if(hasOwn)return true;\n  var parent = getPrototypeOf(O);\n  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;\n};\n\nmetadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});","var metadata               = require('./_metadata')\n  , anObject               = require('./_an-object')\n  , ordinaryHasOwnMetadata = metadata.has\n  , toMetaKey              = metadata.key;\n\nmetadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){\n  return ordinaryHasOwnMetadata(metadataKey, anObject(target)\n    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));\n}});","var metadata                  = require('./_metadata')\n  , anObject                  = require('./_an-object')\n  , aFunction                 = require('./_a-function')\n  , toMetaKey                 = metadata.key\n  , ordinaryDefineOwnMetadata = metadata.set;\n\nmetadata.exp({metadata: function metadata(metadataKey, metadataValue){\n  return function decorator(target, targetKey){\n    ordinaryDefineOwnMetadata(\n      metadataKey, metadataValue,\n      (targetKey !== undefined ? anObject : aFunction)(target),\n      toMetaKey(targetKey)\n    );\n  };\n}});","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export  = require('./_export');\n\n$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});","'use strict';\n// https://github.com/mathiasbynens/String.prototype.at\nvar $export = require('./_export')\n  , $at     = require('./_string-at')(true);\n\n$export($export.P, 'String', {\n  at: function at(pos){\n    return $at(this, pos);\n  }\n});","'use strict';\n// https://tc39.github.io/String.prototype.matchAll/\nvar $export     = require('./_export')\n  , defined     = require('./_defined')\n  , toLength    = require('./_to-length')\n  , isRegExp    = require('./_is-regexp')\n  , getFlags    = require('./_flags')\n  , RegExpProto = RegExp.prototype;\n\nvar $RegExpStringIterator = function(regexp, string){\n  this._r = regexp;\n  this._s = string;\n};\n\nrequire('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){\n  var match = this._r.exec(this._s);\n  return {value: match, done: match === null};\n});\n\n$export($export.P, 'String', {\n  matchAll: function matchAll(regexp){\n    defined(this);\n    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');\n    var S     = String(this)\n      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)\n      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);\n    rx.lastIndex = toLength(regexp.lastIndex);\n    return new $RegExpStringIterator(rx, S);\n  }\n});","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export')\n  , $pad    = require('./_string-pad');\n\n$export($export.P, 'String', {\n  padEnd: function padEnd(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export')\n  , $pad    = require('./_string-pad');\n\n$export($export.P, 'String', {\n  padStart: function padStart(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});","'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./_string-trim')('trimLeft', function($trim){\n  return function trimLeft(){\n    return $trim(this, 1);\n  };\n}, 'trimStart');","'use strict';\n// https://github.com/sebmarkbage/ecmascript-string-left-right-trim\nrequire('./_string-trim')('trimRight', function($trim){\n  return function trimRight(){\n    return $trim(this, 2);\n  };\n}, 'trimEnd');","require('./_wks-define')('asyncIterator');","require('./_wks-define')('observable');","// https://github.com/ljharb/proposal-global\nvar $export = require('./_export');\n\n$export($export.S, 'System', {global: require('./_global')});","var $iterators    = require('./es6.array.iterator')\n  , redefine      = require('./_redefine')\n  , global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , wks           = require('./_wks')\n  , ITERATOR      = wks('iterator')\n  , TO_STRING_TAG = wks('toStringTag')\n  , ArrayValues   = Iterators.Array;\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype\n    , key;\n  if(proto){\n    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);\n    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);\n  }\n}","var $export = require('./_export')\n  , $task   = require('./_task');\n$export($export.G + $export.B, {\n  setImmediate:   $task.set,\n  clearImmediate: $task.clear\n});","// ie9- setTimeout & setInterval additional parameters fix\nvar global     = require('./_global')\n  , $export    = require('./_export')\n  , invoke     = require('./_invoke')\n  , partial    = require('./_partial')\n  , navigator  = global.navigator\n  , MSIE       = !!navigator && /MSIE .\\./.test(navigator.userAgent); // <- dirty ie9- check\nvar wrap = function(set){\n  return MSIE ? function(fn, time /*, ...args */){\n    return set(invoke(\n      partial,\n      [].slice.call(arguments, 2),\n      typeof fn == 'function' ? fn : Function(fn)\n    ), time);\n  } : set;\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout:  wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});","require('./modules/es6.symbol');\nrequire('./modules/es6.object.create');\nrequire('./modules/es6.object.define-property');\nrequire('./modules/es6.object.define-properties');\nrequire('./modules/es6.object.get-own-property-descriptor');\nrequire('./modules/es6.object.get-prototype-of');\nrequire('./modules/es6.object.keys');\nrequire('./modules/es6.object.get-own-property-names');\nrequire('./modules/es6.object.freeze');\nrequire('./modules/es6.object.seal');\nrequire('./modules/es6.object.prevent-extensions');\nrequire('./modules/es6.object.is-frozen');\nrequire('./modules/es6.object.is-sealed');\nrequire('./modules/es6.object.is-extensible');\nrequire('./modules/es6.object.assign');\nrequire('./modules/es6.object.is');\nrequire('./modules/es6.object.set-prototype-of');\nrequire('./modules/es6.object.to-string');\nrequire('./modules/es6.function.bind');\nrequire('./modules/es6.function.name');\nrequire('./modules/es6.function.has-instance');\nrequire('./modules/es6.parse-int');\nrequire('./modules/es6.parse-float');\nrequire('./modules/es6.number.constructor');\nrequire('./modules/es6.number.to-fixed');\nrequire('./modules/es6.number.to-precision');\nrequire('./modules/es6.number.epsilon');\nrequire('./modules/es6.number.is-finite');\nrequire('./modules/es6.number.is-integer');\nrequire('./modules/es6.number.is-nan');\nrequire('./modules/es6.number.is-safe-integer');\nrequire('./modules/es6.number.max-safe-integer');\nrequire('./modules/es6.number.min-safe-integer');\nrequire('./modules/es6.number.parse-float');\nrequire('./modules/es6.number.parse-int');\nrequire('./modules/es6.math.acosh');\nrequire('./modules/es6.math.asinh');\nrequire('./modules/es6.math.atanh');\nrequire('./modules/es6.math.cbrt');\nrequire('./modules/es6.math.clz32');\nrequire('./modules/es6.math.cosh');\nrequire('./modules/es6.math.expm1');\nrequire('./modules/es6.math.fround');\nrequire('./modules/es6.math.hypot');\nrequire('./modules/es6.math.imul');\nrequire('./modules/es6.math.log10');\nrequire('./modules/es6.math.log1p');\nrequire('./modules/es6.math.log2');\nrequire('./modules/es6.math.sign');\nrequire('./modules/es6.math.sinh');\nrequire('./modules/es6.math.tanh');\nrequire('./modules/es6.math.trunc');\nrequire('./modules/es6.string.from-code-point');\nrequire('./modules/es6.string.raw');\nrequire('./modules/es6.string.trim');\nrequire('./modules/es6.string.iterator');\nrequire('./modules/es6.string.code-point-at');\nrequire('./modules/es6.string.ends-with');\nrequire('./modules/es6.string.includes');\nrequire('./modules/es6.string.repeat');\nrequire('./modules/es6.string.starts-with');\nrequire('./modules/es6.string.anchor');\nrequire('./modules/es6.string.big');\nrequire('./modules/es6.string.blink');\nrequire('./modules/es6.string.bold');\nrequire('./modules/es6.string.fixed');\nrequire('./modules/es6.string.fontcolor');\nrequire('./modules/es6.string.fontsize');\nrequire('./modules/es6.string.italics');\nrequire('./modules/es6.string.link');\nrequire('./modules/es6.string.small');\nrequire('./modules/es6.string.strike');\nrequire('./modules/es6.string.sub');\nrequire('./modules/es6.string.sup');\nrequire('./modules/es6.date.now');\nrequire('./modules/es6.date.to-json');\nrequire('./modules/es6.date.to-iso-string');\nrequire('./modules/es6.date.to-string');\nrequire('./modules/es6.date.to-primitive');\nrequire('./modules/es6.array.is-array');\nrequire('./modules/es6.array.from');\nrequire('./modules/es6.array.of');\nrequire('./modules/es6.array.join');\nrequire('./modules/es6.array.slice');\nrequire('./modules/es6.array.sort');\nrequire('./modules/es6.array.for-each');\nrequire('./modules/es6.array.map');\nrequire('./modules/es6.array.filter');\nrequire('./modules/es6.array.some');\nrequire('./modules/es6.array.every');\nrequire('./modules/es6.array.reduce');\nrequire('./modules/es6.array.reduce-right');\nrequire('./modules/es6.array.index-of');\nrequire('./modules/es6.array.last-index-of');\nrequire('./modules/es6.array.copy-within');\nrequire('./modules/es6.array.fill');\nrequire('./modules/es6.array.find');\nrequire('./modules/es6.array.find-index');\nrequire('./modules/es6.array.species');\nrequire('./modules/es6.array.iterator');\nrequire('./modules/es6.regexp.constructor');\nrequire('./modules/es6.regexp.to-string');\nrequire('./modules/es6.regexp.flags');\nrequire('./modules/es6.regexp.match');\nrequire('./modules/es6.regexp.replace');\nrequire('./modules/es6.regexp.search');\nrequire('./modules/es6.regexp.split');\nrequire('./modules/es6.promise');\nrequire('./modules/es6.map');\nrequire('./modules/es6.set');\nrequire('./modules/es6.weak-map');\nrequire('./modules/es6.weak-set');\nrequire('./modules/es6.typed.array-buffer');\nrequire('./modules/es6.typed.data-view');\nrequire('./modules/es6.typed.int8-array');\nrequire('./modules/es6.typed.uint8-array');\nrequire('./modules/es6.typed.uint8-clamped-array');\nrequire('./modules/es6.typed.int16-array');\nrequire('./modules/es6.typed.uint16-array');\nrequire('./modules/es6.typed.int32-array');\nrequire('./modules/es6.typed.uint32-array');\nrequire('./modules/es6.typed.float32-array');\nrequire('./modules/es6.typed.float64-array');\nrequire('./modules/es6.reflect.apply');\nrequire('./modules/es6.reflect.construct');\nrequire('./modules/es6.reflect.define-property');\nrequire('./modules/es6.reflect.delete-property');\nrequire('./modules/es6.reflect.enumerate');\nrequire('./modules/es6.reflect.get');\nrequire('./modules/es6.reflect.get-own-property-descriptor');\nrequire('./modules/es6.reflect.get-prototype-of');\nrequire('./modules/es6.reflect.has');\nrequire('./modules/es6.reflect.is-extensible');\nrequire('./modules/es6.reflect.own-keys');\nrequire('./modules/es6.reflect.prevent-extensions');\nrequire('./modules/es6.reflect.set');\nrequire('./modules/es6.reflect.set-prototype-of');\nrequire('./modules/es7.array.includes');\nrequire('./modules/es7.string.at');\nrequire('./modules/es7.string.pad-start');\nrequire('./modules/es7.string.pad-end');\nrequire('./modules/es7.string.trim-left');\nrequire('./modules/es7.string.trim-right');\nrequire('./modules/es7.string.match-all');\nrequire('./modules/es7.symbol.async-iterator');\nrequire('./modules/es7.symbol.observable');\nrequire('./modules/es7.object.get-own-property-descriptors');\nrequire('./modules/es7.object.values');\nrequire('./modules/es7.object.entries');\nrequire('./modules/es7.object.define-getter');\nrequire('./modules/es7.object.define-setter');\nrequire('./modules/es7.object.lookup-getter');\nrequire('./modules/es7.object.lookup-setter');\nrequire('./modules/es7.map.to-json');\nrequire('./modules/es7.set.to-json');\nrequire('./modules/es7.system.global');\nrequire('./modules/es7.error.is-error');\nrequire('./modules/es7.math.iaddh');\nrequire('./modules/es7.math.isubh');\nrequire('./modules/es7.math.imulh');\nrequire('./modules/es7.math.umulh');\nrequire('./modules/es7.reflect.define-metadata');\nrequire('./modules/es7.reflect.delete-metadata');\nrequire('./modules/es7.reflect.get-metadata');\nrequire('./modules/es7.reflect.get-metadata-keys');\nrequire('./modules/es7.reflect.get-own-metadata');\nrequire('./modules/es7.reflect.get-own-metadata-keys');\nrequire('./modules/es7.reflect.has-metadata');\nrequire('./modules/es7.reflect.has-own-metadata');\nrequire('./modules/es7.reflect.metadata');\nrequire('./modules/es7.asap');\nrequire('./modules/es7.observable');\nrequire('./modules/web.timers');\nrequire('./modules/web.immediate');\nrequire('./modules/web.dom.iterable');\nmodule.exports = require('./modules/_core');","!function() {\n  var d3 = {\n    version: \"3.5.17\"\n  };\n  var d3_arraySlice = [].slice, d3_array = function(list) {\n    return d3_arraySlice.call(list);\n  };\n  var d3_document = this.document;\n  function d3_documentElement(node) {\n    return node && (node.ownerDocument || node.document || node).documentElement;\n  }\n  function d3_window(node) {\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\n  }\n  if (d3_document) {\n    try {\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\n    } catch (e) {\n      d3_array = function(list) {\n        var i = list.length, array = new Array(i);\n        while (i--) array[i] = list[i];\n        return array;\n      };\n    }\n  }\n  if (!Date.now) Date.now = function() {\n    return +new Date();\n  };\n  if (d3_document) {\n    try {\n      d3_document.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n    } catch (error) {\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\n      d3_element_prototype.setAttribute = function(name, value) {\n        d3_element_setAttribute.call(this, name, value + \"\");\n      };\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\n        d3_element_setAttributeNS.call(this, space, local, value + \"\");\n      };\n      d3_style_prototype.setProperty = function(name, value, priority) {\n        d3_style_setProperty.call(this, name, value + \"\", priority);\n      };\n    }\n  }\n  d3.ascending = d3_ascending;\n  function d3_ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  }\n  d3.descending = function(a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n  d3.min = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n    return a;\n  };\n  d3.max = function(array, f) {\n    var i = -1, n = array.length, a, b;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n    return a;\n  };\n  d3.extent = function(array, f) {\n    var i = -1, n = array.length, a, b, c;\n    if (arguments.length === 1) {\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\n        a = c = b;\n        break;\n      }\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n    return [ a, c ];\n  };\n  function d3_number(x) {\n    return x === null ? NaN : +x;\n  }\n  function d3_numeric(x) {\n    return !isNaN(x);\n  }\n  d3.sum = function(array, f) {\n    var s = 0, n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\n    }\n    return s;\n  };\n  d3.mean = function(array, f) {\n    var s = 0, n = array.length, a, i = -1, j = n;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\n    }\n    if (j) return s / j;\n  };\n  d3.quantile = function(values, p) {\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n  d3.median = function(array, f) {\n    var numbers = [], n = array.length, a, i = -1;\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\n    } else {\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\n    }\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\n  };\n  d3.variance = function(array, f) {\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\n    if (arguments.length === 1) {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(array[i]))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    } else {\n      while (++i < n) {\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\n          d = a - m;\n          m += d / ++j;\n          s += d * (a - m);\n        }\n      }\n    }\n    if (j > 1) return s / (j - 1);\n  };\n  d3.deviation = function() {\n    var v = d3.variance.apply(this, arguments);\n    return v ? Math.sqrt(v) : v;\n  };\n  function d3_bisector(compare) {\n    return {\n      left: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\n        }\n        return lo;\n      },\n      right: function(a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\n        }\n        return lo;\n      }\n    };\n  }\n  var d3_bisect = d3_bisector(d3_ascending);\n  d3.bisectLeft = d3_bisect.left;\n  d3.bisect = d3.bisectRight = d3_bisect.right;\n  d3.bisector = function(f) {\n    return d3_bisector(f.length === 1 ? function(d, x) {\n      return d3_ascending(f(d), x);\n    } : f);\n  };\n  d3.shuffle = function(array, i0, i1) {\n    if ((m = arguments.length) < 3) {\n      i1 = array.length;\n      if (m < 2) i0 = 0;\n    }\n    var m = i1 - i0, t, i;\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\n    }\n    return array;\n  };\n  d3.permute = function(array, indexes) {\n    var i = indexes.length, permutes = new Array(i);\n    while (i--) permutes[i] = array[indexes[i]];\n    return permutes;\n  };\n  d3.pairs = function(array) {\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\n    return pairs;\n  };\n  d3.transpose = function(matrix) {\n    if (!(n = matrix.length)) return [];\n    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {\n      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {\n        row[j] = matrix[j][i];\n      }\n    }\n    return transpose;\n  };\n  function d3_transposeLength(d) {\n    return d.length;\n  }\n  d3.zip = function() {\n    return d3.transpose(arguments);\n  };\n  d3.keys = function(map) {\n    var keys = [];\n    for (var key in map) keys.push(key);\n    return keys;\n  };\n  d3.values = function(map) {\n    var values = [];\n    for (var key in map) values.push(map[key]);\n    return values;\n  };\n  d3.entries = function(map) {\n    var entries = [];\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n    return entries;\n  };\n  d3.merge = function(arrays) {\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\n    while (++i < n) j += arrays[i].length;\n    merged = new Array(j);\n    while (--n >= 0) {\n      array = arrays[n];\n      m = array.length;\n      while (--m >= 0) {\n        merged[--j] = array[m];\n      }\n    }\n    return merged;\n  };\n  var abs = Math.abs;\n  d3.range = function(start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n  function d3_range_integerScale(x) {\n    var k = 1;\n    while (x * k % 1) k *= 10;\n    return k;\n  }\n  function d3_class(ctor, properties) {\n    for (var key in properties) {\n      Object.defineProperty(ctor.prototype, key, {\n        value: properties[key],\n        enumerable: false\n      });\n    }\n  }\n  d3.map = function(object, f) {\n    var map = new d3_Map();\n    if (object instanceof d3_Map) {\n      object.forEach(function(key, value) {\n        map.set(key, value);\n      });\n    } else if (Array.isArray(object)) {\n      var i = -1, n = object.length, o;\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\n    } else {\n      for (var key in object) map.set(key, object[key]);\n    }\n    return map;\n  };\n  function d3_Map() {\n    this._ = Object.create(null);\n  }\n  var d3_map_proto = \"__proto__\", d3_map_zero = \"\\x00\";\n  d3_class(d3_Map, {\n    has: d3_map_has,\n    get: function(key) {\n      return this._[d3_map_escape(key)];\n    },\n    set: function(key, value) {\n      return this._[d3_map_escape(key)] = value;\n    },\n    remove: d3_map_remove,\n    keys: d3_map_keys,\n    values: function() {\n      var values = [];\n      for (var key in this._) values.push(this._[key]);\n      return values;\n    },\n    entries: function() {\n      var entries = [];\n      for (var key in this._) entries.push({\n        key: d3_map_unescape(key),\n        value: this._[key]\n      });\n      return entries;\n    },\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\n    }\n  });\n  function d3_map_escape(key) {\n    return (key += \"\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\n  }\n  function d3_map_unescape(key) {\n    return (key += \"\")[0] === d3_map_zero ? key.slice(1) : key;\n  }\n  function d3_map_has(key) {\n    return d3_map_escape(key) in this._;\n  }\n  function d3_map_remove(key) {\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\n  }\n  function d3_map_keys() {\n    var keys = [];\n    for (var key in this._) keys.push(d3_map_unescape(key));\n    return keys;\n  }\n  function d3_map_size() {\n    var size = 0;\n    for (var key in this._) ++size;\n    return size;\n  }\n  function d3_map_empty() {\n    for (var key in this._) return false;\n    return true;\n  }\n  d3.nest = function() {\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\n    function map(mapType, array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [ object ]);\n        }\n      }\n      if (mapType) {\n        object = mapType();\n        setter = function(keyValue, values) {\n          object.set(keyValue, map(mapType, values, depth));\n        };\n      } else {\n        object = {};\n        setter = function(keyValue, values) {\n          object[keyValue] = map(mapType, values, depth);\n        };\n      }\n      valuesByKey.forEach(setter);\n      return object;\n    }\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var array = [], sortKey = sortKeys[depth++];\n      map.forEach(function(key, keyMap) {\n        array.push({\n          key: key,\n          values: entries(keyMap, depth)\n        });\n      });\n      return sortKey ? array.sort(function(a, b) {\n        return sortKey(a.key, b.key);\n      }) : array;\n    }\n    nest.map = function(array, mapType) {\n      return map(mapType, array, 0);\n    };\n    nest.entries = function(array) {\n      return entries(map(d3.map, array, 0), 0);\n    };\n    nest.key = function(d) {\n      keys.push(d);\n      return nest;\n    };\n    nest.sortKeys = function(order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n    nest.sortValues = function(order) {\n      sortValues = order;\n      return nest;\n    };\n    nest.rollup = function(f) {\n      rollup = f;\n      return nest;\n    };\n    return nest;\n  };\n  d3.set = function(array) {\n    var set = new d3_Set();\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\n    return set;\n  };\n  function d3_Set() {\n    this._ = Object.create(null);\n  }\n  d3_class(d3_Set, {\n    has: d3_map_has,\n    add: function(key) {\n      this._[d3_map_escape(key += \"\")] = true;\n      return key;\n    },\n    remove: d3_map_remove,\n    values: d3_map_keys,\n    size: d3_map_size,\n    empty: d3_map_empty,\n    forEach: function(f) {\n      for (var key in this._) f.call(this, d3_map_unescape(key));\n    }\n  });\n  d3.behavior = {};\n  function d3_identity(d) {\n    return d;\n  }\n  d3.rebind = function(target, source) {\n    var i = 1, n = arguments.length, method;\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n    return target;\n  };\n  function d3_rebind(target, source, method) {\n    return function() {\n      var value = method.apply(source, arguments);\n      return value === source ? target : value;\n    };\n  }\n  function d3_vendorSymbol(object, name) {\n    if (name in object) return name;\n    name = name.charAt(0).toUpperCase() + name.slice(1);\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\n      var prefixName = d3_vendorPrefixes[i] + name;\n      if (prefixName in object) return prefixName;\n    }\n  }\n  var d3_vendorPrefixes = [ \"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\" ];\n  function d3_noop() {}\n  d3.dispatch = function() {\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    return dispatch;\n  };\n  function d3_dispatch() {}\n  d3_dispatch.prototype.on = function(type, listener) {\n    var i = type.indexOf(\".\"), name = \"\";\n    if (i >= 0) {\n      name = type.slice(i + 1);\n      type = type.slice(0, i);\n    }\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n    if (arguments.length === 2) {\n      if (listener == null) for (type in this) {\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\n      }\n      return this;\n    }\n  };\n  function d3_dispatch_event(dispatch) {\n    var listeners = [], listenerByName = new d3_Map();\n    function event() {\n      var z = listeners, i = -1, n = z.length, l;\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n      return dispatch;\n    }\n    event.on = function(name, listener) {\n      var l = listenerByName.get(name), i;\n      if (arguments.length < 2) return l && l.on;\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n    return event;\n  }\n  d3.event = null;\n  function d3_eventPreventDefault() {\n    d3.event.preventDefault();\n  }\n  function d3_eventSource() {\n    var e = d3.event, s;\n    while (s = e.sourceEvent) e = s;\n    return e;\n  }\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n    dispatch.of = function(thiz, argumentz) {\n      return function(e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n    return dispatch;\n  }\n  d3.requote = function(s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\n    object.__proto__ = prototype;\n  } : function(object, prototype) {\n    for (var property in prototype) object[property] = prototype[property];\n  };\n  function d3_selection(groups) {\n    d3_subclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n  var d3_select = function(s, n) {\n    return n.querySelector(s);\n  }, d3_selectAll = function(s, n) {\n    return n.querySelectorAll(s);\n  }, d3_selectMatches = function(n, s) {\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \"matchesSelector\")];\n    d3_selectMatches = function(n, s) {\n      return d3_selectMatcher.call(n, s);\n    };\n    return d3_selectMatches(n, s);\n  };\n  if (typeof Sizzle === \"function\") {\n    d3_select = function(s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n    d3_selectAll = Sizzle;\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n  d3.selection = function() {\n    return d3.select(d3_document.documentElement);\n  };\n  var d3_selectionPrototype = d3.selection.prototype = [];\n  d3_selectionPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, group, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selector(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_select(selector, this);\n    };\n  }\n  d3_selectionPrototype.selectAll = function(selector) {\n    var subgroups = [], subgroup, node;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_selectorAll(selector) {\n    return typeof selector === \"function\" ? selector : function() {\n      return d3_selectAll(selector, this);\n    };\n  }\n  var d3_nsXhtml = \"http://www.w3.org/1999/xhtml\";\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: d3_nsXhtml,\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function(name) {\n      var i = name.indexOf(\":\"), prefix = name;\n      if (i >= 0 && (prefix = name.slice(0, i)) !== \"xmlns\") name = name.slice(i + 1);\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n  d3_selectionPrototype.attr = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_attr(name, value));\n  };\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\n    }\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\n    }\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n  d3_selectionPrototype.classed = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.getAttribute(\"class\");\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n        return true;\n      }\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_classed(name, value));\n  };\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n  function d3_selection_classes(name) {\n    return (name + \"\").trim().split(/^|\\s+/);\n  }\n  function d3_selection_classed(name, value) {\n    name = d3_selection_classes(name).map(d3_selection_classedName);\n    var n = name.length;\n    function classedConstant() {\n      var i = -1;\n      while (++i < n) name[i](this, value);\n    }\n    function classedFunction() {\n      var i = -1, x = value.apply(this, arguments);\n      while (++i < n) name[i](this, x);\n    }\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function(node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.getAttribute(\"class\") || \"\";\n      if (value) {\n        re.lastIndex = 0;\n        if (!re.test(c)) node.setAttribute(\"class\", d3_collapse(c + \" \" + name));\n      } else {\n        node.setAttribute(\"class\", d3_collapse(c.replace(re, \" \")));\n      }\n    };\n  }\n  d3_selectionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n        return this;\n      }\n      if (n < 2) {\n        var node = this.node();\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\n      }\n      priority = \"\";\n    }\n    return this.each(d3_selection_style(name, value, priority));\n  };\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\n    }\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n  d3_selectionPrototype.property = function(name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") return this.node()[name];\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n      return this;\n    }\n    return this.each(d3_selection_property(name, value));\n  };\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n    function propertyConstant() {\n      this[name] = value;\n    }\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name]; else this[name] = x;\n    }\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n  d3_selectionPrototype.text = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.textContent = \"\";\n    } : function() {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n  d3_selectionPrototype.html = function(value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function() {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function() {\n      this.innerHTML = \"\";\n    } : function() {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n  d3_selectionPrototype.append = function(name) {\n    name = d3_selection_creator(name);\n    return this.select(function() {\n      return this.appendChild(name.apply(this, arguments));\n    });\n  };\n  function d3_selection_creator(name) {\n    function create() {\n      var document = this.ownerDocument, namespace = this.namespaceURI;\n      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);\n    }\n    function createNS() {\n      return this.ownerDocument.createElementNS(name.space, name.local);\n    }\n    return typeof name === \"function\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\n  }\n  d3_selectionPrototype.insert = function(name, before) {\n    name = d3_selection_creator(name);\n    before = d3_selection_selector(before);\n    return this.select(function() {\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\n    });\n  };\n  d3_selectionPrototype.remove = function() {\n    return this.each(d3_selectionRemove);\n  };\n  function d3_selectionRemove() {\n    var parent = this.parentNode;\n    if (parent) parent.removeChild(this);\n  }\n  d3_selectionPrototype.data = function(value, key) {\n    var i = -1, n = this.length, group, node;\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n      return value;\n    }\n    function bind(group, groupData) {\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\n      if (key) {\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\n        for (i = -1; ++i < n; ) {\n          if (node = group[i]) {\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\n              exitNodes[i] = node;\n            } else {\n              nodeByKeyValue.set(keyValue, node);\n            }\n            keyValues[i] = keyValue;\n          }\n        }\n        for (i = -1; ++i < m; ) {\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          } else if (node !== true) {\n            updateNodes[i] = node;\n            node.__data__ = nodeData;\n          }\n          nodeByKeyValue.set(keyValue, true);\n        }\n        for (i = -1; ++i < n; ) {\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0; ) {\n          node = group[i];\n          nodeData = groupData[i];\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n          }\n        }\n        for (;i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n        }\n        for (;i < n; ++i) {\n          exitNodes[i] = group[i];\n        }\n      }\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n    update.enter = function() {\n      return enter;\n    };\n    update.exit = function() {\n      return exit;\n    };\n    return update;\n  };\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n  d3_selectionPrototype.datum = function(value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n  d3_selectionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  function d3_selection_filter(selector) {\n    return function() {\n      return d3_selectMatches(this, selector);\n    };\n  }\n  d3_selectionPrototype.order = function() {\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n    return this;\n  };\n  d3_selectionPrototype.sort = function(comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\n    return this.order();\n  };\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3_ascending;\n    return function(a, b) {\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\n    };\n  }\n  d3_selectionPrototype.each = function(callback) {\n    return d3_selection_each(this, function(node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n    return groups;\n  }\n  d3_selectionPrototype.call = function(callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n  d3_selectionPrototype.empty = function() {\n    return !this.node();\n  };\n  d3_selectionPrototype.node = function() {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n    return null;\n  };\n  d3_selectionPrototype.size = function() {\n    var n = 0;\n    d3_selection_each(this, function() {\n      ++n;\n    });\n    return n;\n  };\n  function d3_selection_enter(selection) {\n    d3_subclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\n  d3_selection_enterPrototype.select = function(selector) {\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\n    for (var j = -1, m = this.length; ++j < m; ) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n      for (var i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_selection(subgroups);\n  };\n  d3_selection_enterPrototype.insert = function(name, before) {\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\n    return d3_selectionPrototype.insert.call(this, name, before);\n  };\n  function d3_selection_enterInsertBefore(enter) {\n    var i0, j0;\n    return function(d, i, j) {\n      var group = enter[j].update, n = group.length, node;\n      if (j != j0) j0 = j, i0 = 0;\n      if (i >= i0) i0 = i + 1;\n      while (!(node = group[i0]) && ++i0 < n) ;\n      return node;\n    };\n  }\n  d3.select = function(node) {\n    var group;\n    if (typeof node === \"string\") {\n      group = [ d3_select(node, d3_document) ];\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = [ node ];\n      group.parentNode = d3_documentElement(node);\n    }\n    return d3_selection([ group ]);\n  };\n  d3.selectAll = function(nodes) {\n    var group;\n    if (typeof nodes === \"string\") {\n      group = d3_array(d3_selectAll(nodes, d3_document));\n      group.parentNode = d3_document.documentElement;\n    } else {\n      group = d3_array(nodes);\n      group.parentNode = null;\n    }\n    return d3_selection([ group ]);\n  };\n  d3_selectionPrototype.on = function(type, listener, capture) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n        return this;\n      }\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n      capture = false;\n    }\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type, i = type.indexOf(\".\"), wrap = d3_selection_onListener;\n    if (i > 0) type = type.slice(0, i);\n    var filter = d3_selection_onFilters.get(type);\n    if (filter) type = filter, wrap = d3_selection_onFilter;\n    function onRemove() {\n      var l = this[name];\n      if (l) {\n        this.removeEventListener(type, l, l.$);\n        delete this[name];\n      }\n    }\n    function onAdd() {\n      var l = wrap(listener, d3_array(arguments));\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = l, l.$ = capture);\n      l._ = listener;\n    }\n    function removeAll() {\n      var re = new RegExp(\"^__on([^.]+)\" + d3.requote(type) + \"$\"), match;\n      for (var name in this) {\n        if (match = name.match(re)) {\n          var l = this[name];\n          this.removeEventListener(match[1], l, l.$);\n          delete this[name];\n        }\n      }\n    }\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\n  }\n  var d3_selection_onFilters = d3.map({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  });\n  if (d3_document) {\n    d3_selection_onFilters.forEach(function(k) {\n      if (\"on\" + k in d3_document) d3_selection_onFilters.remove(k);\n    });\n  }\n  function d3_selection_onListener(listener, argumentz) {\n    return function(e) {\n      var o = d3.event;\n      d3.event = e;\n      argumentz[0] = this.__data__;\n      try {\n        listener.apply(this, argumentz);\n      } finally {\n        d3.event = o;\n      }\n    };\n  }\n  function d3_selection_onFilter(listener, argumentz) {\n    var l = d3_selection_onListener(listener, argumentz);\n    return function(e) {\n      var target = this, related = e.relatedTarget;\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\n        l.call(target, e);\n      }\n    };\n  }\n  var d3_event_dragSelect, d3_event_dragId = 0;\n  function d3_event_dragSuppress(node) {\n    var name = \".dragsuppress-\" + ++d3_event_dragId, click = \"click\" + name, w = d3.select(d3_window(node)).on(\"touchmove\" + name, d3_eventPreventDefault).on(\"dragstart\" + name, d3_eventPreventDefault).on(\"selectstart\" + name, d3_eventPreventDefault);\n    if (d3_event_dragSelect == null) {\n      d3_event_dragSelect = \"onselectstart\" in node ? false : d3_vendorSymbol(node.style, \"userSelect\");\n    }\n    if (d3_event_dragSelect) {\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\n      style[d3_event_dragSelect] = \"none\";\n    }\n    return function(suppressClick) {\n      w.on(name, null);\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\n      if (suppressClick) {\n        var off = function() {\n          w.on(click, null);\n        };\n        w.on(click, function() {\n          d3_eventPreventDefault();\n          off();\n        }, true);\n        setTimeout(off, 0);\n      }\n    };\n  }\n  d3.mouse = function(container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n  function d3_mousePoint(container, e) {\n    if (e.changedTouches) e = e.changedTouches[0];\n    var svg = container.ownerSVGElement || container;\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n      if (d3_mouse_bug44083 < 0) {\n        var window = d3_window(container);\n        if (window.scrollX || window.scrollY) {\n          svg = d3.select(\"body\").append(\"svg\").style({\n            position: \"absolute\",\n            top: 0,\n            left: 0,\n            margin: 0,\n            padding: 0,\n            border: \"none\"\n          }, \"important\");\n          var ctm = svg[0][0].getScreenCTM();\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\n          svg.remove();\n        }\n      }\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \n      point.y = e.clientY;\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [ point.x, point.y ];\n    }\n    var rect = container.getBoundingClientRect();\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\n  }\n  d3.touch = function(container, touches, identifier) {\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\n      if ((touch = touches[i]).identifier === identifier) {\n        return d3_mousePoint(container, touch);\n      }\n    }\n  };\n  d3.behavior.drag = function() {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, \"mousemove\", \"mouseup\"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \"touchmove\", \"touchend\");\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", touchstart);\n    }\n    function dragstart(id, position, subject, move, end) {\n      return function() {\n        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = \".drag\" + (dragId == null ? \"\" : \"-\" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\n        if (origin) {\n          dragOffset = origin.apply(that, arguments);\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\n        } else {\n          dragOffset = [ 0, 0 ];\n        }\n        dispatch({\n          type: \"dragstart\"\n        });\n        function moved() {\n          var position1 = position(parent, dragId), dx, dy;\n          if (!position1) return;\n          dx = position1[0] - position0[0];\n          dy = position1[1] - position0[1];\n          dragged |= dx | dy;\n          position0 = position1;\n          dispatch({\n            type: \"drag\",\n            x: position1[0] + dragOffset[0],\n            y: position1[1] + dragOffset[1],\n            dx: dx,\n            dy: dy\n          });\n        }\n        function ended() {\n          if (!position(parent, dragId)) return;\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\n          dragRestore(dragged);\n          dispatch({\n            type: \"dragend\"\n          });\n        }\n      };\n    }\n    drag.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n    return d3.rebind(drag, event, \"on\");\n  };\n  function d3_behavior_dragTouchId() {\n    return d3.event.changedTouches[0].identifier;\n  }\n  d3.touches = function(container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function(touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;\n  function d3_sgn(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  }\n  function d3_cross2d(a, b, c) {\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\n  }\n  function d3_acos(x) {\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\n  }\n  function d3_asin(x) {\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\n  }\n  function d3_sinh(x) {\n    return ((x = Math.exp(x)) - 1 / x) / 2;\n  }\n  function d3_cosh(x) {\n    return ((x = Math.exp(x)) + 1 / x) / 2;\n  }\n  function d3_tanh(x) {\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n  }\n  function d3_haversin(x) {\n    return (x = Math.sin(x / 2)) * x;\n  }\n  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;\n  d3.interpolateZoom = function(p0, p1) {\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\n    if (d2 < ε2) {\n      S = Math.log(w1 / w0) / ρ;\n      i = function(t) {\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];\n      };\n    } else {\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n      S = (r1 - r0) / ρ;\n      i = function(t) {\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];\n      };\n    }\n    i.duration = S * 1e3;\n    return i;\n  };\n  d3.behavior.zoom = function() {\n    var view = {\n      x: 0,\n      y: 0,\n      k: 1\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \"mousedown.zoom\", mousemove = \"mousemove.zoom\", mouseup = \"mouseup.zoom\", mousewheelTimer, touchstart = \"touchstart.zoom\", touchtime, event = d3_eventDispatch(zoom, \"zoomstart\", \"zoom\", \"zoomend\"), x0, x1, y0, y1;\n    if (!d3_behavior_zoomWheel) {\n      d3_behavior_zoomWheel = \"onwheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\n      }, \"wheel\") : \"onmousewheel\" in d3_document ? (d3_behavior_zoomDelta = function() {\n        return d3.event.wheelDelta;\n      }, \"mousewheel\") : (d3_behavior_zoomDelta = function() {\n        return -d3.event.detail;\n      }, \"MozMousePixelScroll\");\n    }\n    function zoom(g) {\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \".zoom\", mousewheeled).on(\"dblclick.zoom\", dblclicked).on(touchstart, touchstarted);\n    }\n    zoom.event = function(g) {\n      g.each(function() {\n        var dispatch = event.of(this, arguments), view1 = view;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.zoom\", function() {\n            view = this.__chart__ || {\n              x: 0,\n              y: 0,\n              k: 1\n            };\n            zoomstarted(dispatch);\n          }).tween(\"zoom:zoom\", function() {\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\n            return function(t) {\n              var l = i(t), k = dx / l[2];\n              this.__chart__ = view = {\n                x: cx - l[0] * k,\n                y: cy - l[1] * k,\n                k: k\n              };\n              zoomed(dispatch);\n            };\n          }).each(\"interrupt.zoom\", function() {\n            zoomended(dispatch);\n          }).each(\"end.zoom\", function() {\n            zoomended(dispatch);\n          });\n        } else {\n          this.__chart__ = view;\n          zoomstarted(dispatch);\n          zoomed(dispatch);\n          zoomended(dispatch);\n        }\n      });\n    };\n    zoom.translate = function(_) {\n      if (!arguments.length) return [ view.x, view.y ];\n      view = {\n        x: +_[0],\n        y: +_[1],\n        k: view.k\n      };\n      rescale();\n      return zoom;\n    };\n    zoom.scale = function(_) {\n      if (!arguments.length) return view.k;\n      view = {\n        x: view.x,\n        y: view.y,\n        k: null\n      };\n      scaleTo(+_);\n      rescale();\n      return zoom;\n    };\n    zoom.scaleExtent = function(_) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.center = function(_) {\n      if (!arguments.length) return center;\n      center = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.size = function(_) {\n      if (!arguments.length) return size;\n      size = _ && [ +_[0], +_[1] ];\n      return zoom;\n    };\n    zoom.duration = function(_) {\n      if (!arguments.length) return duration;\n      duration = +_;\n      return zoom;\n    };\n    zoom.x = function(z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    zoom.y = function(z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      view = {\n        x: 0,\n        y: 0,\n        k: 1\n      };\n      return zoom;\n    };\n    function location(p) {\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\n    }\n    function point(l) {\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\n    }\n    function scaleTo(s) {\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n    function translateTo(p, l) {\n      l = point(l);\n      view.x += p[0] - l[0];\n      view.y += p[1] - l[1];\n    }\n    function zoomTo(that, p, l, k) {\n      that.__chart__ = {\n        x: view.x,\n        y: view.y,\n        k: view.k\n      };\n      scaleTo(Math.pow(2, k));\n      translateTo(center0 = p, l);\n      that = d3.select(that);\n      if (duration > 0) that = that.transition().duration(duration);\n      that.call(zoom.event);\n    }\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function(x) {\n        return (x - view.x) / view.k;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function(y) {\n        return (y - view.y) / view.k;\n      }).map(y0.invert));\n    }\n    function zoomstarted(dispatch) {\n      if (!zooming++) dispatch({\n        type: \"zoomstart\"\n      });\n    }\n    function zoomed(dispatch) {\n      rescale();\n      dispatch({\n        type: \"zoom\",\n        scale: view.k,\n        translate: [ view.x, view.y ]\n      });\n    }\n    function zoomended(dispatch) {\n      if (!--zooming) dispatch({\n        type: \"zoomend\"\n      }), center0 = null;\n    }\n    function mousedowned() {\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\n      d3_selection_interrupt.call(that);\n      zoomstarted(dispatch);\n      function moved() {\n        dragged = 1;\n        translateTo(d3.mouse(that), location0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        subject.on(mousemove, null).on(mouseup, null);\n        dragRestore(dragged);\n        zoomended(dispatch);\n      }\n    }\n    function touchstarted() {\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = \".zoom-\" + d3.event.changedTouches[0].identifier, touchmove = \"touchmove\" + zoomName, touchend = \"touchend\" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\n      started();\n      zoomstarted(dispatch);\n      subject.on(mousedown, null).on(touchstart, started);\n      function relocate() {\n        var touches = d3.touches(that);\n        scale0 = view.k;\n        touches.forEach(function(t) {\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\n        });\n        return touches;\n      }\n      function started() {\n        var target = d3.event.target;\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\n        targets.push(target);\n        var changed = d3.event.changedTouches;\n        for (var i = 0, n = changed.length; i < n; ++i) {\n          locations0[changed[i].identifier] = null;\n        }\n        var touches = relocate(), now = Date.now();\n        if (touches.length === 1) {\n          if (now - touchtime < 500) {\n            var p = touches[0];\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\n            d3_eventPreventDefault();\n          }\n          touchtime = now;\n        } else if (touches.length > 1) {\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\n          distance0 = dx * dx + dy * dy;\n        }\n      }\n      function moved() {\n        var touches = d3.touches(that), p0, l0, p1, l1;\n        d3_selection_interrupt.call(that);\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\n          p1 = touches[i];\n          if (l1 = locations0[p1.identifier]) {\n            if (l0) break;\n            p0 = p1, l0 = l1;\n          }\n        }\n        if (l1) {\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\n          scaleTo(scale1 * scale0);\n        }\n        touchtime = null;\n        translateTo(p0, l0);\n        zoomed(dispatch);\n      }\n      function ended() {\n        if (d3.event.touches.length) {\n          var changed = d3.event.changedTouches;\n          for (var i = 0, n = changed.length; i < n; ++i) {\n            delete locations0[changed[i].identifier];\n          }\n          for (var identifier in locations0) {\n            return void relocate();\n          }\n        }\n        d3.selectAll(targets).on(zoomName, null);\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\n        dragRestore();\n        zoomended(dispatch);\n      }\n    }\n    function mousewheeled() {\n      var dispatch = event.of(this, arguments);\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\n      mousewheelTimer = setTimeout(function() {\n        mousewheelTimer = null;\n        zoomended(dispatch);\n      }, 50);\n      d3_eventPreventDefault();\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\n      translateTo(center0, translate0);\n      zoomed(dispatch);\n    }\n    function dblclicked() {\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\n    }\n    return d3.rebind(zoom, event, \"on\");\n  };\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\n  d3.color = d3_color;\n  function d3_color() {}\n  d3_color.prototype.toString = function() {\n    return this.rgb() + \"\";\n  };\n  d3.hsl = d3_hsl;\n  function d3_hsl(h, s, l) {\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\n  }\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\n  d3_hslPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, this.l / k);\n  };\n  d3_hslPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_hsl(this.h, this.s, k * this.l);\n  };\n  d3_hslPrototype.rgb = function() {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n    function v(h) {\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n  d3.hcl = d3_hcl;\n  function d3_hcl(h, c, l) {\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\n  }\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\n  d3_hclPrototype.brighter = function(k) {\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.darker = function(k) {\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n  d3_hclPrototype.rgb = function() {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n  function d3_hcl_lab(h, c, l) {\n    if (isNaN(h)) h = 0;\n    if (isNaN(c)) c = 0;\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n  d3.lab = d3_lab;\n  function d3_lab(l, a, b) {\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\n  }\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\n  d3_labPrototype.brighter = function(k) {\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.darker = function(k) {\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n  d3_labPrototype.rgb = function() {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n  function d3_lab_hcl(l, a, b) {\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\n  }\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n  d3.rgb = d3_rgb;\n  function d3_rgb(r, g, b) {\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\n  }\n  function d3_rgbNumber(value) {\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\n  }\n  function d3_rgbString(value) {\n    return d3_rgbNumber(value) + \"\";\n  }\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\n  d3_rgbPrototype.brighter = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r, g = this.g, b = this.b, i = 30;\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\n  };\n  d3_rgbPrototype.darker = function(k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\n  };\n  d3_rgbPrototype.hsl = function() {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n  d3_rgbPrototype.toString = function() {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n  function d3_rgb_hex(v) {\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0, g = 0, b = 0, m1, m2, color;\n    m1 = /([a-z]+)\\((.*)\\)/.exec(format = format.toLowerCase());\n    if (m1) {\n      m2 = m1[2].split(\",\");\n      switch (m1[1]) {\n       case \"hsl\":\n        {\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n        }\n\n       case \"rgb\":\n        {\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n        }\n      }\n    }\n    if (color = d3_rgb_names.get(format)) {\n      return rgb(color.r, color.g, color.b);\n    }\n    if (format != null && format.charAt(0) === \"#\" && !isNaN(color = parseInt(format.slice(1), 16))) {\n      if (format.length === 4) {\n        r = (color & 3840) >> 4;\n        r = r >> 4 | r;\n        g = color & 240;\n        g = g >> 4 | g;\n        b = color & 15;\n        b = b << 4 | b;\n      } else if (format.length === 7) {\n        r = (color & 16711680) >> 16;\n        g = (color & 65280) >> 8;\n        b = color & 255;\n      }\n    }\n    return rgb(r, g, b);\n  }\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      h = NaN;\n      s = l > 0 && l < 1 ? 0 : h;\n    }\n    return new d3_hsl(h, s, l);\n  }\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n  var d3_rgb_names = d3.map({\n    aliceblue: 15792383,\n    antiquewhite: 16444375,\n    aqua: 65535,\n    aquamarine: 8388564,\n    azure: 15794175,\n    beige: 16119260,\n    bisque: 16770244,\n    black: 0,\n    blanchedalmond: 16772045,\n    blue: 255,\n    blueviolet: 9055202,\n    brown: 10824234,\n    burlywood: 14596231,\n    cadetblue: 6266528,\n    chartreuse: 8388352,\n    chocolate: 13789470,\n    coral: 16744272,\n    cornflowerblue: 6591981,\n    cornsilk: 16775388,\n    crimson: 14423100,\n    cyan: 65535,\n    darkblue: 139,\n    darkcyan: 35723,\n    darkgoldenrod: 12092939,\n    darkgray: 11119017,\n    darkgreen: 25600,\n    darkgrey: 11119017,\n    darkkhaki: 12433259,\n    darkmagenta: 9109643,\n    darkolivegreen: 5597999,\n    darkorange: 16747520,\n    darkorchid: 10040012,\n    darkred: 9109504,\n    darksalmon: 15308410,\n    darkseagreen: 9419919,\n    darkslateblue: 4734347,\n    darkslategray: 3100495,\n    darkslategrey: 3100495,\n    darkturquoise: 52945,\n    darkviolet: 9699539,\n    deeppink: 16716947,\n    deepskyblue: 49151,\n    dimgray: 6908265,\n    dimgrey: 6908265,\n    dodgerblue: 2003199,\n    firebrick: 11674146,\n    floralwhite: 16775920,\n    forestgreen: 2263842,\n    fuchsia: 16711935,\n    gainsboro: 14474460,\n    ghostwhite: 16316671,\n    gold: 16766720,\n    goldenrod: 14329120,\n    gray: 8421504,\n    green: 32768,\n    greenyellow: 11403055,\n    grey: 8421504,\n    honeydew: 15794160,\n    hotpink: 16738740,\n    indianred: 13458524,\n    indigo: 4915330,\n    ivory: 16777200,\n    khaki: 15787660,\n    lavender: 15132410,\n    lavenderblush: 16773365,\n    lawngreen: 8190976,\n    lemonchiffon: 16775885,\n    lightblue: 11393254,\n    lightcoral: 15761536,\n    lightcyan: 14745599,\n    lightgoldenrodyellow: 16448210,\n    lightgray: 13882323,\n    lightgreen: 9498256,\n    lightgrey: 13882323,\n    lightpink: 16758465,\n    lightsalmon: 16752762,\n    lightseagreen: 2142890,\n    lightskyblue: 8900346,\n    lightslategray: 7833753,\n    lightslategrey: 7833753,\n    lightsteelblue: 11584734,\n    lightyellow: 16777184,\n    lime: 65280,\n    limegreen: 3329330,\n    linen: 16445670,\n    magenta: 16711935,\n    maroon: 8388608,\n    mediumaquamarine: 6737322,\n    mediumblue: 205,\n    mediumorchid: 12211667,\n    mediumpurple: 9662683,\n    mediumseagreen: 3978097,\n    mediumslateblue: 8087790,\n    mediumspringgreen: 64154,\n    mediumturquoise: 4772300,\n    mediumvioletred: 13047173,\n    midnightblue: 1644912,\n    mintcream: 16121850,\n    mistyrose: 16770273,\n    moccasin: 16770229,\n    navajowhite: 16768685,\n    navy: 128,\n    oldlace: 16643558,\n    olive: 8421376,\n    olivedrab: 7048739,\n    orange: 16753920,\n    orangered: 16729344,\n    orchid: 14315734,\n    palegoldenrod: 15657130,\n    palegreen: 10025880,\n    paleturquoise: 11529966,\n    palevioletred: 14381203,\n    papayawhip: 16773077,\n    peachpuff: 16767673,\n    peru: 13468991,\n    pink: 16761035,\n    plum: 14524637,\n    powderblue: 11591910,\n    purple: 8388736,\n    rebeccapurple: 6697881,\n    red: 16711680,\n    rosybrown: 12357519,\n    royalblue: 4286945,\n    saddlebrown: 9127187,\n    salmon: 16416882,\n    sandybrown: 16032864,\n    seagreen: 3050327,\n    seashell: 16774638,\n    sienna: 10506797,\n    silver: 12632256,\n    skyblue: 8900331,\n    slateblue: 6970061,\n    slategray: 7372944,\n    slategrey: 7372944,\n    snow: 16775930,\n    springgreen: 65407,\n    steelblue: 4620980,\n    tan: 13808780,\n    teal: 32896,\n    thistle: 14204888,\n    tomato: 16737095,\n    turquoise: 4251856,\n    violet: 15631086,\n    wheat: 16113331,\n    white: 16777215,\n    whitesmoke: 16119285,\n    yellow: 16776960,\n    yellowgreen: 10145074\n  });\n  d3_rgb_names.forEach(function(key, value) {\n    d3_rgb_names.set(key, d3_rgbNumber(value));\n  });\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function() {\n      return v;\n    };\n  }\n  d3.functor = d3_functor;\n  d3.xhr = d3_xhrType(d3_identity);\n  function d3_xhrType(response) {\n    return function(url, mimeType, callback) {\n      if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, \n      mimeType = null;\n      return d3_xhr(url, mimeType, response, callback);\n    };\n  }\n  function d3_xhr(url, mimeType, response, callback) {\n    var xhr = {}, dispatch = d3.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), headers = {}, request = new XMLHttpRequest(), responseType = null;\n    if (this.XDomainRequest && !(\"withCredentials\" in request) && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\n      request.readyState > 3 && respond();\n    };\n    function respond() {\n      var status = request.status, result;\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n        try {\n          result = response.call(xhr, request);\n        } catch (e) {\n          dispatch.error.call(xhr, e);\n          return;\n        }\n        dispatch.load.call(xhr, result);\n      } else {\n        dispatch.error.call(xhr, request);\n      }\n    }\n    request.onprogress = function(event) {\n      var o = d3.event;\n      d3.event = event;\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n    xhr.header = function(name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name]; else headers[name] = value + \"\";\n      return xhr;\n    };\n    xhr.mimeType = function(value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    };\n    xhr.responseType = function(value) {\n      if (!arguments.length) return responseType;\n      responseType = value;\n      return xhr;\n    };\n    xhr.response = function(value) {\n      response = value;\n      return xhr;\n    };\n    [ \"get\", \"post\" ].forEach(function(method) {\n      xhr[method] = function() {\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\n      };\n    });\n    xhr.send = function(method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (responseType != null) request.responseType = responseType;\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function(request) {\n        callback(null, request);\n      });\n      dispatch.beforesend.call(xhr, request);\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n    xhr.abort = function() {\n      request.abort();\n      return xhr;\n    };\n    d3.rebind(xhr, dispatch, \"on\");\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  }\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function(error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n  function d3_xhrHasResponse(request) {\n    var type = request.responseType;\n    return type && type !== \"text\" ? request.response : request.responseText;\n  }\n  d3.dsv = function(delimiter, mimeType) {\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"), delimiterCode = delimiter.charCodeAt(0);\n    function dsv(url, row, callback) {\n      if (arguments.length < 3) callback = row, row = null;\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\n      xhr.row = function(_) {\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\n      };\n      return xhr;\n    }\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n    function typedResponse(f) {\n      return function(request) {\n        return dsv.parse(request.responseText, f);\n      };\n    }\n    dsv.parse = function(text, f) {\n      var o;\n      return dsv.parseRows(text, function(row, i) {\n        if (o) return o(row, i - 1);\n        var a = new Function(\"d\", \"return {\" + row.map(function(name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n        o = f ? function(row, i) {\n          return f(a(row), i);\n        } : a;\n      });\n    };\n    dsv.parseRows = function(text, f) {\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n          return text.slice(j + 1, i).replace(/\"\"/g, '\"');\n        }\n        while (I < N) {\n          var c = text.charCodeAt(I++), k = 1;\n          if (c === 10) eol = true; else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.slice(j, I - k);\n        }\n        return text.slice(j);\n      }\n      while ((t = token()) !== EOF) {\n        var a = [];\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n        if (f && (a = f(a, n++)) == null) continue;\n        rows.push(a);\n      }\n      return rows;\n    };\n    dsv.format = function(rows) {\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\n      var fieldSet = new d3_Set(), fields = [];\n      rows.forEach(function(row) {\n        for (var field in row) {\n          if (!fieldSet.has(field)) {\n            fields.push(fieldSet.add(field));\n          }\n        }\n      });\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\n        return fields.map(function(field) {\n          return formatValue(row[field]);\n        }).join(delimiter);\n      })).join(\"\\n\");\n    };\n    dsv.formatRows = function(rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n    function formatValue(text) {\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n    }\n    return dsv;\n  };\n  d3.csv = d3.dsv(\",\", \"text/csv\");\n  d3.tsv = d3.dsv(\"\t\", \"text/tab-separated-values\");\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, \"requestAnimationFrame\")] || function(callback) {\n    setTimeout(callback, 17);\n  };\n  d3.timer = function() {\n    d3_timer.apply(this, arguments);\n  };\n  function d3_timer(callback, delay, then) {\n    var n = arguments.length;\n    if (n < 2) delay = 0;\n    if (n < 3) then = Date.now();\n    var time = then + delay, timer = {\n      c: callback,\n      t: time,\n      n: null\n    };\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\n    d3_timer_queueTail = timer;\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n    return timer;\n  }\n  function d3_timer_step() {\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n  d3.timer.flush = function() {\n    d3_timer_mark();\n    d3_timer_sweep();\n  };\n  function d3_timer_mark() {\n    var now = Date.now(), timer = d3_timer_queueHead;\n    while (timer) {\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\n      timer = timer.n;\n    }\n    return now;\n  }\n  function d3_timer_sweep() {\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\n    while (t1) {\n      if (t1.c) {\n        if (t1.t < time) time = t1.t;\n        t1 = (t0 = t1).n;\n      } else {\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\n      }\n    }\n    d3_timer_queueTail = t0;\n    return time;\n  }\n  function d3_format_precision(x, p) {\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\n  }\n  d3.round = function(x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n  var d3_formatPrefixes = [ \"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\" ].map(d3_formatPrefix);\n  d3.formatPrefix = function(value, precision) {\n    var i = 0;\n    if (value = +value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\n    }\n    return d3_formatPrefixes[8 + i / 3];\n  };\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function(d) {\n        return d / k;\n      } : function(d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n  function d3_locale_numberFormat(locale) {\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\n      while (i > 0 && g > 0) {\n        if (length + g + 1 > width) g = Math.max(1, width - length);\n        t.push(value.substring(i -= g, i + g));\n        if ((length += g + 1) > width) break;\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\n      }\n      return t.reverse().join(locale_thousands);\n    } : d3_identity;\n    return function(specifier) {\n      var match = d3_format_re.exec(specifier), fill = match[1] || \" \", align = match[2] || \">\", sign = match[3] || \"-\", symbol = match[4] || \"\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \"\", suffix = \"\", integer = false, exponent = true;\n      if (precision) precision = +precision.substring(1);\n      if (zfill || fill === \"0\" && align === \"=\") {\n        zfill = fill = \"0\";\n        align = \"=\";\n      }\n      switch (type) {\n       case \"n\":\n        comma = true;\n        type = \"g\";\n        break;\n\n       case \"%\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"f\";\n        break;\n\n       case \"p\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"r\";\n        break;\n\n       case \"b\":\n       case \"o\":\n       case \"x\":\n       case \"X\":\n        if (symbol === \"#\") prefix = \"0\" + type.toLowerCase();\n\n       case \"c\":\n        exponent = false;\n\n       case \"d\":\n        integer = true;\n        precision = 0;\n        break;\n\n       case \"s\":\n        scale = -1;\n        type = \"r\";\n        break;\n      }\n      if (symbol === \"$\") prefix = locale_currency[0], suffix = locale_currency[1];\n      if (type == \"r\" && !precision) type = \"g\";\n      if (precision != null) {\n        if (type == \"g\") precision = Math.max(1, Math.min(21, precision)); else if (type == \"e\" || type == \"f\") precision = Math.max(0, Math.min(20, precision));\n      }\n      type = d3_format_types.get(type) || d3_format_typeDefault;\n      var zcomma = zfill && comma;\n      return function(value) {\n        var fullSuffix = suffix;\n        if (integer && value % 1) return \"\";\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign === \"-\" ? \"\" : sign;\n        if (scale < 0) {\n          var unit = d3.formatPrefix(value, precision);\n          value = unit.scale(value);\n          fullSuffix = unit.symbol + suffix;\n        } else {\n          value *= scale;\n        }\n        value = type(value, precision);\n        var i = value.lastIndexOf(\".\"), before, after;\n        if (i < 0) {\n          var j = exponent ? value.lastIndexOf(\"e\") : -1;\n          if (j < 0) before = value, after = \"\"; else before = value.substring(0, j), after = value.substring(j);\n        } else {\n          before = value.substring(0, i);\n          after = locale_decimal + value.substring(i + 1);\n        }\n        if (!zfill && comma) before = formatGroup(before, Infinity);\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\n        negative += prefix;\n        value = before + after;\n        return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\n      };\n    };\n  }\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i;\n  var d3_format_types = d3.map({\n    b: function(x) {\n      return x.toString(2);\n    },\n    c: function(x) {\n      return String.fromCharCode(x);\n    },\n    o: function(x) {\n      return x.toString(8);\n    },\n    x: function(x) {\n      return x.toString(16);\n    },\n    X: function(x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function(x, p) {\n      return x.toPrecision(p);\n    },\n    e: function(x, p) {\n      return x.toExponential(p);\n    },\n    f: function(x, p) {\n      return x.toFixed(p);\n    },\n    r: function(x, p) {\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\n    }\n  });\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n  var d3_time = d3.time = {}, d3_date = Date;\n  function d3_date_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n  d3_date_utc.prototype = {\n    getDate: function() {\n      return this._.getUTCDate();\n    },\n    getDay: function() {\n      return this._.getUTCDay();\n    },\n    getFullYear: function() {\n      return this._.getUTCFullYear();\n    },\n    getHours: function() {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function() {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function() {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function() {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function() {\n      return this._.getUTCSeconds();\n    },\n    getTime: function() {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function() {\n      return 0;\n    },\n    valueOf: function() {\n      return this._.valueOf();\n    },\n    setDate: function() {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function() {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function() {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function() {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function() {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function() {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function() {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function() {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function() {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date), d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n    function ceil(date) {\n      step(date = local(new d3_date(date - 1)), 1);\n      return date;\n    }\n    function offset(date, k) {\n      step(date = new d3_date(+date), k);\n      return date;\n    }\n    function range(t0, t1, dt) {\n      var time = ceil(t0), times = [];\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n      return times;\n    }\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_date = Date;\n      }\n    }\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n  function d3_time_interval_utc(method) {\n    return function(date, k) {\n      try {\n        d3_date = d3_date_utc;\n        var utc = new d3_date_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_date = Date;\n      }\n    };\n  }\n  d3_time.year = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function(date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function(date) {\n    return date.getFullYear();\n  });\n  d3_time.years = d3_time.year.range;\n  d3_time.years.utc = d3_time.year.utc.range;\n  d3_time.day = d3_time_interval(function(date) {\n    var day = new d3_date(2e3, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function(date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n  d3_time.days = d3_time.day.range;\n  d3_time.days.utc = d3_time.day.utc.range;\n  d3_time.dayOfYear = function(date) {\n    var year = d3_time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n  [ \"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\" ].forEach(function(day, i) {\n    i = 7 - i;\n    var interval = d3_time[day] = d3_time_interval(function(date) {\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function(date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3_time[day + \"s\"] = interval.range;\n    d3_time[day + \"s\"].utc = interval.utc.range;\n    d3_time[day + \"OfYear\"] = function(date) {\n      var day = d3_time.year(date).getDay();\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3_time.week = d3_time.sunday;\n  d3_time.weeks = d3_time.sunday.range;\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\n  d3_time.weekOfYear = d3_time.sundayOfYear;\n  function d3_locale_timeFormat(locale) {\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\n    function d3_time_format(template) {\n      var n = template.length;\n      function format(date) {\n        var string = [], i = -1, j = 0, c, p, f;\n        while (++i < n) {\n          if (template.charCodeAt(i) === 37) {\n            string.push(template.slice(j, i));\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n            string.push(c);\n            j = i + 1;\n          }\n        }\n        string.push(template.slice(j, i));\n        return string.join(\"\");\n      }\n      format.parse = function(string) {\n        var d = {\n          y: 1900,\n          m: 0,\n          d: 1,\n          H: 0,\n          M: 0,\n          S: 0,\n          L: 0,\n          Z: null\n        }, i = d3_time_parse(d, template, string, 0);\n        if (i != string.length) return null;\n        if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\n        if (\"j\" in d) date.setFullYear(d.y, 0, d.j); else if (\"W\" in d || \"U\" in d) {\n          if (!(\"w\" in d)) d.w = \"W\" in d ? 1 : 0;\n          date.setFullYear(d.y, 0, 1);\n          date.setFullYear(d.y, 0, \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\n        } else date.setFullYear(d.y, d.m, d.d);\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\n        return localZ ? date._ : date;\n      };\n      format.toString = function() {\n        return template;\n      };\n      return format;\n    }\n    function d3_time_parse(date, template, string, j) {\n      var c, p, t, i = 0, n = template.length, m = string.length;\n      while (i < n) {\n        if (j >= m) return -1;\n        c = template.charCodeAt(i++);\n        if (c === 37) {\n          t = template.charAt(i++);\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\n          if (!p || (j = p(date, string, j)) < 0) return -1;\n        } else if (c != string.charCodeAt(j++)) {\n          return -1;\n        }\n      }\n      return j;\n    }\n    d3_time_format.utc = function(template) {\n      var local = d3_time_format(template);\n      function format(date) {\n        try {\n          d3_date = d3_date_utc;\n          var utc = new d3_date();\n          utc._ = date;\n          return local(utc);\n        } finally {\n          d3_date = Date;\n        }\n      }\n      format.parse = function(string) {\n        try {\n          d3_date = d3_date_utc;\n          var date = local.parse(string);\n          return date && date._;\n        } finally {\n          d3_date = Date;\n        }\n      };\n      format.toString = local.toString;\n      return format;\n    };\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\n    locale_periods.forEach(function(p, i) {\n      d3_time_periodLookup.set(p.toLowerCase(), i);\n    });\n    var d3_time_formats = {\n      a: function(d) {\n        return locale_shortDays[d.getDay()];\n      },\n      A: function(d) {\n        return locale_days[d.getDay()];\n      },\n      b: function(d) {\n        return locale_shortMonths[d.getMonth()];\n      },\n      B: function(d) {\n        return locale_months[d.getMonth()];\n      },\n      c: d3_time_format(locale_dateTime),\n      d: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      e: function(d, p) {\n        return d3_time_formatPad(d.getDate(), p, 2);\n      },\n      H: function(d, p) {\n        return d3_time_formatPad(d.getHours(), p, 2);\n      },\n      I: function(d, p) {\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n      },\n      j: function(d, p) {\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\n      },\n      L: function(d, p) {\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\n      },\n      m: function(d, p) {\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\n      },\n      M: function(d, p) {\n        return d3_time_formatPad(d.getMinutes(), p, 2);\n      },\n      p: function(d) {\n        return locale_periods[+(d.getHours() >= 12)];\n      },\n      S: function(d, p) {\n        return d3_time_formatPad(d.getSeconds(), p, 2);\n      },\n      U: function(d, p) {\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\n      },\n      w: function(d) {\n        return d.getDay();\n      },\n      W: function(d, p) {\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\n      },\n      x: d3_time_format(locale_date),\n      X: d3_time_format(locale_time),\n      y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n      },\n      Y: function(d, p) {\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n      },\n      Z: d3_time_zone,\n      \"%\": function() {\n        return \"%\";\n      }\n    };\n    var d3_time_parsers = {\n      a: d3_time_parseWeekdayAbbrev,\n      A: d3_time_parseWeekday,\n      b: d3_time_parseMonthAbbrev,\n      B: d3_time_parseMonth,\n      c: d3_time_parseLocaleFull,\n      d: d3_time_parseDay,\n      e: d3_time_parseDay,\n      H: d3_time_parseHour24,\n      I: d3_time_parseHour24,\n      j: d3_time_parseDayOfYear,\n      L: d3_time_parseMilliseconds,\n      m: d3_time_parseMonthNumber,\n      M: d3_time_parseMinutes,\n      p: d3_time_parseAmPm,\n      S: d3_time_parseSeconds,\n      U: d3_time_parseWeekNumberSunday,\n      w: d3_time_parseWeekdayNumber,\n      W: d3_time_parseWeekNumberMonday,\n      x: d3_time_parseLocaleDate,\n      X: d3_time_parseLocaleTime,\n      y: d3_time_parseYear,\n      Y: d3_time_parseFullYear,\n      Z: d3_time_parseZone,\n      \"%\": d3_time_parseLiteralPercent\n    };\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\n      d3_time_dayAbbrevRe.lastIndex = 0;\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseWeekday(date, string, i) {\n      d3_time_dayRe.lastIndex = 0;\n      var n = d3_time_dayRe.exec(string.slice(i));\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonthAbbrev(date, string, i) {\n      d3_time_monthAbbrevRe.lastIndex = 0;\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseMonth(date, string, i) {\n      d3_time_monthRe.lastIndex = 0;\n      var n = d3_time_monthRe.exec(string.slice(i));\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\n    }\n    function d3_time_parseLocaleFull(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n    }\n    function d3_time_parseLocaleDate(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n    }\n    function d3_time_parseLocaleTime(date, string, i) {\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n    }\n    function d3_time_parseAmPm(date, string, i) {\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\n      return n == null ? -1 : (date.p = n, i);\n    }\n    return d3_time_format;\n  }\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    _: \" \",\n    \"0\": \"0\"\n  }, d3_time_numberRe = /^\\s*\\d+/, d3_time_percentRe = /^%/;\n  function d3_time_formatPad(value, fill, width) {\n    var sign = value < 0 ? \"-\" : \"\", string = (sign ? -value : value) + \"\", length = string.length;\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n  }\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(), i = -1, n = names.length;\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n    return map;\n  }\n  function d3_time_parseWeekdayNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberSunday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseWeekNumberMonday(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i));\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\n  }\n  function d3_time_parseZone(date, string, i) {\n    return /^[+-]\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \n    i + 5) : -1;\n  }\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\n  }\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseDayOfYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\n  }\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \"-\" : \"+\", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n  function d3_time_parseLiteralPercent(date, string, i) {\n    d3_time_percentRe.lastIndex = 0;\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\n    return n ? i + n[0].length : -1;\n  }\n  function d3_time_formatMulti(formats) {\n    var n = formats.length, i = -1;\n    while (++i < n) formats[i][0] = this(formats[i][0]);\n    return function(date) {\n      var i = 0, f = formats[i];\n      while (!f[1](date)) f = formats[++i];\n      return f[0](date);\n    };\n  }\n  d3.locale = function(locale) {\n    return {\n      numberFormat: d3_locale_numberFormat(locale),\n      timeFormat: d3_locale_timeFormat(locale)\n    };\n  };\n  var d3_locale_enUS = d3.locale({\n    decimal: \".\",\n    thousands: \",\",\n    grouping: [ 3 ],\n    currency: [ \"$\", \"\" ],\n    dateTime: \"%a %b %e %X %Y\",\n    date: \"%m/%d/%Y\",\n    time: \"%H:%M:%S\",\n    periods: [ \"AM\", \"PM\" ],\n    days: [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\" ],\n    shortDays: [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" ],\n    months: [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ],\n    shortMonths: [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" ]\n  });\n  d3.format = d3_locale_enUS.numberFormat;\n  d3.geo = {};\n  function d3_adder() {}\n  d3_adder.prototype = {\n    s: 0,\n    t: 0,\n    add: function(y) {\n      d3_adderSum(y, this.t, d3_adderTemp);\n      d3_adderSum(d3_adderTemp.s, this.s, this);\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\n    },\n    reset: function() {\n      this.s = this.t = 0;\n    },\n    valueOf: function() {\n      return this.s;\n    }\n  };\n  var d3_adderTemp = new d3_adder();\n  function d3_adderSum(a, b, o) {\n    var x = o.s = a + b, bv = x - a, av = x - bv;\n    o.t = a - av + (b - bv);\n  }\n  d3.geo.stream = function(object, listener) {\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n  var d3_geo_streamObjectType = {\n    Feature: function(feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function(object, listener) {\n      var features = object.features, i = -1, n = features.length;\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function(object, listener) {\n      listener.sphere();\n    },\n    Point: function(object, listener) {\n      object = object.coordinates;\n      listener.point(object[0], object[1], object[2]);\n    },\n    MultiPoint: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\n    },\n    LineString: function(object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function(object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function(object, listener) {\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    },\n    GeometryCollection: function(object, listener) {\n      var geometries = object.geometries, i = -1, n = geometries.length;\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1, n = coordinates.length - closed, coordinate;\n    listener.lineStart();\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\n    listener.lineEnd();\n  }\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1, n = coordinates.length;\n    listener.polygonStart();\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n    listener.polygonEnd();\n  }\n  d3.geo.area = function(object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\n  var d3_geo_area = {\n    sphere: function() {\n      d3_geo_areaSum += 4 * π;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_areaRingSum.reset();\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function() {\n      var area = 2 * d3_geo_areaRingSum;\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n  function d3_geo_areaRingStart() {\n    var λ00, φ00, λ0, cosφ0, sinφ0;\n    d3_geo_area.point = function(λ, φ) {\n      d3_geo_area.point = nextPoint;\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), \n      sinφ0 = Math.sin(φ);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      φ = φ * d3_radians / 2 + π / 4;\n      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\n    }\n    d3_geo_area.lineEnd = function() {\n      nextPoint(λ00, φ00);\n    };\n  }\n  function d3_geo_cartesian(spherical) {\n    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);\n    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];\n  }\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n  function d3_geo_cartesianCross(a, b) {\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n  }\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n  function d3_geo_cartesianScale(vector, k) {\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\n  }\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n  function d3_geo_spherical(cartesian) {\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\n  }\n  function d3_geo_sphericalEqual(a, b) {\n    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\n  }\n  d3.geo.bounds = function() {\n    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;\n    var bound = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        bound.point = ringPoint;\n        bound.lineStart = ringStart;\n        bound.lineEnd = ringEnd;\n        dλSum = 0;\n        d3_geo_area.polygonStart();\n      },\n      polygonEnd: function() {\n        d3_geo_area.polygonEnd();\n        bound.point = point;\n        bound.lineStart = lineStart;\n        bound.lineEnd = lineEnd;\n        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;\n        range[0] = λ0, range[1] = λ1;\n      }\n    };\n    function point(λ, φ) {\n      ranges.push(range = [ λ0 = λ, λ1 = λ ]);\n      if (φ < φ0) φ0 = φ;\n      if (φ > φ1) φ1 = φ;\n    }\n    function linePoint(λ, φ) {\n      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);\n      if (p0) {\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\n        d3_geo_cartesianNormalize(inflection);\n        inflection = d3_geo_spherical(inflection);\n        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;\n        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = inflection[1] * d3_degrees;\n          if (φi > φ1) φ1 = φi;\n        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\n          var φi = -inflection[1] * d3_degrees;\n          if (φi < φ0) φ0 = φi;\n        } else {\n          if (φ < φ0) φ0 = φ;\n          if (φ > φ1) φ1 = φ;\n        }\n        if (antimeridian) {\n          if (λ < λ_) {\n            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n          } else {\n            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n          }\n        } else {\n          if (λ1 >= λ0) {\n            if (λ < λ0) λ0 = λ;\n            if (λ > λ1) λ1 = λ;\n          } else {\n            if (λ > λ_) {\n              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\n            } else {\n              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\n            }\n          }\n        }\n      } else {\n        point(λ, φ);\n      }\n      p0 = p, λ_ = λ;\n    }\n    function lineStart() {\n      bound.point = linePoint;\n    }\n    function lineEnd() {\n      range[0] = λ0, range[1] = λ1;\n      bound.point = point;\n      p0 = null;\n    }\n    function ringPoint(λ, φ) {\n      if (p0) {\n        var dλ = λ - λ_;\n        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\n      } else λ__ = λ, φ__ = φ;\n      d3_geo_area.point(λ, φ);\n      linePoint(λ, φ);\n    }\n    function ringStart() {\n      d3_geo_area.lineStart();\n    }\n    function ringEnd() {\n      ringPoint(λ__, φ__);\n      d3_geo_area.lineEnd();\n      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\n      range[0] = λ0, range[1] = λ1;\n      p0 = null;\n    }\n    function angle(λ0, λ1) {\n      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\n    }\n    function compareRanges(a, b) {\n      return a[0] - b[0];\n    }\n    function withinRange(x, range) {\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    return function(feature) {\n      φ1 = λ1 = -(λ0 = φ0 = Infinity);\n      ranges = [];\n      d3.geo.stream(feature, bound);\n      var n = ranges.length;\n      if (n) {\n        ranges.sort(compareRanges);\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\n          b = ranges[i];\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n          } else {\n            merged.push(a = b);\n          }\n        }\n        var best = -Infinity, dλ;\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\n          b = merged[i];\n          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\n        }\n      }\n      ranges = range = null;\n      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];\n    };\n  }();\n  d3.geo.centroid = function(object) {\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\n    if (m < ε2) {\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\n      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\n      m = x * x + y * y + z * z;\n      if (m < ε2) return [ NaN, NaN ];\n    }\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\n  };\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n  function d3_geo_centroidPoint(λ, φ) {\n    λ *= d3_radians;\n    var cosφ = Math.cos(φ *= d3_radians);\n    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\n  }\n  function d3_geo_centroidPointXYZ(x, y, z) {\n    ++d3_geo_centroidW0;\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\n  }\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroid.point = nextPoint;\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n  function d3_geo_centroidRingStart() {\n    var λ00, φ00, x0, y0, z0;\n    d3_geo_centroid.point = function(λ, φ) {\n      λ00 = λ, φ00 = φ;\n      d3_geo_centroid.point = nextPoint;\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    };\n    d3_geo_centroid.lineEnd = function() {\n      nextPoint(λ00, φ00);\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n      d3_geo_centroid.point = d3_geo_centroidPoint;\n    };\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\n      d3_geo_centroidX2 += v * cx;\n      d3_geo_centroidY2 += v * cy;\n      d3_geo_centroidZ2 += v * cz;\n      d3_geo_centroidW1 += w;\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\n      d3_geo_centroidPointXYZ(x0, y0, z0);\n    }\n  }\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n    if (a.invert && b.invert) compose.invert = function(x, y) {\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n  function d3_true() {\n    return true;\n  }\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\n    var subject = [], clip = [];\n    segments.forEach(function(segment) {\n      if ((n = segment.length - 1) <= 0) return;\n      var n, p0 = segment[0], p1 = segment[n];\n      if (d3_geo_sphericalEqual(p0, p1)) {\n        listener.lineStart();\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\n        listener.lineEnd();\n        return;\n      }\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\n      a.o = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(compare);\n    d3_geo_clipPolygonLinkCircular(subject);\n    d3_geo_clipPolygonLinkCircular(clip);\n    if (!subject.length) return;\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\n      clip[i].e = entry = !entry;\n    }\n    var start = subject[0], points, point;\n    while (1) {\n      var current = start, isSubject = true;\n      while (current.v) if ((current = current.n) === start) return;\n      points = current.z;\n      listener.lineStart();\n      do {\n        current.v = current.o.v = true;\n        if (current.e) {\n          if (isSubject) {\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.n.x, 1, listener);\n          }\n          current = current.n;\n        } else {\n          if (isSubject) {\n            points = current.p.z;\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.x, current.p.x, -1, listener);\n          }\n          current = current.p;\n        }\n        current = current.o;\n        points = current.z;\n        isSubject = !isSubject;\n      } while (!current.v);\n      listener.lineEnd();\n    }\n  }\n  function d3_geo_clipPolygonLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n, i = 0, a = array[0], b;\n    while (++i < n) {\n      a.n = b = array[i];\n      b.p = a;\n      a = b;\n    }\n    a.n = b = array[0];\n    b.p = a;\n  }\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\n    this.x = point;\n    this.z = points;\n    this.o = other;\n    this.e = entry;\n    this.v = false;\n    this.n = this.p = null;\n  }\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\n    return function(rotate, listener) {\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          segments = [];\n          polygon = [];\n        },\n        polygonEnd: function() {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\n          if (segments.length) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\n          } else if (clipStartInside) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\n          segments = polygon = null;\n        },\n        sphere: function() {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n      function point(λ, φ) {\n        var point = rotate(λ, φ);\n        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\n      }\n      function pointLine(λ, φ) {\n        var point = rotate(λ, φ);\n        line.point(point[0], point[1]);\n      }\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n      var segments;\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\n      function pointRing(λ, φ) {\n        ring.push([ λ, φ ]);\n        var point = rotate(λ, φ);\n        ringListener.point(point[0], point[1]);\n      }\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\n        ring.pop();\n        polygon.push(ring);\n        ring = null;\n        if (!n) return;\n        if (clean & 1) {\n          segment = ringSegments[0];\n          var n = segment.length - 1, i = -1, point;\n          if (n > 0) {\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\n            listener.lineStart();\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\n            listener.lineEnd();\n          }\n          return;\n        }\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n      return clip;\n    };\n  }\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n  function d3_geo_clipBufferListener() {\n    var lines = [], line;\n    return {\n      lineStart: function() {\n        lines.push(line = []);\n      },\n      point: function(λ, φ) {\n        line.push([ λ, φ ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function() {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      },\n      rejoin: function() {\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n      }\n    };\n  }\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\n  }\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);\n  function d3_geo_clipAntimeridianLine(listener) {\n    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;\n    return {\n      lineStart: function() {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function(λ1, φ1) {\n        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);\n        if (abs(dλ - π) < ε) {\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          listener.point(λ1, φ0);\n          clean = 0;\n        } else if (sλ0 !== sλ1 && dλ >= π) {\n          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          clean = 0;\n        }\n        listener.point(λ0 = λ1, φ0 = φ1);\n        sλ0 = sλ1;\n      },\n      lineEnd: function() {\n        listener.lineEnd();\n        λ0 = φ0 = NaN;\n      },\n      clean: function() {\n        return 2 - clean;\n      }\n    };\n  }\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);\n    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n  }\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var φ;\n    if (from == null) {\n      φ = direction * halfπ;\n      listener.point(-π, φ);\n      listener.point(0, φ);\n      listener.point(π, φ);\n      listener.point(π, 0);\n      listener.point(π, -φ);\n      listener.point(0, -φ);\n      listener.point(-π, -φ);\n      listener.point(-π, 0);\n      listener.point(-π, φ);\n    } else if (abs(from[0] - to[0]) > ε) {\n      var s = from[0] < to[0] ? π : -π;\n      φ = direction * s / 2;\n      listener.point(-s, φ);\n      listener.point(0, φ);\n      listener.point(s, φ);\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n  function d3_geo_pointInPolygon(point, polygon) {\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\n    d3_geo_areaRingSum.reset();\n    for (var i = 0, n = polygon.length; i < n; ++i) {\n      var ring = polygon[i], m = ring.length;\n      if (!m) continue;\n      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;\n      while (true) {\n        if (j === m) j = 0;\n        point = ring[j];\n        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;\n        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\n        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;\n        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\n          d3_geo_cartesianNormalize(arc);\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\n          d3_geo_cartesianNormalize(intersection);\n          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\n          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\n            winding += antimeridian ^ dλ >= 0 ? 1 : -1;\n          }\n        }\n        if (!j++) break;\n        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\n      }\n    }\n    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;\n  }\n  function d3_geo_clipCircle(radius) {\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);\n    function visible(λ, φ) {\n      return Math.cos(λ) * Math.cos(φ) > cr;\n    }\n    function clipLine(listener) {\n      var point0, c0, v0, v00, clean;\n      return {\n        lineStart: function() {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function(λ, φ) {\n          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ε;\n              point1[1] += ε;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n          if (v !== v0) {\n            clean = 0;\n            if (v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n            point0 = point2;\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\n            var t;\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\n              clean = 0;\n              if (smallRadius) {\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n              } else {\n                listener.point(t[1][0], t[1][1]);\n                listener.lineEnd();\n                listener.lineStart();\n                listener.point(t[0][0], t[0][1]);\n              }\n            }\n          }\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\n            listener.point(point1[0], point1[1]);\n          }\n          point0 = point1, v0 = v, c0 = c;\n        },\n        lineEnd: function() {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function() {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n    function intersect(a, b, two) {\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return !two && a;\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\n      if (t2 < 0) return;\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      q = d3_geo_spherical(q);\n      if (!two) return q;\n      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;\n      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\n      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;\n      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;\n      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\n        d3_geo_cartesianAdd(q1, A);\n        return [ q, d3_geo_spherical(q1) ];\n      }\n    }\n    function code(λ, φ) {\n      var r = smallRadius ? radius : π - radius, code = 0;\n      if (λ < -r) code |= 1; else if (λ > r) code |= 2;\n      if (φ < -r) code |= 4; else if (φ > r) code |= 8;\n      return code;\n    }\n  }\n  function d3_geom_clipLine(x0, y0, x1, y1) {\n    return function(line) {\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n      r = x0 - ax;\n      if (!dx && r > 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dx > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = x1 - ax;\n      if (!dx && r < 0) return;\n      r /= dx;\n      if (dx < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dx > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      r = y0 - ay;\n      if (!dy && r > 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      } else if (dy > 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      }\n      r = y1 - ay;\n      if (!dy && r < 0) return;\n      r /= dy;\n      if (dy < 0) {\n        if (r > t1) return;\n        if (r > t0) t0 = r;\n      } else if (dy > 0) {\n        if (r < t0) return;\n        if (r < t1) t1 = r;\n      }\n      if (t0 > 0) line.a = {\n        x: ax + t0 * dx,\n        y: ay + t0 * dy\n      };\n      if (t1 < 1) line.b = {\n        x: ax + t1 * dx,\n        y: ay + t1 * dy\n      };\n      return line;\n    };\n  }\n  var d3_geo_clipExtentMAX = 1e9;\n  d3.geo.clipExtent = function() {\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\n      stream: function(output) {\n        if (stream) stream.valid = false;\n        stream = clip(output);\n        stream.valid = true;\n        return stream;\n      },\n      extent: function(_) {\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\n        if (stream) stream.valid = false, stream = null;\n        return clipExtent;\n      }\n    };\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\n  };\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\n    return function(listener) {\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          listener = bufferListener;\n          segments = [];\n          polygon = [];\n          clean = true;\n        },\n        polygonEnd: function() {\n          listener = listener_;\n          segments = d3.merge(segments);\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\n          if (inside || visible) {\n            listener.polygonStart();\n            if (inside) {\n              listener.lineStart();\n              interpolate(null, null, 1, listener);\n              listener.lineEnd();\n            }\n            if (visible) {\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\n            }\n            listener.polygonEnd();\n          }\n          segments = polygon = ring = null;\n        }\n      };\n      function insidePolygon(p) {\n        var wn = 0, n = polygon.length, y = p[1];\n        for (var i = 0; i < n; ++i) {\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\n            b = v[j];\n            if (a[1] <= y) {\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\n            } else {\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\n            }\n            a = b;\n          }\n        }\n        return wn !== 0;\n      }\n      function interpolate(from, to, direction, listener) {\n        var a = 0, a1 = 0;\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\n          do {\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n          } while ((a = (a + direction + 4) % 4) !== a1);\n        } else {\n          listener.point(to[0], to[1]);\n        }\n      }\n      function pointVisible(x, y) {\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n      }\n      function point(x, y) {\n        if (pointVisible(x, y)) listener.point(x, y);\n      }\n      var x__, y__, v__, x_, y_, v_, first, clean;\n      function lineStart() {\n        clip.point = linePoint;\n        if (polygon) polygon.push(ring = []);\n        first = true;\n        v_ = false;\n        x_ = y_ = NaN;\n      }\n      function lineEnd() {\n        if (segments) {\n          linePoint(x__, y__);\n          if (v__ && v_) bufferListener.rejoin();\n          segments.push(bufferListener.buffer());\n        }\n        clip.point = point;\n        if (v_) listener.lineEnd();\n      }\n      function linePoint(x, y) {\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\n        var v = pointVisible(x, y);\n        if (polygon) ring.push([ x, y ]);\n        if (first) {\n          x__ = x, y__ = y, v__ = v;\n          first = false;\n          if (v) {\n            listener.lineStart();\n            listener.point(x, y);\n          }\n        } else {\n          if (v && v_) listener.point(x, y); else {\n            var l = {\n              a: {\n                x: x_,\n                y: y_\n              },\n              b: {\n                x: x,\n                y: y\n              }\n            };\n            if (clipLine(l)) {\n              if (!v_) {\n                listener.lineStart();\n                listener.point(l.a.x, l.a.y);\n              }\n              listener.point(l.b.x, l.b.y);\n              if (!v) listener.lineEnd();\n              clean = false;\n            } else if (v) {\n              listener.lineStart();\n              listener.point(x, y);\n              clean = false;\n            }\n          }\n        }\n        x_ = x, y_ = y, v_ = v;\n      }\n      return clip;\n    };\n    function corner(p, direction) {\n      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\n    }\n    function compare(a, b) {\n      return comparePoints(a.x, b.x);\n    }\n    function comparePoints(a, b) {\n      var ca = corner(a, 1), cb = corner(b, 1);\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\n    }\n  }\n  function d3_geo_conic(projectAt) {\n    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);\n    p.parallels = function(_) {\n      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];\n      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\n    };\n    return p;\n  }\n  function d3_geo_conicEqualArea(φ0, φ1) {\n    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;\n    function forward(λ, φ) {\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = ρ0 - y;\n      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEqualArea = function() {\n    return d3_geo_conic(d3_geo_conicEqualArea);\n  }).raw = d3_geo_conicEqualArea;\n  d3.geo.albers = function() {\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\n  };\n  d3.geo.albersUsa = function() {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\n    var point, pointStream = {\n      point: function(x, y) {\n        point = [ x, y ];\n      }\n    }, lower48Point, alaskaPoint, hawaiiPoint;\n    function albersUsa(coordinates) {\n      var x = coordinates[0], y = coordinates[1];\n      point = null;\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\n      return point;\n    }\n    albersUsa.invert = function(coordinates) {\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\n    };\n    albersUsa.stream = function(stream) {\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\n      return {\n        point: function(x, y) {\n          lower48Stream.point(x, y);\n          alaskaStream.point(x, y);\n          hawaiiStream.point(x, y);\n        },\n        sphere: function() {\n          lower48Stream.sphere();\n          alaskaStream.sphere();\n          hawaiiStream.sphere();\n        },\n        lineStart: function() {\n          lower48Stream.lineStart();\n          alaskaStream.lineStart();\n          hawaiiStream.lineStart();\n        },\n        lineEnd: function() {\n          lower48Stream.lineEnd();\n          alaskaStream.lineEnd();\n          hawaiiStream.lineEnd();\n        },\n        polygonStart: function() {\n          lower48Stream.polygonStart();\n          alaskaStream.polygonStart();\n          hawaiiStream.polygonStart();\n        },\n        polygonEnd: function() {\n          lower48Stream.polygonEnd();\n          alaskaStream.polygonEnd();\n          hawaiiStream.polygonEnd();\n        }\n      };\n    };\n    albersUsa.precision = function(_) {\n      if (!arguments.length) return lower48.precision();\n      lower48.precision(_);\n      alaska.precision(_);\n      hawaii.precision(_);\n      return albersUsa;\n    };\n    albersUsa.scale = function(_) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(_);\n      alaska.scale(_ * .35);\n      hawaii.scale(_);\n      return albersUsa.translate(lower48.translate());\n    };\n    albersUsa.translate = function(_) {\n      if (!arguments.length) return lower48.translate();\n      var k = lower48.scale(), x = +_[0], y = +_[1];\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\n      return albersUsa;\n    };\n    return albersUsa.scale(1070);\n  };\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function() {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathArea.point = function(x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n    d3_geo_pathArea.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\n  var d3_geo_pathBounds = {\n    point: d3_geo_pathBoundsPoint,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_pathBoundsPoint(x, y) {\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\n  }\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointCircle = d3_geo_pathBufferCircle(_);\n        return stream;\n      },\n      result: function() {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n    return stream;\n  }\n  function d3_geo_pathBufferCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius + \"z\";\n  }\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function() {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function() {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n  function d3_geo_pathCentroidPoint(x, y) {\n    d3_geo_centroidX0 += x;\n    d3_geo_centroidY0 += y;\n    ++d3_geo_centroidZ0;\n  }\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n  }\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n    d3_geo_pathCentroid.point = function(x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\n    };\n    function nextPoint(x, y) {\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\n      d3_geo_centroidZ1 += z;\n      z = y0 * x - x0 * y;\n      d3_geo_centroidX2 += z * (x0 + x);\n      d3_geo_centroidY2 += z * (y0 + y);\n      d3_geo_centroidZ2 += z * 3;\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\n    }\n    d3_geo_pathCentroid.lineEnd = function() {\n      nextPoint(x00, y00);\n    };\n  }\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function() {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function() {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function(_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n    function point(x, y) {\n      context.moveTo(x + pointRadius, y);\n      context.arc(x, y, pointRadius, 0, τ);\n    }\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n    function lineEnd() {\n      stream.point = point;\n    }\n    function lineEndPolygon() {\n      context.closePath();\n    }\n    return stream;\n  }\n  function d3_geo_resample(project) {\n    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\n    function resample(stream) {\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\n    }\n    function resampleNone(stream) {\n      return d3_geo_transformPoint(stream, function(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      });\n    }\n    function resampleRecursive(stream) {\n      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function() {\n          stream.polygonStart();\n          resample.lineStart = ringStart;\n        },\n        polygonEnd: function() {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n      function linePoint(λ, φ) {\n        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n      function ringStart() {\n        lineStart();\n        resample.point = ringPoint;\n        resample.lineEnd = ringEnd;\n      }\n      function ringPoint(λ, φ) {\n        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n        resample.point = linePoint;\n      }\n      function ringEnd() {\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n        resample.lineEnd = lineEnd;\n        lineEnd();\n      }\n      return resample;\n    }\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n      if (d2 > 4 * δ2 && depth--) {\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n    resample.precision = function(_) {\n      if (!arguments.length) return Math.sqrt(δ2);\n      maxDepth = (δ2 = _ * _) > 0 && 16;\n      return resample;\n    };\n    return resample;\n  }\n  d3.geo.path = function() {\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\n    function path(object) {\n      if (object) {\n        if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\n        d3.geo.stream(object, cacheStream);\n      }\n      return contextStream.result();\n    }\n    path.area = function(object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n    path.centroid = function(object) {\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\n    };\n    path.bounds = function(object) {\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\n    };\n    path.projection = function(_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return reset();\n    };\n    path.context = function(_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n      return reset();\n    };\n    path.pointRadius = function(_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n      return path;\n    };\n    function reset() {\n      cacheStream = null;\n      return path;\n    }\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function(x, y) {\n      return project([ x * d3_degrees, y * d3_degrees ]);\n    });\n    return function(stream) {\n      return d3_geo_projectionRadians(resample(stream));\n    };\n  }\n  d3.geo.transform = function(methods) {\n    return {\n      stream: function(stream) {\n        var transform = new d3_geo_transform(stream);\n        for (var k in methods) transform[k] = methods[k];\n        return transform;\n      }\n    };\n  };\n  function d3_geo_transform(stream) {\n    this.stream = stream;\n  }\n  d3_geo_transform.prototype = {\n    point: function(x, y) {\n      this.stream.point(x, y);\n    },\n    sphere: function() {\n      this.stream.sphere();\n    },\n    lineStart: function() {\n      this.stream.lineStart();\n    },\n    lineEnd: function() {\n      this.stream.lineEnd();\n    },\n    polygonStart: function() {\n      this.stream.polygonStart();\n    },\n    polygonEnd: function() {\n      this.stream.polygonEnd();\n    }\n  };\n  function d3_geo_transformPoint(stream, point) {\n    return {\n      point: point,\n      sphere: function() {\n        stream.sphere();\n      },\n      lineStart: function() {\n        stream.lineStart();\n      },\n      lineEnd: function() {\n        stream.lineEnd();\n      },\n      polygonStart: function() {\n        stream.polygonStart();\n      },\n      polygonEnd: function() {\n        stream.polygonEnd();\n      }\n    };\n  }\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function() {\n      return project;\n    })();\n  }\n  function d3_geo_projectionMutator(projectAt) {\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\n      x = project(x, y);\n      return [ x[0] * k + δx, δy - x[1] * k ];\n    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [ point[0] * k + δx, δy - point[1] * k ];\n    }\n    function invert(point) {\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\n    }\n    projection.stream = function(output) {\n      if (stream) stream.valid = false;\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\n      stream.valid = true;\n      return stream;\n    };\n    projection.clipAngle = function(_) {\n      if (!arguments.length) return clipAngle;\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\n      return invalidate();\n    };\n    projection.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent;\n      clipExtent = _;\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\n      return invalidate();\n    };\n    projection.scale = function(_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n    projection.translate = function(_) {\n      if (!arguments.length) return [ x, y ];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n    projection.center = function(_) {\n      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];\n      λ = _[0] % 360 * d3_radians;\n      φ = _[1] % 360 * d3_radians;\n      return reset();\n    };\n    projection.rotate = function(_) {\n      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];\n      δλ = _[0] % 360 * d3_radians;\n      δφ = _[1] % 360 * d3_radians;\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n    d3.rebind(projection, projectResample, \"precision\");\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n      var center = project(λ, φ);\n      δx = x - center[0] * k;\n      δy = y + center[1] * k;\n      return invalidate();\n    }\n    function invalidate() {\n      if (stream) stream.valid = false, stream = null;\n      return projection;\n    }\n    return function() {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n  function d3_geo_projectionRadians(stream) {\n    return d3_geo_transformPoint(stream, function(x, y) {\n      stream.point(x * d3_radians, y * d3_radians);\n    });\n  }\n  function d3_geo_equirectangular(λ, φ) {\n    return [ λ, φ ];\n  }\n  (d3.geo.equirectangular = function() {\n    return d3_geo_projection(d3_geo_equirectangular);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  d3.geo.rotation = function(rotate) {\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\n    function forward(coordinates) {\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    }\n    forward.invert = function(coordinates) {\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\n    };\n    return forward;\n  };\n  function d3_geo_identityRotation(λ, φ) {\n    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n  }\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\n  function d3_geo_rotation(δλ, δφ, δγ) {\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\n  }\n  function d3_geo_forwardRotationλ(δλ) {\n    return function(λ, φ) {\n      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\n    };\n  }\n  function d3_geo_rotationλ(δλ) {\n    var rotation = d3_geo_forwardRotationλ(δλ);\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\n    return rotation;\n  }\n  function d3_geo_rotationφγ(δφ, δγ) {\n    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);\n    function rotation(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;\n      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];\n    }\n    rotation.invert = function(λ, φ) {\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;\n      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];\n    };\n    return rotation;\n  }\n  d3.geo.circle = function() {\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\n      interpolate(null, null, 1, {\n        point: function(x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ ring ]\n      };\n    }\n    circle.origin = function(x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n    circle.angle = function(x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n    circle.precision = function(_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n    return circle.angle(90);\n  };\n  function d3_geo_circleInterpolate(radius, precision) {\n    var cr = Math.cos(radius), sr = Math.sin(radius);\n    return function(from, to, direction, listener) {\n      var step = direction * precision;\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * τ;\n      } else {\n        from = radius + direction * τ;\n        to = radius - .5 * step;\n      }\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\n      }\n    };\n  }\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = d3_acos(-a[1]);\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n  }\n  d3.geo.distance = function(a, b) {\n    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;\n    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);\n  };\n  d3.geo.graticule = function() {\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n    function graticule() {\n      return {\n        type: \"MultiLineString\",\n        coordinates: lines()\n      };\n    }\n    function lines() {\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\n        return abs(x % DX) > ε;\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\n        return abs(y % DY) > ε;\n      }).map(y));\n    }\n    graticule.lines = function() {\n      return lines().map(function(coordinates) {\n        return {\n          type: \"LineString\",\n          coordinates: coordinates\n        };\n      });\n    };\n    graticule.outline = function() {\n      return {\n        type: \"Polygon\",\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\n      };\n    };\n    graticule.extent = function(_) {\n      if (!arguments.length) return graticule.minorExtent();\n      return graticule.majorExtent(_).minorExtent(_);\n    };\n    graticule.majorExtent = function(_) {\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\n      X0 = +_[0][0], X1 = +_[1][0];\n      Y0 = +_[0][1], Y1 = +_[1][1];\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.minorExtent = function(_) {\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n    graticule.step = function(_) {\n      if (!arguments.length) return graticule.minorStep();\n      return graticule.majorStep(_).minorStep(_);\n    };\n    graticule.majorStep = function(_) {\n      if (!arguments.length) return [ DX, DY ];\n      DX = +_[0], DY = +_[1];\n      return graticule;\n    };\n    graticule.minorStep = function(_) {\n      if (!arguments.length) return [ dx, dy ];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n    graticule.precision = function(_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, 90);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      X = d3_geo_graticuleX(Y0, Y1, 90);\n      Y = d3_geo_graticuleY(X0, X1, precision);\n      return graticule;\n    };\n    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);\n  };\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\n    return function(x) {\n      return y.map(function(y) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\n    return function(y) {\n      return x.map(function(x) {\n        return [ x, y ];\n      });\n    };\n  }\n  function d3_source(d) {\n    return d.source;\n  }\n  function d3_target(d) {\n    return d.target;\n  }\n  d3.geo.greatArc = function() {\n    var source = d3_source, source_, target = d3_target, target_;\n    function greatArc() {\n      return {\n        type: \"LineString\",\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\n      };\n    }\n    greatArc.distance = function() {\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\n    };\n    greatArc.source = function(_) {\n      if (!arguments.length) return source;\n      source = _, source_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.target = function(_) {\n      if (!arguments.length) return target;\n      target = _, target_ = typeof _ === \"function\" ? null : _;\n      return greatArc;\n    };\n    greatArc.precision = function() {\n      return arguments.length ? greatArc : 0;\n    };\n    return greatArc;\n  };\n  d3.geo.interpolate = function(source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\n    var interpolate = d ? function(t) {\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\n    } : function() {\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\n    };\n    interpolate.distance = d;\n    return interpolate;\n  }\n  d3.geo.length = function(object) {\n    d3_geo_lengthSum = 0;\n    d3.geo.stream(object, d3_geo_length);\n    return d3_geo_lengthSum;\n  };\n  var d3_geo_lengthSum;\n  var d3_geo_length = {\n    sphere: d3_noop,\n    point: d3_noop,\n    lineStart: d3_geo_lengthLineStart,\n    lineEnd: d3_noop,\n    polygonStart: d3_noop,\n    polygonEnd: d3_noop\n  };\n  function d3_geo_lengthLineStart() {\n    var λ0, sinφ0, cosφ0;\n    d3_geo_length.point = function(λ, φ) {\n      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);\n      d3_geo_length.point = nextPoint;\n    };\n    d3_geo_length.lineEnd = function() {\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\n    };\n    function nextPoint(λ, φ) {\n      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);\n      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;\n    }\n  }\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(λ, φ) {\n      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);\n      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];\n    }\n    azimuthal.invert = function(x, y) {\n      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);\n      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];\n    };\n    return azimuthal;\n  }\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {\n    return Math.sqrt(2 / (1 + cosλcosφ));\n  }, function(ρ) {\n    return 2 * Math.asin(ρ / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function() {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {\n    var c = Math.acos(cosλcosφ);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function() {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  function d3_geo_conicConformal(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), t = function(φ) {\n      return Math.tan(π / 4 + φ / 2);\n    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;\n    if (!n) return d3_geo_mercator;\n    function forward(λ, φ) {\n      if (F > 0) {\n        if (φ < -halfπ + ε) φ = -halfπ + ε;\n      } else {\n        if (φ > halfπ - ε) φ = halfπ - ε;\n      }\n      var ρ = F / Math.pow(t(φ), n);\n      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);\n      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];\n    };\n    return forward;\n  }\n  (d3.geo.conicConformal = function() {\n    return d3_geo_conic(d3_geo_conicConformal);\n  }).raw = d3_geo_conicConformal;\n  function d3_geo_conicEquidistant(φ0, φ1) {\n    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;\n    if (abs(n) < ε) return d3_geo_equirectangular;\n    function forward(λ, φ) {\n      var ρ = G - φ;\n      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];\n    }\n    forward.invert = function(x, y) {\n      var ρ0_y = G - y;\n      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];\n    };\n    return forward;\n  }\n  (d3.geo.conicEquidistant = function() {\n    return d3_geo_conic(d3_geo_conicEquidistant);\n  }).raw = d3_geo_conicEquidistant;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / cosλcosφ;\n  }, Math.atan);\n  (d3.geo.gnomonic = function() {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n  function d3_geo_mercator(λ, φ) {\n    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];\n  }\n  d3_geo_mercator.invert = function(x, y) {\n    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];\n  };\n  function d3_geo_mercatorProjection(project) {\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\n    m.scale = function() {\n      var v = scale.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.translate = function() {\n      var v = translate.apply(m, arguments);\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\n    };\n    m.clipExtent = function(_) {\n      var v = clipExtent.apply(m, arguments);\n      if (v === m) {\n        if (clipAuto = _ == null) {\n          var k = π * scale(), t = translate();\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\n        }\n      } else if (clipAuto) {\n        v = null;\n      }\n      return v;\n    };\n    return m.clipExtent(null);\n  }\n  (d3.geo.mercator = function() {\n    return d3_geo_mercatorProjection(d3_geo_mercator);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function() {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {\n    return 1 / (1 + cosλcosφ);\n  }, function(ρ) {\n    return 2 * Math.atan(ρ);\n  });\n  (d3.geo.stereographic = function() {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n  function d3_geo_transverseMercator(λ, φ) {\n    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];\n  }\n  d3_geo_transverseMercator.invert = function(x, y) {\n    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];\n  };\n  (d3.geo.transverseMercator = function() {\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\n    projection.center = function(_) {\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\n    };\n    projection.rotate = function(_) {\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \n      [ _[0], _[1], _[2] - 90 ]);\n    };\n    return rotate([ 0, 0, 90 ]);\n  }).raw = d3_geo_transverseMercator;\n  d3.geom = {};\n  function d3_geom_pointX(d) {\n    return d[0];\n  }\n  function d3_geom_pointY(d) {\n    return d[1];\n  }\n  d3.geom.hull = function(vertices) {\n    var x = d3_geom_pointX, y = d3_geom_pointY;\n    if (arguments.length) return hull(vertices);\n    function hull(data) {\n      if (data.length < 3) return [];\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\n      for (i = 0; i < n; i++) {\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\n      }\n      points.sort(d3_geom_hullOrder);\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\n      return polygon;\n    }\n    hull.x = function(_) {\n      return arguments.length ? (x = _, hull) : x;\n    };\n    hull.y = function(_) {\n      return arguments.length ? (y = _, hull) : y;\n    };\n    return hull;\n  };\n  function d3_geom_hullUpper(points) {\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\n    for (var i = 2; i < n; i++) {\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\n      hull[hs++] = i;\n    }\n    return hull.slice(0, hs);\n  }\n  function d3_geom_hullOrder(a, b) {\n    return a[0] - b[0] || a[1] - b[1];\n  }\n  d3.geom.polygon = function(coordinates) {\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\n    return coordinates;\n  };\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\n  d3_geom_polygonPrototype.area = function() {\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      area += a[1] * b[0] - a[0] * b[1];\n    }\n    return area * .5;\n  };\n  d3_geom_polygonPrototype.centroid = function(k) {\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\n    if (!arguments.length) k = -1 / (6 * this.area());\n    while (++i < n) {\n      a = b;\n      b = this[i];\n      c = a[0] * b[1] - b[0] * a[1];\n      x += (a[0] + b[0]) * c;\n      y += (a[1] + b[1]) * c;\n    }\n    return [ x * k, y * k ];\n  };\n  d3_geom_polygonPrototype.clip = function(subject) {\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\n    while (++i < n) {\n      input = subject.slice();\n      subject.length = 0;\n      b = this[i];\n      c = input[(m = input.length - closed) - 1];\n      j = -1;\n      while (++j < m) {\n        d = input[j];\n        if (d3_geom_polygonInside(d, a, b)) {\n          if (!d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n          subject.push(d);\n        } else if (d3_geom_polygonInside(c, a, b)) {\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\n        }\n        c = d;\n      }\n      if (closed) subject.push(subject[0]);\n      a = b;\n    }\n    return subject;\n  };\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [ x1 + ua * x21, y1 + ua * y21 ];\n  }\n  function d3_geom_polygonClosed(coordinates) {\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\n    return !(a[0] - b[0] || a[1] - b[1]);\n  }\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\n  function d3_geom_voronoiBeach() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.edge = this.site = this.circle = null;\n  }\n  function d3_geom_voronoiCreateBeach(site) {\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\n    beach.site = site;\n    return beach;\n  }\n  function d3_geom_voronoiDetachBeach(beach) {\n    d3_geom_voronoiDetachCircle(beach);\n    d3_geom_voronoiBeaches.remove(beach);\n    d3_geom_voronoiBeachPool.push(beach);\n    d3_geom_voronoiRedBlackNode(beach);\n  }\n  function d3_geom_voronoiRemoveBeach(beach) {\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\n      x: x,\n      y: y\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\n    d3_geom_voronoiDetachBeach(beach);\n    var lArc = previous;\n    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {\n      previous = lArc.P;\n      disappearing.unshift(lArc);\n      d3_geom_voronoiDetachBeach(lArc);\n      lArc = previous;\n    }\n    disappearing.unshift(lArc);\n    d3_geom_voronoiDetachCircle(lArc);\n    var rArc = next;\n    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {\n      next = rArc.N;\n      disappearing.push(rArc);\n      d3_geom_voronoiDetachBeach(rArc);\n      rArc = next;\n    }\n    disappearing.push(rArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var nArcs = disappearing.length, iArc;\n    for (iArc = 1; iArc < nArcs; ++iArc) {\n      rArc = disappearing[iArc];\n      lArc = disappearing[iArc - 1];\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n    }\n    lArc = disappearing[0];\n    rArc = disappearing[nArcs - 1];\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiAddBeach(site) {\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\n    while (node) {\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\n      if (dxl > ε) node = node.L; else {\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\n        if (dxr > ε) {\n          if (!node.R) {\n            lArc = node;\n            break;\n          }\n          node = node.R;\n        } else {\n          if (dxl > -ε) {\n            lArc = node.P;\n            rArc = node;\n          } else if (dxr > -ε) {\n            lArc = node;\n            rArc = node.N;\n          } else {\n            lArc = rArc = node;\n          }\n          break;\n        }\n      }\n    }\n    var newArc = d3_geom_voronoiCreateBeach(site);\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\n    if (!lArc && !rArc) return;\n    if (lArc === rArc) {\n      d3_geom_voronoiDetachCircle(lArc);\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      d3_geom_voronoiAttachCircle(lArc);\n      d3_geom_voronoiAttachCircle(rArc);\n      return;\n    }\n    if (!rArc) {\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\n      return;\n    }\n    d3_geom_voronoiDetachCircle(lArc);\n    d3_geom_voronoiDetachCircle(rArc);\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\n      x: (cy * hb - by * hc) / d + ax,\n      y: (bx * hc - cx * hb) / d + ay\n    };\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\n    d3_geom_voronoiAttachCircle(lArc);\n    d3_geom_voronoiAttachCircle(rArc);\n  }\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\n    if (!pby2) return rfocx;\n    var lArc = arc.P;\n    if (!lArc) return -Infinity;\n    site = lArc.site;\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\n    if (!plby2) return lfocx;\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n    return (rfocx + lfocx) / 2;\n  }\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\n    var rArc = arc.N;\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\n    var site = arc.site;\n    return site.y === directrix ? site.x : Infinity;\n  }\n  function d3_geom_voronoiCell(site) {\n    this.site = site;\n    this.edges = [];\n  }\n  d3_geom_voronoiCell.prototype.prepare = function() {\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\n    while (iHalfEdge--) {\n      edge = halfEdges[iHalfEdge].edge;\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\n    }\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\n    return halfEdges.length;\n  };\n  function d3_geom_voronoiCloseCells(extent) {\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\n    while (iCell--) {\n      cell = cells[iCell];\n      if (!cell || !cell.prepare()) continue;\n      halfEdges = cell.edges;\n      nHalfEdges = halfEdges.length;\n      iHalfEdge = 0;\n      while (iHalfEdge < nHalfEdges) {\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\n        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {\n            x: x0,\n            y: abs(x2 - x0) < ε ? y2 : y1\n          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {\n            x: abs(y2 - y1) < ε ? x2 : x1,\n            y: y1\n          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {\n            x: x1,\n            y: abs(x2 - x1) < ε ? y2 : y0\n          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {\n            x: abs(y2 - y0) < ε ? x2 : x0,\n            y: y0\n          } : null), cell.site, null));\n          ++nHalfEdges;\n        }\n      }\n    }\n  }\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\n    return b.angle - a.angle;\n  }\n  function d3_geom_voronoiCircle() {\n    d3_geom_voronoiRedBlackNode(this);\n    this.x = this.y = this.arc = this.site = this.cy = null;\n  }\n  function d3_geom_voronoiAttachCircle(arc) {\n    var lArc = arc.P, rArc = arc.N;\n    if (!lArc || !rArc) return;\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n    if (lSite === rSite) return;\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\n    var d = 2 * (ax * cy - ay * cx);\n    if (d >= -ε2) return;\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\n    circle.arc = arc;\n    circle.site = cSite;\n    circle.x = x + bx;\n    circle.y = cy + Math.sqrt(x * x + y * y);\n    circle.cy = cy;\n    arc.circle = circle;\n    var before = null, node = d3_geom_voronoiCircles._;\n    while (node) {\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\n        if (node.L) node = node.L; else {\n          before = node.P;\n          break;\n        }\n      } else {\n        if (node.R) node = node.R; else {\n          before = node;\n          break;\n        }\n      }\n    }\n    d3_geom_voronoiCircles.insert(before, circle);\n    if (!before) d3_geom_voronoiFirstCircle = circle;\n  }\n  function d3_geom_voronoiDetachCircle(arc) {\n    var circle = arc.circle;\n    if (circle) {\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\n      d3_geom_voronoiCircles.remove(circle);\n      d3_geom_voronoiCirclePool.push(circle);\n      d3_geom_voronoiRedBlackNode(circle);\n      arc.circle = null;\n    }\n  }\n  function d3_geom_voronoiClipEdges(extent) {\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\n    while (i--) {\n      e = edges[i];\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {\n        e.a = e.b = null;\n        edges.splice(i, 1);\n      }\n    }\n  }\n  function d3_geom_voronoiConnectEdge(edge, extent) {\n    var vb = edge.b;\n    if (vb) return true;\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n    if (ry === ly) {\n      if (fx < x0 || fx >= x1) return;\n      if (lx > rx) {\n        if (!va) va = {\n          x: fx,\n          y: y0\n        }; else if (va.y >= y1) return;\n        vb = {\n          x: fx,\n          y: y1\n        };\n      } else {\n        if (!va) va = {\n          x: fx,\n          y: y1\n        }; else if (va.y < y0) return;\n        vb = {\n          x: fx,\n          y: y0\n        };\n      }\n    } else {\n      fm = (lx - rx) / (ry - ly);\n      fb = fy - fm * fx;\n      if (fm < -1 || fm > 1) {\n        if (lx > rx) {\n          if (!va) va = {\n            x: (y0 - fb) / fm,\n            y: y0\n          }; else if (va.y >= y1) return;\n          vb = {\n            x: (y1 - fb) / fm,\n            y: y1\n          };\n        } else {\n          if (!va) va = {\n            x: (y1 - fb) / fm,\n            y: y1\n          }; else if (va.y < y0) return;\n          vb = {\n            x: (y0 - fb) / fm,\n            y: y0\n          };\n        }\n      } else {\n        if (ly < ry) {\n          if (!va) va = {\n            x: x0,\n            y: fm * x0 + fb\n          }; else if (va.x >= x1) return;\n          vb = {\n            x: x1,\n            y: fm * x1 + fb\n          };\n        } else {\n          if (!va) va = {\n            x: x1,\n            y: fm * x1 + fb\n          }; else if (va.x < x0) return;\n          vb = {\n            x: x0,\n            y: fm * x0 + fb\n          };\n        }\n      }\n    }\n    edge.a = va;\n    edge.b = vb;\n    return true;\n  }\n  function d3_geom_voronoiEdge(lSite, rSite) {\n    this.l = lSite;\n    this.r = rSite;\n    this.a = this.b = null;\n  }\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\n    d3_geom_voronoiEdges.push(edge);\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\n    return edge;\n  }\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\n    var edge = new d3_geom_voronoiEdge(lSite, null);\n    edge.a = va;\n    edge.b = vb;\n    d3_geom_voronoiEdges.push(edge);\n    return edge;\n  }\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\n    if (!edge.a && !edge.b) {\n      edge.a = vertex;\n      edge.l = lSite;\n      edge.r = rSite;\n    } else if (edge.l === rSite) {\n      edge.b = vertex;\n    } else {\n      edge.a = vertex;\n    }\n  }\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\n    var va = edge.a, vb = edge.b;\n    this.edge = edge;\n    this.site = lSite;\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\n  }\n  d3_geom_voronoiHalfEdge.prototype = {\n    start: function() {\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\n    },\n    end: function() {\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\n    }\n  };\n  function d3_geom_voronoiRedBlackTree() {\n    this._ = null;\n  }\n  function d3_geom_voronoiRedBlackNode(node) {\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\n  }\n  d3_geom_voronoiRedBlackTree.prototype = {\n    insert: function(after, node) {\n      var parent, grandpa, uncle;\n      if (after) {\n        node.P = after;\n        node.N = after.N;\n        if (after.N) after.N.P = node;\n        after.N = node;\n        if (after.R) {\n          after = after.R;\n          while (after.L) after = after.L;\n          after.L = node;\n        } else {\n          after.R = node;\n        }\n        parent = after;\n      } else if (this._) {\n        after = d3_geom_voronoiRedBlackFirst(this._);\n        node.P = null;\n        node.N = after;\n        after.P = after.L = node;\n        parent = after;\n      } else {\n        node.P = node.N = null;\n        this._ = node;\n        parent = null;\n      }\n      node.L = node.R = null;\n      node.U = parent;\n      node.C = true;\n      after = node;\n      while (parent && parent.C) {\n        grandpa = parent.U;\n        if (parent === grandpa.L) {\n          uncle = grandpa.R;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.R) {\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\n          }\n        } else {\n          uncle = grandpa.L;\n          if (uncle && uncle.C) {\n            parent.C = uncle.C = false;\n            grandpa.C = true;\n            after = grandpa;\n          } else {\n            if (after === parent.L) {\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\n              after = parent;\n              parent = after.U;\n            }\n            parent.C = false;\n            grandpa.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\n          }\n        }\n        parent = after.U;\n      }\n      this._.C = false;\n    },\n    remove: function(node) {\n      if (node.N) node.N.P = node.P;\n      if (node.P) node.P.N = node.N;\n      node.N = node.P = null;\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\n      if (parent) {\n        if (parent.L === node) parent.L = next; else parent.R = next;\n      } else {\n        this._ = next;\n      }\n      if (left && right) {\n        red = next.C;\n        next.C = node.C;\n        next.L = left;\n        left.U = next;\n        if (next !== right) {\n          parent = next.U;\n          next.U = node.U;\n          node = next.R;\n          parent.L = node;\n          next.R = right;\n          right.U = next;\n        } else {\n          next.U = parent;\n          parent = next;\n          node = next.R;\n        }\n      } else {\n        red = node.C;\n        node = next;\n      }\n      if (node) node.U = parent;\n      if (red) return;\n      if (node && node.C) {\n        node.C = false;\n        return;\n      }\n      do {\n        if (node === this._) break;\n        if (node === parent.L) {\n          sibling = parent.R;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            sibling = parent.R;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.R || !sibling.R.C) {\n              sibling.L.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\n              sibling = parent.R;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.R.C = false;\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\n            node = this._;\n            break;\n          }\n        } else {\n          sibling = parent.L;\n          if (sibling.C) {\n            sibling.C = false;\n            parent.C = true;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            sibling = parent.L;\n          }\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\n            if (!sibling.L || !sibling.L.C) {\n              sibling.R.C = false;\n              sibling.C = true;\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\n              sibling = parent.L;\n            }\n            sibling.C = parent.C;\n            parent.C = sibling.L.C = false;\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\n            node = this._;\n            break;\n          }\n        }\n        sibling.C = true;\n        node = parent;\n        parent = parent.U;\n      } while (!node.C);\n      if (node) node.C = false;\n    }\n  };\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\n    var p = node, q = node.R, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.R = q.L;\n    if (p.R) p.R.U = p;\n    q.L = p;\n  }\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\n    var p = node, q = node.L, parent = p.U;\n    if (parent) {\n      if (parent.L === p) parent.L = q; else parent.R = q;\n    } else {\n      tree._ = q;\n    }\n    q.U = parent;\n    p.U = q;\n    p.L = q.R;\n    if (p.L) p.L.U = p;\n    q.R = p;\n  }\n  function d3_geom_voronoiRedBlackFirst(node) {\n    while (node.L) node = node.L;\n    return node;\n  }\n  function d3_geom_voronoi(sites, bbox) {\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\n    d3_geom_voronoiEdges = [];\n    d3_geom_voronoiCells = new Array(sites.length);\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\n    while (true) {\n      circle = d3_geom_voronoiFirstCircle;\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\n        if (site.x !== x0 || site.y !== y0) {\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\n          d3_geom_voronoiAddBeach(site);\n          x0 = site.x, y0 = site.y;\n        }\n        site = sites.pop();\n      } else if (circle) {\n        d3_geom_voronoiRemoveBeach(circle.arc);\n      } else {\n        break;\n      }\n    }\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\n    var diagram = {\n      cells: d3_geom_voronoiCells,\n      edges: d3_geom_voronoiEdges\n    };\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\n    return diagram;\n  }\n  function d3_geom_voronoiVertexOrder(a, b) {\n    return b.y - a.y || b.x - a.x;\n  }\n  d3.geom.voronoi = function(points) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\n    if (points) return voronoi(points);\n    function voronoi(data) {\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\n          var s = e.start();\n          return [ s.x, s.y ];\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\n        polygon.point = data[i];\n      });\n      return polygons;\n    }\n    function sites(data) {\n      return data.map(function(d, i) {\n        return {\n          x: Math.round(fx(d, i) / ε) * ε,\n          y: Math.round(fy(d, i) / ε) * ε,\n          i: i\n        };\n      });\n    }\n    voronoi.links = function(data) {\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\n        return edge.l && edge.r;\n      }).map(function(edge) {\n        return {\n          source: data[edge.l.i],\n          target: data[edge.r.i]\n        };\n      });\n    };\n    voronoi.triangles = function(data) {\n      var triangles = [];\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\n        while (++j < m) {\n          e0 = e1;\n          s0 = s1;\n          e1 = edges[j].edge;\n          s1 = e1.l === site ? e1.r : e1.l;\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\n          }\n        }\n      });\n      return triangles;\n    };\n    voronoi.x = function(_) {\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\n    };\n    voronoi.y = function(_) {\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\n    };\n    voronoi.clipExtent = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\n      return voronoi;\n    };\n    voronoi.size = function(_) {\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\n    };\n    return voronoi;\n  };\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\n  function d3_geom_voronoiTriangleArea(a, b, c) {\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\n  }\n  d3.geom.delaunay = function(vertices) {\n    return d3.geom.voronoi().triangles(vertices);\n  };\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\n    if (compat = arguments.length) {\n      x = d3_geom_quadtreeCompatX;\n      y = d3_geom_quadtreeCompatY;\n      if (compat === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      }\n      return quadtree(points);\n    }\n    function quadtree(data) {\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\n      if (x1 != null) {\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\n      } else {\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\n        xs = [], ys = [];\n        n = data.length;\n        if (compat) for (i = 0; i < n; ++i) {\n          d = data[i];\n          if (d.x < x1_) x1_ = d.x;\n          if (d.y < y1_) y1_ = d.y;\n          if (d.x > x2_) x2_ = d.x;\n          if (d.y > y2_) y2_ = d.y;\n          xs.push(d.x);\n          ys.push(d.y);\n        } else for (i = 0; i < n; ++i) {\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\n          if (x_ < x1_) x1_ = x_;\n          if (y_ < y1_) y1_ = y_;\n          if (x_ > x2_) x2_ = x_;\n          if (y_ > y2_) y2_ = y_;\n          xs.push(x_);\n          ys.push(y_);\n        }\n      }\n      var dx = x2_ - x1_, dy = y2_ - y1_;\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\n      function insert(n, d, x, y, x1, y1, x2, y2) {\n        if (isNaN(x) || isNaN(y)) return;\n        if (n.leaf) {\n          var nx = n.x, ny = n.y;\n          if (nx != null) {\n            if (abs(nx - x) + abs(ny - y) < .01) {\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            } else {\n              var nPoint = n.point;\n              n.x = n.y = n.point = null;\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\n              insertChild(n, d, x, y, x1, y1, x2, y2);\n            }\n          } else {\n            n.x = x, n.y = y, n.point = d;\n          }\n        } else {\n          insertChild(n, d, x, y, x1, y1, x2, y2);\n        }\n      }\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\n        n.leaf = false;\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n        if (right) x1 = xm; else x2 = xm;\n        if (below) y1 = ym; else y2 = ym;\n        insert(n, d, x, y, x1, y1, x2, y2);\n      }\n      var root = d3_geom_quadtreeNode();\n      root.add = function(d) {\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\n      };\n      root.visit = function(f) {\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\n      };\n      root.find = function(point) {\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\n      };\n      i = -1;\n      if (x1 == null) {\n        while (++i < n) {\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\n        }\n        --i;\n      } else data.forEach(root.add);\n      xs = ys = data = d = null;\n      return root;\n    }\n    quadtree.x = function(_) {\n      return arguments.length ? (x = _, quadtree) : x;\n    };\n    quadtree.y = function(_) {\n      return arguments.length ? (y = _, quadtree) : y;\n    };\n    quadtree.extent = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \n      y2 = +_[1][1];\n      return quadtree;\n    };\n    quadtree.size = function(_) {\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\n      return quadtree;\n    };\n    return quadtree;\n  };\n  function d3_geom_quadtreeCompatX(d) {\n    return d.x;\n  }\n  function d3_geom_quadtreeCompatY(d) {\n    return d.y;\n  }\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null,\n      x: null,\n      y: null\n    };\n  }\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\n    var minDistance2 = Infinity, closestPoint;\n    (function find(node, x1, y1, x2, y2) {\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\n      if (point = node.point) {\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\n        if (distance2 < minDistance2) {\n          var distance = Math.sqrt(minDistance2 = distance2);\n          x0 = x - distance, y0 = y - distance;\n          x3 = x + distance, y3 = y + distance;\n          closestPoint = point;\n        }\n      }\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\n        if (node = children[i & 3]) switch (i & 3) {\n         case 0:\n          find(node, x1, y1, xm, ym);\n          break;\n\n         case 1:\n          find(node, xm, y1, x2, ym);\n          break;\n\n         case 2:\n          find(node, x1, ym, xm, y2);\n          break;\n\n         case 3:\n          find(node, xm, ym, x2, y2);\n          break;\n        }\n      }\n    })(root, x0, y0, x3, y3);\n    return closestPoint;\n  }\n  d3.interpolateRgb = d3_interpolateRgb;\n  function d3_interpolateRgb(a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\n    return function(t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  }\n  d3.interpolateObject = d3_interpolateObject;\n  function d3_interpolateObject(a, b) {\n    var i = {}, c = {}, k;\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolate(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n    return function(t) {\n      for (k in i) c[k] = i[k](t);\n      return c;\n    };\n  }\n  d3.interpolateNumber = d3_interpolateNumber;\n  function d3_interpolateNumber(a, b) {\n    a = +a, b = +b;\n    return function(t) {\n      return a * (1 - t) + b * t;\n    };\n  }\n  d3.interpolateString = d3_interpolateString;\n  function d3_interpolateString(a, b) {\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\n    a = a + \"\", b = b + \"\";\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\n      if ((bs = bm.index) > bi) {\n        bs = b.slice(bi, bs);\n        if (s[i]) s[i] += bs; else s[++i] = bs;\n      }\n      if ((am = am[0]) === (bm = bm[0])) {\n        if (s[i]) s[i] += bm; else s[++i] = bm;\n      } else {\n        s[++i] = null;\n        q.push({\n          i: i,\n          x: d3_interpolateNumber(am, bm)\n        });\n      }\n      bi = d3_interpolate_numberB.lastIndex;\n    }\n    if (bi < b.length) {\n      bs = b.slice(bi);\n      if (s[i]) s[i] += bs; else s[++i] = bs;\n    }\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\n      return b(t) + \"\";\n    }) : function() {\n      return b;\n    } : (b = q.length, function(t) {\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    });\n  }\n  var d3_interpolate_numberA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \"g\");\n  d3.interpolate = d3_interpolate;\n  function d3_interpolate(a, b) {\n    var i = d3.interpolators.length, f;\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\n    return f;\n  }\n  d3.interpolators = [ function(a, b) {\n    var t = typeof b;\n    return (t === \"string\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\(|hsl\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \"object\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\n  } ];\n  d3.interpolateArray = d3_interpolateArray;\n  function d3_interpolateArray(a, b) {\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\n    for (;i < na; ++i) c[i] = a[i];\n    for (;i < nb; ++i) c[i] = b[i];\n    return function(t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n      return c;\n    };\n  }\n  var d3_ease_default = function() {\n    return d3_identity;\n  };\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function() {\n      return d3_ease_quad;\n    },\n    cubic: function() {\n      return d3_ease_cubic;\n    },\n    sin: function() {\n      return d3_ease_sin;\n    },\n    exp: function() {\n      return d3_ease_exp;\n    },\n    circle: function() {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function() {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    out: d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function(f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n  d3.ease = function(name) {\n    var i = name.indexOf(\"-\"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\n  };\n  function d3_ease_clamp(f) {\n    return function(t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n  function d3_ease_reverse(f) {\n    return function(t) {\n      return 1 - f(1 - t);\n    };\n  }\n  function d3_ease_reflect(f) {\n    return function(t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t, t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n  function d3_ease_poly(e) {\n    return function(t) {\n      return Math.pow(t, e);\n    };\n  }\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * halfπ);\n  }\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;\n    return function(t) {\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\n    };\n  }\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function(t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n  d3.interpolateHcl = d3_interpolateHcl;\n  function d3_interpolateHcl(a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateHsl = d3_interpolateHsl;\n  function d3_interpolateHsl(a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\n    return function(t) {\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \"\";\n    };\n  }\n  d3.interpolateLab = d3_interpolateLab;\n  function d3_interpolateLab(a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\n    return function(t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n    };\n  }\n  d3.interpolateRound = d3_interpolateRound;\n  function d3_interpolateRound(a, b) {\n    b -= a;\n    return function(t) {\n      return Math.round(a + b * t);\n    };\n  }\n  d3.transform = function(string) {\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function(string) {\n      if (string != null) {\n        g.setAttribute(\"transform\", string);\n        var t = g.transform.baseVal.consolidate();\n      }\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n  function d3_transform(m) {\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [ m.e, m.f ];\n    this.scale = [ kx, ky ];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n  d3_transform.prototype.toString = function() {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n    return k;\n  }\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n  d3.interpolateTransform = d3_interpolateTransform;\n  function d3_interpolateTransformPop(s) {\n    return s.length ? s.pop() + \",\" : \"\";\n  }\n  function d3_interpolateTranslate(ta, tb, s, q) {\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\n      var i = s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ta[0], tb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    }\n  }\n  function d3_interpolateRotate(ra, rb, s, q) {\n    if (ra !== rb) {\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"rotate(\", null, \")\") - 2,\n        x: d3_interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(d3_interpolateTransformPop(s) + \"rotate(\" + rb + \")\");\n    }\n  }\n  function d3_interpolateSkew(wa, wb, s, q) {\n    if (wa !== wb) {\n      q.push({\n        i: s.push(d3_interpolateTransformPop(s) + \"skewX(\", null, \")\") - 2,\n        x: d3_interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(d3_interpolateTransformPop(s) + \"skewX(\" + wb + \")\");\n    }\n  }\n  function d3_interpolateScale(ka, kb, s, q) {\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\n      var i = s.push(d3_interpolateTransformPop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: i - 4,\n        x: d3_interpolateNumber(ka[0], kb[0])\n      }, {\n        i: i - 2,\n        x: d3_interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\n      s.push(d3_interpolateTransformPop(s) + \"scale(\" + kb + \")\");\n    }\n  }\n  function d3_interpolateTransform(a, b) {\n    var s = [], q = [];\n    a = d3.transform(a), b = d3.transform(b);\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\n    d3_interpolateSkew(a.skew, b.skew, s, q);\n    d3_interpolateScale(a.scale, b.scale, s, q);\n    a = b = null;\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  }\n  function d3_uninterpolateNumber(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return (x - a) / b;\n    };\n  }\n  function d3_uninterpolateClamp(a, b) {\n    b = (b -= a = +a) || 1 / b;\n    return function(x) {\n      return Math.max(0, Math.min(1, (x - a) / b));\n    };\n  }\n  d3.layout = {};\n  d3.layout.bundle = function() {\n    return function(links) {\n      var paths = [], i = -1, n = links.length;\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n      return paths;\n    };\n  };\n  function d3_layout_bundlePath(link) {\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n    var k = points.length;\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n    return points;\n  }\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [], parent = node.parent;\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n    ancestors.push(node);\n    return ancestors;\n  }\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n    return sharedNode;\n  }\n  d3.layout.chord = function() {\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\n    function relayout() {\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n      while (++i < n) {\n        x = 0, j = -1;\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n      if (sortGroups) {\n        groupIndex.sort(function(a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function(d, i) {\n          d.sort(function(a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n      k = (τ - padding * n) / k;\n      x = 0, i = -1;\n      while (++i < n) {\n        x0 = x, j = -1;\n        while (++j < n) {\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\n          subgroups[di + \"-\" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: groupSums[di]\n        };\n        x += padding;\n      }\n      i = -1;\n      while (++i < n) {\n        j = i - 1;\n        while (++j < n) {\n          var source = subgroups[i + \"-\" + j], target = subgroups[j + \"-\" + i];\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n      if (sortChords) resort();\n    }\n    function resort() {\n      chords.sort(function(a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n    chord.matrix = function(x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n    chord.padding = function(x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortGroups = function(x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n    chord.sortSubgroups = function(x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n    chord.sortChords = function(x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n    chord.chords = function() {\n      if (!chords) relayout();\n      return chords;\n    };\n    chord.groups = function() {\n      if (!groups) relayout();\n      return groups;\n    };\n    return chord;\n  };\n  d3.layout.force = function() {\n    var force = {}, event = d3.dispatch(\"start\", \"tick\", \"end\"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\n    function repulse(node) {\n      return function(quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\n          if (dw * dw / theta2 < dn) {\n            if (dn < chargeDistance2) {\n              var k = quad.charge / dn;\n              node.px -= dx * k;\n              node.py -= dy * k;\n            }\n            return true;\n          }\n          if (quad.point && dn && dn < chargeDistance2) {\n            var k = quad.pointCharge / dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n        return !quad.charge;\n      };\n    }\n    force.tick = function() {\n      if ((alpha *= .99) < .005) {\n        timer = null;\n        event.end({\n          type: \"end\",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n      i = -1;\n      while (++i < n) {\n        o = nodes[i];\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n      event.tick({\n        type: \"tick\",\n        alpha: alpha\n      });\n    };\n    force.nodes = function(x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n    force.links = function(x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n    force.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n    force.linkDistance = function(x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.distance = force.linkDistance;\n    force.linkStrength = function(x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.friction = function(x) {\n      if (!arguments.length) return friction;\n      friction = +x;\n      return force;\n    };\n    force.charge = function(x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n    force.chargeDistance = function(x) {\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\n      chargeDistance2 = x * x;\n      return force;\n    };\n    force.gravity = function(x) {\n      if (!arguments.length) return gravity;\n      gravity = +x;\n      return force;\n    };\n    force.theta = function(x) {\n      if (!arguments.length) return Math.sqrt(theta2);\n      theta2 = x * x;\n      return force;\n    };\n    force.alpha = function(x) {\n      if (!arguments.length) return alpha;\n      x = +x;\n      if (alpha) {\n        if (x > 0) {\n          alpha = x;\n        } else {\n          timer.c = null, timer.t = NaN, timer = null;\n          event.end({\n            type: \"end\",\n            alpha: alpha = 0\n          });\n        }\n      } else if (x > 0) {\n        event.start({\n          type: \"start\",\n          alpha: alpha = x\n        });\n        timer = d3_timer(force.tick);\n      }\n      return force;\n    };\n    force.start = function() {\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position(\"x\", w);\n        if (isNaN(o.y)) o.y = position(\"y\", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n      distances = [];\n      if (typeof linkDistance === \"function\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\n      strengths = [];\n      if (typeof linkStrength === \"function\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\n      charges = [];\n      if (typeof charge === \"function\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\n      function position(dimension, size) {\n        if (!neighbors) {\n          neighbors = new Array(n);\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\n        return Math.random() * size;\n      }\n      return force.resume();\n    };\n    force.resume = function() {\n      return force.alpha(.1);\n    };\n    force.stop = function() {\n      return force.alpha(0);\n    };\n    force.drag = function() {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart.force\", d3_layout_forceDragstart).on(\"drag.force\", dragmove).on(\"dragend.force\", d3_layout_forceDragend);\n      if (!arguments.length) return drag;\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n    };\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n    return d3.rebind(force, event, \"on\");\n  };\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n  function d3_layout_forceDragend(d) {\n    d.fixed &= ~6;\n  }\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= ~4;\n  }\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0, cy = 0;\n    quad.charge = 0;\n    if (!quad.leaf) {\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\n  d3.layout.hierarchy = function() {\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n    function hierarchy(root) {\n      var stack = [ root ], nodes = [], node;\n      root.depth = 0;\n      while ((node = stack.pop()) != null) {\n        nodes.push(node);\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n          var n, childs, child;\n          while (--n >= 0) {\n            stack.push(child = childs[n]);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n          if (value) node.value = 0;\n          node.children = childs;\n        } else {\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          delete node.children;\n        }\n      }\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var childs, parent;\n        if (sort && (childs = node.children)) childs.sort(sort);\n        if (value && (parent = node.parent)) parent.value += node.value;\n      });\n      return nodes;\n    }\n    hierarchy.sort = function(x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n    hierarchy.children = function(x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n    hierarchy.value = function(x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n    hierarchy.revalue = function(root) {\n      if (value) {\n        d3_layout_hierarchyVisitBefore(root, function(node) {\n          if (node.children) node.value = 0;\n        });\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var parent;\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n          if (parent = node.parent) parent.value += node.value;\n        });\n      }\n      return root;\n    };\n    return hierarchy;\n  };\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n  function d3_layout_hierarchyVisitBefore(node, callback) {\n    var nodes = [ node ];\n    while ((node = nodes.pop()) != null) {\n      callback(node);\n      if ((children = node.children) && (n = children.length)) {\n        var n, children;\n        while (--n >= 0) nodes.push(children[n]);\n      }\n    }\n  }\n  function d3_layout_hierarchyVisitAfter(node, callback) {\n    var nodes = [ node ], nodes2 = [];\n    while ((node = nodes.pop()) != null) {\n      nodes2.push(node);\n      if ((children = node.children) && (n = children.length)) {\n        var i = -1, n, children;\n        while (++i < n) nodes.push(children[i]);\n      }\n    }\n    while ((node = nodes2.pop()) != null) {\n      callback(node);\n    }\n  }\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function(parent) {\n      return (parent.children || []).map(function(child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n  d3.layout.partition = function() {\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n  d3.layout.pie = function() {\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;\n    function pie(data) {\n      var n = data.length, values = data.map(function(d, i) {\n        return +value.call(pie, d, i);\n      }), a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === \"function\" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\n        return values[j] - values[i];\n      } : function(i, j) {\n        return sort(data[i], data[j]);\n      });\n      index.forEach(function(i) {\n        arcs[i] = {\n          data: data[i],\n          value: v = values[i],\n          startAngle: a,\n          endAngle: a += v * k + pa,\n          padAngle: p\n        };\n      });\n      return arcs;\n    }\n    pie.value = function(_) {\n      if (!arguments.length) return value;\n      value = _;\n      return pie;\n    };\n    pie.sort = function(_) {\n      if (!arguments.length) return sort;\n      sort = _;\n      return pie;\n    };\n    pie.startAngle = function(_) {\n      if (!arguments.length) return startAngle;\n      startAngle = _;\n      return pie;\n    };\n    pie.endAngle = function(_) {\n      if (!arguments.length) return endAngle;\n      endAngle = _;\n      return pie;\n    };\n    pie.padAngle = function(_) {\n      if (!arguments.length) return padAngle;\n      padAngle = _;\n      return pie;\n    };\n    return pie;\n  };\n  var d3_layout_pieSortByValue = {};\n  d3.layout.stack = function() {\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\n    function stack(data, index) {\n      if (!(n = data.length)) return data;\n      var series = data.map(function(d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function(d) {\n        return d.map(function(v, i) {\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var m = series[0].length, n, i, j, o;\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n      return data;\n    }\n    stack.values = function(x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n    stack.order = function(x) {\n      if (!arguments.length) return order;\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n    stack.offset = function(x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n    stack.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n    stack.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n    stack.out = function(z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n    return stack;\n  };\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n  var d3_layout_stackOrders = d3.map({\n    \"inside-out\": function(data) {\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\n        return max[a] - max[b];\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function(data) {\n      return d3.range(data.length).reverse();\n    },\n    \"default\": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function(data) {\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o > max) max = o;\n        sums.push(o);\n      }\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n      return y0;\n    },\n    wiggle: function(data) {\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\n      y0[0] = o = o0 = 0;\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n          s2 += s3 * data[i][j][1];\n        }\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n      return y0;\n    },\n    expand: function(data) {\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n      for (j = 0; j < m; ++j) y0[j] = 0;\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1, m = data[0].length, y0 = [];\n    while (++j < m) y0[j] = 0;\n    return y0;\n  }\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\n    for (;i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n    return j;\n  }\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n  d3.layout.histogram = function() {\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\n    function histogram(data, i) {\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n      if (m > 0) {\n        i = -1;\n        while (++i < n) {\n          x = values[i];\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n      return bins;\n    }\n    histogram.value = function(x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n    histogram.range = function(x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n    histogram.bins = function(x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === \"number\" ? function(range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n    histogram.frequency = function(x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n    return histogram;\n  };\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\n    while (++x <= n) f[x] = m * x + b;\n    return f;\n  }\n  function d3_layout_histogramRange(values) {\n    return [ d3.min(values), d3.max(values) ];\n  }\n  d3.layout.pack = function() {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \"function\" ? radius : function() {\n        return radius;\n      };\n      root.x = root.y = 0;\n      d3_layout_hierarchyVisitAfter(root, function(d) {\n        d.r = +r(d.value);\n      });\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n      if (padding) {\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r += dr;\n        });\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_hierarchyVisitAfter(root, function(d) {\n          d.r -= dr;\n        });\n      }\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\n      return nodes;\n    }\n    pack.size = function(_) {\n      if (!arguments.length) return size;\n      size = _;\n      return pack;\n    };\n    pack.radius = function(_) {\n      if (!arguments.length) return radius;\n      radius = _ == null || typeof _ === \"function\" ? _ : +_;\n      return pack;\n    };\n    pack.padding = function(_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\n    return .999 * dr * dr > dx * dx + dy * dy;\n  }\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0, s1 = 1, s2 = 1;\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n    if (children) {\n      var i = -1, n = children.length;\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\n    if (db && (dx || dy)) {\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n  d3.layout.tree = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\n        var left = root0, right = root0, bottom = root0;\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          if (node.x < left.x) left = node;\n          if (node.x > right.x) right = node;\n          if (node.depth > bottom.depth) bottom = node;\n        });\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\n          node.x = (node.x + tx) * kx;\n          node.y = node.depth * ky;\n        });\n      }\n      return nodes;\n    }\n    function wrapTree(root0) {\n      var root1 = {\n        A: null,\n        children: [ root0 ]\n      }, queue = [ root1 ], node1;\n      while ((node1 = queue.pop()) != null) {\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\n          queue.push((children[i] = child = {\n            _: children[i],\n            parent: node1,\n            children: (child = children[i].children) && child.slice() || [],\n            A: null,\n            a: null,\n            z: 0,\n            m: 0,\n            c: 0,\n            s: 0,\n            t: null,\n            i: i\n          }).a = child);\n        }\n      }\n      return root1.children[0];\n    }\n    function firstWalk(v) {\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n      if (children.length) {\n        d3_layout_treeShift(v);\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n        if (w) {\n          v.z = w.z + separation(v._, w._);\n          v.m = v.z - midpoint;\n        } else {\n          v.z = midpoint;\n        }\n      } else if (w) {\n        v.z = w.z + separation(v._, w._);\n      }\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n    }\n    function secondWalk(v) {\n      v._.x = v.z + v.parent.m;\n      v.m += v.parent.m;\n    }\n    function apportion(v, w, ancestor) {\n      if (w) {\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n          vom = d3_layout_treeLeft(vom);\n          vop = d3_layout_treeRight(vop);\n          vop.a = v;\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n          if (shift > 0) {\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\n            sip += shift;\n            sop += shift;\n          }\n          sim += vim.m;\n          sip += vip.m;\n          som += vom.m;\n          sop += vop.m;\n        }\n        if (vim && !d3_layout_treeRight(vop)) {\n          vop.t = vim;\n          vop.m += sim - sop;\n        }\n        if (vip && !d3_layout_treeLeft(vom)) {\n          vom.t = vip;\n          vom.m += sip - som;\n          ancestor = v;\n        }\n      }\n      return ancestor;\n    }\n    function sizeNode(node) {\n      node.x *= size[0];\n      node.y = node.depth * size[1];\n    }\n    tree.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n    tree.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null ? sizeNode : null;\n      return tree;\n    };\n    tree.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) == null ? null : sizeNode;\n      return tree;\n    };\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n  function d3_layout_treeLeft(v) {\n    var children = v.children;\n    return children.length ? children[0] : v.t;\n  }\n  function d3_layout_treeRight(v) {\n    var children = v.children, n;\n    return (n = children.length) ? children[n - 1] : v.t;\n  }\n  function d3_layout_treeMove(wm, wp, shift) {\n    var change = shift / (wp.i - wm.i);\n    wp.c -= change;\n    wp.s += shift;\n    wm.c += change;\n    wp.z += shift;\n    wp.m += shift;\n  }\n  function d3_layout_treeShift(v) {\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\n    while (--i >= 0) {\n      w = children[i];\n      w.z += shift;\n      w.m += shift;\n      shift += w.s + (change += w.c);\n    }\n  }\n  function d3_layout_treeAncestor(vim, v, ancestor) {\n    return vim.a.parent === v.parent ? vim.a : ancestor;\n  }\n  d3.layout.cluster = function() {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\n      d3_layout_hierarchyVisitAfter(root, function(node) {\n        var children = node.children;\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\n        node.x = (node.x - root.x) * size[0];\n        node.y = (root.y - node.y) * size[1];\n      } : function(node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n    cluster.separation = function(x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n    cluster.size = function(x) {\n      if (!arguments.length) return nodeSize ? null : size;\n      nodeSize = (size = x) == null;\n      return cluster;\n    };\n    cluster.nodeSize = function(x) {\n      if (!arguments.length) return nodeSize ? size : null;\n      nodeSize = (size = x) != null;\n      return cluster;\n    };\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function(child) {\n      return child.y;\n    });\n  }\n  function d3_layout_clusterX(children) {\n    return children.reduce(function(x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n  function d3_layout_clusterRight(node) {\n    var children = node.children, n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n  d3.layout.treemap = function() {\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \"squarify\", ratio = .5 * (1 + Math.sqrt(5));\n    function scale(children, k) {\n      var i = -1, n = children.length, child, area;\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n    function squarify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \"slice\" ? rect.dx : mode === \"dice\" ? rect.dy : mode === \"slice-dice\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n        children.forEach(squarify);\n      }\n    }\n    function stickify(node) {\n      var children = node.children;\n      if (children && children.length) {\n        var rect = pad(node), remaining = children.slice(), child, row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n        children.forEach(stickify);\n      }\n    }\n    function worst(row, u) {\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n    function position(row, u, rect, flush) {\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d), root = nodes[0];\n      root.x = root.y = 0;\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\n      if (stickies) hierarchy.revalue(root);\n      scale([ root ], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n    treemap.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n    treemap.padding = function(x) {\n      if (!arguments.length) return padding;\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [ p, p, p, p ] : p);\n      }\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [ x, x, x, x ], \n      padConstant) : padConstant;\n      return treemap;\n    };\n    treemap.round = function(x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n    treemap.sticky = function(x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n    treemap.ratio = function(x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n    treemap.mode = function(x) {\n      if (!arguments.length) return mode;\n      mode = x + \"\";\n      return treemap;\n    };\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n  d3.random = {\n    normal: function(µ, σ) {\n      var n = arguments.length;\n      if (n < 2) σ = 1;\n      if (n < 1) µ = 0;\n      return function() {\n        var x, y, r;\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function() {\n      var random = d3.random.normal.apply(d3, arguments);\n      return function() {\n        return Math.exp(random());\n      };\n    },\n    bates: function(m) {\n      var random = d3.random.irwinHall(m);\n      return function() {\n        return random() / m;\n      };\n    },\n    irwinHall: function(m) {\n      return function() {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n        return s;\n      };\n    }\n  };\n  d3.scale = {};\n  function d3_scaleExtent(domain) {\n    var start = domain[0], stop = domain[domain.length - 1];\n    return start < stop ? [ start, stop ] : [ stop, start ];\n  }\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\n    return function(x) {\n      return i(u(x));\n    };\n  }\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n    domain[i0] = nice.floor(x0);\n    domain[i1] = nice.ceil(x1);\n    return domain;\n  }\n  function d3_scale_niceStep(step) {\n    return step ? {\n      floor: function(x) {\n        return Math.floor(x / step) * step;\n      },\n      ceil: function(x) {\n        return Math.ceil(x / step) * step;\n      }\n    } : d3_scale_niceIdentity;\n  }\n  var d3_scale_niceIdentity = {\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n    return function(x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n  d3.scale.linear = function() {\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\n  };\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3_interpolate);\n      return scale;\n    }\n    function scale(x) {\n      return output(x);\n    }\n    scale.invert = function(y) {\n      return input(y);\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.rangeRound = function(x) {\n      return scale.range(x).interpolate(d3_interpolateRound);\n    };\n    scale.clamp = function(x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n    scale.interpolate = function(x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      d3_scale_linearNice(domain, m);\n      return rescale();\n    };\n    scale.copy = function() {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n    return rescale();\n  }\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n  function d3_scale_linearNice(domain, m) {\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\n    return domain;\n  }\n  function d3_scale_linearTickRange(domain, m) {\n    if (m == null) m = 10;\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n  function d3_scale_linearTickFormat(domain, m, format) {\n    var range = d3_scale_linearTickRange(domain, m);\n    if (format) {\n      var match = d3_format_re.exec(format);\n      match.shift();\n      if (match[8] === \"s\") {\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\n        if (!match[7]) match[7] = \".\" + d3_scale_linearPrecision(prefix.scale(range[2]));\n        match[8] = \"f\";\n        format = d3.format(match.join(\"\"));\n        return function(d) {\n          return format(prefix.scale(d)) + prefix.symbol;\n        };\n      }\n      if (!match[7]) match[7] = \".\" + d3_scale_linearFormatPrecision(match[8], range);\n      format = match.join(\"\");\n    } else {\n      format = \",.\" + d3_scale_linearPrecision(range[2]) + \"f\";\n    }\n    return d3.format(format);\n  }\n  var d3_scale_linearFormatSignificant = {\n    s: 1,\n    g: 1,\n    p: 1,\n    r: 1,\n    e: 1\n  };\n  function d3_scale_linearPrecision(value) {\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\n  }\n  function d3_scale_linearFormatPrecision(type, range) {\n    var p = d3_scale_linearPrecision(range[2]);\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \"e\") : p - (type === \"%\") * 2;\n  }\n  d3.scale.log = function() {\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\n  };\n  function d3_scale_log(linear, base, positive, domain) {\n    function log(x) {\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\n    }\n    function pow(x) {\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\n    }\n    function scale(x) {\n      return linear(log(x));\n    }\n    scale.invert = function(x) {\n      return pow(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      positive = x[0] >= 0;\n      linear.domain((domain = x.map(Number)).map(log));\n      return scale;\n    };\n    scale.base = function(_) {\n      if (!arguments.length) return base;\n      base = +_;\n      linear.domain(domain.map(log));\n      return scale;\n    };\n    scale.nice = function() {\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\n      linear.domain(niced);\n      domain = niced.map(pow);\n      return scale;\n    };\n    scale.ticks = function() {\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\n      if (isFinite(j - i)) {\n        if (positive) {\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\n          ticks.push(pow(i));\n        } else {\n          ticks.push(pow(i));\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\n        }\n        for (i = 0; ticks[i] < u; i++) {}\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n        ticks = ticks.slice(i, j);\n      }\n      return ticks;\n    };\n    scale.tickFormat = function(n, format) {\n      if (!arguments.length) return d3_scale_logFormat;\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== \"function\") format = d3.format(format);\n      var k = Math.max(1, base * n / scale.ticks().length);\n      return function(d) {\n        var i = d / pow(Math.round(log(d)));\n        if (i * base < base - .5) i *= base;\n        return i <= k ? format(d) : \"\";\n      };\n    };\n    scale.copy = function() {\n      return d3_scale_log(linear.copy(), base, positive, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  var d3_scale_logFormat = d3.format(\".0e\"), d3_scale_logNiceNegative = {\n    floor: function(x) {\n      return -Math.ceil(-x);\n    },\n    ceil: function(x) {\n      return -Math.floor(-x);\n    }\n  };\n  d3.scale.pow = function() {\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\n  };\n  function d3_scale_pow(linear, exponent, domain) {\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\n    function scale(x) {\n      return linear(powp(x));\n    }\n    scale.invert = function(x) {\n      return powb(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      linear.domain((domain = x.map(Number)).map(powp));\n      return scale;\n    };\n    scale.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    scale.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    scale.nice = function(m) {\n      return scale.domain(d3_scale_linearNice(domain, m));\n    };\n    scale.exponent = function(x) {\n      if (!arguments.length) return exponent;\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      linear.domain(domain.map(powp));\n      return scale;\n    };\n    scale.copy = function() {\n      return d3_scale_pow(linear.copy(), exponent, domain);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_scale_powPow(e) {\n    return function(x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n  d3.scale.sqrt = function() {\n    return d3.scale.pow().exponent(.5);\n  };\n  d3.scale.ordinal = function() {\n    return d3_scale_ordinal([], {\n      t: \"range\",\n      a: [ [] ]\n    });\n  };\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n    function scale(x) {\n      return range[((index.get(x) || (ranger.t === \"range\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\n    }\n    function steps(start, step) {\n      return d3.range(domain.length).map(function(i) {\n        return start + step * i;\n      });\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1, n = x.length, xi;\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: \"range\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangePoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \n      0) : (stop - start) / (domain.length - 1 + padding);\n      range = steps(start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangePoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundPoints = function(x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangeRoundPoints\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: \"rangeBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: \"rangeRoundBands\",\n        a: arguments\n      };\n      return scale;\n    };\n    scale.rangeBand = function() {\n      return rangeBand;\n    };\n    scale.rangeExtent = function() {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n    scale.copy = function() {\n      return d3_scale_ordinal(domain, ranger);\n    };\n    return scale.domain(domain);\n  }\n  d3.scale.category10 = function() {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n  d3.scale.category20 = function() {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n  d3.scale.category20b = function() {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n  d3.scale.category20c = function() {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\n  d3.scale.quantile = function() {\n    return d3_scale_quantile([], []);\n  };\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n    function rescale() {\n      var k = 0, q = range.length;\n      thresholds = [];\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n      return scale;\n    }\n    function scale(x) {\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.quantiles = function() {\n      return thresholds;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantile(domain, range);\n    };\n    return rescale();\n  }\n  d3.scale.quantize = function() {\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\n  };\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n    scale.domain = function(x) {\n      if (!arguments.length) return [ x0, x1 ];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n    scale.range = function(x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      y = y < 0 ? NaN : y / kx + x0;\n      return [ y, y + 1 / kx ];\n    };\n    scale.copy = function() {\n      return d3_scale_quantize(x0, x1, range);\n    };\n    return rescale();\n  }\n  d3.scale.threshold = function() {\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\n  };\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      if (x <= x) return range[d3.bisect(domain, x)];\n    }\n    scale.domain = function(_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n    scale.range = function(_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n    scale.invertExtent = function(y) {\n      y = range.indexOf(y);\n      return [ domain[y - 1], domain[y] ];\n    };\n    scale.copy = function() {\n      return d3_scale_threshold(domain, range);\n    };\n    return scale;\n  }\n  d3.scale.identity = function() {\n    return d3_scale_identity([ 0, 1 ]);\n  };\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n    identity.invert = identity;\n    identity.domain = identity.range = function(x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n    identity.ticks = function(m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n    identity.tickFormat = function(m, format) {\n      return d3_scale_linearTickFormat(domain, m, format);\n    };\n    identity.copy = function() {\n      return d3_scale_identity(domain);\n    };\n    return identity;\n  }\n  d3.svg = {};\n  function d3_zero() {\n    return 0;\n  }\n  d3.svg.arc = function() {\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\n    function arc() {\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\n      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \"\") + \"Z\";\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\n        if (!cw) p1 *= -1;\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\n      }\n      if (r1) {\n        x0 = r1 * Math.cos(a0 + p1);\n        y0 = r1 * Math.sin(a0 + p1);\n        x1 = r1 * Math.cos(a1 - p1);\n        y1 = r1 * Math.sin(a1 - p1);\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\n          var h1 = (a0 + a1) / 2;\n          x0 = r1 * Math.cos(h1);\n          y0 = r1 * Math.sin(h1);\n          x1 = y1 = null;\n        }\n      } else {\n        x0 = y0 = 0;\n      }\n      if (r0) {\n        x2 = r0 * Math.cos(a1 - p0);\n        y2 = r0 * Math.sin(a1 - p0);\n        x3 = r0 * Math.cos(a0 + p0);\n        y3 = r0 * Math.sin(a0 + p0);\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\n          var h0 = (a0 + a1) / 2;\n          x2 = r0 * Math.cos(h0);\n          y2 = r0 * Math.sin(h0);\n          x3 = y3 = null;\n        }\n      } else {\n        x2 = y2 = 0;\n      }\n      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\n        cr = r0 < r1 ^ cw ? 0 : 1;\n        var rc1 = rc, rc0 = rc;\n        if (da < π) {\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\n        }\n        if (x1 != null) {\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\n          if (rc === rc1) {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t30[1], \"A\", r1, \",\", r1, \" 0 \", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \",\", cw, \" \", t12[1], \"A\", rc1, \",\", rc1, \" 0 0,\", cr, \" \", t12[0]);\n          } else {\n            path.push(\"M\", t30[0], \"A\", rc1, \",\", rc1, \" 0 1,\", cr, \" \", t12[0]);\n          }\n        } else {\n          path.push(\"M\", x0, \",\", y0);\n        }\n        if (x3 != null) {\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\n          if (rc === rc0) {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t21[1], \"A\", r0, \",\", r0, \" 0 \", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \",\", 1 - cw, \" \", t03[1], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          } else {\n            path.push(\"L\", t21[0], \"A\", rc0, \",\", rc0, \" 0 0,\", cr, \" \", t03[0]);\n          }\n        } else {\n          path.push(\"L\", x2, \",\", y2);\n        }\n      } else {\n        path.push(\"M\", x0, \",\", y0);\n        if (x1 != null) path.push(\"A\", r1, \",\", r1, \" 0 \", l1, \",\", cw, \" \", x1, \",\", y1);\n        path.push(\"L\", x2, \",\", y2);\n        if (x3 != null) path.push(\"A\", r0, \",\", r0, \" 0 \", l0, \",\", 1 - cw, \" \", x3, \",\", y3);\n      }\n      path.push(\"Z\");\n      return path.join(\"\");\n    }\n    function circleSegment(r1, cw) {\n      return \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,\" + cw + \" 0,\" + r1;\n    }\n    arc.innerRadius = function(v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.outerRadius = function(v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.cornerRadius = function(v) {\n      if (!arguments.length) return cornerRadius;\n      cornerRadius = d3_functor(v);\n      return arc;\n    };\n    arc.padRadius = function(v) {\n      if (!arguments.length) return padRadius;\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\n      return arc;\n    };\n    arc.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n    arc.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n    arc.padAngle = function(v) {\n      if (!arguments.length) return padAngle;\n      padAngle = d3_functor(v);\n      return arc;\n    };\n    arc.centroid = function() {\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\n    };\n    return arc;\n  };\n  var d3_svg_arcAuto = \"auto\";\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n  function d3_svg_arcPadAngle(d) {\n    return d && d.padAngle;\n  }\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\n  }\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\n  }\n  function d3_svg_line(projection) {\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\n    function line(data) {\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points), tension));\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n      if (points.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    line.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n    line.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n    line.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n    line.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n    line.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n    return line;\n  }\n  d3.svg.line = function() {\n    return d3_svg_line(d3_identity);\n  };\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    \"linear-closed\": d3_svg_lineLinearClosed,\n    step: d3_svg_lineStep,\n    \"step-before\": d3_svg_lineStepBefore,\n    \"step-after\": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    \"basis-open\": d3_svg_lineBasisOpen,\n    \"basis-closed\": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function(key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n  function d3_svg_lineLinear(points) {\n    return points.length > 1 ? points.join(\"L\") : points + \"Z\";\n  }\n  function d3_svg_lineLinearClosed(points) {\n    return points.join(\"L\") + \"Z\";\n  }\n  function d3_svg_lineStep(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p[0] + (p = points[i])[0]) / 2, \"V\", p[1]);\n    if (n > 1) path.push(\"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepBefore(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineStepAfter(points) {\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \",\", p[1] ];\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n    return path.join(\"\");\n  }\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\n  }\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n    var quad = points.length != tangents.length, path = \"\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\n    if (quad) {\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      }\n    }\n    if (quad) {\n      var lp = points[pi];\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n    }\n    return path;\n  }\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \",\", y0, \"L\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    points.push(points[n - 1]);\n    while (++i <= n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    points.pop();\n    path.push(\"L\", pi);\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBasisClosed(points) {\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\n    --i;\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n    return path.join(\"\");\n  }\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n    if (n) {\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n    return d3_svg_lineBasis(points);\n  }\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n    m[i] = d;\n    return m;\n  }\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n      if (abs(d) < ε) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n    i = -1;\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([ s || 0, m[i] * s || 0 ]);\n    }\n    return tangents;\n  }\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n  d3.svg.line.radial = function() {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n  function d3_svg_lineRadial(points) {\n    var point, i = -1, n = points.length, r, a;\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] - halfπ;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n    return points;\n  }\n  function d3_svg_area(projection) {\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \"L\", tension = .7;\n    function area(data) {\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\n        return x;\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\n        return y;\n      } : d3_functor(y1), x, y;\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n      }\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n      if (points0.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n    area.x = function(_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n    area.x0 = function(_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n    area.x1 = function(_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n    area.y = function(_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n    area.y0 = function(_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n    area.y1 = function(_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n    area.defined = function(_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n    area.interpolate = function(_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? \"M\" : \"L\";\n      return area;\n    };\n    area.tension = function(_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n    return area;\n  }\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n  d3.svg.area = function() {\n    return d3_svg_area(d3_identity);\n  };\n  d3.svg.area.radial = function() {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n  d3.svg.chord = function() {\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n    }\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\n      };\n    }\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n    function arc(r, p, a) {\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > π) + \",1 \" + p;\n    }\n    function curve(r0, p0, r1, p1) {\n      return \"Q 0,0 \" + p1;\n    }\n    chord.radius = function(v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n    chord.source = function(v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n    chord.target = function(v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n    chord.startAngle = function(v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n    chord.endAngle = function(v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n    return chord;\n  };\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n  d3.svg.diagonal = function() {\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3 ];\n      p = p.map(projection);\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n    }\n    diagonal.source = function(x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.target = function(x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n    diagonal.projection = function(x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalProjection(d) {\n    return [ d.x, d.y ];\n  }\n  d3.svg.diagonal.radial = function() {\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\n    diagonal.projection = function(x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n    return diagonal;\n  };\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function() {\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;\n      return [ r * Math.cos(a), r * Math.sin(a) ];\n    };\n  }\n  d3.svg.symbol = function() {\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n    symbol.type = function(x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n    symbol.size = function(x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n    return symbol;\n  };\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n  function d3_svg_symbolType() {\n    return \"circle\";\n  }\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / π);\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n  }\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function(size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n    },\n    diamond: function(size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n    },\n    square: function(size) {\n      var r = Math.sqrt(size) / 2;\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n    },\n    \"triangle-down\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n    },\n    \"triangle-up\": function(size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n  d3_selectionPrototype.transition = function(name) {\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\n      time: Date.now(),\n      ease: d3_ease_cubicInOut,\n      delay: 0,\n      duration: 250\n    };\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_selectionPrototype.interrupt = function(name) {\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\n  };\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\n  function d3_selection_interruptNS(ns) {\n    return function() {\n      var lock, activeId, active;\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\n        lock.active += .5;\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\n      }\n    };\n  }\n  function d3_transition(groups, ns, id) {\n    d3_subclass(groups, d3_transitionPrototype);\n    groups.namespace = ns;\n    groups.id = id;\n    return groups;\n  }\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\n  d3.transition = function(selection, name) {\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\n  };\n  d3.transition.prototype = d3_transitionPrototype;\n  d3_transitionPrototype.select = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\n    selector = d3_selection_selector(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.selectAll = function(selector) {\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\n    selector = d3_selection_selectorAll(selector);\n    for (var j = -1, m = this.length; ++j < m; ) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\n        if (node = group[i]) {\n          transition = node[ns][id];\n          subnodes = selector.call(node, node.__data__, i, j);\n          subgroups.push(subgroup = []);\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n    return d3_transition(subgroups, ns, id);\n  };\n  d3_transitionPrototype.filter = function(filter) {\n    var subgroups = [], subgroup, group, node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\n          subgroup.push(node);\n        }\n      }\n    }\n    return d3_transition(subgroups, this.namespace, this.id);\n  };\n  d3_transitionPrototype.tween = function(name, tween) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function(node) {\n      node[ns][id].tween.remove(name);\n    } : function(node) {\n      node[ns][id].tween.set(name, tween);\n    });\n  };\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id, ns = groups.namespace;\n    return d3_selection_each(groups, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function(node) {\n      node[ns][id].tween.set(name, value);\n    }));\n  }\n  d3_transitionPrototype.attr = function(nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n      return this;\n    }\n    var interpolate = nameNS == \"transform\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n    function attrTween(b) {\n      return b == null ? attrNull : (b += \"\", function() {\n        var a = this.getAttribute(name), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttribute(name, i(t));\n        });\n      });\n    }\n    function attrTweenNS(b) {\n      return b == null ? attrNullNS : (b += \"\", function() {\n        var a = this.getAttributeNS(name.space, name.local), i;\n        return a !== b && (i = interpolate(a, b), function(t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      });\n    }\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function(t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function(t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n  d3_transitionPrototype.style = function(name, value, priority) {\n    var n = arguments.length;\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n        for (priority in name) this.style(priority, name[priority], value);\n        return this;\n      }\n      priority = \"\";\n    }\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n    function styleString(b) {\n      return b == null ? styleNull : (b += \"\", function() {\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      });\n    }\n    return d3_transition_tween(this, \"style.\" + name, value, styleString);\n  };\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n    function styleTween(d, i) {\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\n      return f && function(t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    }\n    return this.tween(\"style.\" + name, styleTween);\n  };\n  d3_transitionPrototype.text = function(value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function() {\n      this.textContent = b;\n    };\n  }\n  d3_transitionPrototype.remove = function() {\n    var ns = this.namespace;\n    return this.each(\"end.transition\", function() {\n      var p;\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n  d3_transitionPrototype.ease = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function(node) {\n      node[ns][id].ease = value;\n    });\n  };\n  d3_transitionPrototype.delay = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].delay;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\n    } : (value = +value, function(node) {\n      node[ns][id].delay = value;\n    }));\n  };\n  d3_transitionPrototype.duration = function(value) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 1) return this.node()[ns][id].duration;\n    return d3_selection_each(this, typeof value === \"function\" ? function(node, i, j) {\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\n    } : (value = Math.max(1, value), function(node) {\n      node[ns][id].duration = value;\n    }));\n  };\n  d3_transitionPrototype.each = function(type, listener) {\n    var id = this.id, ns = this.namespace;\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\n      try {\n        d3_transitionInheritId = id;\n        d3_selection_each(this, function(node, i, j) {\n          d3_transitionInherit = node[ns][id];\n          type.call(node, node.__data__, i, j);\n        });\n      } finally {\n        d3_transitionInherit = inherit;\n        d3_transitionInheritId = inheritId;\n      }\n    } else {\n      d3_selection_each(this, function(node) {\n        var transition = node[ns][id];\n        (transition.event || (transition.event = d3.dispatch(\"start\", \"end\", \"interrupt\"))).on(type, listener);\n      });\n    }\n    return this;\n  };\n  d3_transitionPrototype.transition = function() {\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = node[ns][id0];\n          d3_transitionNode(node, i, ns, id1, {\n            time: transition.time,\n            ease: transition.ease,\n            delay: transition.delay + transition.duration,\n            duration: transition.duration\n          });\n        }\n        subgroup.push(node);\n      }\n    }\n    return d3_transition(subgroups, ns, id1);\n  };\n  function d3_transitionNamespace(name) {\n    return name == null ? \"__transition__\" : \"__transition_\" + name + \"__\";\n  }\n  function d3_transitionNode(node, i, ns, id, inherit) {\n    var lock = node[ns] || (node[ns] = {\n      active: 0,\n      count: 0\n    }), transition = lock[id], time, timer, duration, ease, tweens;\n    function schedule(elapsed) {\n      var delay = transition.delay;\n      timer.t = delay + time;\n      if (delay <= elapsed) return start(elapsed - delay);\n      timer.c = start;\n    }\n    function start(elapsed) {\n      var activeId = lock.active, active = lock[activeId];\n      if (active) {\n        active.timer.c = null;\n        active.timer.t = NaN;\n        --lock.count;\n        delete lock[activeId];\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\n      }\n      for (var cancelId in lock) {\n        if (+cancelId < id) {\n          var cancel = lock[cancelId];\n          cancel.timer.c = null;\n          cancel.timer.t = NaN;\n          --lock.count;\n          delete lock[cancelId];\n        }\n      }\n      timer.c = tick;\n      d3_timer(function() {\n        if (timer.c && tick(elapsed || 1)) {\n          timer.c = null;\n          timer.t = NaN;\n        }\n        return 1;\n      }, 0, time);\n      lock.active = id;\n      transition.event && transition.event.start.call(node, node.__data__, i);\n      tweens = [];\n      transition.tween.forEach(function(key, value) {\n        if (value = value.call(node, node.__data__, i)) {\n          tweens.push(value);\n        }\n      });\n      ease = transition.ease;\n      duration = transition.duration;\n    }\n    function tick(elapsed) {\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\n      while (n > 0) {\n        tweens[--n].call(node, e);\n      }\n      if (t >= 1) {\n        transition.event && transition.event.end.call(node, node.__data__, i);\n        if (--lock.count) delete lock[id]; else delete node[ns];\n        return 1;\n      }\n    }\n    if (!transition) {\n      time = inherit.time;\n      timer = d3_timer(schedule, 0, time);\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        time: time,\n        timer: timer,\n        delay: inherit.delay,\n        duration: inherit.duration,\n        ease: inherit.ease,\n        index: i\n      };\n      inherit = null;\n      ++lock.count;\n    }\n  }\n  d3.svg.axis = function() {\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\n    function axis(g) {\n      g.each(function() {\n        var g = d3.select(this);\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(\".tick\").data(ticks, scale1), tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", ε), tickExit = d3.transition(tick.exit()).style(\"opacity\", ε).remove(), tickUpdate = d3.transition(tick.order()).style(\"opacity\", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\n        var range = d3_scaleRange(scale1), path = g.selectAll(\".domain\").data([ 0 ]), pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), \n        d3.transition(path));\n        tickEnter.append(\"line\");\n        tickEnter.append(\"text\");\n        var lineEnter = tickEnter.select(\"line\"), lineUpdate = tickUpdate.select(\"line\"), text = tick.select(\"text\").text(tickFormat), textEnter = tickEnter.select(\"text\"), textUpdate = tickUpdate.select(\"text\"), sign = orient === \"top\" || orient === \"left\" ? -1 : 1, x1, x2, y1, y2;\n        if (orient === \"bottom\" || orient === \"top\") {\n          tickTransform = d3_svg_axisX, x1 = \"x\", y1 = \"y\", x2 = \"x2\", y2 = \"y2\";\n          text.attr(\"dy\", sign < 0 ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\");\n          pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + sign * outerTickSize + \"V0H\" + range[1] + \"V\" + sign * outerTickSize);\n        } else {\n          tickTransform = d3_svg_axisY, x1 = \"y\", y1 = \"x\", x2 = \"y2\", y2 = \"x2\";\n          text.attr(\"dy\", \".32em\").style(\"text-anchor\", sign < 0 ? \"end\" : \"start\");\n          pathUpdate.attr(\"d\", \"M\" + sign * outerTickSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + sign * outerTickSize);\n        }\n        lineEnter.attr(y2, sign * innerTickSize);\n        textEnter.attr(y1, sign * tickSpacing);\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\n        if (scale1.rangeBand) {\n          var x = scale1, dx = x.rangeBand() / 2;\n          scale0 = scale1 = function(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, scale0);\n        }\n        tickEnter.call(tickTransform, scale0, scale1);\n        tickUpdate.call(tickTransform, scale1, scale1);\n      });\n    }\n    axis.scale = function(x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n    axis.orient = function(x) {\n      if (!arguments.length) return orient;\n      orient = x in d3_svg_axisOrients ? x + \"\" : d3_svg_axisDefaultOrient;\n      return axis;\n    };\n    axis.ticks = function() {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = d3_array(arguments);\n      return axis;\n    };\n    axis.tickValues = function(x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n    axis.tickFormat = function(x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n    axis.tickSize = function(x) {\n      var n = arguments.length;\n      if (!n) return innerTickSize;\n      innerTickSize = +x;\n      outerTickSize = +arguments[n - 1];\n      return axis;\n    };\n    axis.innerTickSize = function(x) {\n      if (!arguments.length) return innerTickSize;\n      innerTickSize = +x;\n      return axis;\n    };\n    axis.outerTickSize = function(x) {\n      if (!arguments.length) return outerTickSize;\n      outerTickSize = +x;\n      return axis;\n    };\n    axis.tickPadding = function(x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n    axis.tickSubdivide = function() {\n      return arguments.length && axis;\n    };\n    return axis;\n  };\n  var d3_svg_axisDefaultOrient = \"bottom\", d3_svg_axisOrients = {\n    top: 1,\n    right: 1,\n    bottom: 1,\n    left: 1\n  };\n  function d3_svg_axisX(selection, x0, x1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = x0(d);\n      return \"translate(\" + (isFinite(v0) ? v0 : x1(d)) + \",0)\";\n    });\n  }\n  function d3_svg_axisY(selection, y0, y1) {\n    selection.attr(\"transform\", function(d) {\n      var v0 = y0(d);\n      return \"translate(0,\" + (isFinite(v0) ? v0 : y1(d)) + \")\";\n    });\n  }\n  d3.svg.brush = function() {\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\n    function brush(g) {\n      g.each(function() {\n        var g = d3.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n        var background = g.selectAll(\".background\").data([ 0 ]);\n        background.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n        g.selectAll(\".extent\").data([ 0 ]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n        var resize = g.selectAll(\".resize\").data(resizes, d3_identity);\n        resize.exit().remove();\n        resize.enter().append(\"g\").attr(\"class\", function(d) {\n          return \"resize \" + d;\n        }).style(\"cursor\", function(d) {\n          return d3_svg_brushCursor[d];\n        }).append(\"rect\").attr(\"x\", function(d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr(\"y\", function(d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n        resize.style(\"display\", brush.empty() ? \"none\" : null);\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\n        if (x) {\n          range = d3_scaleRange(x);\n          backgroundUpdate.attr(\"x\", range[0]).attr(\"width\", range[1] - range[0]);\n          redrawX(gUpdate);\n        }\n        if (y) {\n          range = d3_scaleRange(y);\n          backgroundUpdate.attr(\"y\", range[0]).attr(\"height\", range[1] - range[0]);\n          redrawY(gUpdate);\n        }\n        redraw(gUpdate);\n      });\n    }\n    brush.event = function(g) {\n      g.each(function() {\n        var event_ = event.of(this, arguments), extent1 = {\n          x: xExtent,\n          y: yExtent,\n          i: xExtentDomain,\n          j: yExtentDomain\n        }, extent0 = this.__chart__ || extent1;\n        this.__chart__ = extent1;\n        if (d3_transitionInheritId) {\n          d3.select(this).transition().each(\"start.brush\", function() {\n            xExtentDomain = extent0.i;\n            yExtentDomain = extent0.j;\n            xExtent = extent0.x;\n            yExtent = extent0.y;\n            event_({\n              type: \"brushstart\"\n            });\n          }).tween(\"brush:brush\", function() {\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\n            xExtentDomain = yExtentDomain = null;\n            return function(t) {\n              xExtent = extent1.x = xi(t);\n              yExtent = extent1.y = yi(t);\n              event_({\n                type: \"brush\",\n                mode: \"resize\"\n              });\n            };\n          }).each(\"end.brush\", function() {\n            xExtentDomain = extent1.i;\n            yExtentDomain = extent1.j;\n            event_({\n              type: \"brush\",\n              mode: \"resize\"\n            });\n            event_({\n              type: \"brushend\"\n            });\n          });\n        } else {\n          event_({\n            type: \"brushstart\"\n          });\n          event_({\n            type: \"brush\",\n            mode: \"resize\"\n          });\n          event_({\n            type: \"brushend\"\n          });\n        }\n      });\n    };\n    function redraw(g) {\n      g.selectAll(\".resize\").attr(\"transform\", function(d) {\n        return \"translate(\" + xExtent[+/e$/.test(d)] + \",\" + yExtent[+/^s/.test(d)] + \")\";\n      });\n    }\n    function redrawX(g) {\n      g.select(\".extent\").attr(\"x\", xExtent[0]);\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", xExtent[1] - xExtent[0]);\n    }\n    function redrawY(g) {\n      g.select(\".extent\").attr(\"y\", yExtent[0]);\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", yExtent[1] - yExtent[0]);\n    }\n    function brushstart() {\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\"extent\"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\n      var w = d3.select(d3_window(target)).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n      if (d3.event.changedTouches) {\n        w.on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend);\n      } else {\n        w.on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend);\n      }\n      g.interrupt().selectAll(\"*\").interrupt();\n      if (dragging) {\n        origin[0] = xExtent[0] - origin[0];\n        origin[1] = yExtent[0] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\n        origin[0] = xExtent[ex];\n        origin[1] = yExtent[ey];\n      } else if (d3.event.altKey) center = origin.slice();\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n      event_({\n        type: \"brushstart\"\n      });\n      brushmove();\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= xExtent[1];\n            origin[1] -= yExtent[1];\n            dragging = 2;\n          }\n          d3_eventPreventDefault();\n        }\n      }\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += xExtent[1];\n          origin[1] += yExtent[1];\n          dragging = 0;\n          d3_eventPreventDefault();\n        }\n      }\n      function brushmove() {\n        var point = d3.mouse(target), moved = false;\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\n            origin[0] = xExtent[+(point[0] < center[0])];\n            origin[1] = yExtent[+(point[1] < center[1])];\n          } else center = null;\n        }\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n        if (moved) {\n          redraw(g);\n          event_({\n            type: \"brush\",\n            mode: dragging ? \"move\" : \"resize\"\n          });\n        }\n      }\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n        if (extent[0] != min || extent[1] != max) {\n          if (i) yExtentDomain = null; else xExtentDomain = null;\n          extent[0] = min;\n          extent[1] = max;\n          return true;\n        }\n      }\n      function brushend() {\n        brushmove();\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n        d3.select(\"body\").style(\"cursor\", null);\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n        dragRestore();\n        event_({\n          type: \"brushend\"\n        });\n      }\n    }\n    brush.x = function(z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.y = function(z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n    brush.clamp = function(z) {\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\n      return brush;\n    };\n    brush.extent = function(z) {\n      var x0, x1, y0, y1, t;\n      if (!arguments.length) {\n        if (x) {\n          if (xExtentDomain) {\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\n          } else {\n            x0 = xExtent[0], x1 = xExtent[1];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n        if (y) {\n          if (yExtentDomain) {\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\n          } else {\n            y0 = yExtent[0], y1 = yExtent[1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\n      }\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        xExtentDomain = [ x0, x1 ];\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\n      }\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        yExtentDomain = [ y0, y1 ];\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\n      }\n      return brush;\n    };\n    brush.clear = function() {\n      if (!brush.empty()) {\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\n        xExtentDomain = yExtentDomain = null;\n      }\n      return brush;\n    };\n    brush.empty = function() {\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\n    };\n    return d3.rebind(brush, event, \"on\");\n  };\n  var d3_svg_brushCursor = {\n    n: \"ns-resize\",\n    e: \"ew-resize\",\n    s: \"ns-resize\",\n    w: \"ew-resize\",\n    nw: \"nwse-resize\",\n    ne: \"nesw-resize\",\n    se: \"nwse-resize\",\n    sw: \"nesw-resize\"\n  };\n  var d3_svg_brushResizes = [ [ \"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\" ], [ \"e\", \"w\" ], [ \"n\", \"s\" ], [] ];\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\n  var d3_time_formatUtc = d3_time_format.utc;\n  var d3_time_formatIso = d3_time_formatUtc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n  d3_time_format.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? d3_time_formatIsoNative : d3_time_formatIso;\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n  d3_time_formatIsoNative.parse = function(string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n  d3_time.second = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function(date) {\n    return date.getSeconds();\n  });\n  d3_time.seconds = d3_time.second.range;\n  d3_time.seconds.utc = d3_time.second.utc.range;\n  d3_time.minute = d3_time_interval(function(date) {\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function(date) {\n    return date.getMinutes();\n  });\n  d3_time.minutes = d3_time.minute.range;\n  d3_time.minutes.utc = d3_time.minute.utc.range;\n  d3_time.hour = d3_time_interval(function(date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function(date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function(date) {\n    return date.getHours();\n  });\n  d3_time.hours = d3_time.hour.range;\n  d3_time.hours.utc = d3_time.hour.utc.range;\n  d3_time.month = d3_time_interval(function(date) {\n    date = d3_time.day(date);\n    date.setDate(1);\n    return date;\n  }, function(date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function(date) {\n    return date.getMonth();\n  });\n  d3_time.months = d3_time.month.range;\n  d3_time.months.utc = d3_time.month.utc.range;\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n    scale.invert = function(x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n    scale.domain = function(x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n    function tickMethod(extent, count) {\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\n        return d / 31536e6;\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\n    }\n    scale.nice = function(interval, skip) {\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" && tickMethod(extent, interval);\n      if (method) interval = method[0], skip = method[1];\n      function skipped(date) {\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\n      }\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\n        floor: function(date) {\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\n          return date;\n        },\n        ceil: function(date) {\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\n          return date;\n        }\n      } : interval));\n    };\n    scale.ticks = function(interval, skip) {\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === \"number\" ? tickMethod(extent, interval) : !interval.range && [ {\n        range: interval\n      }, skip ];\n      if (method) interval = method[0], skip = method[1];\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\n    };\n    scale.tickFormat = function() {\n      return format;\n    };\n    scale.copy = function() {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n    return d3_scale_linearRebind(scale, linear);\n  }\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ \".%L\", function(d) {\n    return d.getMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getDay() && d.getDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  var d3_time_scaleMilliseconds = {\n    range: function(start, stop, step) {\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\n    },\n    floor: d3_identity,\n    ceil: d3_identity\n  };\n  d3_time_scaleLocalMethods.year = d3_time.year;\n  d3_time.scale = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\n    return [ m[0].utc, m[1] ];\n  });\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ \".%L\", function(d) {\n    return d.getUTCMilliseconds();\n  } ], [ \":%S\", function(d) {\n    return d.getUTCSeconds();\n  } ], [ \"%I:%M\", function(d) {\n    return d.getUTCMinutes();\n  } ], [ \"%I %p\", function(d) {\n    return d.getUTCHours();\n  } ], [ \"%a %d\", function(d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  } ], [ \"%b %d\", function(d) {\n    return d.getUTCDate() != 1;\n  } ], [ \"%B\", function(d) {\n    return d.getUTCMonth();\n  } ], [ \"%Y\", d3_true ] ]);\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\n  d3_time.scale.utc = function() {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\n  };\n  d3.text = d3_xhrType(function(request) {\n    return request.responseText;\n  });\n  d3.json = function(url, callback) {\n    return d3_xhr(url, \"application/json\", d3_json, callback);\n  };\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n  d3.html = function(url, callback) {\n    return d3_xhr(url, \"text/html\", d3_html, callback);\n  };\n  function d3_html(request) {\n    var range = d3_document.createRange();\n    range.selectNode(d3_document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n  d3.xml = d3_xhrType(function(request) {\n    return request.responseXML;\n  });\n  if (typeof define === \"function\" && define.amd) this.d3 = d3, define(d3); else if (typeof module === \"object\" && module.exports) module.exports = d3; else this.d3 = d3;\n}();","/* nvd3 version 1.8.5 (https://github.com/novus/nvd3) 2016-12-01 */\n(function(){\n\n// set up main nv object\nvar nv = {};\n\n// the major global objects under the nv namespace\nnv.dev = false; //set false when in production\nnv.tooltip = nv.tooltip || {}; // For the tooltip system\nnv.utils = nv.utils || {}; // Utility subsystem\nnv.models = nv.models || {}; //stores all the possible models/components\nnv.charts = {}; //stores all the ready to use charts\nnv.logs = {}; //stores some statistics and potential error messages\nnv.dom = {}; //DOM manipulation functions\n\n// Node/CommonJS - require D3\nif (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined' && typeof(d3) == 'undefined') {\n    d3 = require('d3');\n}\n\nnv.dispatch = d3.dispatch('render_start', 'render_end');\n\n// Function bind polyfill\n// Needed ONLY for phantomJS as it's missing until version 2.0 which is unreleased as of this comment\n// https://github.com/ariya/phantomjs/issues/10522\n// http://kangax.github.io/compat-table/es5/#Function.prototype.bind\n// phantomJS is used for running the test suite\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n        if (typeof this !== \"function\") {\n            // closest thing possible to the ECMAScript 5 internal IsCallable function\n            throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n        }\n\n        var aArgs = Array.prototype.slice.call(arguments, 1),\n            fToBind = this,\n            fNOP = function () {},\n            fBound = function () {\n                return fToBind.apply(this instanceof fNOP && oThis\n                        ? this\n                        : oThis,\n                    aArgs.concat(Array.prototype.slice.call(arguments)));\n            };\n\n        fNOP.prototype = this.prototype;\n        fBound.prototype = new fNOP();\n        return fBound;\n    };\n}\n\n//  Development render timers - disabled if dev = false\nif (nv.dev) {\n    nv.dispatch.on('render_start', function(e) {\n        nv.logs.startTime = +new Date();\n    });\n\n    nv.dispatch.on('render_end', function(e) {\n        nv.logs.endTime = +new Date();\n        nv.logs.totalTime = nv.logs.endTime - nv.logs.startTime;\n        nv.log('total', nv.logs.totalTime); // used for development, to keep track of graph generation times\n    });\n}\n\n// Logs all arguments, and returns the last so you can test things in place\n// Note: in IE8 console.log is an object not a function, and if modernizr is used\n// then calling Function.prototype.bind with with anything other than a function\n// causes a TypeError to be thrown.\nnv.log = function() {\n    if (nv.dev && window.console && console.log && console.log.apply)\n        console.log.apply(console, arguments);\n    else if (nv.dev && window.console && typeof console.log == \"function\" && Function.prototype.bind) {\n        var log = Function.prototype.bind.call(console.log, console);\n        log.apply(console, arguments);\n    }\n    return arguments[arguments.length - 1];\n};\n\n// print console warning, should be used by deprecated functions\nnv.deprecated = function(name, info) {\n    if (console && console.warn) {\n        console.warn('nvd3 warning: `' + name + '` has been deprecated. ', info || '');\n    }\n};\n\n// The nv.render function is used to queue up chart rendering\n// in non-blocking async functions.\n// When all queued charts are done rendering, nv.dispatch.render_end is invoked.\nnv.render = function render(step) {\n    // number of graphs to generate in each timeout loop\n    step = step || 1;\n\n    nv.render.active = true;\n    nv.dispatch.render_start();\n\n    var renderLoop = function() {\n        var chart, graph;\n\n        for (var i = 0; i < step && (graph = nv.render.queue[i]); i++) {\n            chart = graph.generate();\n            if (typeof graph.callback == typeof(Function)) graph.callback(chart);\n        }\n\n        nv.render.queue.splice(0, i);\n\n        if (nv.render.queue.length) {\n            setTimeout(renderLoop);\n        }\n        else {\n            nv.dispatch.render_end();\n            nv.render.active = false;\n        }\n    };\n\n    setTimeout(renderLoop);\n};\n\nnv.render.active = false;\nnv.render.queue = [];\n\n/*\nAdds a chart to the async rendering queue. This method can take arguments in two forms:\nnv.addGraph({\n    generate: <Function>\n    callback: <Function>\n})\n\nor\n\nnv.addGraph(<generate Function>, <callback Function>)\n\nThe generate function should contain code that creates the NVD3 model, sets options\non it, adds data to an SVG element, and invokes the chart model. The generate function\nshould return the chart model.  See examples/lineChart.html for a usage example.\n\nThe callback function is optional, and it is called when the generate function completes.\n*/\nnv.addGraph = function(obj) {\n    if (typeof arguments[0] === typeof(Function)) {\n        obj = {generate: arguments[0], callback: arguments[1]};\n    }\n\n    nv.render.queue.push(obj);\n\n    if (!nv.render.active) {\n        nv.render();\n    }\n};\n\n// Node/CommonJS exports\nif (typeof(module) !== 'undefined' && typeof(exports) !== 'undefined') {\n  module.exports = nv;\n}\n\nif (typeof(window) !== 'undefined') {\n  window.nv = nv;\n}\n/* Facade for queueing DOM write operations\r\n * with Fastdom (https://github.com/wilsonpage/fastdom)\r\n * if available.\r\n * This could easily be extended to support alternate\r\n * implementations in the future.\r\n */\r\nnv.dom.write = function(callback) {\r\n\tif (window.fastdom !== undefined) {\r\n\t\treturn fastdom.mutate(callback);\r\n\t}\r\n\treturn callback();\r\n};\r\n\r\n/* Facade for queueing DOM read operations\r\n * with Fastdom (https://github.com/wilsonpage/fastdom)\r\n * if available.\r\n * This could easily be extended to support alternate\r\n * implementations in the future.\r\n */\r\nnv.dom.read = function(callback) {\r\n\tif (window.fastdom !== undefined) {\r\n\t\treturn fastdom.measure(callback);\r\n\t}\r\n\treturn callback();\r\n};\r\n/* Utility class to handle creation of an interactive layer.\n This places a rectangle on top of the chart. When you mouse move over it, it sends a dispatch\n containing the X-coordinate. It can also render a vertical line where the mouse is located.\n\n dispatch.elementMousemove is the important event to latch onto.  It is fired whenever the mouse moves over\n the rectangle. The dispatch is given one object which contains the mouseX/Y location.\n It also has 'pointXValue', which is the conversion of mouseX to the x-axis scale.\n */\nnv.interactiveGuideline = function() {\n    \"use strict\";\n\n    var margin = { left: 0, top: 0 } //Pass the chart's top and left magins. Used to calculate the mouseX/Y.\n        ,   width = null\n        ,   height = null\n        ,   xScale = d3.scale.linear()\n        ,   dispatch = d3.dispatch('elementMousemove', 'elementMouseout', 'elementClick', 'elementDblclick', 'elementMouseDown', 'elementMouseUp')\n        ,   showGuideLine = true\n        ,   svgContainer = null // Must pass the chart's svg, we'll use its mousemove event.\n        ,   tooltip = nv.models.tooltip()\n        ,   isMSIE =  window.ActiveXObject// Checkt if IE by looking for activeX. (excludes IE11)\n    ;\n\n    tooltip\n        .duration(0)\n        .hideDelay(0)\n        .hidden(false);\n\n    function layer(selection) {\n        selection.each(function(data) {\n            var container = d3.select(this);\n            var availableWidth = (width || 960), availableHeight = (height || 400);\n            var wrap = container.selectAll(\"g.nv-wrap.nv-interactiveLineLayer\")\n                .data([data]);\n            var wrapEnter = wrap.enter()\n                .append(\"g\").attr(\"class\", \" nv-wrap nv-interactiveLineLayer\");\n            wrapEnter.append(\"g\").attr(\"class\",\"nv-interactiveGuideLine\");\n\n            if (!svgContainer) {\n                return;\n            }\n\n            function mouseHandler() {\n                var d3mouse = d3.mouse(this);\n                var mouseX = d3mouse[0];\n                var mouseY = d3mouse[1];\n                var subtractMargin = true;\n                var mouseOutAnyReason = false;\n                if (isMSIE) {\n                    /*\n                     D3.js (or maybe SVG.getScreenCTM) has a nasty bug in Internet Explorer 10.\n                     d3.mouse() returns incorrect X,Y mouse coordinates when mouse moving\n                     over a rect in IE 10.\n                     However, d3.event.offsetX/Y also returns the mouse coordinates\n                     relative to the triggering <rect>. So we use offsetX/Y on IE.\n                     */\n                    mouseX = d3.event.offsetX;\n                    mouseY = d3.event.offsetY;\n\n                    /*\n                     On IE, if you attach a mouse event listener to the <svg> container,\n                     it will actually trigger it for all the child elements (like <path>, <circle>, etc).\n                     When this happens on IE, the offsetX/Y is set to where ever the child element\n                     is located.\n                     As a result, we do NOT need to subtract margins to figure out the mouse X/Y\n                     position under this scenario. Removing the line below *will* cause\n                     the interactive layer to not work right on IE.\n                     */\n                    if(d3.event.target.tagName !== \"svg\") {\n                        subtractMargin = false;\n                    }\n\n                    if (d3.event.target.className.baseVal.match(\"nv-legend\")) {\n                        mouseOutAnyReason = true;\n                    }\n\n                }\n\n                if(subtractMargin) {\n                    mouseX -= margin.left;\n                    mouseY -= margin.top;\n                }\n\n                /* If mouseX/Y is outside of the chart's bounds,\n                 trigger a mouseOut event.\n                 */\n                if (d3.event.type === 'mouseout'\n                    || mouseX < 0 || mouseY < 0\n                    || mouseX > availableWidth || mouseY > availableHeight\n                    || (d3.event.relatedTarget && d3.event.relatedTarget.ownerSVGElement === undefined)\n                    || mouseOutAnyReason\n                    ) {\n\n                    if (isMSIE) {\n                        if (d3.event.relatedTarget\n                            && d3.event.relatedTarget.ownerSVGElement === undefined\n                            && (d3.event.relatedTarget.className === undefined\n                                || d3.event.relatedTarget.className.match(tooltip.nvPointerEventsClass))) {\n\n                            return;\n                        }\n                    }\n                    dispatch.elementMouseout({\n                        mouseX: mouseX,\n                        mouseY: mouseY\n                    });\n                    layer.renderGuideLine(null); //hide the guideline\n                    tooltip.hidden(true);\n                    return;\n                } else {\n                    tooltip.hidden(false);\n                }\n\n\n                var scaleIsOrdinal = typeof xScale.rangeBands === 'function';\n                var pointXValue = undefined;\n\n                // Ordinal scale has no invert method\n                if (scaleIsOrdinal) {\n                    var elementIndex = d3.bisect(xScale.range(), mouseX) - 1;\n                    // Check if mouseX is in the range band\n                    if (xScale.range()[elementIndex] + xScale.rangeBand() >= mouseX) {\n                        pointXValue = xScale.domain()[d3.bisect(xScale.range(), mouseX) - 1];\n                    }\n                    else {\n                        dispatch.elementMouseout({\n                            mouseX: mouseX,\n                            mouseY: mouseY\n                        });\n                        layer.renderGuideLine(null); //hide the guideline\n                        tooltip.hidden(true);\n                        return;\n                    }\n                }\n                else {\n                    pointXValue = xScale.invert(mouseX);\n                }\n\n                dispatch.elementMousemove({\n                    mouseX: mouseX,\n                    mouseY: mouseY,\n                    pointXValue: pointXValue\n                });\n\n                //If user double clicks the layer, fire a elementDblclick\n                if (d3.event.type === \"dblclick\") {\n                    dispatch.elementDblclick({\n                        mouseX: mouseX,\n                        mouseY: mouseY,\n                        pointXValue: pointXValue\n                    });\n                }\n\n                // if user single clicks the layer, fire elementClick\n                if (d3.event.type === 'click') {\n                    dispatch.elementClick({\n                        mouseX: mouseX,\n                        mouseY: mouseY,\n                        pointXValue: pointXValue\n                    });\n                }\n\n                // if user presses mouse down the layer, fire elementMouseDown\n                if (d3.event.type === 'mousedown') {\n                \tdispatch.elementMouseDown({\n                \t\tmouseX: mouseX,\n                \t\tmouseY: mouseY,\n                \t\tpointXValue: pointXValue\n                \t});\n                }\n\n                // if user presses mouse down the layer, fire elementMouseUp\n                if (d3.event.type === 'mouseup') {\n                \tdispatch.elementMouseUp({\n                \t\tmouseX: mouseX,\n                \t\tmouseY: mouseY,\n                \t\tpointXValue: pointXValue\n                \t});\n                }\n            }\n\n            svgContainer\n                .on(\"touchmove\",mouseHandler)\n                .on(\"mousemove\",mouseHandler, true)\n                .on(\"mouseout\" ,mouseHandler,true)\n                .on(\"mousedown\" ,mouseHandler,true)\n                .on(\"mouseup\" ,mouseHandler,true)\n                .on(\"dblclick\" ,mouseHandler)\n                .on(\"click\", mouseHandler)\n            ;\n\n            layer.guideLine = null;\n            //Draws a vertical guideline at the given X postion.\n            layer.renderGuideLine = function(x) {\n                if (!showGuideLine) return;\n                if (layer.guideLine && layer.guideLine.attr(\"x1\") === x) return;\n                nv.dom.write(function() {\n                    var line = wrap.select(\".nv-interactiveGuideLine\")\n                        .selectAll(\"line\")\n                        .data((x != null) ? [nv.utils.NaNtoZero(x)] : [], String);\n                    line.enter()\n                        .append(\"line\")\n                        .attr(\"class\", \"nv-guideline\")\n                        .attr(\"x1\", function(d) { return d;})\n                        .attr(\"x2\", function(d) { return d;})\n                        .attr(\"y1\", availableHeight)\n                        .attr(\"y2\",0);\n                    line.exit().remove();\n                });\n            }\n        });\n    }\n\n    layer.dispatch = dispatch;\n    layer.tooltip = tooltip;\n\n    layer.margin = function(_) {\n        if (!arguments.length) return margin;\n        margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;\n        margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;\n        return layer;\n    };\n\n    layer.width = function(_) {\n        if (!arguments.length) return width;\n        width = _;\n        return layer;\n    };\n\n    layer.height = function(_) {\n        if (!arguments.length) return height;\n        height = _;\n        return layer;\n    };\n\n    layer.xScale = function(_) {\n        if (!arguments.length) return xScale;\n        xScale = _;\n        return layer;\n    };\n\n    layer.showGuideLine = function(_) {\n        if (!arguments.length) return showGuideLine;\n        showGuideLine = _;\n        return layer;\n    };\n\n    layer.svgContainer = function(_) {\n        if (!arguments.length) return svgContainer;\n        svgContainer = _;\n        return layer;\n    };\n\n    return layer;\n};\n\n/* Utility class that uses d3.bisect to find the index in a given array, where a search value can be inserted.\n This is different from normal bisectLeft; this function finds the nearest index to insert the search value.\n\n For instance, lets say your array is [1,2,3,5,10,30], and you search for 28.\n Normal d3.bisectLeft will return 4, because 28 is inserted after the number 10.  But interactiveBisect will return 5\n because 28 is closer to 30 than 10.\n\n Unit tests can be found in: interactiveBisectTest.html\n\n Has the following known issues:\n * Will not work if the data points move backwards (ie, 10,9,8,7, etc) or if the data points are in random order.\n * Won't work if there are duplicate x coordinate values.\n */\nnv.interactiveBisect = function (values, searchVal, xAccessor) {\n    \"use strict\";\n    if (! (values instanceof Array)) {\n        return null;\n    }\n    var _xAccessor;\n    if (typeof xAccessor !== 'function') {\n        _xAccessor = function(d) {\n            return d.x;\n        }\n    } else {\n        _xAccessor = xAccessor;\n    }\n    var _cmp = function(d, v) {\n        // Accessors are no longer passed the index of the element along with\n        // the element itself when invoked by d3.bisector.\n        //\n        // Starting at D3 v3.4.4, d3.bisector() started inspecting the\n        // function passed to determine if it should consider it an accessor\n        // or a comparator. This meant that accessors that take two arguments\n        // (expecting an index as the second parameter) are treated as\n        // comparators where the second argument is the search value against\n        // which the first argument is compared.\n        return _xAccessor(d) - v;\n    };\n\n    var bisect = d3.bisector(_cmp).left;\n    var index = d3.max([0, bisect(values,searchVal) - 1]);\n    var currentValue = _xAccessor(values[index]);\n\n    if (typeof currentValue === 'undefined') {\n        currentValue = index;\n    }\n\n    if (currentValue === searchVal) {\n        return index; //found exact match\n    }\n\n    var nextIndex = d3.min([index+1, values.length - 1]);\n    var nextValue = _xAccessor(values[nextIndex]);\n\n    if (typeof nextValue === 'undefined') {\n        nextValue = nextIndex;\n    }\n\n    if (Math.abs(nextValue - searchVal) >= Math.abs(currentValue - searchVal)) {\n        return index;\n    } else {\n        return nextIndex\n    }\n};\n\n/*\n Returns the index in the array \"values\" that is closest to searchVal.\n Only returns an index if searchVal is within some \"threshold\".\n Otherwise, returns null.\n */\nnv.nearestValueIndex = function (values, searchVal, threshold) {\n    \"use strict\";\n    var yDistMax = Infinity, indexToHighlight = null;\n    values.forEach(function(d,i) {\n        var delta = Math.abs(searchVal - d);\n        if ( d != null && delta <= yDistMax && delta < threshold) {\n            yDistMax = delta;\n            indexToHighlight = i;\n        }\n    });\n    return indexToHighlight;\n};\n\n/* Model which can be instantiated to handle tooltip rendering.\n Example usage:\n var tip = nv.models.tooltip().gravity('w').distance(23)\n .data(myDataObject);\n\n tip();    //just invoke the returned function to render tooltip.\n */\nnv.models.tooltip = function() {\n    \"use strict\";\n\n    /*\n    Tooltip data. If data is given in the proper format, a consistent tooltip is generated.\n    Example Format of data:\n    {\n        key: \"Date\",\n        value: \"August 2009\",\n        series: [\n            {key: \"Series 1\", value: \"Value 1\", color: \"#000\"},\n            {key: \"Series 2\", value: \"Value 2\", color: \"#00f\"}\n        ]\n    }\n    */\n    var id = \"nvtooltip-\" + Math.floor(Math.random() * 100000) // Generates a unique id when you create a new tooltip() object.\n        ,   data = null\n        ,   gravity = 'w'   // Can be 'n','s','e','w'. Determines how tooltip is positioned.\n        ,   distance = 25 // Distance to offset tooltip from the mouse location.\n        ,   snapDistance = 0   // Tolerance allowed before tooltip is moved from its current position (creates 'snapping' effect)\n        ,   classes = null  // Attaches additional CSS classes to the tooltip DIV that is created.\n        ,   hidden = true  // Start off hidden, toggle with hide/show functions below.\n        ,   hideDelay = 200  // Delay (in ms) before the tooltip hides after calling hide().\n        ,   tooltip = null // d3 select of the tooltip div.\n        ,   lastPosition = { left: null, top: null } // Last position the tooltip was in.\n        ,   enabled = true  // True -> tooltips are rendered. False -> don't render tooltips.\n        ,   duration = 100 // Tooltip movement duration, in ms.\n        ,   headerEnabled = true // If is to show the tooltip header.\n        ,   nvPointerEventsClass = \"nv-pointer-events-none\" // CSS class to specify whether element should not have mouse events.\n    ;\n\n    // Format function for the tooltip values column.\n    var valueFormatter = function(d, i) {\n        return d;\n    };\n\n    // Format function for the tooltip header value.\n    var headerFormatter = function(d) {\n        return d;\n    };\n\n    var keyFormatter = function(d, i) {\n        return d;\n    };\n\n    // By default, the tooltip model renders a beautiful table inside a DIV.\n    // You can override this function if a custom tooltip is desired.\n    var contentGenerator = function(d) {\n        if (d === null) {\n            return '';\n        }\n\n        var table = d3.select(document.createElement(\"table\"));\n        if (headerEnabled) {\n            var theadEnter = table.selectAll(\"thead\")\n                .data([d])\n                .enter().append(\"thead\");\n\n            theadEnter.append(\"tr\")\n                .append(\"td\")\n                .attr(\"colspan\", 3)\n                .append(\"strong\")\n                .classed(\"x-value\", true)\n                .html(headerFormatter(d.value));\n        }\n\n        var tbodyEnter = table.selectAll(\"tbody\")\n            .data([d])\n            .enter().append(\"tbody\");\n\n        var trowEnter = tbodyEnter.selectAll(\"tr\")\n                .data(function(p) { return p.series})\n                .enter()\n                .append(\"tr\")\n                .classed(\"highlight\", function(p) { return p.highlight});\n\n        trowEnter.append(\"td\")\n            .classed(\"legend-color-guide\",true)\n            .append(\"div\")\n            .style(\"background-color\", function(p) { return p.color});\n\n        trowEnter.append(\"td\")\n            .classed(\"key\",true)\n            .classed(\"total\",function(p) { return !!p.total})\n            .html(function(p, i) { return keyFormatter(p.key, i)});\n\n        trowEnter.append(\"td\")\n            .classed(\"value\",true)\n            .html(function(p, i) { return valueFormatter(p.value, i) });\n\n        trowEnter.filter(function (p,i) { return p.percent !== undefined }).append(\"td\")\n            .classed(\"percent\", true)\n            .html(function(p, i) { return \"(\" + d3.format('%')(p.percent) + \")\" });\n\n        trowEnter.selectAll(\"td\").each(function(p) {\n            if (p.highlight) {\n                var opacityScale = d3.scale.linear().domain([0,1]).range([\"#fff\",p.color]);\n                var opacity = 0.6;\n                d3.select(this)\n                    .style(\"border-bottom-color\", opacityScale(opacity))\n                    .style(\"border-top-color\", opacityScale(opacity))\n                ;\n            }\n        });\n\n        var html = table.node().outerHTML;\n        if (d.footer !== undefined)\n            html += \"<div class='footer'>\" + d.footer + \"</div>\";\n        return html;\n\n    };\n\n    /*\n     Function that returns the position (relative to the viewport/document.body)\n     the tooltip should be placed in.\n     Should return: {\n        left: <leftPos>,\n        top: <topPos>\n     }\n     */\n    var position = function() {\n        var pos = {\n            left: d3.event !== null ? d3.event.clientX : 0,\n            top: d3.event !== null ? d3.event.clientY : 0\n        };\n\n        if(getComputedStyle(document.body).transform != 'none') {\n            // Take the offset into account, as now the tooltip is relative\n            // to document.body.\n            var client = document.body.getBoundingClientRect();\n            pos.left -= client.left;\n            pos.top -= client.top;\n        }\n\n        return pos;\n    };\n\n    var dataSeriesExists = function(d) {\n        if (d && d.series) {\n            if (nv.utils.isArray(d.series)) {\n                return true;\n            }\n            // if object, it's okay just convert to array of the object\n            if (nv.utils.isObject(d.series)) {\n                d.series = [d.series];\n                return true;\n            }\n        }\n        return false;\n    };\n\n    // Calculates the gravity offset of the tooltip. Parameter is position of tooltip\n    // relative to the viewport.\n    var calcGravityOffset = function(pos) {\n        var height = tooltip.node().offsetHeight,\n            width = tooltip.node().offsetWidth,\n            clientWidth = document.documentElement.clientWidth, // Don't want scrollbars.\n            clientHeight = document.documentElement.clientHeight, // Don't want scrollbars.\n            left, top, tmp;\n\n        // calculate position based on gravity\n        switch (gravity) {\n            case 'e':\n                left = - width - distance;\n                top = - (height / 2);\n                if(pos.left + left < 0) left = distance;\n                if((tmp = pos.top + top) < 0) top -= tmp;\n                if((tmp = pos.top + top + height) > clientHeight) top -= tmp - clientHeight;\n                break;\n            case 'w':\n                left = distance;\n                top = - (height / 2);\n                if (pos.left + left + width > clientWidth) left = - width - distance;\n                if ((tmp = pos.top + top) < 0) top -= tmp;\n                if ((tmp = pos.top + top + height) > clientHeight) top -= tmp - clientHeight;\n                break;\n            case 'n':\n                left = - (width / 2) - 5; // - 5 is an approximation of the mouse's height.\n                top = distance;\n                if (pos.top + top + height > clientHeight) top = - height - distance;\n                if ((tmp = pos.left + left) < 0) left -= tmp;\n                if ((tmp = pos.left + left + width) > clientWidth) left -= tmp - clientWidth;\n                break;\n            case 's':\n                left = - (width / 2);\n                top = - height - distance;\n                if (pos.top + top < 0) top = distance;\n                if ((tmp = pos.left + left) < 0) left -= tmp;\n                if ((tmp = pos.left + left + width) > clientWidth) left -= tmp - clientWidth;\n                break;\n            case 'center':\n                left = - (width / 2);\n                top = - (height / 2);\n                break;\n            default:\n                left = 0;\n                top = 0;\n                break;\n        }\n\n        return { 'left': left, 'top': top };\n    };\n\n    /*\n     Positions the tooltip in the correct place, as given by the position() function.\n     */\n    var positionTooltip = function() {\n        nv.dom.read(function() {\n            var pos = position(),\n                gravityOffset = calcGravityOffset(pos),\n                left = pos.left + gravityOffset.left,\n                top = pos.top + gravityOffset.top;\n\n            // delay hiding a bit to avoid flickering\n            if (hidden) {\n                tooltip\n                    .interrupt()\n                    .transition()\n                    .delay(hideDelay)\n                    .duration(0)\n                    .style('opacity', 0);\n            } else {\n                // using tooltip.style('transform') returns values un-usable for tween\n                var old_translate = 'translate(' + lastPosition.left + 'px, ' + lastPosition.top + 'px)';\n                var new_translate = 'translate(' + Math.round(left) + 'px, ' + Math.round(top) + 'px)';\n                var translateInterpolator = d3.interpolateString(old_translate, new_translate);\n                var is_hidden = tooltip.style('opacity') < 0.1;\n\n                tooltip\n                    .interrupt() // cancel running transitions\n                    .transition()\n                    .duration(is_hidden ? 0 : duration)\n                    // using tween since some versions of d3 can't auto-tween a translate on a div\n                    .styleTween('transform', function (d) {\n                        return translateInterpolator;\n                    }, 'important')\n                    // Safari has its own `-webkit-transform` and does not support `transform`\n                    .styleTween('-webkit-transform', function (d) {\n                        return translateInterpolator;\n                    })\n                    .style('-ms-transform', new_translate)\n                    .style('opacity', 1);\n            }\n\n            lastPosition.left = left;\n            lastPosition.top = top;\n        });\n    };\n\n    // Creates new tooltip container, or uses existing one on DOM.\n    function initTooltip() {\n        if (!tooltip || !tooltip.node()) {\n            // Create new tooltip div if it doesn't exist on DOM.\n\n            var data = [1];\n            tooltip = d3.select(document.body).select('#'+id).data(data);\n\n            tooltip.enter().append('div')\n                   .attr(\"class\", \"nvtooltip \" + (classes ? classes : \"xy-tooltip\"))\n                   .attr(\"id\", id)\n                   .style(\"top\", 0).style(\"left\", 0)\n                   .style('opacity', 0)\n                   .style('position', 'fixed')\n                   .selectAll(\"div, table, td, tr\").classed(nvPointerEventsClass, true)\n                   .classed(nvPointerEventsClass, true);\n\n            tooltip.exit().remove()\n        }\n    }\n\n    // Draw the tooltip onto the DOM.\n    function nvtooltip() {\n        if (!enabled) return;\n        if (!dataSeriesExists(data)) return;\n\n        nv.dom.write(function () {\n            initTooltip();\n            // Generate data and set it into tooltip.\n            // Bonus - If you override contentGenerator and return falsey you can use something like\n            //         React or Knockout to bind the data for your tooltip.\n            var newContent = contentGenerator(data);\n            if (newContent) {\n                tooltip.node().innerHTML = newContent;\n            }\n\n            positionTooltip();\n        });\n\n        return nvtooltip;\n    }\n\n    nvtooltip.nvPointerEventsClass = nvPointerEventsClass;\n    nvtooltip.options = nv.utils.optionsFunc.bind(nvtooltip);\n\n    nvtooltip._options = Object.create({}, {\n        // simple read/write options\n        duration: {get: function(){return duration;}, set: function(_){duration=_;}},\n        gravity: {get: function(){return gravity;}, set: function(_){gravity=_;}},\n        distance: {get: function(){return distance;}, set: function(_){distance=_;}},\n        snapDistance: {get: function(){return snapDistance;}, set: function(_){snapDistance=_;}},\n        classes: {get: function(){return classes;}, set: function(_){classes=_;}},\n        enabled: {get: function(){return enabled;}, set: function(_){enabled=_;}},\n        hideDelay: {get: function(){return hideDelay;}, set: function(_){hideDelay=_;}},\n        contentGenerator: {get: function(){return contentGenerator;}, set: function(_){contentGenerator=_;}},\n        valueFormatter: {get: function(){return valueFormatter;}, set: function(_){valueFormatter=_;}},\n        headerFormatter: {get: function(){return headerFormatter;}, set: function(_){headerFormatter=_;}},\n        keyFormatter: {get: function(){return keyFormatter;}, set: function(_){keyFormatter=_;}},\n        headerEnabled: {get: function(){return headerEnabled;}, set: function(_){headerEnabled=_;}},\n        position: {get: function(){return position;}, set: function(_){position=_;}},\n\n        // Deprecated options\n        chartContainer: {get: function(){return document.body;}, set: function(_){\n            // deprecated after 1.8.3\n            nv.deprecated('chartContainer', 'feature removed after 1.8.3');\n        }},\n        fixedTop: {get: function(){return null;}, set: function(_){\n            // deprecated after 1.8.1\n            nv.deprecated('fixedTop', 'feature removed after 1.8.1');\n        }},\n        offset: {get: function(){return {left: 0, top: 0};}, set: function(_){\n            // deprecated after 1.8.1\n            nv.deprecated('offset', 'use chart.tooltip.distance() instead');\n        }},\n\n        // options with extra logic\n        hidden: {get: function(){return hidden;}, set: function(_){\n            if (hidden != _) {\n                hidden = !!_;\n                nvtooltip();\n            }\n        }},\n        data: {get: function(){return data;}, set: function(_){\n            // if showing a single data point, adjust data format with that\n            if (_.point) {\n                _.value = _.point.x;\n                _.series = _.series || {};\n                _.series.value = _.point.y;\n                _.series.color = _.point.color || _.series.color;\n            }\n            data = _;\n        }},\n\n        // read only properties\n        node: {get: function(){return tooltip.node();}, set: function(_){}},\n        id: {get: function(){return id;}, set: function(_){}}\n    });\n\n    nv.utils.initOptions(nvtooltip);\n    return nvtooltip;\n};\n\n\n/*\nGets the browser window size\n\nReturns object with height and width properties\n */\nnv.utils.windowSize = function() {\n    // Sane defaults\n    var size = {width: 640, height: 480};\n\n    // Most recent browsers use\n    if (window.innerWidth && window.innerHeight) {\n        size.width = window.innerWidth;\n        size.height = window.innerHeight;\n        return (size);\n    }\n\n    // IE can use depending on mode it is in\n    if (document.compatMode=='CSS1Compat' &&\n        document.documentElement &&\n        document.documentElement.offsetWidth ) {\n\n        size.width = document.documentElement.offsetWidth;\n        size.height = document.documentElement.offsetHeight;\n        return (size);\n    }\n\n    // Earlier IE uses Doc.body\n    if (document.body && document.body.offsetWidth) {\n        size.width = document.body.offsetWidth;\n        size.height = document.body.offsetHeight;\n        return (size);\n    }\n\n    return (size);\n};\n\n\n/* handle dumb browser quirks...  isinstance breaks if you use frames\ntypeof returns 'object' for null, NaN is a number, etc.\n */\nnv.utils.isArray = Array.isArray;\nnv.utils.isObject = function(a) {\n    return a !== null && typeof a === 'object';\n};\nnv.utils.isFunction = function(a) {\n    return typeof a === 'function';\n};\nnv.utils.isDate = function(a) {\n    return toString.call(a) === '[object Date]';\n};\nnv.utils.isNumber = function(a) {\n    return !isNaN(a) && typeof a === 'number';\n};\n\n\n/*\nBinds callback function to run when window is resized\n */\nnv.utils.windowResize = function(handler) {\n    if (window.addEventListener) {\n        window.addEventListener('resize', handler);\n    } else {\n        nv.log(\"ERROR: Failed to bind to window.resize with: \", handler);\n    }\n    // return object with clear function to remove the single added callback.\n    return {\n        callback: handler,\n        clear: function() {\n            window.removeEventListener('resize', handler);\n        }\n    }\n};\n\n\n/*\nBackwards compatible way to implement more d3-like coloring of graphs.\nCan take in nothing, an array, or a function/scale\nTo use a normal scale, get the range and pass that because we must be able\nto take two arguments and use the index to keep backward compatibility\n*/\nnv.utils.getColor = function(color) {\n    //if you pass in nothing, get default colors back\n    if (color === undefined) {\n        return nv.utils.defaultColor();\n\n    //if passed an array, turn it into a color scale\n    } else if(nv.utils.isArray(color)) {\n        var color_scale = d3.scale.ordinal().range(color);\n        return function(d, i) {\n            var key = i === undefined ? d : i;\n            return d.color || color_scale(key);\n        };\n\n    //if passed a function or scale, return it, or whatever it may be\n    //external libs, such as angularjs-nvd3-directives use this\n    } else {\n        //can't really help it if someone passes rubbish as color\n        return color;\n    }\n};\n\n\n/*\nDefault color chooser uses a color scale of 20 colors from D3\n https://github.com/mbostock/d3/wiki/Ordinal-Scales#categorical-colors\n */\nnv.utils.defaultColor = function() {\n    // get range of the scale so we'll turn it into our own function.\n    return nv.utils.getColor(d3.scale.category20().range());\n};\n\n\n/*\nReturns a color function that takes the result of 'getKey' for each series and\nlooks for a corresponding color from the dictionary\n*/\nnv.utils.customTheme = function(dictionary, getKey, defaultColors) {\n    // use default series.key if getKey is undefined\n    getKey = getKey || function(series) { return series.key };\n    defaultColors = defaultColors || d3.scale.category20().range();\n\n    // start at end of default color list and walk back to index 0\n    var defIndex = defaultColors.length;\n\n    return function(series, index) {\n        var key = getKey(series);\n        if (nv.utils.isFunction(dictionary[key])) {\n            return dictionary[key]();\n        } else if (dictionary[key] !== undefined) {\n            return dictionary[key];\n        } else {\n            // no match in dictionary, use a default color\n            if (!defIndex) {\n                // used all the default colors, start over\n                defIndex = defaultColors.length;\n            }\n            defIndex = defIndex - 1;\n            return defaultColors[defIndex];\n        }\n    };\n};\n\n\n/*\nFrom the PJAX example on d3js.org, while this is not really directly needed\nit's a very cool method for doing pjax, I may expand upon it a little bit,\nopen to suggestions on anything that may be useful\n*/\nnv.utils.pjax = function(links, content) {\n\n    var load = function(href) {\n        d3.html(href, function(fragment) {\n            var target = d3.select(content).node();\n            target.parentNode.replaceChild(\n                d3.select(fragment).select(content).node(),\n                target);\n            nv.utils.pjax(links, content);\n        });\n    };\n\n    d3.selectAll(links).on(\"click\", function() {\n        history.pushState(this.href, this.textContent, this.href);\n        load(this.href);\n        d3.event.preventDefault();\n    });\n\n    d3.select(window).on(\"popstate\", function() {\n        if (d3.event.state) {\n            load(d3.event.state);\n        }\n    });\n};\n\n\n/*\nFor when we want to approximate the width in pixels for an SVG:text element.\nMost common instance is when the element is in a display:none; container.\nForumla is : text.length * font-size * constant_factor\n*/\nnv.utils.calcApproxTextWidth = function (svgTextElem) {\n    if (nv.utils.isFunction(svgTextElem.style) && nv.utils.isFunction(svgTextElem.text)) {\n        var fontSize = parseInt(svgTextElem.style(\"font-size\").replace(\"px\",\"\"), 10);\n        var textLength = svgTextElem.text().length;\n        return nv.utils.NaNtoZero(textLength * fontSize * 0.5);\n    }\n    return 0;\n};\n\n\n/*\nNumbers that are undefined, null or NaN, convert them to zeros.\n*/\nnv.utils.NaNtoZero = function(n) {\n    if (!nv.utils.isNumber(n)\n        || isNaN(n)\n        || n === null\n        || n === Infinity\n        || n === -Infinity) {\n\n        return 0;\n    }\n    return n;\n};\n\n/*\nAdd a way to watch for d3 transition ends to d3\n*/\nd3.selection.prototype.watchTransition = function(renderWatch){\n    var args = [this].concat([].slice.call(arguments, 1));\n    return renderWatch.transition.apply(renderWatch, args);\n};\n\n\n/*\nHelper object to watch when d3 has rendered something\n*/\nnv.utils.renderWatch = function(dispatch, duration) {\n    if (!(this instanceof nv.utils.renderWatch)) {\n        return new nv.utils.renderWatch(dispatch, duration);\n    }\n\n    var _duration = duration !== undefined ? duration : 250;\n    var renderStack = [];\n    var self = this;\n\n    this.models = function(models) {\n        models = [].slice.call(arguments, 0);\n        models.forEach(function(model){\n            model.__rendered = false;\n            (function(m){\n                m.dispatch.on('renderEnd', function(arg){\n                    m.__rendered = true;\n                    self.renderEnd('model');\n                });\n            })(model);\n\n            if (renderStack.indexOf(model) < 0) {\n                renderStack.push(model);\n            }\n        });\n    return this;\n    };\n\n    this.reset = function(duration) {\n        if (duration !== undefined) {\n            _duration = duration;\n        }\n        renderStack = [];\n    };\n\n    this.transition = function(selection, args, duration) {\n        args = arguments.length > 1 ? [].slice.call(arguments, 1) : [];\n\n        if (args.length > 1) {\n            duration = args.pop();\n        } else {\n            duration = _duration !== undefined ? _duration : 250;\n        }\n        selection.__rendered = false;\n\n        if (renderStack.indexOf(selection) < 0) {\n            renderStack.push(selection);\n        }\n\n        if (duration === 0) {\n            selection.__rendered = true;\n            selection.delay = function() { return this; };\n            selection.duration = function() { return this; };\n            return selection;\n        } else {\n            if (selection.length === 0) {\n                selection.__rendered = true;\n            } else if (selection.every( function(d){ return !d.length; } )) {\n                selection.__rendered = true;\n            } else {\n                selection.__rendered = false;\n            }\n\n            var n = 0;\n            return selection\n                .transition()\n                .duration(duration)\n                .each(function(){ ++n; })\n                .each('end', function(d, i) {\n                    if (--n === 0) {\n                        selection.__rendered = true;\n                        self.renderEnd.apply(this, args);\n                    }\n                });\n        }\n    };\n\n    this.renderEnd = function() {\n        if (renderStack.every( function(d){ return d.__rendered; } )) {\n            renderStack.forEach( function(d){ d.__rendered = false; });\n            dispatch.renderEnd.apply(this, arguments);\n        }\n    }\n\n};\n\n\n/*\nTakes multiple objects and combines them into the first one (dst)\nexample:  nv.utils.deepExtend({a: 1}, {a: 2, b: 3}, {c: 4});\ngives:  {a: 2, b: 3, c: 4}\n*/\nnv.utils.deepExtend = function(dst){\n    var sources = arguments.length > 1 ? [].slice.call(arguments, 1) : [];\n    sources.forEach(function(source) {\n        for (var key in source) {\n            var isArray = nv.utils.isArray(dst[key]);\n            var isObject = nv.utils.isObject(dst[key]);\n            var srcObj = nv.utils.isObject(source[key]);\n\n            if (isObject && !isArray && srcObj) {\n                nv.utils.deepExtend(dst[key], source[key]);\n            } else {\n                dst[key] = source[key];\n            }\n        }\n    });\n};\n\n\n/*\nstate utility object, used to track d3 states in the models\n*/\nnv.utils.state = function(){\n    if (!(this instanceof nv.utils.state)) {\n        return new nv.utils.state();\n    }\n    var state = {};\n    var _self = this;\n    var _setState = function(){};\n    var _getState = function(){ return {}; };\n    var init = null;\n    var changed = null;\n\n    this.dispatch = d3.dispatch('change', 'set');\n\n    this.dispatch.on('set', function(state){\n        _setState(state, true);\n    });\n\n    this.getter = function(fn){\n        _getState = fn;\n        return this;\n    };\n\n    this.setter = function(fn, callback) {\n        if (!callback) {\n            callback = function(){};\n        }\n        _setState = function(state, update){\n            fn(state);\n            if (update) {\n                callback();\n            }\n        };\n        return this;\n    };\n\n    this.init = function(state){\n        init = init || {};\n        nv.utils.deepExtend(init, state);\n    };\n\n    var _set = function(){\n        var settings = _getState();\n\n        if (JSON.stringify(settings) === JSON.stringify(state)) {\n            return false;\n        }\n\n        for (var key in settings) {\n            if (state[key] === undefined) {\n                state[key] = {};\n            }\n            state[key] = settings[key];\n            changed = true;\n        }\n        return true;\n    };\n\n    this.update = function(){\n        if (init) {\n            _setState(init, false);\n            init = null;\n        }\n        if (_set.call(this)) {\n            this.dispatch.change(state);\n        }\n    };\n\n};\n\n\n/*\nSnippet of code you can insert into each nv.models.* to give you the ability to\ndo things like:\nchart.options({\n  showXAxis: true,\n  tooltips: true\n});\n\nTo enable in the chart:\nchart.options = nv.utils.optionsFunc.bind(chart);\n*/\nnv.utils.optionsFunc = function(args) {\n    if (args) {\n        d3.map(args).forEach((function(key,value) {\n            if (nv.utils.isFunction(this[key])) {\n                this[key](value);\n            }\n        }).bind(this));\n    }\n    return this;\n};\n\n\n/*\nnumTicks:  requested number of ticks\ndata:  the chart data\n\nreturns the number of ticks to actually use on X axis, based on chart data\nto avoid duplicate ticks with the same value\n*/\nnv.utils.calcTicksX = function(numTicks, data) {\n    // find max number of values from all data streams\n    var numValues = 1;\n    var i = 0;\n    for (i; i < data.length; i += 1) {\n        var stream_len = data[i] && data[i].values ? data[i].values.length : 0;\n        numValues = stream_len > numValues ? stream_len : numValues;\n    }\n    nv.log(\"Requested number of ticks: \", numTicks);\n    nv.log(\"Calculated max values to be: \", numValues);\n    // make sure we don't have more ticks than values to avoid duplicates\n    numTicks = numTicks > numValues ? numTicks = numValues - 1 : numTicks;\n    // make sure we have at least one tick\n    numTicks = numTicks < 1 ? 1 : numTicks;\n    // make sure it's an integer\n    numTicks = Math.floor(numTicks);\n    nv.log(\"Calculating tick count as: \", numTicks);\n    return numTicks;\n};\n\n\n/*\nreturns number of ticks to actually use on Y axis, based on chart data\n*/\nnv.utils.calcTicksY = function(numTicks, data) {\n    // currently uses the same logic but we can adjust here if needed later\n    return nv.utils.calcTicksX(numTicks, data);\n};\n\n\n/*\nAdd a particular option from an options object onto chart\nOptions exposed on a chart are a getter/setter function that returns chart\non set to mimic typical d3 option chaining, e.g. svg.option1('a').option2('b');\n\noption objects should be generated via Object.create() to provide\nthe option of manipulating data via get/set functions.\n*/\nnv.utils.initOption = function(chart, name) {\n    // if it's a call option, just call it directly, otherwise do get/set\n    if (chart._calls && chart._calls[name]) {\n        chart[name] = chart._calls[name];\n    } else {\n        chart[name] = function (_) {\n            if (!arguments.length) return chart._options[name];\n            chart._overrides[name] = true;\n            chart._options[name] = _;\n            return chart;\n        };\n        // calling the option as _option will ignore if set by option already\n        // so nvd3 can set options internally but the stop if set manually\n        chart['_' + name] = function(_) {\n            if (!arguments.length) return chart._options[name];\n            if (!chart._overrides[name]) {\n                chart._options[name] = _;\n            }\n            return chart;\n        }\n    }\n};\n\n\n/*\nAdd all options in an options object to the chart\n*/\nnv.utils.initOptions = function(chart) {\n    chart._overrides = chart._overrides || {};\n    var ops = Object.getOwnPropertyNames(chart._options || {});\n    var calls = Object.getOwnPropertyNames(chart._calls || {});\n    ops = ops.concat(calls);\n    for (var i in ops) {\n        nv.utils.initOption(chart, ops[i]);\n    }\n};\n\n\n/*\nInherit options from a D3 object\nd3.rebind makes calling the function on target actually call it on source\nAlso use _d3options so we can track what we inherit for documentation and chained inheritance\n*/\nnv.utils.inheritOptionsD3 = function(target, d3_source, oplist) {\n    target._d3options = oplist.concat(target._d3options || []);\n    oplist.unshift(d3_source);\n    oplist.unshift(target);\n    d3.rebind.apply(this, oplist);\n};\n\n\n/*\nRemove duplicates from an array\n*/\nnv.utils.arrayUnique = function(a) {\n    return a.sort().filter(function(item, pos) {\n        return !pos || item != a[pos - 1];\n    });\n};\n\n\n/*\nKeeps a list of custom symbols to draw from in addition to d3.svg.symbol\nNecessary since d3 doesn't let you extend its list -_-\nAdd new symbols by doing nv.utils.symbols.set('name', function(size){...});\n*/\nnv.utils.symbolMap = d3.map();\n\n\n/*\nReplaces d3.svg.symbol so that we can look both there and our own map\n */\nnv.utils.symbol = function() {\n    var type,\n        size = 64;\n    function symbol(d,i) {\n        var t = type.call(this,d,i);\n        var s = size.call(this,d,i);\n        if (d3.svg.symbolTypes.indexOf(t) !== -1) {\n            return d3.svg.symbol().type(t).size(s)();\n        } else {\n            return nv.utils.symbolMap.get(t)(s);\n        }\n    }\n    symbol.type = function(_) {\n        if (!arguments.length) return type;\n        type = d3.functor(_);\n        return symbol;\n    };\n    symbol.size = function(_) {\n        if (!arguments.length) return size;\n        size = d3.functor(_);\n        return symbol;\n    };\n    return symbol;\n};\n\n\n/*\nInherit option getter/setter functions from source to target\nd3.rebind makes calling the function on target actually call it on source\nAlso track via _inherited and _d3options so we can track what we inherit\nfor documentation generation purposes and chained inheritance\n*/\nnv.utils.inheritOptions = function(target, source) {\n    // inherit all the things\n    var ops = Object.getOwnPropertyNames(source._options || {});\n    var calls = Object.getOwnPropertyNames(source._calls || {});\n    var inherited = source._inherited || [];\n    var d3ops = source._d3options || [];\n    var args = ops.concat(calls).concat(inherited).concat(d3ops);\n    args.unshift(source);\n    args.unshift(target);\n    d3.rebind.apply(this, args);\n    // pass along the lists to keep track of them, don't allow duplicates\n    target._inherited = nv.utils.arrayUnique(ops.concat(calls).concat(inherited).concat(ops).concat(target._inherited || []));\n    target._d3options = nv.utils.arrayUnique(d3ops.concat(target._d3options || []));\n};\n\n\n/*\nRuns common initialize code on the svg before the chart builds\n*/\nnv.utils.initSVG = function(svg) {\n    svg.classed({'nvd3-svg':true});\n};\n\n\n/*\nSanitize and provide default for the container height.\n*/\nnv.utils.sanitizeHeight = function(height, container) {\n    return (height || parseInt(container.style('height'), 10) || 400);\n};\n\n\n/*\nSanitize and provide default for the container width.\n*/\nnv.utils.sanitizeWidth = function(width, container) {\n    return (width || parseInt(container.style('width'), 10) || 960);\n};\n\n\n/*\nCalculate the available height for a chart.\n*/\nnv.utils.availableHeight = function(height, container, margin) {\n    return Math.max(0,nv.utils.sanitizeHeight(height, container) - margin.top - margin.bottom);\n};\n\n/*\nCalculate the available width for a chart.\n*/\nnv.utils.availableWidth = function(width, container, margin) {\n    return Math.max(0,nv.utils.sanitizeWidth(width, container) - margin.left - margin.right);\n};\n\n/*\nClear any rendered chart components and display a chart's 'noData' message\n*/\nnv.utils.noData = function(chart, container) {\n    var opt = chart.options(),\n        margin = opt.margin(),\n        noData = opt.noData(),\n        data = (noData == null) ? [\"No Data Available.\"] : [noData],\n        height = nv.utils.availableHeight(null, container, margin),\n        width = nv.utils.availableWidth(null, container, margin),\n        x = margin.left + width/2,\n        y = margin.top + height/2;\n\n    //Remove any previously created chart components\n    container.selectAll('g').remove();\n\n    var noDataText = container.selectAll('.nv-noData').data(data);\n\n    noDataText.enter().append('text')\n        .attr('class', 'nvd3 nv-noData')\n        .attr('dy', '-.7em')\n        .style('text-anchor', 'middle');\n\n    noDataText\n        .attr('x', x)\n        .attr('y', y)\n        .text(function(t){ return t; });\n};\n\n/*\n Wrap long labels.\n */\nnv.utils.wrapTicks = function (text, width) {\n    text.each(function() {\n        var text = d3.select(this),\n            words = text.text().split(/\\s+/).reverse(),\n            word,\n            line = [],\n            lineNumber = 0,\n            lineHeight = 1.1,\n            y = text.attr(\"y\"),\n            dy = parseFloat(text.attr(\"dy\")),\n            tspan = text.text(null).append(\"tspan\").attr(\"x\", 0).attr(\"y\", y).attr(\"dy\", dy + \"em\");\n        while (word = words.pop()) {\n            line.push(word);\n            tspan.text(line.join(\" \"));\n            if (tspan.node().getComputedTextLength() > width) {\n                line.pop();\n                tspan.text(line.join(\" \"));\n                line = [word];\n                tspan = text.append(\"tspan\").attr(\"x\", 0).attr(\"y\", y).attr(\"dy\", ++lineNumber * lineHeight + dy + \"em\").text(word);\n            }\n        }\n    });\n};\n\n/*\nCheck equality of 2 array\n*/\nnv.utils.arrayEquals = function (array1, array2) {\n    if (array1 === array2)\n        return true;\n\n    if (!array1 || !array2)\n        return false;\n\n    // compare lengths - can save a lot of time\n    if (array1.length != array2.length)\n        return false;\n\n    for (var i = 0,\n        l = array1.length; i < l; i++) {\n        // Check if we have nested arrays\n        if (array1[i] instanceof Array && array2[i] instanceof Array) {\n            // recurse into the nested arrays\n            if (!nv.arrayEquals(array1[i], array2[i]))\n                return false;\n        } else if (array1[i] != array2[i]) {\n            // Warning - two different object instances will never be equal: {x:20} != {x:20}\n            return false;\n        }\n    }\n    return true;\n};\nnv.models.axis = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var axis = d3.svg.axis();\n    var scale = d3.scale.linear();\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 75 //only used for tickLabel currently\n        , height = 60 //only used for tickLabel currently\n        , axisLabelText = null\n        , showMaxMin = true //TODO: showMaxMin should be disabled on all ordinal scaled axes\n        , rotateLabels = 0\n        , rotateYLabel = true\n        , staggerLabels = false\n        , isOrdinal = false\n        , ticks = null\n        , axisLabelDistance = 0\n        , fontSize = undefined\n        , duration = 250\n        , dispatch = d3.dispatch('renderEnd')\n        ;\n    axis\n        .scale(scale)\n        .orient('bottom')\n        .tickFormat(function(d) { return d })\n    ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var scale0;\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-axis').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-axis');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            if (ticks !== null)\n                axis.ticks(ticks);\n            else if (axis.orient() == 'top' || axis.orient() == 'bottom')\n                axis.ticks(Math.abs(scale.range()[1] - scale.range()[0]) / 100);\n\n            //TODO: consider calculating width/height based on whether or not label is added, for reference in charts using this component\n            g.watchTransition(renderWatch, 'axis').call(axis);\n\n            scale0 = scale0 || axis.scale();\n\n            var fmt = axis.tickFormat();\n            if (fmt == null) {\n                fmt = scale0.tickFormat();\n            }\n\n            var axisLabel = g.selectAll('text.nv-axislabel')\n                .data([axisLabelText || null]);\n            axisLabel.exit().remove();\n\n            //only skip when fontSize is undefined so it can be cleared with a null or blank string\n            if (fontSize !== undefined) {\n                g.selectAll('g').select(\"text\").style('font-size', fontSize);\n            }\n\n            var xLabelMargin;\n            var axisMaxMin;\n            var w;\n            switch (axis.orient()) {\n                case 'top':\n                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n                  w = 0;\n                  if (scale.range().length === 1) {\n                    w = isOrdinal ? scale.range()[0] * 2 + scale.rangeBand() : 0;\n                  } else if (scale.range().length === 2) {\n                    w = isOrdinal ? scale.range()[0] + scale.range()[1] + scale.rangeBand() : scale.range()[1];\n                  } else if ( scale.range().length > 2){\n                    w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);\n                  };\n                    axisLabel\n                        .attr('text-anchor', 'middle')\n                        .attr('y', 0)\n                        .attr('x', w/2);\n                    if (showMaxMin) {\n                        axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')\n                            .data(scale.domain());\n                        axisMaxMin.enter().append('g').attr('class',function(d,i){\n                                return ['nv-axisMaxMin','nv-axisMaxMin-x',(i == 0 ? 'nv-axisMin-x':'nv-axisMax-x')].join(' ')\n                        }).append('text');\n                        axisMaxMin.exit().remove();\n                        axisMaxMin\n                            .attr('transform', function(d,i) {\n                                return 'translate(' + nv.utils.NaNtoZero(scale(d)) + ',0)'\n                            })\n                            .select('text')\n                            .attr('dy', '-0.5em')\n                            .attr('y', -axis.tickPadding())\n                            .attr('text-anchor', 'middle')\n                            .text(function(d,i) {\n                                var v = fmt(d);\n                                return ('' + v).match('NaN') ? '' : v;\n                            });\n                        axisMaxMin.watchTransition(renderWatch, 'min-max top')\n                            .attr('transform', function(d,i) {\n                                return 'translate(' + nv.utils.NaNtoZero(scale.range()[i]) + ',0)'\n                            });\n                    }\n                    break;\n                case 'bottom':\n                    xLabelMargin = axisLabelDistance + 36;\n                    var maxTextWidth = 30;\n                    var textHeight = 0;\n                    var xTicks = g.selectAll('g').select(\"text\");\n                    var rotateLabelsRule = '';\n                    if (rotateLabels%360) {\n                        //Reset transform on ticks so textHeight can be calculated correctly\n                        xTicks.attr('transform', ''); \n                        //Calculate the longest xTick width\n                        xTicks.each(function(d,i){\n                            var box = this.getBoundingClientRect();\n                            var width = box.width;\n                            textHeight = box.height;\n                            if(width > maxTextWidth) maxTextWidth = width;\n                        });\n                        rotateLabelsRule = 'rotate(' + rotateLabels + ' 0,' + (textHeight/2 + axis.tickPadding()) + ')';\n                        //Convert to radians before calculating sin. Add 30 to margin for healthy padding.\n                        var sin = Math.abs(Math.sin(rotateLabels*Math.PI/180));\n                        xLabelMargin = (sin ? sin*maxTextWidth : maxTextWidth)+30;\n                        //Rotate all xTicks\n                        xTicks\n                            .attr('transform', rotateLabelsRule)\n                            .style('text-anchor', rotateLabels%360 > 0 ? 'start' : 'end');\n                    } else {\n                        if (staggerLabels) {\n                            xTicks\n                                .attr('transform', function(d,i) {\n                                    return 'translate(0,' + (i % 2 == 0 ? '0' : '12') + ')'\n                                });\n                        } else {\n                            xTicks.attr('transform', \"translate(0,0)\");\n                        }\n                    }\n                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n                    w = 0;\n                    if (scale.range().length === 1) {\n                        w = isOrdinal ? scale.range()[0] * 2 + scale.rangeBand() : 0;\n                    } else if (scale.range().length === 2) {\n                        w = isOrdinal ? scale.range()[0] + scale.range()[1] + scale.rangeBand() : scale.range()[1];\n                    } else if ( scale.range().length > 2){\n                        w = scale.range()[scale.range().length-1]+(scale.range()[1]-scale.range()[0]);\n                    };\n                    axisLabel\n                        .attr('text-anchor', 'middle')\n                        .attr('y', xLabelMargin)\n                        .attr('x', w/2);\n                    if (showMaxMin) {\n                        //if (showMaxMin && !isOrdinal) {\n                        axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')\n                            //.data(scale.domain())\n                            .data([scale.domain()[0], scale.domain()[scale.domain().length - 1]]);\n                        axisMaxMin.enter().append('g').attr('class',function(d,i){\n                                return ['nv-axisMaxMin','nv-axisMaxMin-x',(i == 0 ? 'nv-axisMin-x':'nv-axisMax-x')].join(' ')\n                        }).append('text');\n                        axisMaxMin.exit().remove();\n                        axisMaxMin\n                            .attr('transform', function(d,i) {\n                                return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'\n                            })\n                            .select('text')\n                            .attr('dy', '.71em')\n                            .attr('y', axis.tickPadding())\n                            .attr('transform', rotateLabelsRule)\n                            .style('text-anchor', rotateLabels ? (rotateLabels%360 > 0 ? 'start' : 'end') : 'middle')\n                            .text(function(d,i) {\n                                var v = fmt(d);\n                                return ('' + v).match('NaN') ? '' : v;\n                            });\n                        axisMaxMin.watchTransition(renderWatch, 'min-max bottom')\n                            .attr('transform', function(d,i) {\n                                return 'translate(' + nv.utils.NaNtoZero((scale(d) + (isOrdinal ? scale.rangeBand() / 2 : 0))) + ',0)'\n                            });\n                    }\n\n                    break;\n                case 'right':\n                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n                    axisLabel\n                        .style('text-anchor', rotateYLabel ? 'middle' : 'begin')\n                        .attr('transform', rotateYLabel ? 'rotate(90)' : '')\n                        .attr('y', rotateYLabel ? (-Math.max(margin.right, width) + 12 - (axisLabelDistance || 0)) : -10) //TODO: consider calculating this based on largest tick width... OR at least expose this on chart\n                        .attr('x', rotateYLabel ? (d3.max(scale.range()) / 2) : axis.tickPadding());\n                    if (showMaxMin) {\n                        axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')\n                            .data(scale.domain());\n                       \taxisMaxMin.enter().append('g').attr('class',function(d,i){\n                                return ['nv-axisMaxMin','nv-axisMaxMin-y',(i == 0 ? 'nv-axisMin-y':'nv-axisMax-y')].join(' ')\n                        }).append('text')\n                            .style('opacity', 0);\n                        axisMaxMin.exit().remove();\n                        axisMaxMin\n                            .attr('transform', function(d,i) {\n                                return 'translate(0,' + nv.utils.NaNtoZero(scale(d)) + ')'\n                            })\n                            .select('text')\n                            .attr('dy', '.32em')\n                            .attr('y', 0)\n                            .attr('x', axis.tickPadding())\n                            .style('text-anchor', 'start')\n                            .text(function(d, i) {\n                                var v = fmt(d);\n                                return ('' + v).match('NaN') ? '' : v;\n                            });\n                        axisMaxMin.watchTransition(renderWatch, 'min-max right')\n                            .attr('transform', function(d,i) {\n                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'\n                            })\n                            .select('text')\n                            .style('opacity', 1);\n                    }\n                    break;\n                case 'left':\n                    /*\n                     //For dynamically placing the label. Can be used with dynamically-sized chart axis margins\n                     var yTicks = g.selectAll('g').select(\"text\");\n                     yTicks.each(function(d,i){\n                     var labelPadding = this.getBoundingClientRect().width + axis.tickPadding() + 16;\n                     if(labelPadding > width) width = labelPadding;\n                     });\n                     */\n                    axisLabel.enter().append('text').attr('class', 'nv-axislabel');\n                    axisLabel\n                        .style('text-anchor', rotateYLabel ? 'middle' : 'end')\n                        .attr('transform', rotateYLabel ? 'rotate(-90)' : '')\n                        .attr('y', rotateYLabel ? (-Math.max(margin.left, width) + 25 - (axisLabelDistance || 0)) : -10)\n                        .attr('x', rotateYLabel ? (-d3.max(scale.range()) / 2) : -axis.tickPadding());\n                    if (showMaxMin) {\n                        axisMaxMin = wrap.selectAll('g.nv-axisMaxMin')\n                            .data(scale.domain());\n                        axisMaxMin.enter().append('g').attr('class',function(d,i){\n                                return ['nv-axisMaxMin','nv-axisMaxMin-y',(i == 0 ? 'nv-axisMin-y':'nv-axisMax-y')].join(' ')\n                        }).append('text')\n                            .style('opacity', 0);\n                        axisMaxMin.exit().remove();\n                        axisMaxMin\n                            .attr('transform', function(d,i) {\n                                return 'translate(0,' + nv.utils.NaNtoZero(scale0(d)) + ')'\n                            })\n                            .select('text')\n                            .attr('dy', '.32em')\n                            .attr('y', 0)\n                            .attr('x', -axis.tickPadding())\n                            .attr('text-anchor', 'end')\n                            .text(function(d,i) {\n                                var v = fmt(d);\n                                return ('' + v).match('NaN') ? '' : v;\n                            });\n                        axisMaxMin.watchTransition(renderWatch, 'min-max right')\n                            .attr('transform', function(d,i) {\n                                return 'translate(0,' + nv.utils.NaNtoZero(scale.range()[i]) + ')'\n                            })\n                            .select('text')\n                            .style('opacity', 1);\n                    }\n                    break;\n            }\n            axisLabel.text(function(d) { return d });\n\n            if (showMaxMin && (axis.orient() === 'left' || axis.orient() === 'right')) {\n                //check if max and min overlap other values, if so, hide the values that overlap\n                g.selectAll('g') // the g's wrapping each tick\n                    .each(function(d,i) {\n                        d3.select(this).select('text').attr('opacity', 1);\n                        if (scale(d) < scale.range()[1] + 10 || scale(d) > scale.range()[0] - 10) { // 10 is assuming text height is 16... if d is 0, leave it!\n                            if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL\n                                d3.select(this).attr('opacity', 0);\n\n                            d3.select(this).select('text').attr('opacity', 0); // Don't remove the ZERO line!!\n                        }\n                    });\n\n                //if Max and Min = 0 only show min, Issue #281\n                if (scale.domain()[0] == scale.domain()[1] && scale.domain()[0] == 0) {\n                    wrap.selectAll('g.nv-axisMaxMin').style('opacity', function (d, i) {\n                        return !i ? 1 : 0\n                    });\n                }\n            }\n\n            if (showMaxMin && (axis.orient() === 'top' || axis.orient() === 'bottom')) {\n                var maxMinRange = [];\n                wrap.selectAll('g.nv-axisMaxMin')\n                    .each(function(d,i) {\n                        try {\n                            if (i) // i== 1, max position\n                                maxMinRange.push(scale(d) - this.getBoundingClientRect().width - 4);  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)\n                            else // i==0, min position\n                                maxMinRange.push(scale(d) + this.getBoundingClientRect().width + 4)\n                        }catch (err) {\n                            if (i) // i== 1, max position\n                                maxMinRange.push(scale(d) - 4);  //assuming the max and min labels are as wide as the next tick (with an extra 4 pixels just in case)\n                            else // i==0, min position\n                                maxMinRange.push(scale(d) + 4);\n                        }\n                    });\n                // the g's wrapping each tick\n                g.selectAll('g').each(function(d, i) {\n                    if (scale(d) < maxMinRange[0] || scale(d) > maxMinRange[1]) {\n                        if (d > 1e-10 || d < -1e-10) // accounts for minor floating point errors... though could be problematic if the scale is EXTREMELY SMALL\n                            d3.select(this).remove();\n                        else\n                            d3.select(this).select('text').remove(); // Don't remove the ZERO line!!\n                    }\n                });\n            }\n\n            //Highlight zero tick line\n            g.selectAll('.tick')\n                .filter(function (d) {\n                    /*\n                    The filter needs to return only ticks at or near zero.\n                    Numbers like 0.00001 need to count as zero as well,\n                    and the arithmetic trick below solves that.\n                    */\n                    return !parseFloat(Math.round(d * 100000) / 1000000) && (d !== undefined)\n                }) \n                .classed('zero', true);\n            \n            //store old scales for use in transitions on update\n            scale0 = scale.copy();\n\n        });\n\n        renderWatch.renderEnd('axis immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.axis = axis;\n    chart.dispatch = dispatch;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        axisLabelDistance: {get: function(){return axisLabelDistance;}, set: function(_){axisLabelDistance=_;}},\n        staggerLabels:     {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},\n        rotateLabels:      {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},\n        rotateYLabel:      {get: function(){return rotateYLabel;}, set: function(_){rotateYLabel=_;}},\n        showMaxMin:        {get: function(){return showMaxMin;}, set: function(_){showMaxMin=_;}},\n        axisLabel:         {get: function(){return axisLabelText;}, set: function(_){axisLabelText=_;}},\n        height:            {get: function(){return height;}, set: function(_){height=_;}},\n        ticks:             {get: function(){return ticks;}, set: function(_){ticks=_;}},\n        width:             {get: function(){return width;}, set: function(_){width=_;}},\n        fontSize:          {get: function(){return fontSize;}, set: function(_){fontSize=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top !== undefined    ? _.top    : margin.top;\n            margin.right  = _.right !== undefined  ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left !== undefined   ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration=_;\n            renderWatch.reset(duration);\n        }},\n        scale: {get: function(){return scale;}, set: function(_){\n            scale = _;\n            axis.scale(scale);\n            isOrdinal = typeof scale.rangeBands === 'function';\n            nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    nv.utils.inheritOptionsD3(chart, axis, ['orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat']);\n    nv.utils.inheritOptionsD3(chart, scale, ['domain', 'range', 'rangeBand', 'rangeBands']);\n\n    return chart;\n};\nnv.models.boxPlot = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0},\n        width = 960,\n        height = 500,\n        id = Math.floor(Math.random() * 10000), // Create semi-unique ID in case user doesn't select one\n        xScale = d3.scale.ordinal(),\n        yScale = d3.scale.linear(),\n        getX  = function(d) { return d.label }, // Default data model selectors.\n        getQ1 = function(d) { return d.values.Q1 },\n        getQ2 = function(d) { return d.values.Q2 },\n        getQ3 = function(d) { return d.values.Q3 },\n        getWl = function(d) { return d.values.whisker_low },\n        getWh = function(d) { return d.values.whisker_high },\n        getColor = function(d) { return d.color },\n        getOlItems  = function(d) { return d.values.outliers },\n        getOlValue = function(d, i, j) { return d },\n        getOlLabel = function(d, i, j) { return d },\n        getOlColor = function(d, i, j) { return undefined },\n        color = nv.utils.defaultColor(),\n        container = null,\n        xDomain, xRange,\n        yDomain, yRange,\n        dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd'),\n        duration = 250,\n        maxBoxWidth = null;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var xScale0, yScale0;\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            // Setup Scales\n            xScale.domain(xDomain || data.map(function(d,i) { return getX(d,i); }))\n                .rangeBands(xRange || [0, availableWidth], 0.1);\n\n            // if we know yDomain, no need to calculate\n            var yData = []\n            if (!yDomain) {\n                // (y-range is based on quartiles, whiskers and outliers)\n                var values = [], yMin, yMax;\n                data.forEach(function (d, i) {\n                    var q1 = getQ1(d), q3 = getQ3(d), wl = getWl(d), wh = getWh(d);\n                    var olItems = getOlItems(d);\n                    if (olItems) {\n                        olItems.forEach(function (e, i) {\n                            values.push(getOlValue(e, i, undefined));\n                        });\n                    }\n                    if (wl) { values.push(wl) }\n                    if (q1) { values.push(q1) }\n                    if (q3) { values.push(q3) }\n                    if (wh) { values.push(wh) }\n                });\n                yMin = d3.min(values);\n                yMax = d3.max(values);\n                yData = [ yMin, yMax ] ;\n            }\n\n            yScale.domain(yDomain || yData);\n            yScale.range(yRange || [availableHeight, 0]);\n\n            //store old scales if they exist\n            xScale0 = xScale0 || xScale;\n            yScale0 = yScale0 || yScale.copy().range([yScale(0),yScale(0)]);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap');\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            var boxplots = wrap.selectAll('.nv-boxplot').data(function(d) { return d });\n            var boxEnter = boxplots.enter().append('g').style('stroke-opacity', 1e-6).style('fill-opacity', 1e-6);\n            boxplots\n                .attr('class', 'nv-boxplot')\n                .attr('transform', function(d,i,j) { return 'translate(' + (xScale(getX(d,i)) + xScale.rangeBand() * 0.05) + ', 0)'; })\n                .classed('hover', function(d) { return d.hover });\n            boxplots\n                .watchTransition(renderWatch, 'nv-boxplot: boxplots')\n                .style('stroke-opacity', 1)\n                .style('fill-opacity', 0.75)\n                .delay(function(d,i) { return i * duration / data.length })\n                .attr('transform', function(d,i) {\n                    return 'translate(' + (xScale(getX(d,i)) + xScale.rangeBand() * 0.05) + ', 0)';\n                });\n            boxplots.exit().remove();\n\n            // ----- add the SVG elements for each boxPlot -----\n\n            // conditionally append whisker lines\n            boxEnter.each(function(d,i) {\n                var box = d3.select(this);\n                [getWl, getWh].forEach(function (f) {\n                    if (f(d) !== undefined && f(d) !== null) {\n                        var key = (f === getWl) ? 'low' : 'high';\n                        box.append('line')\n                          .style('stroke', getColor(d) || color(d,i))\n                          .attr('class', 'nv-boxplot-whisker nv-boxplot-' + key);\n                        box.append('line')\n                          .style('stroke', getColor(d) || color(d,i))\n                          .attr('class', 'nv-boxplot-tick nv-boxplot-' + key);\n                    }\n                });\n            });\n\n            var box_width = function() { return (maxBoxWidth === null ? xScale.rangeBand() * 0.9 : Math.min(75, xScale.rangeBand() * 0.9)); };\n            var box_left  = function() { return xScale.rangeBand() * 0.45 - box_width()/2; };\n            var box_right = function() { return xScale.rangeBand() * 0.45 + box_width()/2; };\n\n            // update whisker lines and ticks\n            [getWl, getWh].forEach(function (f) {\n                var key = (f === getWl) ? 'low' : 'high';\n                var endpoint = (f === getWl) ? getQ1 : getQ3;\n                boxplots.select('line.nv-boxplot-whisker.nv-boxplot-' + key)\n                  .watchTransition(renderWatch, 'nv-boxplot: boxplots')\n                    .attr('x1', xScale.rangeBand() * 0.45 )\n                    .attr('y1', function(d,i) { return yScale(f(d)); })\n                    .attr('x2', xScale.rangeBand() * 0.45 )\n                    .attr('y2', function(d,i) { return yScale(endpoint(d)); });\n                boxplots.select('line.nv-boxplot-tick.nv-boxplot-' + key)\n                  .watchTransition(renderWatch, 'nv-boxplot: boxplots')\n                    .attr('x1', box_left )\n                    .attr('y1', function(d,i) { return yScale(f(d)); })\n                    .attr('x2', box_right )\n                    .attr('y2', function(d,i) { return yScale(f(d)); });\n            });\n\n            [getWl, getWh].forEach(function (f) {\n                var key = (f === getWl) ? 'low' : 'high';\n                boxEnter.selectAll('.nv-boxplot-' + key)\n                  .on('mouseover', function(d,i,j) {\n                      d3.select(this).classed('hover', true);\n                      dispatch.elementMouseover({\n                          series: { key: f(d), color: getColor(d) || color(d,j) },\n                          e: d3.event\n                      });\n                  })\n                  .on('mouseout', function(d,i,j) {\n                      d3.select(this).classed('hover', false);\n                      dispatch.elementMouseout({\n                          series: { key: f(d), color: getColor(d) || color(d,j) },\n                          e: d3.event\n                      });\n                  })\n                  .on('mousemove', function(d,i) {\n                      dispatch.elementMousemove({e: d3.event});\n                  });\n            });\n\n            // boxes\n            boxEnter.append('rect')\n                .attr('class', 'nv-boxplot-box')\n                // tooltip events\n                .on('mouseover', function(d,i) {\n                    d3.select(this).classed('hover', true);\n                    dispatch.elementMouseover({\n                        key: getX(d),\n                        value: getX(d),\n                        series: [\n                            { key: 'Q3', value: getQ3(d), color: getColor(d) || color(d,i) },\n                            { key: 'Q2', value: getQ2(d), color: getColor(d) || color(d,i) },\n                            { key: 'Q1', value: getQ1(d), color: getColor(d) || color(d,i) }\n                        ],\n                        data: d,\n                        index: i,\n                        e: d3.event\n                    });\n                })\n                .on('mouseout', function(d,i) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.elementMouseout({\n                        key: getX(d),\n                        value: getX(d),\n                        series: [\n                            { key: 'Q3', value: getQ3(d), color: getColor(d) || color(d,i) },\n                            { key: 'Q2', value: getQ2(d), color: getColor(d) || color(d,i) },\n                            { key: 'Q1', value: getQ1(d), color: getColor(d) || color(d,i) }\n                        ],\n                        data: d,\n                        index: i,\n                        e: d3.event\n                    });\n                })\n                .on('mousemove', function(d,i) {\n                    dispatch.elementMousemove({e: d3.event});\n                });\n\n            // box transitions\n            boxplots.select('rect.nv-boxplot-box')\n              .watchTransition(renderWatch, 'nv-boxplot: boxes')\n                .attr('y', function(d,i) { return yScale(getQ3(d)); })\n                .attr('width', box_width)\n                .attr('x', box_left )\n                .attr('height', function(d,i) { return Math.abs(yScale(getQ3(d)) - yScale(getQ1(d))) || 1 })\n                .style('fill', function(d,i) { return getColor(d) || color(d,i) })\n                .style('stroke', function(d,i) { return getColor(d) || color(d,i) });\n\n            // median line\n            boxEnter.append('line').attr('class', 'nv-boxplot-median');\n\n            boxplots.select('line.nv-boxplot-median')\n              .watchTransition(renderWatch, 'nv-boxplot: boxplots line')\n                .attr('x1', box_left)\n                .attr('y1', function(d,i) { return yScale(getQ2(d)); })\n                .attr('x2', box_right)\n                .attr('y2', function(d,i) { return yScale(getQ2(d)); });\n\n            // outliers\n            var outliers = boxplots.selectAll('.nv-boxplot-outlier').data(function(d) {\n                return getOlItems(d) || [];\n            });\n            outliers.enter().append('circle')\n                .style('fill', function(d,i,j) { return getOlColor(d,i,j) || color(d,j) })\n                .style('stroke', function(d,i,j) { return getOlColor(d,i,j) || color(d,j) })\n                .style('z-index', 9000)\n                .on('mouseover', function(d,i,j) {\n                    d3.select(this).classed('hover', true);\n                    dispatch.elementMouseover({\n                        series: { key: getOlLabel(d,i,j), color: getOlColor(d,i,j) || color(d,j) },\n                        e: d3.event\n                    });\n                })\n                .on('mouseout', function(d,i,j) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.elementMouseout({\n                        series: { key: getOlLabel(d,i,j), color: getOlColor(d,i,j) || color(d,j) },\n                        e: d3.event\n                    });\n                })\n                .on('mousemove', function(d,i) {\n                    dispatch.elementMousemove({e: d3.event});\n                });\n            outliers.attr('class', 'nv-boxplot-outlier');\n            outliers\n              .watchTransition(renderWatch, 'nv-boxplot: nv-boxplot-outlier')\n                .attr('cx', xScale.rangeBand() * 0.45)\n                .attr('cy', function(d,i,j) { return yScale(getOlValue(d,i,j)); })\n                .attr('r', '3');\n            outliers.exit().remove();\n\n            //store old scales for use in transitions on update\n            xScale0 = xScale.copy();\n            yScale0 = yScale.copy();\n        });\n\n        renderWatch.renderEnd('nv-boxplot immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:       {get: function(){return width;}, set: function(_){width=_;}},\n        height:      {get: function(){return height;}, set: function(_){height=_;}},\n        maxBoxWidth: {get: function(){return maxBoxWidth;}, set: function(_){maxBoxWidth=_;}},\n        x:           {get: function(){return getX;}, set: function(_){getX=_;}},\n        q1: {get: function(){return getQ1;}, set: function(_){getQ1=_;}},\n        q2: {get: function(){return getQ2;}, set: function(_){getQ2=_;}},\n        q3: {get: function(){return getQ3;}, set: function(_){getQ3=_;}},\n        wl: {get: function(){return getWl;}, set: function(_){getWl=_;}},\n        wh: {get: function(){return getWh;}, set: function(_){getWh=_;}},\n        itemColor:    {get: function(){return getColor;}, set: function(_){getColor=_;}},\n        outliers:     {get: function(){return getOlItems;}, set: function(_){getOlItems=_;}},\n        outlierValue: {get: function(){return getOlValue;}, set: function(_){getOlValue=_;}},\n        outlierLabel: {get: function(){return getOlLabel;}, set: function(_){getOlLabel=_;}},\n        outlierColor: {get: function(){return getOlColor;}, set: function(_){getOlColor=_;}},\n        xScale:  {get: function(){return xScale;}, set: function(_){xScale=_;}},\n        yScale:  {get: function(){return yScale;}, set: function(_){yScale=_;}},\n        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        id:          {get: function(){return id;}, set: function(_){id=_;}},\n        // rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},\n        y: {\n            get: function() {\n                console.warn('BoxPlot \\'y\\' chart option is deprecated. Please use model overrides instead.');\n                return {};\n            },\n            set: function(_) {\n                console.warn('BoxPlot \\'y\\' chart option is deprecated. Please use model overrides instead.');\n            }\n        },\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\nnv.models.boxPlotChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var boxplot = nv.models.boxPlot(),\n        xAxis = nv.models.axis(),\n        yAxis = nv.models.axis();\n\n    var margin = {top: 15, right: 10, bottom: 50, left: 60},\n        width = null,\n        height = null,\n        color = nv.utils.getColor(),\n        showXAxis = true,\n        showYAxis = true,\n        rightAlignYAxis = false,\n        staggerLabels = false,\n        tooltip = nv.models.tooltip(),\n        x, y,\n        noData = 'No Data Available.',\n        dispatch = d3.dispatch('beforeUpdate', 'renderEnd'),\n        duration = 250;\n\n    xAxis\n        .orient('bottom')\n        .showMaxMin(false)\n        .tickFormat(function(d) { return d })\n    ;\n    yAxis\n        .orient((rightAlignYAxis) ? 'right' : 'left')\n        .tickFormat(d3.format(',.1f'))\n    ;\n\n    tooltip.duration(0);\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(boxplot);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this), that = this;\n            nv.utils.initSVG(container);\n            var availableWidth = (width  || parseInt(container.style('width')) || 960) - margin.left - margin.right;\n            var availableHeight = (height || parseInt(container.style('height')) || 400) - margin.top - margin.bottom;\n\n            chart.update = function() {\n                dispatch.beforeUpdate();\n                container.transition().duration(duration).call(chart);\n            };\n            chart.container = this;\n\n            // TODO still need to find a way to validate quartile data presence using boxPlot callbacks.\n            // Display No Data message if there's nothing to show. (quartiles required at minimum).\n            if (!data || !data.length) {\n                var noDataText = container.selectAll('.nv-noData').data([noData]);\n\n                noDataText.enter().append('text')\n                    .attr('class', 'nvd3 nv-noData')\n                    .attr('dy', '-.7em')\n                    .style('text-anchor', 'middle');\n\n                noDataText\n                    .attr('x', margin.left + availableWidth / 2)\n                    .attr('y', margin.top + availableHeight / 2)\n                    .text(function(d) { return d });\n\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = boxplot.xScale();\n            y = boxplot.yScale().clamp(true);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-boxPlotWithAxes').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-boxPlotWithAxes').append('g');\n            var defsEnter = gEnter.append('defs');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis')\n                .append('g').attr('class', 'nv-zeroLine')\n                .append('line');\n\n            gEnter.append('g').attr('class', 'nv-barsWrap');\n            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            if (rightAlignYAxis) {\n                g.select('.nv-y.nv-axis')\n                    .attr('transform', 'translate(' + availableWidth + ',0)');\n            }\n\n            // Main Chart Component(s)\n            boxplot.width(availableWidth).height(availableHeight);\n\n            var barsWrap = g.select('.nv-barsWrap')\n                .datum(data.filter(function(d) { return !d.disabled }))\n\n            barsWrap.transition().call(boxplot);\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-x-label-clip-' + boxplot.id())\n                .append('rect');\n\n            g.select('#nv-x-label-clip-' + boxplot.id() + ' rect')\n                .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))\n                .attr('height', 16)\n                .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    .ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight, 0);\n\n                g.select('.nv-x.nv-axis').attr('transform', 'translate(0,' + y.range()[0] + ')');\n                g.select('.nv-x.nv-axis').call(xAxis);\n\n                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');\n                if (staggerLabels) {\n                    xTicks\n                        .selectAll('text')\n                        .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 === 0 ? '5' : '17') + ')' })\n                }\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    .ticks( Math.floor(availableHeight/36) ) // can't use nv.utils.calcTicksY with Object data\n                    .tickSize( -availableWidth, 0);\n\n                g.select('.nv-y.nv-axis').call(yAxis);\n            }\n\n            // Zero line\n            g.select('.nv-zeroLine line')\n                .attr('x1',0)\n                .attr('x2',availableWidth)\n                .attr('y1', y(0))\n                .attr('y2', y(0))\n            ;\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n        });\n\n        renderWatch.renderEnd('nv-boxplot chart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    boxplot.dispatch.on('elementMouseover.tooltip', function(evt) {\n        tooltip.data(evt).hidden(false);\n    });\n\n    boxplot.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.data(evt).hidden(true);\n    });\n\n    boxplot.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.boxplot = boxplot;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},\n        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        tooltipContent:    {get: function(){return tooltip;}, set: function(_){tooltip=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            boxplot.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            boxplot.color(color);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( (_) ? 'right' : 'left');\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, boxplot);\n    nv.utils.initOptions(chart);\n\n    return chart;\n}\n\n// Chart design based on the recommendations of Stephen Few. Implementation\n// based on the work of Clint Ivy, Jamie Love, and Jason Davies.\n// http://projects.instantcognition.com/protovis/bulletchart/\n\nnv.models.bullet = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , orient = 'left' // TODO top & bottom\n        , reverse = false\n        , ranges = function(d) { return d.ranges }\n        , markers = function(d) { return d.markers ? d.markers : [] }\n        , markerLines = function(d) { return d.markerLines ? d.markerLines : [0] }\n        , measures = function(d) { return d.measures }\n        , rangeLabels = function(d) { return d.rangeLabels ? d.rangeLabels : [] }\n        , markerLabels = function(d) { return d.markerLabels ? d.markerLabels : []  }\n        , markerLineLabels = function(d) { return d.markerLineLabels ? d.markerLineLabels : []  }\n        , measureLabels = function(d) { return d.measureLabels ? d.measureLabels : []  }\n        , forceX = [0] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)\n        , width = 380\n        , height = 30\n        , container = null\n        , tickFormat = null\n        , color = nv.utils.getColor(['#1f77b4'])\n        , dispatch = d3.dispatch('elementMouseover', 'elementMouseout', 'elementMousemove')\n        , defaultRangeLabels = [\"Maximum\", \"Mean\", \"Minimum\"]\n        , legacyRangeClassNames = [\"Max\", \"Avg\", \"Min\"]\n        , duration = 1000\n        ;\n\n    function sortLabels(labels, values){\n        var lz = labels.slice();\n        labels.sort(function(a, b){\n            var iA = lz.indexOf(a);\n            var iB = lz.indexOf(b);\n            return d3.descending(values[iA], values[iB]);\n        });\n    };\n\n    function chart(selection) {\n        selection.each(function(d, i) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            var rangez = ranges.call(this, d, i).slice(),\n                markerz = markers.call(this, d, i).slice(),\n                markerLinez = markerLines.call(this, d, i).slice(),\n                measurez = measures.call(this, d, i).slice(),\n                rangeLabelz = rangeLabels.call(this, d, i).slice(),\n                markerLabelz = markerLabels.call(this, d, i).slice(),\n                markerLineLabelz = markerLineLabels.call(this, d, i).slice(),\n                measureLabelz = measureLabels.call(this, d, i).slice();\n\n            // Sort labels according to their sorted values\n            sortLabels(rangeLabelz, rangez);\n            sortLabels(markerLabelz, markerz);\n            sortLabels(markerLineLabelz, markerLinez);\n            sortLabels(measureLabelz, measurez);\n\n            // sort values descending\n            rangez.sort(d3.descending);\n            markerz.sort(d3.descending);\n            markerLinez.sort(d3.descending);\n            measurez.sort(d3.descending);\n\n            // Setup Scales\n            // Compute the new x-scale.\n            var x1 = d3.scale.linear()\n                .domain( d3.extent(d3.merge([forceX, rangez])) )\n                .range(reverse ? [availableWidth, 0] : [0, availableWidth]);\n\n            // Retrieve the old x-scale, if this is an update.\n            var x0 = this.__chart__ || d3.scale.linear()\n                .domain([0, Infinity])\n                .range(x1.range());\n\n            // Stash the new scale.\n            this.__chart__ = x1;\n\n            var rangeMin = d3.min(rangez), //rangez[2]\n                rangeMax = d3.max(rangez), //rangez[0]\n                rangeAvg = rangez[1];\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-bullet').data([d]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bullet');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            for(var i=0,il=rangez.length; i<il; i++){\n                var rangeClassNames = 'nv-range nv-range'+i;\n                if(i <= 2){\n                    rangeClassNames = rangeClassNames + ' nv-range'+legacyRangeClassNames[i];\n                }\n                gEnter.append('rect').attr('class', rangeClassNames);\n            }\n\n            gEnter.append('rect').attr('class', 'nv-measure');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)\n                w1 = function(d) { return Math.abs(x1(d) - x1(0)) };\n            var xp0 = function(d) { return d < 0 ? x0(d) : x0(0) },\n                xp1 = function(d) { return d < 0 ? x1(d) : x1(0) };\n\n            for(var i=0,il=rangez.length; i<il; i++){\n                var range = rangez[i];\n                g.select('rect.nv-range'+i)\n                    .datum(range)\n                    .attr('height', availableHeight)\n                    .transition()\n                    .duration(duration)\n                    .attr('width', w1(range))\n                    .attr('x', xp1(range))\n            }\n\n            g.select('rect.nv-measure')\n                .style('fill', color)\n                .attr('height', availableHeight / 3)\n                .attr('y', availableHeight / 3)\n                .on('mouseover', function() {\n                    dispatch.elementMouseover({\n                        value: measurez[0],\n                        label: measureLabelz[0] || 'Current',\n                        color: d3.select(this).style(\"fill\")\n                    })\n                })\n                .on('mousemove', function() {\n                    dispatch.elementMousemove({\n                        value: measurez[0],\n                        label: measureLabelz[0] || 'Current',\n                        color: d3.select(this).style(\"fill\")\n                    })\n                })\n                .on('mouseout', function() {\n                    dispatch.elementMouseout({\n                        value: measurez[0],\n                        label: measureLabelz[0] || 'Current',\n                        color: d3.select(this).style(\"fill\")\n                    })\n                })\n                .transition()\n                .duration(duration)\n                .attr('width', measurez < 0 ?\n                    x1(0) - x1(measurez[0])\n                    : x1(measurez[0]) - x1(0))\n                .attr('x', xp1(measurez));\n\n            var h3 =  availableHeight / 6;\n\n            var markerData = markerz.map( function(marker, index) {\n                return {value: marker, label: markerLabelz[index]}\n            });\n            gEnter\n              .selectAll(\"path.nv-markerTriangle\")\n              .data(markerData)\n              .enter()\n              .append('path')\n              .attr('class', 'nv-markerTriangle')\n              .attr('d', 'M0,' + h3 + 'L' + h3 + ',' + (-h3) + ' ' + (-h3) + ',' + (-h3) + 'Z')\n              .on('mouseover', function(d) {\n                dispatch.elementMouseover({\n                  value: d.value,\n                  label: d.label || 'Previous',\n                  color: d3.select(this).style(\"fill\"),\n                  pos: [x1(d.value), availableHeight/2]\n                })\n\n              })\n              .on('mousemove', function(d) {\n                  dispatch.elementMousemove({\n                      value: d.value,\n                      label: d.label || 'Previous',\n                      color: d3.select(this).style(\"fill\")\n                  })\n              })\n              .on('mouseout', function(d, i) {\n                  dispatch.elementMouseout({\n                      value: d.value,\n                      label: d.label || 'Previous',\n                      color: d3.select(this).style(\"fill\")\n                  })\n              });\n\n            g.selectAll(\"path.nv-markerTriangle\")\n              .data(markerData)\n              .transition()\n              .duration(duration)\n              .attr('transform', function(d) { return 'translate(' + x1(d.value) + ',' + (availableHeight / 2) + ')' });\n\n            var markerLinesData = markerLinez.map( function(marker, index) {\n                return {value: marker, label: markerLineLabelz[index]}\n            });\n            gEnter\n              .selectAll(\"line.nv-markerLine\")\n              .data(markerLinesData)\n              .enter()\n              .append('line')\n              .attr('cursor', '')\n              .attr('class', 'nv-markerLine')\n              .attr('x1', function(d) { return x1(d.value) })\n              .attr('y1', '2')\n              .attr('x2', function(d) { return x1(d.value) })\n              .attr('y2', availableHeight - 2)\n              .on('mouseover', function(d) {\n                dispatch.elementMouseover({\n                  value: d.value,\n                  label: d.label || 'Previous',\n                  color: d3.select(this).style(\"fill\"),\n                  pos: [x1(d.value), availableHeight/2]\n                })\n\n              })\n              .on('mousemove', function(d) {\n                  dispatch.elementMousemove({\n                      value: d.value,\n                      label: d.label || 'Previous',\n                      color: d3.select(this).style(\"fill\")\n                  })\n              })\n              .on('mouseout', function(d, i) {\n                  dispatch.elementMouseout({\n                      value: d.value,\n                      label: d.label || 'Previous',\n                      color: d3.select(this).style(\"fill\")\n                  })\n              });\n\n            g.selectAll(\"line.nv-markerLine\")\n              .data(markerLinesData)\n              .transition()\n              .duration(duration)\n              .attr('x1', function(d) { return x1(d.value) })\n              .attr('x2', function(d) { return x1(d.value) });\n\n            wrap.selectAll('.nv-range')\n                .on('mouseover', function(d,i) {\n                    var label = rangeLabelz[i] || defaultRangeLabels[i];\n                    dispatch.elementMouseover({\n                        value: d,\n                        label: label,\n                        color: d3.select(this).style(\"fill\")\n                    })\n                })\n                .on('mousemove', function() {\n                    dispatch.elementMousemove({\n                        value: measurez[0],\n                        label: measureLabelz[0] || 'Previous',\n                        color: d3.select(this).style(\"fill\")\n                    })\n                })\n                .on('mouseout', function(d,i) {\n                    var label = rangeLabelz[i] || defaultRangeLabels[i];\n                    dispatch.elementMouseout({\n                        value: d,\n                        label: label,\n                        color: d3.select(this).style(\"fill\")\n                    })\n                });\n        });\n\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)\n        markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)\n        measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)\n        forceX:      {get: function(){return forceX;}, set: function(_){forceX=_;}},\n        width:    {get: function(){return width;}, set: function(_){width=_;}},\n        height:    {get: function(){return height;}, set: function(_){height=_;}},\n        tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},\n        duration:    {get: function(){return duration;}, set: function(_){duration=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom\n            orient = _;\n            reverse = orient == 'right' || orient == 'bottom';\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    return chart;\n};\n\n\n\n// Chart design based on the recommendations of Stephen Few. Implementation\n// based on the work of Clint Ivy, Jamie Love, and Jason Davies.\n// http://projects.instantcognition.com/protovis/bulletchart/\nnv.models.bulletChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var bullet = nv.models.bullet();\n    var tooltip = nv.models.tooltip();\n\n    var orient = 'left' // TODO top & bottom\n        , reverse = false\n        , margin = {top: 5, right: 40, bottom: 20, left: 120}\n        , ranges = function(d) { return d.ranges }\n        , markers = function(d) { return d.markers ? d.markers : [] }\n        , measures = function(d) { return d.measures }\n        , width = null\n        , height = 55\n        , tickFormat = null\n        , ticks = null\n        , noData = null\n        , dispatch = d3.dispatch()\n        ;\n\n    tooltip\n        .duration(0)\n        .headerEnabled(false);\n\n    function chart(selection) {\n        selection.each(function(d, i) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = height - margin.top - margin.bottom,\n                that = this;\n\n            chart.update = function() { chart(selection) };\n            chart.container = this;\n\n            // Display No Data message if there's nothing to show.\n            if (!d || !ranges.call(this, d, i)) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            var rangez = ranges.call(this, d, i).slice().sort(d3.descending),\n                markerz = markers.call(this, d, i).slice().sort(d3.descending),\n                measurez = measures.call(this, d, i).slice().sort(d3.descending);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-bulletChart').data([d]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-bulletChart');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-bulletWrap');\n            gEnter.append('g').attr('class', 'nv-titles');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            // Compute the new x-scale.\n            var x1 = d3.scale.linear()\n                .domain([0, Math.max(rangez[0], (markerz[0] || 0), measurez[0])])  // TODO: need to allow forceX and forceY, and xDomain, yDomain\n                .range(reverse ? [availableWidth, 0] : [0, availableWidth]);\n\n            // Retrieve the old x-scale, if this is an update.\n            var x0 = this.__chart__ || d3.scale.linear()\n                .domain([0, Infinity])\n                .range(x1.range());\n\n            // Stash the new scale.\n            this.__chart__ = x1;\n\n            var w0 = function(d) { return Math.abs(x0(d) - x0(0)) }, // TODO: could optimize by precalculating x0(0) and x1(0)\n                w1 = function(d) { return Math.abs(x1(d) - x1(0)) };\n\n            var title = gEnter.select('.nv-titles').append('g')\n                .attr('text-anchor', 'end')\n                .attr('transform', 'translate(-6,' + (height - margin.top - margin.bottom) / 2 + ')');\n            title.append('text')\n                .attr('class', 'nv-title')\n                .text(function(d) { return d.title; });\n\n            title.append('text')\n                .attr('class', 'nv-subtitle')\n                .attr('dy', '1em')\n                .text(function(d) { return d.subtitle; });\n\n            bullet\n                .width(availableWidth)\n                .height(availableHeight);\n\n            var bulletWrap = g.select('.nv-bulletWrap');\n            d3.transition(bulletWrap).call(bullet);\n\n            // Compute the tick format.\n            var format = tickFormat || x1.tickFormat( availableWidth / 100 );\n\n            // Update the tick groups.\n            var tick = g.selectAll('g.nv-tick')\n                .data(x1.ticks( ticks ? ticks : (availableWidth / 50) ), function(d) {\n                    return this.textContent || format(d);\n                });\n\n            // Initialize the ticks with the old scale, x0.\n            var tickEnter = tick.enter().append('g')\n                .attr('class', 'nv-tick')\n                .attr('transform', function(d) { return 'translate(' + x0(d) + ',0)' })\n                .style('opacity', 1e-6);\n\n            tickEnter.append('line')\n                .attr('y1', availableHeight)\n                .attr('y2', availableHeight * 7 / 6);\n\n            tickEnter.append('text')\n                .attr('text-anchor', 'middle')\n                .attr('dy', '1em')\n                .attr('y', availableHeight * 7 / 6)\n                .text(format);\n\n            // Transition the updating ticks to the new scale, x1.\n            var tickUpdate = d3.transition(tick)\n                .transition()\n                .duration(bullet.duration())\n                .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })\n                .style('opacity', 1);\n\n            tickUpdate.select('line')\n                .attr('y1', availableHeight)\n                .attr('y2', availableHeight * 7 / 6);\n\n            tickUpdate.select('text')\n                .attr('y', availableHeight * 7 / 6);\n\n            // Transition the exiting ticks to the new scale, x1.\n            d3.transition(tick.exit())\n                .transition()\n                .duration(bullet.duration())\n                .attr('transform', function(d) { return 'translate(' + x1(d) + ',0)' })\n                .style('opacity', 1e-6)\n                .remove();\n        });\n\n        d3.timer.flush();\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    bullet.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt['series'] = {\n            key: evt.label,\n            value: evt.value,\n            color: evt.color\n        };\n        tooltip.data(evt).hidden(false);\n    });\n\n    bullet.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    bullet.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.bullet = bullet;\n    chart.dispatch = dispatch;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        ranges:      {get: function(){return ranges;}, set: function(_){ranges=_;}}, // ranges (bad, satisfactory, good)\n        markers:     {get: function(){return markers;}, set: function(_){markers=_;}}, // markers (previous, goal)\n        measures: {get: function(){return measures;}, set: function(_){measures=_;}}, // measures (actual, forecast)\n        width:    {get: function(){return width;}, set: function(_){width=_;}},\n        height:    {get: function(){return height;}, set: function(_){height=_;}},\n        tickFormat:    {get: function(){return tickFormat;}, set: function(_){tickFormat=_;}},\n        ticks:    {get: function(){return ticks;}, set: function(_){ticks=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        orient: {get: function(){return orient;}, set: function(_){ // left, right, top, bottom\n            orient = _;\n            reverse = orient == 'right' || orient == 'bottom';\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, bullet);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\n\n\nnv.models.candlestickBar = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = null\n        , height = null\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container\n        , x = d3.scale.linear()\n        , y = d3.scale.linear()\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , getOpen = function(d) { return d.open }\n        , getClose = function(d) { return d.close }\n        , getHigh = function(d) { return d.high }\n        , getLow = function(d) { return d.low }\n        , forceX = []\n        , forceY = []\n        , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart\n        , clipEdge = true\n        , color = nv.utils.defaultColor()\n        , interactive = false\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove')\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    function chart(selection) {\n        selection.each(function(data) {\n            container = d3.select(this);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            nv.utils.initSVG(container);\n\n            // Width of the candlestick bars.\n            var barWidth = (availableWidth / data[0].values.length) * .45;\n\n            // Setup Scales\n            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));\n\n            if (padData)\n                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);\n            else\n                x.range(xRange || [5 + barWidth / 2, availableWidth - barWidth / 2 - 5]);\n\n            y.domain(yDomain || [\n                    d3.min(data[0].values.map(getLow).concat(forceY)),\n                    d3.max(data[0].values.map(getHigh).concat(forceY))\n                ]\n            ).range(yRange || [availableHeight, 0]);\n\n            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n            if (x.domain()[0] === x.domain()[1])\n                x.domain()[0] ?\n                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])\n                    : x.domain([-1,1]);\n\n            if (y.domain()[0] === y.domain()[1])\n                y.domain()[0] ?\n                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])\n                    : y.domain([-1,1]);\n\n            // Setup containers and skeleton of chart\n            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-candlestickBar').data([data[0].values]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-candlestickBar');\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-ticks');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            container\n                .on('click', function(d,i) {\n                    dispatch.chartClick({\n                        data: d,\n                        index: i,\n                        pos: d3.event,\n                        id: id\n                    });\n                });\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-chart-clip-path-' + id)\n                .append('rect');\n\n            wrap.select('#nv-chart-clip-path-' + id + ' rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');\n\n            var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')\n                .data(function(d) { return d });\n            ticks.exit().remove();\n\n            var tickGroups = ticks.enter().append('g');\n\n            // The colors are currently controlled by CSS.\n            ticks\n                .attr('class', function(d, i, j) { return (getOpen(d, i) > getClose(d, i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i});\n\n            var lines = tickGroups.append('line')\n                .attr('class', 'nv-candlestick-lines')\n                .attr('transform', function(d, i) { return 'translate(' + x(getX(d, i)) + ',0)'; })\n                .attr('x1', 0)\n                .attr('y1', function(d, i) { return y(getHigh(d, i)); })\n                .attr('x2', 0)\n                .attr('y2', function(d, i) { return y(getLow(d, i)); });\n\n            var rects = tickGroups.append('rect')\n                .attr('class', 'nv-candlestick-rects nv-bars')\n                .attr('transform', function(d, i) {\n                    return 'translate(' + (x(getX(d, i)) - barWidth/2) + ','\n                    + (y(getY(d, i)) - (getOpen(d, i) > getClose(d, i) ? (y(getClose(d, i)) - y(getOpen(d, i))) : 0))\n                    + ')';\n                })\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('width', barWidth)\n                .attr('height', function(d, i) {\n                    var open = getOpen(d, i);\n                    var close = getClose(d, i);\n                    return open > close ? y(close) - y(open) : y(open) - y(close);\n                });\n\n            ticks.select('.nv-candlestick-lines').transition()\n                .attr('transform', function(d, i) { return 'translate(' + x(getX(d, i)) + ',0)'; })\n                .attr('x1', 0)\n                .attr('y1', function(d, i) { return y(getHigh(d, i)); })\n                .attr('x2', 0)\n                .attr('y2', function(d, i) { return y(getLow(d, i)); });\n\n            ticks.select('.nv-candlestick-rects').transition()\n                .attr('transform', function(d, i) {\n                    return 'translate(' + (x(getX(d, i)) - barWidth/2) + ','\n                    + (y(getY(d, i)) - (getOpen(d, i) > getClose(d, i) ? (y(getClose(d, i)) - y(getOpen(d, i))) : 0))\n                    + ')';\n                })\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('width', barWidth)\n                .attr('height', function(d, i) {\n                    var open = getOpen(d, i);\n                    var close = getClose(d, i);\n                    return open > close ? y(close) - y(open) : y(open) - y(close);\n                });\n        });\n\n        return chart;\n    }\n\n\n    //Create methods to allow outside functions to highlight a specific bar.\n    chart.highlightPoint = function(pointIndex, isHoverOver) {\n        chart.clearHighlights();\n        container.select(\".nv-candlestickBar .nv-tick-0-\" + pointIndex)\n            .classed(\"hover\", isHoverOver)\n        ;\n    };\n\n    chart.clearHighlights = function() {\n        container.select(\".nv-candlestickBar .nv-tick.hover\")\n            .classed(\"hover\", false)\n        ;\n    };\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:    {get: function(){return width;}, set: function(_){width=_;}},\n        height:   {get: function(){return height;}, set: function(_){height=_;}},\n        xScale:   {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:   {get: function(){return y;}, set: function(_){y=_;}},\n        xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:   {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:   {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        forceX:   {get: function(){return forceX;}, set: function(_){forceX=_;}},\n        forceY:   {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        padData:  {get: function(){return padData;}, set: function(_){padData=_;}},\n        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n        id:       {get: function(){return id;}, set: function(_){id=_;}},\n        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},\n\n        x:     {get: function(){return getX;}, set: function(_){getX=_;}},\n        y:     {get: function(){return getY;}, set: function(_){getY=_;}},\n        open:  {get: function(){return getOpen();}, set: function(_){getOpen=_;}},\n        close: {get: function(){return getClose();}, set: function(_){getClose=_;}},\n        high:  {get: function(){return getHigh;}, set: function(_){getHigh=_;}},\n        low:   {get: function(){return getLow;}, set: function(_){getLow=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    != undefined ? _.top    : margin.top;\n            margin.right  = _.right  != undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   != undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    return chart;\n};\n\nnv.models.cumulativeLineChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var lines = nv.models.line()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , legend = nv.models.legend()\n        , controls = nv.models.legend()\n        , interactiveLayer = nv.interactiveGuideline()\n        , tooltip = nv.models.tooltip()\n        ;\n\n    var margin = {top: 30, right: 30, bottom: 50, left: 60}\n        , marginTop = null\n        , color = nv.utils.defaultColor()\n        , width = null\n        , height = null\n        , showLegend = true\n        , showXAxis = true\n        , showYAxis = true\n        , rightAlignYAxis = false\n        , showControls = true\n        , useInteractiveGuideline = false\n        , rescaleY = true\n        , x //can be accessed via chart.xScale()\n        , y //can be accessed via chart.yScale()\n        , id = lines.id()\n        , state = nv.utils.state()\n        , defaultState = null\n        , noData = null\n        , average = function(d) { return d.average }\n        , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')\n        , transitionDuration = 250\n        , duration = 250\n        , noErrorCheck = false  //if set to TRUE, will bypass an error check in the indexify function.\n        ;\n\n    state.index = 0;\n    state.rescaleY = rescaleY;\n\n    xAxis.orient('bottom').tickPadding(7);\n    yAxis.orient((rightAlignYAxis) ? 'right' : 'left');\n\n    tooltip.valueFormatter(function(d, i) {\n        return yAxis.tickFormat()(d, i);\n    }).headerFormatter(function(d, i) {\n        return xAxis.tickFormat()(d, i);\n    });\n\n    controls.updateState(false);\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var dx = d3.scale.linear()\n        , index = {i: 0, x: 0}\n        , renderWatch = nv.utils.renderWatch(dispatch, duration)\n        ;\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled }),\n                index: index.i,\n                rescaleY: rescaleY\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.index !== undefined)\n                index.i = state.index;\n            if (state.rescaleY !== undefined)\n                rescaleY = state.rescaleY;\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        }\n    };\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(lines);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n        selection.each(function(data) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n            container.classed('nv-chart-' + id, true);\n            var that = this;\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() {\n                if (duration === 0)\n                    container.call(chart);\n                else\n                    container.transition().duration(duration).call(chart)\n            };\n            chart.container = this;\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disableddisabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            var indexDrag = d3.behavior.drag()\n                .on('dragstart', dragStart)\n                .on('drag', dragMove)\n                .on('dragend', dragEnd);\n\n\n            function dragStart(d,i) {\n                d3.select(chart.container)\n                    .style('cursor', 'ew-resize');\n            }\n\n            function dragMove(d,i) {\n                index.x = d3.event.x;\n                index.i = Math.round(dx.invert(index.x));\n                updateZero();\n            }\n\n            function dragEnd(d,i) {\n                d3.select(chart.container)\n                    .style('cursor', 'auto');\n\n                // update state and send stateChange with new index\n                state.index = index.i;\n                dispatch.stateChange(state);\n            }\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = lines.xScale();\n            y = lines.yScale();\n\n            if (!rescaleY) {\n                var seriesDomains = data\n                    .filter(function(series) { return !series.disabled })\n                    .map(function(series,i) {\n                        var initialDomain = d3.extent(series.values, lines.y());\n\n                        //account for series being disabled when losing 95% or more\n                        if (initialDomain[0] < -.95) initialDomain[0] = -.95;\n\n                        return [\n                                (initialDomain[0] - initialDomain[1]) / (1 + initialDomain[1]),\n                                (initialDomain[1] - initialDomain[0]) / (1 + initialDomain[0])\n                        ];\n                    });\n\n                var completeDomain = [\n                    d3.min(seriesDomains, function(d) { return d[0] }),\n                    d3.max(seriesDomains, function(d) { return d[1] })\n                ];\n\n                lines.yDomain(completeDomain);\n            } else {\n                lines.yDomain(null);\n            }\n\n            dx.domain([0, data[0].values.length - 1]) //Assumes all series have same length\n                .range([0, availableWidth])\n                .clamp(true);\n\n            var data = indexify(index.i, data);\n\n            // Setup containers and skeleton of chart\n            var interactivePointerEvents = (useInteractiveGuideline) ? \"none\" : \"all\";\n            var wrap = container.selectAll('g.nv-wrap.nv-cumulativeLine').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-cumulativeLine').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-interactive');\n            gEnter.append('g').attr('class', 'nv-x nv-axis').style(\"pointer-events\",\"none\");\n            gEnter.append('g').attr('class', 'nv-y nv-axis');\n            gEnter.append('g').attr('class', 'nv-background');\n            gEnter.append('g').attr('class', 'nv-linesWrap').style(\"pointer-events\",interactivePointerEvents);\n            gEnter.append('g').attr('class', 'nv-avgLinesWrap').style(\"pointer-events\",\"none\");\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n            gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                legend.width(availableWidth);\n\n                g.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                g.select('.nv-legendWrap')\n                    .attr('transform', 'translate(0,' + (-margin.top) +')')\n            }\n\n            // Controls\n            if (!showControls) {\n                 g.select('.nv-controlsWrap').selectAll('*').remove();\n            } else {\n                var controlsData = [\n                    { key: 'Re-scale y-axis', disabled: !rescaleY }\n                ];\n\n                controls\n                    .width(140)\n                    .color(['#444', '#444', '#444'])\n                    .rightAlign(false)\n                    .margin({top: 5, right: 0, bottom: 5, left: 20})\n                ;\n\n                g.select('.nv-controlsWrap')\n                    .datum(controlsData)\n                    .attr('transform', 'translate(0,' + (-margin.top) +')')\n                    .call(controls);\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            // Show error if series goes below 100%\n            var tempDisabled = data.filter(function(d) { return d.tempDisabled });\n\n            wrap.select('.tempDisabled').remove(); //clean-up and prevent duplicates\n            if (tempDisabled.length) {\n                wrap.append('text').attr('class', 'tempDisabled')\n                    .attr('x', availableWidth / 2)\n                    .attr('y', '-.71em')\n                    .style('text-anchor', 'end')\n                    .text(tempDisabled.map(function(d) { return d.key }).join(', ') + ' values cannot be calculated for this time period.');\n            }\n\n            //Set up interactive layer\n            if (useInteractiveGuideline) {\n                interactiveLayer\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .margin({left:margin.left,top:margin.top})\n                    .svgContainer(container)\n                    .xScale(x);\n                wrap.select(\".nv-interactive\").call(interactiveLayer);\n            }\n\n            gEnter.select('.nv-background')\n                .append('rect');\n\n            g.select('.nv-background rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            lines\n                //.x(function(d) { return d.x })\n                .y(function(d) { return d.display.y })\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled && !data[i].tempDisabled; }));\n\n            var linesWrap = g.select('.nv-linesWrap')\n                .datum(data.filter(function(d) { return  !d.disabled && !d.tempDisabled }));\n\n            linesWrap.call(lines);\n\n            //Store a series index number in the data array.\n            data.forEach(function(d,i) {\n                d.seriesIndex = i;\n            });\n\n            var avgLineData = data.filter(function(d) {\n                return !d.disabled && !!average(d);\n            });\n\n            var avgLines = g.select(\".nv-avgLinesWrap\").selectAll(\"line\")\n                .data(avgLineData, function(d) { return d.key; });\n\n            var getAvgLineY = function(d) {\n                //If average lines go off the svg element, clamp them to the svg bounds.\n                var yVal = y(average(d));\n                if (yVal < 0) return 0;\n                if (yVal > availableHeight) return availableHeight;\n                return yVal;\n            };\n\n            avgLines.enter()\n                .append('line')\n                .style('stroke-width',2)\n                .style('stroke-dasharray','10,10')\n                .style('stroke',function (d,i) {\n                    return lines.color()(d,d.seriesIndex);\n                })\n                .attr('x1',0)\n                .attr('x2',availableWidth)\n                .attr('y1', getAvgLineY)\n                .attr('y2', getAvgLineY);\n\n            avgLines\n                .style('stroke-opacity',function(d){\n                    //If average lines go offscreen, make them transparent\n                    var yVal = y(average(d));\n                    if (yVal < 0 || yVal > availableHeight) return 0;\n                    return 1;\n                })\n                .attr('x1',0)\n                .attr('x2',availableWidth)\n                .attr('y1', getAvgLineY)\n                .attr('y2', getAvgLineY);\n\n            avgLines.exit().remove();\n\n            //Create index line\n            var indexLine = linesWrap.selectAll('.nv-indexLine')\n                .data([index]);\n            indexLine.enter().append('rect').attr('class', 'nv-indexLine')\n                .attr('width', 3)\n                .attr('x', -2)\n                .attr('fill', 'red')\n                .attr('fill-opacity', .5)\n                .style(\"pointer-events\",\"all\")\n                .call(indexDrag);\n\n            indexLine\n                .attr('transform', function(d) { return 'translate(' + dx(d.i) + ',0)' })\n                .attr('height', availableHeight);\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/70, data) )\n                    .tickSize(-availableHeight, 0);\n\n                g.select('.nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y.range()[0] + ')');\n                g.select('.nv-x.nv-axis')\n                    .call(xAxis);\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n\n                g.select('.nv-y.nv-axis')\n                    .call(yAxis);\n            }\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            function updateZero() {\n                indexLine\n                    .data([index]);\n\n                //When dragging the index line, turn off line transitions.\n                // Then turn them back on when done dragging.\n                var oldDuration = chart.duration();\n                chart.duration(0);\n                chart.update();\n                chart.duration(oldDuration);\n            }\n\n            g.select('.nv-background rect')\n                .on('click', function() {\n                    index.x = d3.mouse(this)[0];\n                    index.i = Math.round(dx.invert(index.x));\n\n                    // update state and send stateChange with new index\n                    state.index = index.i;\n                    dispatch.stateChange(state);\n\n                    updateZero();\n                });\n\n            lines.dispatch.on('elementClick', function(e) {\n                index.i = e.pointIndex;\n                index.x = dx(index.i);\n\n                // update state and send stateChange with new index\n                state.index = index.i;\n                dispatch.stateChange(state);\n\n                updateZero();\n            });\n\n            controls.dispatch.on('legendClick', function(d,i) {\n                d.disabled = !d.disabled;\n                rescaleY = !d.disabled;\n\n                state.rescaleY = rescaleY;\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            interactiveLayer.dispatch.on('elementMousemove', function(e) {\n                lines.clearHighlights();\n                var singlePoint, pointIndex, pointXLocation, allData = [];\n\n                data\n                    .filter(function(series, i) {\n                        series.seriesIndex = i;\n                        return !series.disabled;\n                    })\n                    .forEach(function(series,i) {\n                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n                        lines.highlightPoint(i, pointIndex, true);\n                        var point = series.values[pointIndex];\n                        if (typeof point === 'undefined') return;\n                        if (typeof singlePoint === 'undefined') singlePoint = point;\n                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));\n                        allData.push({\n                            key: series.key,\n                            value: chart.y()(point, pointIndex),\n                            color: color(series,series.seriesIndex)\n                        });\n                    });\n\n                //Highlight the tooltip entry based on which point the mouse is closest to.\n                if (allData.length > 2) {\n                    var yValue = chart.yScale().invert(e.mouseY);\n                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);\n                    var threshold = 0.03 * domainExtent;\n                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value}),yValue,threshold);\n                    if (indexToHighlight !== null)\n                        allData[indexToHighlight].highlight = true;\n                }\n\n                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex), pointIndex);\n                interactiveLayer.tooltip\n                    .valueFormatter(function(d,i) {\n                        return yAxis.tickFormat()(d);\n                    })\n                    .data(\n                    {\n                        value: xValue,\n                        series: allData\n                    }\n                )();\n\n                interactiveLayer.renderGuideLine(pointXLocation);\n            });\n\n            interactiveLayer.dispatch.on(\"elementMouseout\",function(e) {\n                lines.clearHighlights();\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n\n                    state.disabled = e.disabled;\n                }\n\n                if (typeof e.index !== 'undefined') {\n                    index.i = e.index;\n                    index.x = dx(index.i);\n\n                    state.index = e.index;\n\n                    indexLine\n                        .data([index]);\n                }\n\n                if (typeof e.rescaleY !== 'undefined') {\n                    rescaleY = e.rescaleY;\n                }\n\n                chart.update();\n            });\n\n        });\n\n        renderWatch.renderEnd('cumulativeLineChart immediate');\n\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    lines.dispatch.on('elementMouseover.tooltip', function(evt) {\n        var point = {\n            x: chart.x()(evt.point),\n            y: chart.y()(evt.point),\n            color: evt.point.color\n        };\n        evt.point = point;\n        tooltip.data(evt).hidden(false);\n    });\n\n    lines.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true)\n    });\n\n    //============================================================\n    // Functions\n    //------------------------------------------------------------\n\n    var indexifyYGetter = null;\n    /* Normalize the data according to an index point. */\n    function indexify(idx, data) {\n        if (!indexifyYGetter) indexifyYGetter = lines.y();\n        return data.map(function(line, i) {\n            if (!line.values) {\n                return line;\n            }\n            var indexValue = line.values[idx];\n            if (indexValue == null) {\n                return line;\n            }\n            var v = indexifyYGetter(indexValue, idx);\n\n            //TODO: implement check below, and disable series if series loses 100% or more cause divide by 0 issue\n            if (v < -.95 && !noErrorCheck) {\n                //if a series loses more than 100%, calculations fail.. anything close can cause major distortion (but is mathematically correct till it hits 100)\n\n                line.tempDisabled = true;\n                return line;\n            }\n\n            line.tempDisabled = false;\n\n            line.values = line.values.map(function(point, pointIndex) {\n                point.display = {'y': (indexifyYGetter(point, pointIndex) - v) / (1 + v) };\n                return point;\n            });\n\n            return line;\n        })\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.lines = lines;\n    chart.legend = legend;\n    chart.controls = controls;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.interactiveLayer = interactiveLayer;\n    chart.state = state;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        rescaleY:     {get: function(){return rescaleY;}, set: function(_){rescaleY=_;}},\n        showControls:     {get: function(){return showControls;}, set: function(_){showControls=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        average: {get: function(){return average;}, set: function(_){average=_;}},\n        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        showXAxis:    {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        noErrorCheck:    {get: function(){return noErrorCheck;}, set: function(_){noErrorCheck=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n        }},\n        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){\n            useInteractiveGuideline = _;\n            if (_ === true) {\n                chart.interactive(false);\n                chart.useVoronoi(false);\n            }\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( (_) ? 'right' : 'left');\n        }},\n        duration:    {get: function(){return duration;}, set: function(_){\n            duration = _;\n            lines.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n            renderWatch.reset(duration);\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, lines);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n//TODO: consider deprecating by adding necessary features to multiBar model\nnv.models.discreteBar = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 960\n        , height = 500\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container\n        , x = d3.scale.ordinal()\n        , y = d3.scale.linear()\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove\n        , color = nv.utils.defaultColor()\n        , showValues = false\n        , valueFormat = d3.format(',.2f')\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')\n        , rectClass = 'discreteBar'\n        , duration = 250\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x0, y0;\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            //add series index to each data point for reference\n            data.forEach(function(series, i) {\n                series.values.forEach(function(point) {\n                    point.series = i;\n                });\n            });\n\n            // Setup Scales\n            // remap and flatten the data for use in calculating the scales' domains\n            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate\n                data.map(function(d) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d,i), y: getY(d,i), y0: d.y0 }\n                    })\n                });\n\n            x   .domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))\n                .rangeBands(xRange || [0, availableWidth], .1);\n            y   .domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return d.y }).concat(forceY)));\n\n            // If showValues, pad the Y axis range to account for label height\n            if (showValues) y.range(yRange || [availableHeight - (y.domain()[0] < 0 ? 12 : 0), y.domain()[1] > 0 ? 12 : 0]);\n            else y.range(yRange || [availableHeight, 0]);\n\n            //store old scales if they exist\n            x0 = x0 || x;\n            y0 = y0 || y.copy().range([y(0),y(0)]);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-discretebar').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discretebar');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-groups');\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            //TODO: by definition, the discrete bar should not have multiple groups, will modify/remove later\n            var groups = wrap.select('.nv-groups').selectAll('.nv-group')\n                .data(function(d) { return d }, function(d) { return d.key });\n            groups.enter().append('g')\n                .style('stroke-opacity', 1e-6)\n                .style('fill-opacity', 1e-6);\n            groups.exit()\n                .watchTransition(renderWatch, 'discreteBar: exit groups')\n                .style('stroke-opacity', 1e-6)\n                .style('fill-opacity', 1e-6)\n                .remove();\n            groups\n                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })\n                .classed('hover', function(d) { return d.hover });\n            groups\n                .watchTransition(renderWatch, 'discreteBar: groups')\n                .style('stroke-opacity', 1)\n                .style('fill-opacity', .75);\n\n            var bars = groups.selectAll('g.nv-bar')\n                .data(function(d) { return d.values });\n            bars.exit().remove();\n\n            var barsEnter = bars.enter().append('g')\n                .attr('transform', function(d,i,j) {\n                    return 'translate(' + (x(getX(d,i)) + x.rangeBand() * .05 ) + ', ' + y(0) + ')'\n                })\n                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here\n                    d3.select(this).classed('hover', true);\n                    dispatch.elementMouseover({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mouseout', function(d,i) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.elementMouseout({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mousemove', function(d,i) {\n                    dispatch.elementMousemove({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('click', function(d,i) {\n                    var element = this;\n                    dispatch.elementClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\"),\n                        event: d3.event,\n                        element: element\n                    });\n                    d3.event.stopPropagation();\n                })\n                .on('dblclick', function(d,i) {\n                    dispatch.elementDblClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                    d3.event.stopPropagation();\n                });\n\n            barsEnter.append('rect')\n                .attr('height', 0)\n                .attr('width', x.rangeBand() * .9 / data.length )\n\n            if (showValues) {\n                barsEnter.append('text')\n                    .attr('text-anchor', 'middle')\n                ;\n\n                bars.select('text')\n                    .text(function(d,i) { return valueFormat(getY(d,i)) })\n                    .watchTransition(renderWatch, 'discreteBar: bars text')\n                    .attr('x', x.rangeBand() * .9 / 2)\n                    .attr('y', function(d,i) { return getY(d,i) < 0 ? y(getY(d,i)) - y(0) + 12 : -4 })\n\n                ;\n            } else {\n                bars.selectAll('text').remove();\n            }\n\n            bars\n                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive' })\n                .style('fill', function(d,i) { return d.color || color(d,i) })\n                .style('stroke', function(d,i) { return d.color || color(d,i) })\n                .select('rect')\n                .attr('class', rectClass)\n                .watchTransition(renderWatch, 'discreteBar: bars rect')\n                .attr('width', x.rangeBand() * .9 / data.length);\n            bars.watchTransition(renderWatch, 'discreteBar: bars')\n                //.delay(function(d,i) { return i * 1200 / data[0].values.length })\n                .attr('transform', function(d,i) {\n                    var left = x(getX(d,i)) + x.rangeBand() * .05,\n                        top = getY(d,i) < 0 ?\n                            y(0) :\n                                y(0) - y(getY(d,i)) < 1 ?\n                            y(0) - 1 : //make 1 px positive bars show up above y=0\n                            y(getY(d,i));\n\n                    return 'translate(' + left + ', ' + top + ')'\n                })\n                .select('rect')\n                .attr('height', function(d,i) {\n                    return  Math.max(Math.abs(y(getY(d,i)) - y(0)), 1)\n                });\n\n\n            //store old scales for use in transitions on update\n            x0 = x.copy();\n            y0 = y.copy();\n\n        });\n\n        renderWatch.renderEnd('discreteBar immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:   {get: function(){return width;}, set: function(_){width=_;}},\n        height:  {get: function(){return height;}, set: function(_){height=_;}},\n        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},\n        x:       {get: function(){return getX;}, set: function(_){getX=_;}},\n        y:       {get: function(){return getY;}, set: function(_){getY=_;}},\n        xScale:  {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:  {get: function(){return y;}, set: function(_){y=_;}},\n        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},\n        id:          {get: function(){return id;}, set: function(_){id=_;}},\n        rectClass: {get: function(){return rectClass;}, set: function(_){rectClass=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.discreteBarChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var discretebar = nv.models.discreteBar()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n\t, legend = nv.models.legend()\n        , tooltip = nv.models.tooltip()\n        ;\n\n    var margin = {top: 15, right: 10, bottom: 50, left: 60}\n        , marginTop = null\n        , width = null\n        , height = null\n        , color = nv.utils.getColor()\n\t, showLegend = false\n        , showXAxis = true\n        , showYAxis = true\n        , rightAlignYAxis = false\n        , staggerLabels = false\n        , wrapLabels = false\n        , rotateLabels = 0\n        , x\n        , y\n        , noData = null\n        , dispatch = d3.dispatch('beforeUpdate','renderEnd')\n        , duration = 250\n        ;\n\n    xAxis\n        .orient('bottom')\n        .showMaxMin(false)\n        .tickFormat(function(d) { return d })\n    ;\n    yAxis\n        .orient((rightAlignYAxis) ? 'right' : 'left')\n        .tickFormat(d3.format(',.1f'))\n    ;\n\n    tooltip\n        .duration(0)\n        .headerEnabled(false)\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        })\n        .keyFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(discretebar);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() {\n                dispatch.beforeUpdate();\n                container.transition().duration(duration).call(chart);\n            };\n            chart.container = this;\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container);\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = discretebar.xScale();\n            y = discretebar.yScale().clamp(true);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-discreteBarWithAxes').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-discreteBarWithAxes').append('g');\n            var defsEnter = gEnter.append('defs');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis')\n                .append('g').attr('class', 'nv-zeroLine')\n                .append('line');\n\n            gEnter.append('g').attr('class', 'nv-barsWrap');\n\t    gEnter.append('g').attr('class', 'nv-legendWrap');\n\n            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                legend.width(availableWidth);\n\n                g.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                wrap.select('.nv-legendWrap')\n                    .attr('transform', 'translate(0,' + (-margin.top) +')')\n            }\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            // Main Chart Component(s)\n            discretebar\n                .width(availableWidth)\n                .height(availableHeight);\n\n            var barsWrap = g.select('.nv-barsWrap')\n                .datum(data.filter(function(d) { return !d.disabled }));\n\n            barsWrap.transition().call(discretebar);\n\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-x-label-clip-' + discretebar.id())\n                .append('rect');\n\n            g.select('#nv-x-label-clip-' + discretebar.id() + ' rect')\n                .attr('width', x.rangeBand() * (staggerLabels ? 2 : 1))\n                .attr('height', 16)\n                .attr('x', -x.rangeBand() / (staggerLabels ? 1 : 2 ));\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight, 0);\n\n                g.select('.nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + (y.range()[0] + ((discretebar.showValues() && y.domain()[0] < 0) ? 16 : 0)) + ')');\n                g.select('.nv-x.nv-axis').call(xAxis);\n\n                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');\n                if (staggerLabels) {\n                    xTicks\n                        .selectAll('text')\n                        .attr('transform', function(d,i,j) { return 'translate(0,' + (j % 2 == 0 ? '5' : '17') + ')' })\n                }\n\n                if (rotateLabels) {\n                    xTicks\n                        .selectAll('.tick text')\n                        .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')\n                        .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');\n                }\n\n                if (wrapLabels) {\n                    g.selectAll('.tick text')\n                        .call(nv.utils.wrapTicks, chart.xAxis.rangeBand())\n                }\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n\n                g.select('.nv-y.nv-axis').call(yAxis);\n            }\n\n            // Zero line\n            g.select(\".nv-zeroLine line\")\n                .attr(\"x1\",0)\n                .attr(\"x2\",(rightAlignYAxis) ? -availableWidth : availableWidth)\n                .attr(\"y1\", y(0))\n                .attr(\"y2\", y(0))\n            ;\n        });\n\n        renderWatch.renderEnd('discreteBar chart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    discretebar.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt['series'] = {\n            key: chart.x()(evt.data),\n            value: chart.y()(evt.data),\n            color: evt.color\n        };\n        tooltip.data(evt).hidden(false);\n    });\n\n    discretebar.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    discretebar.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.discretebar = discretebar;\n    chart.legend = legend;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n\tshowLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        staggerLabels: {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},\n        rotateLabels:  {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},\n        wrapLabels:  {get: function(){return wrapLabels;}, set: function(_){wrapLabels=!!_;}},\n        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            discretebar.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            discretebar.color(color);\n\t    legend.color(color);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( (_) ? 'right' : 'left');\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, discretebar);\n    nv.utils.initOptions(chart);\n\n    return chart;\n}\n\nnv.models.distribution = function() {\n    \"use strict\";\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 400 //technically width or height depending on x or y....\n        , size = 8\n        , axis = 'x' // 'x' or 'y'... horizontal or vertical\n        , getData = function(d) { return d[axis] }  // defaults d.x or d.y\n        , color = nv.utils.defaultColor()\n        , scale = d3.scale.linear()\n        , domain\n        , duration = 250\n        , dispatch = d3.dispatch('renderEnd')\n        ;\n\n    //============================================================\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var scale0;\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    //============================================================\n\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableLength = width - (axis === 'x' ? margin.left + margin.right : margin.top + margin.bottom),\n                naxis = axis == 'x' ? 'y' : 'x',\n                container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            //------------------------------------------------------------\n            // Setup Scales\n\n            scale0 = scale0 || scale;\n\n            //------------------------------------------------------------\n\n\n            //------------------------------------------------------------\n            // Setup containers and skeleton of chart\n\n            var wrap = container.selectAll('g.nv-distribution').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-distribution');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')\n\n            //------------------------------------------------------------\n\n\n            var distWrap = g.selectAll('g.nv-dist')\n                .data(function(d) { return d }, function(d) { return d.key });\n\n            distWrap.enter().append('g');\n            distWrap\n                .attr('class', function(d,i) { return 'nv-dist nv-series-' + i })\n                .style('stroke', function(d,i) { return color(d, i) });\n\n            var dist = distWrap.selectAll('line.nv-dist' + axis)\n                .data(function(d) { return d.values })\n            dist.enter().append('line')\n                .attr(axis + '1', function(d,i) { return scale0(getData(d,i)) })\n                .attr(axis + '2', function(d,i) { return scale0(getData(d,i)) })\n            renderWatch.transition(distWrap.exit().selectAll('line.nv-dist' + axis), 'dist exit')\n                // .transition()\n                .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })\n                .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })\n                .style('stroke-opacity', 0)\n                .remove();\n            dist\n                .attr('class', function(d,i) { return 'nv-dist' + axis + ' nv-dist' + axis + '-' + i })\n                .attr(naxis + '1', 0)\n                .attr(naxis + '2', size);\n            renderWatch.transition(dist, 'dist')\n                // .transition()\n                .attr(axis + '1', function(d,i) { return scale(getData(d,i)) })\n                .attr(axis + '2', function(d,i) { return scale(getData(d,i)) })\n\n\n            scale0 = scale.copy();\n\n        });\n        renderWatch.renderEnd('distribution immediate');\n        return chart;\n    }\n\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n    chart.options = nv.utils.optionsFunc.bind(chart);\n    chart.dispatch = dispatch;\n\n    chart.margin = function(_) {\n        if (!arguments.length) return margin;\n        margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;\n        margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;\n        margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n        margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;\n        return chart;\n    };\n\n    chart.width = function(_) {\n        if (!arguments.length) return width;\n        width = _;\n        return chart;\n    };\n\n    chart.axis = function(_) {\n        if (!arguments.length) return axis;\n        axis = _;\n        return chart;\n    };\n\n    chart.size = function(_) {\n        if (!arguments.length) return size;\n        size = _;\n        return chart;\n    };\n\n    chart.getData = function(_) {\n        if (!arguments.length) return getData;\n        getData = d3.functor(_);\n        return chart;\n    };\n\n    chart.scale = function(_) {\n        if (!arguments.length) return scale;\n        scale = _;\n        return chart;\n    };\n\n    chart.color = function(_) {\n        if (!arguments.length) return color;\n        color = nv.utils.getColor(_);\n        return chart;\n    };\n\n    chart.duration = function(_) {\n        if (!arguments.length) return duration;\n        duration = _;\n        renderWatch.reset(duration);\n        return chart;\n    };\n    //============================================================\n\n\n    return chart;\n}\nnv.models.focus = function(content) {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var content = content || nv.models.line()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , brush = d3.svg.brush()\n        ;\n\n    var margin = {top: 10, right: 0, bottom: 30, left: 0}\n        , color = nv.utils.defaultColor()\n        , width = null\n        , height = 70\n        , showXAxis = true\n        , showYAxis = false\n        , rightAlignYAxis = false\n        , ticks = null\n        , x\n        , y\n        , brushExtent = null\n        , duration = 250\n        , dispatch = d3.dispatch('brush', 'onBrush', 'renderEnd')\n        , syncBrushing = true\n        ;\n\n    content.interactive(false);\n    content.pointActive(function(d) { return false; });\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(content);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = height - margin.top - margin.bottom;\n\n            chart.update = function() { \n                if( duration === 0 ) {\n                    container.call( chart );\n                } else {\n                    container.transition().duration(duration).call(chart);\n                }\n            };\n            chart.container = this;\n\n            // Setup Scales\n            x = content.xScale();\n            y = content.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-focus').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-focus').append('g');\n            var g = wrap.select('g');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            gEnter.append('g').attr('class', 'nv-background').append('rect');\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis');\n            gEnter.append('g').attr('class', 'nv-contentWrap');\n            gEnter.append('g').attr('class', 'nv-brushBackground');\n            gEnter.append('g').attr('class', 'nv-x nv-brush');\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            g.select('.nv-background rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n                \n            content\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled; }));\n\n            var contentWrap = g.select('.nv-contentWrap')\n                .datum(data.filter(function(d) { return !d.disabled; }));\n\n            d3.transition(contentWrap).call(content);\n            \n            // Setup Brush\n            brush\n                .x(x)\n                .on('brush', function() {\n                    onBrush(syncBrushing);\n                });\n\n            brush.on('brushend', function () {\n                if (!syncBrushing) {\n                    dispatch.onBrush(brush.empty() ? x.domain() : brush.extent());\n                }\n            });\n\n            if (brushExtent) brush.extent(brushExtent);\n\n            var brushBG = g.select('.nv-brushBackground').selectAll('g')\n                .data([brushExtent || brush.extent()]);\n    \n            var brushBGenter = brushBG.enter()\n                .append('g');\n\n            brushBGenter.append('rect')\n                .attr('class', 'left')\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('height', availableHeight);\n\n            brushBGenter.append('rect')\n                .attr('class', 'right')\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('height', availableHeight);\n\n            var gBrush = g.select('.nv-x.nv-brush')\n                .call(brush);\n            gBrush.selectAll('rect')\n                .attr('height', availableHeight);\n            gBrush.selectAll('.resize').append('path').attr('d', resizePath);\n\n            onBrush(true);\n\n            g.select('.nv-background rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            if (showXAxis) {\n                xAxis.scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight, 0);\n  \n                g.select('.nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y.range()[0] + ')');\n                d3.transition(g.select('.nv-x.nv-axis'))\n                    .call(xAxis);\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n\n                d3.transition(g.select('.nv-y.nv-axis'))\n                    .call(yAxis);\n            }\n            \n            g.select('.nv-x.nv-axis')\n                .attr('transform', 'translate(0,' + y.range()[0] + ')');\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            //============================================================\n            // Functions\n            //------------------------------------------------------------\n    \n            // Taken from crossfilter (http://square.github.com/crossfilter/)\n            function resizePath(d) {\n                var e = +(d == 'e'),\n                    x = e ? 1 : -1,\n                    y = availableHeight / 3;\n                return 'M' + (0.5 * x) + ',' + y\n                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)\n                    + 'V' + (2 * y - 6)\n                    + 'A6,6 0 0 ' + e + ' ' + (0.5 * x) + ',' + (2 * y)\n                    + 'Z'\n                    + 'M' + (2.5 * x) + ',' + (y + 8)\n                    + 'V' + (2 * y - 8)\n                    + 'M' + (4.5 * x) + ',' + (y + 8)\n                    + 'V' + (2 * y - 8);\n            }\n    \n    \n            function updateBrushBG() {\n                if (!brush.empty()) brush.extent(brushExtent);\n                brushBG\n                    .data([brush.empty() ? x.domain() : brushExtent])\n                    .each(function(d,i) {\n                        var leftWidth = x(d[0]) - x.range()[0],\n                            rightWidth = availableWidth - x(d[1]);\n                        d3.select(this).select('.left')\n                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);\n    \n                        d3.select(this).select('.right')\n                            .attr('x', x(d[1]))\n                            .attr('width', rightWidth < 0 ? 0 : rightWidth);\n                    });\n            }\n\n\n            function onBrush(shouldDispatch) {\n                brushExtent = brush.empty() ? null : brush.extent();\n                var extent = brush.empty() ? x.domain() : brush.extent();\n                dispatch.brush({extent: extent, brush: brush});\n                updateBrushBG();\n                if (shouldDispatch) {\n                    dispatch.onBrush(extent);\n                }\n            }\n        });\n\n        renderWatch.renderEnd('focus immediate');\n        return chart;\n    }\n\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.content = content;\n    chart.brush = brush;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        brushExtent: {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},\n        syncBrushing: {get: function(){return syncBrushing;}, set: function(_){syncBrushing=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            content.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            content.color(color);\n        }},\n        interpolate: {get: function(){return content.interpolate();}, set: function(_){\n            content.interpolate(_);\n        }},\n        xTickFormat: {get: function(){return xAxis.tickFormat();}, set: function(_){\n            xAxis.tickFormat(_);\n        }},\n        yTickFormat: {get: function(){return yAxis.tickFormat();}, set: function(_){\n            yAxis.tickFormat(_);\n        }},\n        x: {get: function(){return content.x();}, set: function(_){\n            content.x(_);\n        }},\n        y: {get: function(){return content.y();}, set: function(_){\n            content.y(_);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( rightAlignYAxis ? 'right' : 'left');\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, content);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\nnv.models.forceDirectedGraph = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n    var margin = {top: 2, right: 0, bottom: 2, left: 0}\n        , width = 400\n        , height = 32\n        , container = null\n        , dispatch = d3.dispatch('renderEnd')\n        , color = nv.utils.getColor(['#000'])\n        , tooltip      = nv.models.tooltip()\n        , noData = null\n        // Force directed graph specific parameters [default values]\n        , linkStrength = 0.1\n        , friction = 0.9\n        , linkDist = 30\n        , charge = -120\n        , gravity = 0.1\n        , theta = 0.8\n        , alpha = 0.1\n        , radius = 5\n        // These functions allow to add extra attributes to ndes and links\n        ,nodeExtras = function(nodes) { /* Do nothing */ }\n        ,linkExtras = function(links) { /* Do nothing */ }\n        ;\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    function chart(selection) {\n        renderWatch.reset();\n\n        selection.each(function(data) {\n          container = d3.select(this);\n          nv.utils.initSVG(container);\n\n          var availableWidth = nv.utils.availableWidth(width, container, margin),\n              availableHeight = nv.utils.availableHeight(height, container, margin);\n\n          container\n                  .attr(\"width\", availableWidth)\n                  .attr(\"height\", availableHeight);\n\n          // Display No Data message if there's nothing to show.\n          if (!data || !data.links || !data.nodes) {\n              nv.utils.noData(chart, container)\n              return chart;\n          } else {\n              container.selectAll('.nv-noData').remove();\n          }\n          container.selectAll('*').remove();\n\n          // Collect names of all fields in the nodes\n          var nodeFieldSet = new Set();\n          data.nodes.forEach(function(node) {\n            var keys = Object.keys(node);\n            keys.forEach(function(key) {\n              nodeFieldSet.add(key);\n            });\n          });\n\n          var force = d3.layout.force()\n                .nodes(data.nodes)\n                .links(data.links)\n                .size([availableWidth, availableHeight])\n                .linkStrength(linkStrength)\n                .friction(friction)\n                .linkDistance(linkDist)\n                .charge(charge)\n                .gravity(gravity)\n                .theta(theta)\n                .alpha(alpha)\n                .start();\n\n          var link = container.selectAll(\".link\")\n                .data(data.links)\n                .enter().append(\"line\")\n                .attr(\"class\", \"nv-force-link\")\n                .style(\"stroke-width\", function(d) { return Math.sqrt(d.value); });\n\n          var node = container.selectAll(\".node\")\n                .data(data.nodes)\n                .enter()\n                .append(\"g\")\n                .attr(\"class\", \"nv-force-node\")\n                .call(force.drag);\n\n          node\n            .append(\"circle\")\n            .attr(\"r\", radius)\n            .style(\"fill\", function(d) { return color(d) } )\n            .on(\"mouseover\", function(evt) {\n              container.select('.nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)\n                  .attr('y1', evt.py);\n              container.select('.nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)\n                  .attr('x2', evt.px);\n\n              // Add 'series' object to\n              var nodeColor = color(evt);\n              evt.series = [];\n              nodeFieldSet.forEach(function(field) {\n                evt.series.push({\n                  color: nodeColor,\n                  key:   field,\n                  value: evt[field]\n                });\n              });\n              tooltip.data(evt).hidden(false);\n            })\n            .on(\"mouseout\",  function(d) {\n              tooltip.hidden(true);\n            });\n\n          tooltip.headerFormatter(function(d) {return \"Node\";});\n\n          // Apply extra attributes to nodes and links (if any)\n          linkExtras(link);\n          nodeExtras(node);\n\n          force.on(\"tick\", function() {\n              link.attr(\"x1\", function(d) { return d.source.x; })\n                  .attr(\"y1\", function(d) { return d.source.y; })\n                  .attr(\"x2\", function(d) { return d.target.x; })\n                  .attr(\"y2\", function(d) { return d.target.y; });\n\n              node.attr(\"transform\", function(d) {\n                return \"translate(\" + d.x + \", \" + d.y + \")\";\n              });\n            });\n        });\n\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:     {get: function(){return width;}, set: function(_){width=_;}},\n        height:    {get: function(){return height;}, set: function(_){height=_;}},\n\n        // Force directed graph specific parameters\n        linkStrength:{get: function(){return linkStrength;}, set: function(_){linkStrength=_;}},\n        friction:    {get: function(){return friction;}, set: function(_){friction=_;}},\n        linkDist:    {get: function(){return linkDist;}, set: function(_){linkDist=_;}},\n        charge:      {get: function(){return charge;}, set: function(_){charge=_;}},\n        gravity:     {get: function(){return gravity;}, set: function(_){gravity=_;}},\n        theta:       {get: function(){return theta;}, set: function(_){theta=_;}},\n        alpha:       {get: function(){return alpha;}, set: function(_){alpha=_;}},\n        radius:      {get: function(){return radius;}, set: function(_){radius=_;}},\n\n        //functor options\n        x: {get: function(){return getX;}, set: function(_){getX=d3.functor(_);}},\n        y: {get: function(){return getY;}, set: function(_){getY=d3.functor(_);}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        nodeExtras: {get: function(){return nodeExtras;}, set: function(_){\n            nodeExtras = _;\n        }},\n        linkExtras: {get: function(){return linkExtras;}, set: function(_){\n            linkExtras = _;\n        }}\n    });\n\n    chart.dispatch = dispatch;\n    chart.tooltip = tooltip;\n    nv.utils.initOptions(chart);\n    return chart;\n};\nnv.models.furiousLegend = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 5, right: 0, bottom: 5, left: 0}\n        , width = 400\n        , height = 20\n        , getKey = function(d) { return d.key }\n        , keyFormatter = function (d) { return d }\n        , color = nv.utils.getColor()\n        , maxKeyLength = 20 //default value for key lengths\n        , align = true\n        , padding = 28 //define how much space between legend items. - recommend 32 for furious version\n        , rightAlign = true\n        , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.\n        , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)\n        , expanded = false\n        , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')\n        , vers = 'classic' //Options are \"classic\" and \"furious\"\n        ;\n\n    function chart(selection) {\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-legend').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');\n            var g = wrap.select('g');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            var series = g.selectAll('.nv-series')\n                .data(function(d) {\n                    if(vers != 'furious') return d;\n\n                    return d.filter(function(n) {\n                        return expanded ? true : !n.disengaged;\n                    });\n                });\n            var seriesEnter = series.enter().append('g').attr('class', 'nv-series')\n\n            var seriesShape;\n\n            if(vers == 'classic') {\n                seriesEnter.append('circle')\n                    .style('stroke-width', 2)\n                    .attr('class','nv-legend-symbol')\n                    .attr('r', 5);\n\n                seriesShape = series.select('circle');\n            } else if (vers == 'furious') {\n                seriesEnter.append('rect')\n                    .style('stroke-width', 2)\n                    .attr('class','nv-legend-symbol')\n                    .attr('rx', 3)\n                    .attr('ry', 3);\n\n                seriesShape = series.select('rect');\n\n                seriesEnter.append('g')\n                    .attr('class', 'nv-check-box')\n                    .property('innerHTML','<path d=\"M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z\" class=\"nv-box\"></path><path d=\"M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511\" class=\"nv-check\"></path>')\n                    .attr('transform', 'translate(-10,-8)scale(0.5)');\n\n                var seriesCheckbox = series.select('.nv-check-box');\n\n                seriesCheckbox.each(function(d,i) {\n                    d3.select(this).selectAll('path')\n                        .attr('stroke', setTextColor(d,i));\n                });\n            }\n\n            seriesEnter.append('text')\n                .attr('text-anchor', 'start')\n                .attr('class','nv-legend-text')\n                .attr('dy', '.32em')\n                .attr('dx', '8');\n\n            var seriesText = series.select('text.nv-legend-text');\n\n            series\n                .on('mouseover', function(d,i) {\n                    dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects\n                })\n                .on('mouseout', function(d,i) {\n                    dispatch.legendMouseout(d,i);\n                })\n                .on('click', function(d,i) {\n                    dispatch.legendClick(d,i);\n                    // make sure we re-get data in case it was modified\n                    var data = series.data();\n                    if (updateState) {\n                        if(vers =='classic') {\n                            if (radioButtonMode) {\n                                //Radio button mode: set every series to disabled,\n                                //  and enable the clicked series.\n                                data.forEach(function(series) { series.disabled = true});\n                                d.disabled = false;\n                            }\n                            else {\n                                d.disabled = !d.disabled;\n                                if (data.every(function(series) { return series.disabled})) {\n                                    //the default behavior of NVD3 legends is, if every single series\n                                    // is disabled, turn all series' back on.\n                                    data.forEach(function(series) { series.disabled = false});\n                                }\n                            }\n                        } else if(vers == 'furious') {\n                            if(expanded) {\n                                d.disengaged = !d.disengaged;\n                                d.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;\n                                d.disabled = d.disengaged || d.userDisabled;\n                            } else if (!expanded) {\n                                d.disabled = !d.disabled;\n                                d.userDisabled = d.disabled;\n                                var engaged = data.filter(function(d) { return !d.disengaged; });\n                                if (engaged.every(function(series) { return series.userDisabled })) {\n                                    //the default behavior of NVD3 legends is, if every single series\n                                    // is disabled, turn all series' back on.\n                                    data.forEach(function(series) {\n                                        series.disabled = series.userDisabled = false;\n                                    });\n                                }\n                            }\n                        }\n                        dispatch.stateChange({\n                            disabled: data.map(function(d) { return !!d.disabled }),\n                            disengaged: data.map(function(d) { return !!d.disengaged })\n                        });\n\n                    }\n                })\n                .on('dblclick', function(d,i) {\n                    if(vers == 'furious' && expanded) return;\n                    dispatch.legendDblclick(d,i);\n                    if (updateState) {\n                        // make sure we re-get data in case it was modified\n                        var data = series.data();\n                        //the default behavior of NVD3 legends, when double clicking one,\n                        // is to set all other series' to false, and make the double clicked series enabled.\n                        data.forEach(function(series) {\n                            series.disabled = true;\n                            if(vers == 'furious') series.userDisabled = series.disabled;\n                        });\n                        d.disabled = false;\n                        if(vers == 'furious') d.userDisabled = d.disabled;\n                        dispatch.stateChange({\n                            disabled: data.map(function(d) { return !!d.disabled })\n                        });\n                    }\n                });\n\n            series.classed('nv-disabled', function(d) { return d.userDisabled });\n            series.exit().remove();\n\n            seriesText\n                .attr('fill', setTextColor)\n                .text(function (d) { return keyFormatter(getKey(d)) });\n\n            //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)\n            // NEW ALIGNING CODE, TODO: clean up\n\n            var versPadding;\n            switch(vers) {\n                case 'furious' :\n                    versPadding = 23;\n                    break;\n                case 'classic' :\n                    versPadding = 20;\n            }\n\n            if (align) {\n\n                var seriesWidths = [];\n                series.each(function(d,i) {\n                    var legendText;\n                    if (keyFormatter(getKey(d)) && keyFormatter(getKey(d)).length > maxKeyLength) {\n                        var trimmedKey = keyFormatter(getKey(d)).substring(0, maxKeyLength);\n                        legendText = d3.select(this).select('text').text(trimmedKey + \"...\");\n                        d3.select(this).append(\"svg:title\").text(keyFormatter(getKey(d)));\n                    } else {\n                        legendText = d3.select(this).select('text');\n                    }\n                    var nodeTextLength;\n                    try {\n                        nodeTextLength = legendText.node().getComputedTextLength();\n                        // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead\n                        if(nodeTextLength <= 0) throw Error();\n                    }\n                    catch(e) {\n                        nodeTextLength = nv.utils.calcApproxTextWidth(legendText);\n                    }\n\n                    seriesWidths.push(nodeTextLength + padding);\n                });\n\n                var seriesPerRow = 0;\n                var legendWidth = 0;\n                var columnWidths = [];\n\n                while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {\n                    columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];\n                    legendWidth += seriesWidths[seriesPerRow++];\n                }\n                if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row\n\n                while ( legendWidth > availableWidth && seriesPerRow > 1 ) {\n                    columnWidths = [];\n                    seriesPerRow--;\n\n                    for (var k = 0; k < seriesWidths.length; k++) {\n                        if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )\n                            columnWidths[k % seriesPerRow] = seriesWidths[k];\n                    }\n\n                    legendWidth = columnWidths.reduce(function(prev, cur, index, array) {\n                        return prev + cur;\n                    });\n                }\n\n                var xPositions = [];\n                for (var i = 0, curX = 0; i < seriesPerRow; i++) {\n                    xPositions[i] = curX;\n                    curX += columnWidths[i];\n                }\n\n                series\n                    .attr('transform', function(d, i) {\n                        return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * versPadding) + ')';\n                    });\n\n                //position legend as far right as possible within the total width\n                if (rightAlign) {\n                    g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');\n                }\n                else {\n                    g.attr('transform', 'translate(0' + ',' + margin.top + ')');\n                }\n\n                height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * versPadding);\n\n            } else {\n\n                var ypos = 5,\n                    newxpos = 5,\n                    maxwidth = 0,\n                    xpos;\n                series\n                    .attr('transform', function(d, i) {\n                        var length = d3.select(this).select('text').node().getComputedTextLength() + padding;\n                        xpos = newxpos;\n\n                        if (width < margin.left + margin.right + xpos + length) {\n                            newxpos = xpos = 5;\n                            ypos += versPadding;\n                        }\n\n                        newxpos += length;\n                        if (newxpos > maxwidth) maxwidth = newxpos;\n\n                        return 'translate(' + xpos + ',' + ypos + ')';\n                    });\n\n                //position legend as far right as possible within the total width\n                g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');\n\n                height = margin.top + margin.bottom + ypos + 15;\n            }\n\n            if(vers == 'furious') {\n                // Size rectangles after text is placed\n                seriesShape\n                    .attr('width', function(d,i) {\n                        return seriesText[0][i].getComputedTextLength() + 27;\n                    })\n                    .attr('height', 18)\n                    .attr('y', -9)\n                    .attr('x', -15)\n            }\n\n            seriesShape\n                .style('fill', setBGColor)\n                .style('stroke', function(d,i) { return d.color || color(d, i) });\n        });\n\n        function setTextColor(d,i) {\n            if(vers != 'furious') return '#000';\n            if(expanded) {\n                return d.disengaged ? color(d,i) : '#fff';\n            } else if (!expanded) {\n                return !!d.disabled ? color(d,i) : '#fff';\n            }\n        }\n\n        function setBGColor(d,i) {\n            if(expanded && vers == 'furious') {\n                return d.disengaged ? '#fff' : color(d,i);\n            } else {\n                return !!d.disabled ? '#fff' : color(d,i);\n            }\n        }\n\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:          {get: function(){return width;}, set: function(_){width=_;}},\n        height:         {get: function(){return height;}, set: function(_){height=_;}},\n        key:            {get: function(){return getKey;}, set: function(_){getKey=_;}},\n        keyFormatter:   {get: function(){return keyFormatter;}, set: function(_){keyFormatter=_;}},\n        align:          {get: function(){return align;}, set: function(_){align=_;}},\n        rightAlign:     {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},\n        maxKeyLength:   {get: function(){return maxKeyLength;}, set: function(_){maxKeyLength=_;}},\n        padding:        {get: function(){return padding;}, set: function(_){padding=_;}},\n        updateState:    {get: function(){return updateState;}, set: function(_){updateState=_;}},\n        radioButtonMode:{get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},\n        expanded:       {get: function(){return expanded;}, set: function(_){expanded=_;}},\n        vers:           {get: function(){return vers;}, set: function(_){vers=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n//TODO: consider deprecating and using multibar with single series for this\nnv.models.historicalBar = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = null\n        , height = null\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container = null\n        , x = d3.scale.linear()\n        , y = d3.scale.linear()\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , forceX = []\n        , forceY = [0]\n        , padData = false\n        , clipEdge = true\n        , color = nv.utils.defaultColor()\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')\n        , interactive = true\n        ;\n\n    var renderWatch = nv.utils.renderWatch(dispatch, 0);\n\n    function chart(selection) {\n        selection.each(function(data) {\n            renderWatch.reset();\n\n            container = d3.select(this);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            nv.utils.initSVG(container);\n\n            // Setup Scales\n            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));\n\n            if (padData)\n                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);\n            else\n                x.range(xRange || [0, availableWidth]);\n\n            y.domain(yDomain || d3.extent(data[0].values.map(getY).concat(forceY) ))\n                .range(yRange || [availableHeight, 0]);\n\n            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n            if (x.domain()[0] === x.domain()[1])\n                x.domain()[0] ?\n                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])\n                    : x.domain([-1,1]);\n\n            if (y.domain()[0] === y.domain()[1])\n                y.domain()[0] ?\n                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])\n                    : y.domain([-1,1]);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-historicalBar-' + id).data([data[0].values]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBar-' + id);\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-bars');\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            container\n                .on('click', function(d,i) {\n                    dispatch.chartClick({\n                        data: d,\n                        index: i,\n                        pos: d3.event,\n                        id: id\n                    });\n                });\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-chart-clip-path-' + id)\n                .append('rect');\n\n            wrap.select('#nv-chart-clip-path-' + id + ' rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            g.attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');\n\n            var bars = wrap.select('.nv-bars').selectAll('.nv-bar')\n                .data(function(d) { return d }, function(d,i) {return getX(d,i)});\n            bars.exit().remove();\n\n            bars.enter().append('rect')\n                .attr('x', 0 )\n                .attr('y', function(d,i) {  return nv.utils.NaNtoZero(y(Math.max(0, getY(d,i)))) })\n                .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.abs(y(getY(d,i)) - y(0))) })\n                .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })\n                .on('mouseover', function(d,i) {\n                    if (!interactive) return;\n                    d3.select(this).classed('hover', true);\n                    dispatch.elementMouseover({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n\n                })\n                .on('mouseout', function(d,i) {\n                    if (!interactive) return;\n                    d3.select(this).classed('hover', false);\n                    dispatch.elementMouseout({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mousemove', function(d,i) {\n                    if (!interactive) return;\n                    dispatch.elementMousemove({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('click', function(d,i) {\n                    if (!interactive) return;\n                    var element = this;\n                    dispatch.elementClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\"),\n                        event: d3.event,\n                        element: element\n                    });\n                    d3.event.stopPropagation();\n                })\n                .on('dblclick', function(d,i) {\n                    if (!interactive) return;\n                    dispatch.elementDblClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                    d3.event.stopPropagation();\n                });\n\n            bars\n                .attr('fill', function(d,i) { return color(d, i); })\n                .attr('class', function(d,i,j) { return (getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive') + ' nv-bar-' + j + '-' + i })\n                .watchTransition(renderWatch, 'bars')\n                .attr('transform', function(d,i) { return 'translate(' + (x(getX(d,i)) - availableWidth / data[0].values.length * .45) + ',0)'; })\n                //TODO: better width calculations that don't assume always uniform data spacing;w\n                .attr('width', (availableWidth / data[0].values.length) * .9 );\n\n            bars.watchTransition(renderWatch, 'bars')\n                .attr('y', function(d,i) {\n                    var rval = getY(d,i) < 0 ?\n                        y(0) :\n                            y(0) - y(getY(d,i)) < 1 ?\n                        y(0) - 1 :\n                        y(getY(d,i));\n                    return nv.utils.NaNtoZero(rval);\n                })\n                .attr('height', function(d,i) { return nv.utils.NaNtoZero(Math.max(Math.abs(y(getY(d,i)) - y(0)),1)) });\n\n        });\n\n        renderWatch.renderEnd('historicalBar immediate');\n        return chart;\n    }\n\n    //Create methods to allow outside functions to highlight a specific bar.\n    chart.highlightPoint = function(pointIndex, isHoverOver) {\n        container\n            .select(\".nv-bars .nv-bar-0-\" + pointIndex)\n            .classed(\"hover\", isHoverOver)\n        ;\n    };\n\n    chart.clearHighlights = function() {\n        container\n            .select(\".nv-bars .nv-bar.hover\")\n            .classed(\"hover\", false)\n        ;\n    };\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:   {get: function(){return width;}, set: function(_){width=_;}},\n        height:  {get: function(){return height;}, set: function(_){height=_;}},\n        forceX:  {get: function(){return forceX;}, set: function(_){forceX=_;}},\n        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        padData: {get: function(){return padData;}, set: function(_){padData=_;}},\n        x:       {get: function(){return getX;}, set: function(_){getX=_;}},\n        y:       {get: function(){return getY;}, set: function(_){getY=_;}},\n        xScale:  {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:  {get: function(){return y;}, set: function(_){y=_;}},\n        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n        id:          {get: function(){return id;}, set: function(_){id=_;}},\n        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.historicalBarChart = function(bar_model) {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var bars = bar_model || nv.models.historicalBar()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , legend = nv.models.legend()\n        , interactiveLayer = nv.interactiveGuideline()\n        , tooltip = nv.models.tooltip()\n        ;\n\n\n    var margin = {top: 30, right: 90, bottom: 50, left: 90}\n        , marginTop = null\n        , color = nv.utils.defaultColor()\n        , width = null\n        , height = null\n        , showLegend = false\n        , showXAxis = true\n        , showYAxis = true\n        , rightAlignYAxis = false\n        , useInteractiveGuideline = false\n        , x\n        , y\n        , state = {}\n        , defaultState = null\n        , noData = null\n        , dispatch = d3.dispatch('tooltipHide', 'stateChange', 'changeState', 'renderEnd')\n        , transitionDuration = 250\n        ;\n\n    xAxis.orient('bottom').tickPadding(7);\n    yAxis.orient( (rightAlignYAxis) ? 'right' : 'left');\n    tooltip\n        .duration(0)\n        .headerEnabled(false)\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        })\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch, 0);\n\n    function chart(selection) {\n        selection.each(function(data) {\n            renderWatch.reset();\n            renderWatch.models(bars);\n            if (showXAxis) renderWatch.models(xAxis);\n            if (showYAxis) renderWatch.models(yAxis);\n\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() { container.transition().duration(transitionDuration).call(chart) };\n            chart.container = this;\n\n            //set state.disabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display noData message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = bars.xScale();\n            y = bars.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-historicalBarChart').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-historicalBarChart').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis');\n            gEnter.append('g').attr('class', 'nv-barsWrap');\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n            gEnter.append('g').attr('class', 'nv-interactive');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                legend.width(availableWidth);\n\n                g.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                wrap.select('.nv-legendWrap')\n                    .attr('transform', 'translate(0,' + (-margin.top) +')')\n            }\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            //Set up interactive layer\n            if (useInteractiveGuideline) {\n                interactiveLayer\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .margin({left:margin.left, top:margin.top})\n                    .svgContainer(container)\n                    .xScale(x);\n                wrap.select(\".nv-interactive\").call(interactiveLayer);\n            }\n            bars\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled }));\n\n            var barsWrap = g.select('.nv-barsWrap')\n                .datum(data.filter(function(d) { return !d.disabled }));\n            barsWrap.transition().call(bars);\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight, 0);\n\n                g.select('.nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y.range()[0] + ')');\n                g.select('.nv-x.nv-axis')\n                    .transition()\n                    .call(xAxis);\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n\n                g.select('.nv-y.nv-axis')\n                    .transition()\n                    .call(yAxis);\n            }\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            interactiveLayer.dispatch.on('elementMousemove', function(e) {\n                bars.clearHighlights();\n\n                var singlePoint, pointIndex, pointXLocation, allData = [];\n                data\n                    .filter(function(series, i) {\n                        series.seriesIndex = i;\n                        return !series.disabled;\n                    })\n                    .forEach(function(series,i) {\n                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n                        bars.highlightPoint(pointIndex,true);\n                        var point = series.values[pointIndex];\n                        if (point === undefined) return;\n                        if (singlePoint === undefined) singlePoint = point;\n                        if (pointXLocation === undefined) pointXLocation = chart.xScale()(chart.x()(point,pointIndex));\n                        allData.push({\n                            key: series.key,\n                            value: chart.y()(point, pointIndex),\n                            color: color(series,series.seriesIndex),\n                            data: series.values[pointIndex]\n                        });\n                    });\n\n                var xValue = xAxis.tickFormat()(chart.x()(singlePoint,pointIndex));\n                interactiveLayer.tooltip\n                    .valueFormatter(function(d,i) {\n                        return yAxis.tickFormat()(d);\n                    })\n                    .data({\n                        value: xValue,\n                        index: pointIndex,\n                        series: allData\n                    })();\n\n                interactiveLayer.renderGuideLine(pointXLocation);\n\n            });\n\n            interactiveLayer.dispatch.on(\"elementMouseout\",function(e) {\n                dispatch.tooltipHide();\n                bars.clearHighlights();\n            });\n\n            legend.dispatch.on('legendClick', function(d,i) {\n                d.disabled = !d.disabled;\n\n                if (!data.filter(function(d) { return !d.disabled }).length) {\n                    data.map(function(d) {\n                        d.disabled = false;\n                        wrap.selectAll('.nv-series').classed('disabled', false);\n                        return d;\n                    });\n                }\n\n                state.disabled = data.map(function(d) { return !!d.disabled });\n                dispatch.stateChange(state);\n\n                selection.transition().call(chart);\n            });\n\n            legend.dispatch.on('legendDblclick', function(d) {\n                //Double clicking should always enable current series, and disabled all others.\n                data.forEach(function(d) {\n                    d.disabled = true;\n                });\n                d.disabled = false;\n\n                state.disabled = data.map(function(d) { return !!d.disabled });\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n\n                    state.disabled = e.disabled;\n                }\n\n                chart.update();\n            });\n        });\n\n        renderWatch.renderEnd('historicalBarChart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    bars.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt['series'] = {\n            key: chart.x()(evt.data),\n            value: chart.y()(evt.data),\n            color: evt.color\n        };\n        tooltip.data(evt).hidden(false);\n    });\n\n    bars.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    bars.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.bars = bars;\n    chart.legend = legend;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.interactiveLayer = interactiveLayer;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        showXAxis: {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis: {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n            bars.color(color);\n        }},\n        duration:    {get: function(){return transitionDuration;}, set: function(_){\n            transitionDuration=_;\n            renderWatch.reset(transitionDuration);\n            yAxis.duration(transitionDuration);\n            xAxis.duration(transitionDuration);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( (_) ? 'right' : 'left');\n        }},\n        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){\n            useInteractiveGuideline = _;\n            if (_ === true) {\n                chart.interactive(false);\n            }\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, bars);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\n\n// ohlcChart is just a historical chart with ohlc bars and some tweaks\nnv.models.ohlcBarChart = function() {\n    var chart = nv.models.historicalBarChart(nv.models.ohlcBar());\n\n    // special default tooltip since we show multiple values per x\n    chart.useInteractiveGuideline(true);\n    chart.interactiveLayer.tooltip.contentGenerator(function(data) {\n        // we assume only one series exists for this chart\n        var d = data.series[0].data;\n        // match line colors as defined in nv.d3.css\n        var color = d.open < d.close ? \"2ca02c\" : \"d62728\";\n        return '' +\n            '<h3 style=\"color: #' + color + '\">' + data.value + '</h3>' +\n            '<table>' +\n            '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' +\n            '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' +\n            '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' +\n            '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' +\n            '</table>';\n    });\n    return chart;\n};\n\n// candlestickChart is just a historical chart with candlestick bars and some tweaks\nnv.models.candlestickBarChart = function() {\n    var chart = nv.models.historicalBarChart(nv.models.candlestickBar());\n\n    // special default tooltip since we show multiple values per x\n    chart.useInteractiveGuideline(true);\n    chart.interactiveLayer.tooltip.contentGenerator(function(data) {\n        // we assume only one series exists for this chart\n        var d = data.series[0].data;\n        // match line colors as defined in nv.d3.css\n        var color = d.open < d.close ? \"2ca02c\" : \"d62728\";\n        return '' +\n            '<h3 style=\"color: #' + color + '\">' + data.value + '</h3>' +\n            '<table>' +\n            '<tr><td>open:</td><td>' + chart.yAxis.tickFormat()(d.open) + '</td></tr>' +\n            '<tr><td>close:</td><td>' + chart.yAxis.tickFormat()(d.close) + '</td></tr>' +\n            '<tr><td>high</td><td>' + chart.yAxis.tickFormat()(d.high) + '</td></tr>' +\n            '<tr><td>low:</td><td>' + chart.yAxis.tickFormat()(d.low) + '</td></tr>' +\n            '</table>';\n    });\n    return chart;\n};\nnv.models.legend = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 5, right: 0, bottom: 5, left: 0}\n        , width = 400\n        , height = 20\n        , getKey = function(d) { return d.key }\n        , keyFormatter = function (d) { return d }\n        , color = nv.utils.getColor()\n        , maxKeyLength = 20 //default value for key lengths\n        , align = true\n        , padding = 32 //define how much space between legend items. - recommend 32 for furious version\n        , rightAlign = true\n        , updateState = true   //If true, legend will update data.disabled and trigger a 'stateChange' dispatch.\n        , radioButtonMode = false   //If true, clicking legend items will cause it to behave like a radio button. (only one can be selected at a time)\n        , expanded = false\n        , dispatch = d3.dispatch('legendClick', 'legendDblclick', 'legendMouseover', 'legendMouseout', 'stateChange')\n        , vers = 'classic' //Options are \"classic\" and \"furious\"\n        ;\n\n    function chart(selection) {\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-legend').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-legend').append('g');\n            var g = wrap.select('g');\n\n            if (rightAlign)\n                wrap.attr('transform', 'translate(' + (- margin.right) + ',' + margin.top + ')');\n            else\n                wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            var series = g.selectAll('.nv-series')\n                .data(function(d) {\n                    if(vers != 'furious') return d;\n\n                    return d.filter(function(n) {\n                        return expanded ? true : !n.disengaged;\n                    });\n                });\n\n            var seriesEnter = series.enter().append('g').attr('class', 'nv-series');\n            var seriesShape;\n\n            var versPadding;\n            switch(vers) {\n                case 'furious' :\n                    versPadding = 23;\n                    break;\n                case 'classic' :\n                    versPadding = 20;\n            }\n\n            if(vers == 'classic') {\n                seriesEnter.append('circle')\n                    .style('stroke-width', 2)\n                    .attr('class','nv-legend-symbol')\n                    .attr('r', 5);\n\n                seriesShape = series.select('.nv-legend-symbol');\n            } else if (vers == 'furious') {\n                seriesEnter.append('rect')\n                    .style('stroke-width', 2)\n                    .attr('class','nv-legend-symbol')\n                    .attr('rx', 3)\n                    .attr('ry', 3);\n                seriesShape = series.select('.nv-legend-symbol');\n\n                seriesEnter.append('g')\n                    .attr('class', 'nv-check-box')\n                    .property('innerHTML','<path d=\"M0.5,5 L22.5,5 L22.5,26.5 L0.5,26.5 L0.5,5 Z\" class=\"nv-box\"></path><path d=\"M5.5,12.8618467 L11.9185089,19.2803556 L31,0.198864511\" class=\"nv-check\"></path>')\n                    .attr('transform', 'translate(-10,-8)scale(0.5)');\n\n                var seriesCheckbox = series.select('.nv-check-box');\n\n                seriesCheckbox.each(function(d,i) {\n                    d3.select(this).selectAll('path')\n                        .attr('stroke', setTextColor(d,i));\n                });\n            }\n\n            seriesEnter.append('text')\n                .attr('text-anchor', 'start')\n                .attr('class','nv-legend-text')\n                .attr('dy', '.32em')\n                .attr('dx', '8');\n\n            var seriesText = series.select('text.nv-legend-text');\n\n            series\n                .on('mouseover', function(d,i) {\n                    dispatch.legendMouseover(d,i);  //TODO: Make consistent with other event objects\n                })\n                .on('mouseout', function(d,i) {\n                    dispatch.legendMouseout(d,i);\n                })\n                .on('click', function(d,i) {\n                    dispatch.legendClick(d,i);\n                    // make sure we re-get data in case it was modified\n                    var data = series.data();\n                    if (updateState) {\n                        if(vers =='classic') {\n                            if (radioButtonMode) {\n                                //Radio button mode: set every series to disabled,\n                                //  and enable the clicked series.\n                                data.forEach(function(series) { series.disabled = true});\n                                d.disabled = false;\n                            }\n                            else {\n                                d.disabled = !d.disabled;\n                                if (data.every(function(series) { return series.disabled})) {\n                                    //the default behavior of NVD3 legends is, if every single series\n                                    // is disabled, turn all series' back on.\n                                    data.forEach(function(series) { series.disabled = false});\n                                }\n                            }\n                        } else if(vers == 'furious') {\n                            if(expanded) {\n                                d.disengaged = !d.disengaged;\n                                d.userDisabled = d.userDisabled == undefined ? !!d.disabled : d.userDisabled;\n                                d.disabled = d.disengaged || d.userDisabled;\n                            } else if (!expanded) {\n                                d.disabled = !d.disabled;\n                                d.userDisabled = d.disabled;\n                                var engaged = data.filter(function(d) { return !d.disengaged; });\n                                if (engaged.every(function(series) { return series.userDisabled })) {\n                                    //the default behavior of NVD3 legends is, if every single series\n                                    // is disabled, turn all series' back on.\n                                    data.forEach(function(series) {\n                                        series.disabled = series.userDisabled = false;\n                                    });\n                                }\n                            }\n                        }\n                        dispatch.stateChange({\n                            disabled: data.map(function(d) { return !!d.disabled }),\n                            disengaged: data.map(function(d) { return !!d.disengaged })\n                        });\n\n                    }\n                })\n                .on('dblclick', function(d,i) {\n                    if(vers == 'furious' && expanded) return;\n                    dispatch.legendDblclick(d,i);\n                    if (updateState) {\n                        // make sure we re-get data in case it was modified\n                        var data = series.data();\n                        //the default behavior of NVD3 legends, when double clicking one,\n                        // is to set all other series' to false, and make the double clicked series enabled.\n                        data.forEach(function(series) {\n                            series.disabled = true;\n                            if(vers == 'furious') series.userDisabled = series.disabled;\n                        });\n                        d.disabled = false;\n                        if(vers == 'furious') d.userDisabled = d.disabled;\n                        dispatch.stateChange({\n                            disabled: data.map(function(d) { return !!d.disabled })\n                        });\n                    }\n                });\n\n            series.classed('nv-disabled', function(d) { return d.userDisabled });\n            series.exit().remove();\n\n            seriesText\n                .attr('fill', setTextColor)\n                .text(function (d) { return keyFormatter(getKey(d)) });\n\n            //TODO: implement fixed-width and max-width options (max-width is especially useful with the align option)\n            // NEW ALIGNING CODE, TODO: clean up\n            var legendWidth = 0;\n            if (align) {\n\n                var seriesWidths = [];\n                series.each(function(d,i) {\n                    var legendText;\n                    if (keyFormatter(getKey(d)) && keyFormatter(getKey(d)).length > maxKeyLength) {\n                        var trimmedKey = keyFormatter(getKey(d)).substring(0, maxKeyLength);\n                        legendText = d3.select(this).select('text').text(trimmedKey + \"...\");\n                        d3.select(this).append(\"svg:title\").text(keyFormatter(getKey(d)));\n                    } else {\n                        legendText = d3.select(this).select('text');\n                    }\n                    var nodeTextLength;\n                    try {\n                        nodeTextLength = legendText.node().getComputedTextLength();\n                        // If the legendText is display:none'd (nodeTextLength == 0), simulate an error so we approximate, instead\n                        if(nodeTextLength <= 0) throw Error();\n                    }\n                    catch(e) {\n                        nodeTextLength = nv.utils.calcApproxTextWidth(legendText);\n                    }\n\n                    seriesWidths.push(nodeTextLength + padding);\n                });\n\n                var seriesPerRow = 0;\n                var columnWidths = [];\n                legendWidth = 0;\n\n                while ( legendWidth < availableWidth && seriesPerRow < seriesWidths.length) {\n                    columnWidths[seriesPerRow] = seriesWidths[seriesPerRow];\n                    legendWidth += seriesWidths[seriesPerRow++];\n                }\n                if (seriesPerRow === 0) seriesPerRow = 1; //minimum of one series per row\n\n                while ( legendWidth > availableWidth && seriesPerRow > 1 ) {\n                    columnWidths = [];\n                    seriesPerRow--;\n\n                    for (var k = 0; k < seriesWidths.length; k++) {\n                        if (seriesWidths[k] > (columnWidths[k % seriesPerRow] || 0) )\n                            columnWidths[k % seriesPerRow] = seriesWidths[k];\n                    }\n\n                    legendWidth = columnWidths.reduce(function(prev, cur, index, array) {\n                        return prev + cur;\n                    });\n                }\n\n                var xPositions = [];\n                for (var i = 0, curX = 0; i < seriesPerRow; i++) {\n                    xPositions[i] = curX;\n                    curX += columnWidths[i];\n                }\n\n                series\n                    .attr('transform', function(d, i) {\n                        return 'translate(' + xPositions[i % seriesPerRow] + ',' + (5 + Math.floor(i / seriesPerRow) * versPadding) + ')';\n                    });\n\n                //position legend as far right as possible within the total width\n                if (rightAlign) {\n                    g.attr('transform', 'translate(' + (width - margin.right - legendWidth) + ',' + margin.top + ')');\n                }\n                else {\n                    g.attr('transform', 'translate(0' + ',' + margin.top + ')');\n                }\n\n                height = margin.top + margin.bottom + (Math.ceil(seriesWidths.length / seriesPerRow) * versPadding);\n\n            } else {\n\n                var ypos = 5,\n                    newxpos = 5,\n                    maxwidth = 0,\n                    xpos;\n                series\n                    .attr('transform', function(d, i) {\n                        var length = d3.select(this).select('text').node().getComputedTextLength() + padding;\n                        xpos = newxpos;\n\n                        if (width < margin.left + margin.right + xpos + length) {\n                            newxpos = xpos = 5;\n                            ypos += versPadding;\n                        }\n\n                        newxpos += length;\n                        if (newxpos > maxwidth) maxwidth = newxpos;\n\n                        if(legendWidth < xpos + maxwidth) {\n                            legendWidth = xpos + maxwidth;\n                        }\n                        return 'translate(' + xpos + ',' + ypos + ')';\n                    });\n\n                //position legend as far right as possible within the total width\n                g.attr('transform', 'translate(' + (width - margin.right - maxwidth) + ',' + margin.top + ')');\n\n                height = margin.top + margin.bottom + ypos + 15;\n            }\n\n            if(vers == 'furious') {\n                // Size rectangles after text is placed\n                seriesShape\n                    .attr('width', function(d,i) {\n                        return seriesText[0][i].getComputedTextLength() + 27;\n                    })\n                    .attr('height', 18)\n                    .attr('y', -9)\n                    .attr('x', -15);\n\n                // The background for the expanded legend (UI)\n                gEnter.insert('rect',':first-child')\n                    .attr('class', 'nv-legend-bg')\n                    .attr('fill', '#eee')\n                    // .attr('stroke', '#444')\n                    .attr('opacity',0);\n\n                var seriesBG = g.select('.nv-legend-bg');\n\n                seriesBG\n                .transition().duration(300)\n                    .attr('x', -versPadding )\n                    .attr('width', legendWidth + versPadding - 12)\n                    .attr('height', height + 10)\n                    .attr('y', -margin.top - 10)\n                    .attr('opacity', expanded ? 1 : 0);\n\n\n            }\n\n            seriesShape\n                .style('fill', setBGColor)\n                .style('fill-opacity', setBGOpacity)\n                .style('stroke', setBGColor);\n        });\n\n        function setTextColor(d,i) {\n            if(vers != 'furious') return '#000';\n            if(expanded) {\n                return d.disengaged ? '#000' : '#fff';\n            } else if (!expanded) {\n                if(!d.color) d.color = color(d,i);\n                return !!d.disabled ? d.color : '#fff';\n            }\n        }\n\n        function setBGColor(d,i) {\n            if(expanded && vers == 'furious') {\n                return d.disengaged ? '#eee' : d.color || color(d,i);\n            } else {\n                return d.color || color(d,i);\n            }\n        }\n\n\n        function setBGOpacity(d,i) {\n            if(expanded && vers == 'furious') {\n                return 1;\n            } else {\n                return !!d.disabled ? 0 : 1;\n            }\n        }\n\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:          {get: function(){return width;}, set: function(_){width=_;}},\n        height:         {get: function(){return height;}, set: function(_){height=_;}},\n        key:            {get: function(){return getKey;}, set: function(_){getKey=_;}},\n        keyFormatter:   {get: function(){return keyFormatter;}, set: function(_){keyFormatter=_;}},\n        align:          {get: function(){return align;}, set: function(_){align=_;}},\n        maxKeyLength:   {get: function(){return maxKeyLength;}, set: function(_){maxKeyLength=_;}},\n        rightAlign:     {get: function(){return rightAlign;}, set: function(_){rightAlign=_;}},\n        padding:        {get: function(){return padding;}, set: function(_){padding=_;}},\n        updateState:    {get: function(){return updateState;}, set: function(_){updateState=_;}},\n        radioButtonMode:{get: function(){return radioButtonMode;}, set: function(_){radioButtonMode=_;}},\n        expanded:       {get: function(){return expanded;}, set: function(_){expanded=_;}},\n        vers:           {get: function(){return vers;}, set: function(_){vers=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.line = function() {\n    \"use strict\";\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var  scatter = nv.models.scatter()\n        ;\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 960\n        , height = 500\n        , container = null\n        , strokeWidth = 1.5\n        , color = nv.utils.defaultColor() // a function that returns a color\n        , getX = function(d) { return d.x } // accessor to get the x value from a data point\n        , getY = function(d) { return d.y } // accessor to get the y value from a data point\n        , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined\n        , isArea = function(d) { return d.area } // decides if a line is an area or just a line\n        , clipEdge = false // if true, masks lines within x and y scale\n        , x //can be accessed via chart.xScale()\n        , y //can be accessed via chart.yScale()\n        , interpolate = \"linear\" // controls the line interpolation\n        , duration = 250\n        , dispatch = d3.dispatch('elementClick', 'elementMouseover', 'elementMouseout', 'renderEnd')\n        ;\n\n    scatter\n        .pointSize(16) // default size\n        .pointDomain([16,256]) //set to speed up calculation, needs to be unset if there is a custom size accessor\n    ;\n\n    //============================================================\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x0, y0 //used to store previous scales\n        , renderWatch = nv.utils.renderWatch(dispatch, duration)\n        ;\n\n    //============================================================\n\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(scatter);\n        selection.each(function(data) {\n            container = d3.select(this);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n            nv.utils.initSVG(container);\n\n            // Setup Scales\n            x = scatter.xScale();\n            y = scatter.yScale();\n\n            x0 = x0 || x;\n            y0 = y0 || y;\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-line').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-line');\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-groups');\n            gEnter.append('g').attr('class', 'nv-scatterWrap');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            scatter\n                .width(availableWidth)\n                .height(availableHeight);\n\n            var scatterWrap = wrap.select('.nv-scatterWrap');\n            scatterWrap.call(scatter);\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-edge-clip-' + scatter.id())\n                .append('rect');\n\n            wrap.select('#nv-edge-clip-' + scatter.id() + ' rect')\n                .attr('width', availableWidth)\n                .attr('height', (availableHeight > 0) ? availableHeight : 0);\n\n            g   .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');\n            scatterWrap\n                .attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + scatter.id() + ')' : '');\n\n            var groups = wrap.select('.nv-groups').selectAll('.nv-group')\n                .data(function(d) { return d }, function(d) { return d.key });\n            groups.enter().append('g')\n                .style('stroke-opacity', 1e-6)\n                .style('stroke-width', function(d) { return d.strokeWidth || strokeWidth })\n                .style('fill-opacity', 1e-6);\n\n            groups.exit().remove();\n\n            groups\n                .attr('class', function(d,i) {\n                    return (d.classed || '') + ' nv-group nv-series-' + i;\n                })\n                .classed('hover', function(d) { return d.hover })\n                .style('fill', function(d,i){ return color(d, i) })\n                .style('stroke', function(d,i){ return color(d, i)});\n            groups.watchTransition(renderWatch, 'line: groups')\n                .style('stroke-opacity', 1)\n                .style('fill-opacity', function(d) { return d.fillOpacity || .5});\n\n            var areaPaths = groups.selectAll('path.nv-area')\n                .data(function(d) { return isArea(d) ? [d] : [] }); // this is done differently than lines because I need to check if series is an area\n            areaPaths.enter().append('path')\n                .attr('class', 'nv-area')\n                .attr('d', function(d) {\n                    return d3.svg.area()\n                        .interpolate(interpolate)\n                        .defined(defined)\n                        .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })\n                        .y0(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })\n                        .y1(function(d,i) { return y0( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })\n                        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this\n                        .apply(this, [d.values])\n                });\n            groups.exit().selectAll('path.nv-area')\n                .remove();\n\n            areaPaths.watchTransition(renderWatch, 'line: areaPaths')\n                .attr('d', function(d) {\n                    return d3.svg.area()\n                        .interpolate(interpolate)\n                        .defined(defined)\n                        .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })\n                        .y0(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })\n                        .y1(function(d,i) { return y( y.domain()[0] <= 0 ? y.domain()[1] >= 0 ? 0 : y.domain()[1] : y.domain()[0] ) })\n                        //.y1(function(d,i) { return y0(0) }) //assuming 0 is within y domain.. may need to tweak this\n                        .apply(this, [d.values])\n                });\n\n            var linePaths = groups.selectAll('path.nv-line')\n                .data(function(d) { return [d.values] });\n\n            linePaths.enter().append('path')\n                .attr('class', 'nv-line')\n                .attr('d',\n                    d3.svg.line()\n                    .interpolate(interpolate)\n                    .defined(defined)\n                    .x(function(d,i) { return nv.utils.NaNtoZero(x0(getX(d,i))) })\n                    .y(function(d,i) { return nv.utils.NaNtoZero(y0(getY(d,i))) })\n            );\n\n            linePaths.watchTransition(renderWatch, 'line: linePaths')\n                .attr('d',\n                    d3.svg.line()\n                    .interpolate(interpolate)\n                    .defined(defined)\n                    .x(function(d,i) { return nv.utils.NaNtoZero(x(getX(d,i))) })\n                    .y(function(d,i) { return nv.utils.NaNtoZero(y(getY(d,i))) })\n            );\n\n            //store old scales for use in transitions on update\n            x0 = x.copy();\n            y0 = y.copy();\n        });\n        renderWatch.renderEnd('line immediate');\n        return chart;\n    }\n\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.scatter = scatter;\n    // Pass through events\n    scatter.dispatch.on('elementClick', function(){ dispatch.elementClick.apply(this, arguments); });\n    scatter.dispatch.on('elementMouseover', function(){ dispatch.elementMouseover.apply(this, arguments); });\n    scatter.dispatch.on('elementMouseout', function(){ dispatch.elementMouseout.apply(this, arguments); });\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        defined: {get: function(){return defined;}, set: function(_){defined=_;}},\n        interpolate:      {get: function(){return interpolate;}, set: function(_){interpolate=_;}},\n        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            scatter.duration(duration);\n        }},\n        isArea: {get: function(){return isArea;}, set: function(_){\n            isArea = d3.functor(_);\n        }},\n        x: {get: function(){return getX;}, set: function(_){\n            getX = _;\n            scatter.x(_);\n        }},\n        y: {get: function(){return getY;}, set: function(_){\n            getY = _;\n            scatter.y(_);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            scatter.color(color);\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, scatter);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\nnv.models.lineChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var lines = nv.models.line()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , legend = nv.models.legend()\n        , interactiveLayer = nv.interactiveGuideline()\n        , tooltip = nv.models.tooltip()\n        , focus = nv.models.focus(nv.models.line())\n        ;\n\n    var margin = {top: 30, right: 20, bottom: 50, left: 60}\n        , marginTop = null\n        , color = nv.utils.defaultColor()\n        , width = null\n        , height = null\n        , showLegend = true\n        , legendPosition = 'top'\n        , showXAxis = true\n        , showYAxis = true\n        , rightAlignYAxis = false\n        , useInteractiveGuideline = false\n        , x\n        , y\n        , focusEnable = false\n        , state = nv.utils.state()\n        , defaultState = null\n        , noData = null\n        , dispatch = d3.dispatch('tooltipShow', 'tooltipHide', 'stateChange', 'changeState', 'renderEnd')\n        , duration = 250\n        ;\n\n    // set options on sub-objects for this chart\n    xAxis.orient('bottom').tickPadding(7);\n    yAxis.orient(rightAlignYAxis ? 'right' : 'left');\n\n    lines.clipEdge(true).duration(0);\n\n    tooltip.valueFormatter(function(d, i) {\n        return yAxis.tickFormat()(d, i);\n    }).headerFormatter(function(d, i) {\n        return xAxis.tickFormat()(d, i);\n    });\n\n    interactiveLayer.tooltip.valueFormatter(function(d, i) {\n        return yAxis.tickFormat()(d, i);\n    }).headerFormatter(function(d, i) {\n        return xAxis.tickFormat()(d, i);\n    });\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled; })\n            };\n        };\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        };\n    };\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(lines);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);\n            chart.update = function() {\n                if( duration === 0 ) {\n                    container.call( chart );\n                } else {\n                    container.transition().duration(duration).call(chart);\n                }\n            };\n            chart.container = this;\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disabled\n            state.disabled = data.map(function(d) { return !!d.disabled; });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display noData message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length; }).length) {\n                nv.utils.noData(chart, container);\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            /* Update `main' graph on brush update. */\n            focus.dispatch.on(\"onBrush\", function(extent) {\n                onBrush(extent);\n            });\n\n            // Setup Scales\n            x = lines.xScale();\n            y = lines.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-lineChart').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-lineChart').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n\n            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');\n            focusEnter.append('g').attr('class', 'nv-background').append('rect');\n            focusEnter.append('g').attr('class', 'nv-x nv-axis');\n            focusEnter.append('g').attr('class', 'nv-y nv-axis');\n            focusEnter.append('g').attr('class', 'nv-linesWrap');\n            focusEnter.append('g').attr('class', 'nv-interactive');\n\n            var contextEnter = gEnter.append('g').attr('class', 'nv-focusWrap');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                legend.width(availableWidth);\n\n                g.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (legendPosition === 'bottom') {\n                    wrap.select('.nv-legendWrap')\n                        .attr('transform', 'translate(0,' + availableHeight +')');\n                } else if (legendPosition === 'top') {\n                    if (!marginTop && legend.height() !== margin.top) {\n                        margin.top = legend.height();\n                        availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);\n                    }\n\n                    wrap.select('.nv-legendWrap')\n                        .attr('transform', 'translate(0,' + (-margin.top) +')');\n                }\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            //Set up interactive layer\n            if (useInteractiveGuideline) {\n                interactiveLayer\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .margin({left:margin.left, top:margin.top})\n                    .svgContainer(container)\n                    .xScale(x);\n                wrap.select(\".nv-interactive\").call(interactiveLayer);\n            }\n\n            g.select('.nv-focus .nv-background rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            lines\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled; }));\n\n            var linesWrap = g.select('.nv-linesWrap')\n                .datum(data.filter(function(d) { return !d.disabled; }));\n\n\n            // Setup Main (Focus) Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks(nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight, 0);\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n            }\n\n            //============================================================\n            // Update Axes\n            //============================================================\n            function updateXAxis() {\n              if(showXAxis) {\n                g.select('.nv-focus .nv-x.nv-axis')\n                  .transition()\n                  .duration(duration)\n                  .call(xAxis)\n                ;\n              }\n            }\n\n            function updateYAxis() {\n              if(showYAxis) {\n                g.select('.nv-focus .nv-y.nv-axis')\n                  .transition()\n                  .duration(duration)\n                  .call(yAxis)\n                ;\n              }\n            }\n\n            g.select('.nv-focus .nv-x.nv-axis')\n                .attr('transform', 'translate(0,' + availableHeight + ')');\n\n            //============================================================\n            // Update Focus\n            //============================================================\n            if(!focusEnable) {\n                linesWrap.call(lines);\n                updateXAxis();\n                updateYAxis();\n            } else {\n                focus.width(availableWidth);\n                g.select('.nv-focusWrap')\n                    .attr('transform', 'translate(0,' + ( availableHeight + margin.bottom + focus.margin().top) + ')')\n                    .datum(data.filter(function(d) { return !d.disabled; }))\n                    .call(focus);\n                var extent = focus.brush.empty() ? focus.xDomain() : focus.brush.extent();\n                if(extent !== null){\n                    onBrush(extent);\n                }\n            }\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            interactiveLayer.dispatch.on('elementMousemove', function(e) {\n                lines.clearHighlights();\n                var singlePoint, pointIndex, pointXLocation, allData = [];\n                data\n                    .filter(function(series, i) {\n                        series.seriesIndex = i;\n                        return !series.disabled && !series.disableTooltip;\n                    })\n                    .forEach(function(series,i) {\n                        var extent = focusEnable ? (focus.brush.empty() ? focus.xScale().domain() : focus.brush.extent()) : x.domain();\n                        var currentValues = series.values.filter(function(d,i) {\n                            // Checks if the x point is between the extents, handling case where extent[0] is greater than extent[1]\n                            // (e.g. x domain is manually set to reverse the x-axis)\n                            if(extent[0] <= extent[1]) {\n                                return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];\n                            } else {\n                                return lines.x()(d,i) >= extent[1] && lines.x()(d,i) <= extent[0];\n                            }\n                        });\n\n                        pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, lines.x());\n                        var point = currentValues[pointIndex];\n                        var pointYValue = chart.y()(point, pointIndex);\n                        if (pointYValue !== null) {\n                            lines.highlightPoint(i, pointIndex, true);\n                        }\n                        if (point === undefined) return;\n                        if (singlePoint === undefined) singlePoint = point;\n                        if (pointXLocation === undefined) pointXLocation = chart.xScale()(chart.x()(point,pointIndex));\n                        allData.push({\n                            key: series.key,\n                            value: pointYValue,\n                            color: color(series,series.seriesIndex),\n                            data: point\n                        });\n                    });\n                //Highlight the tooltip entry based on which point the mouse is closest to.\n                if (allData.length > 2) {\n                    var yValue = chart.yScale().invert(e.mouseY);\n                    var domainExtent = Math.abs(chart.yScale().domain()[0] - chart.yScale().domain()[1]);\n                    var threshold = 0.03 * domainExtent;\n                    var indexToHighlight = nv.nearestValueIndex(allData.map(function(d){return d.value;}),yValue,threshold);\n                    if (indexToHighlight !== null)\n                        allData[indexToHighlight].highlight = true;\n                }\n\n                var defaultValueFormatter = function(d,i) {\n                    return d == null ? \"N/A\" : yAxis.tickFormat()(d);\n                };\n\n                interactiveLayer.tooltip\n                    .valueFormatter(interactiveLayer.tooltip.valueFormatter() || defaultValueFormatter)\n                    .data({\n                        value: chart.x()( singlePoint,pointIndex ),\n                        index: pointIndex,\n                        series: allData\n                    })();\n\n                interactiveLayer.renderGuideLine(pointXLocation);\n\n            });\n\n            interactiveLayer.dispatch.on('elementClick', function(e) {\n                var pointXLocation, allData = [];\n\n                data.filter(function(series, i) {\n                    series.seriesIndex = i;\n                    return !series.disabled;\n                }).forEach(function(series) {\n                    var pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n                    var point = series.values[pointIndex];\n                    if (typeof point === 'undefined') return;\n                    if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));\n                    var yPos = chart.yScale()(chart.y()(point,pointIndex));\n                    allData.push({\n                        point: point,\n                        pointIndex: pointIndex,\n                        pos: [pointXLocation, yPos],\n                        seriesIndex: series.seriesIndex,\n                        series: series\n                    });\n                });\n\n                lines.dispatch.elementClick(allData);\n            });\n\n            interactiveLayer.dispatch.on(\"elementMouseout\",function(e) {\n                lines.clearHighlights();\n            });\n\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n\n                    state.disabled = e.disabled;\n                }\n                chart.update();\n            });\n\n            //============================================================\n            // Functions\n            //------------------------------------------------------------\n\n            // Taken from crossfilter (http://square.github.com/crossfilter/)\n            function resizePath(d) {\n                var e = +(d == 'e'),\n                    x = e ? 1 : -1,\n                    y = availableHeight / 3;\n                return 'M' + (0.5 * x) + ',' + y\n                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)\n                    + 'V' + (2 * y - 6)\n                    + 'A6,6 0 0 ' + e + ' ' + (0.5 * x) + ',' + (2 * y)\n                    + 'Z'\n                    + 'M' + (2.5 * x) + ',' + (y + 8)\n                    + 'V' + (2 * y - 8)\n                    + 'M' + (4.5 * x) + ',' + (y + 8)\n                    + 'V' + (2 * y - 8);\n            }\n\n            function onBrush(extent) {\n                // Update Main (Focus)\n                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')\n                    .datum(\n                    data.filter(function(d) { return !d.disabled; })\n                        .map(function(d,i) {\n                            return {\n                                key: d.key,\n                                area: d.area,\n                                classed: d.classed,\n                                values: d.values.filter(function(d,i) {\n                                    return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];\n                                }),\n                                disableTooltip: d.disableTooltip\n                            };\n                        })\n                );\n                focusLinesWrap.transition().duration(duration).call(lines);\n\n                // Update Main (Focus) Axes\n                updateXAxis();\n                updateYAxis();\n            }\n        });\n\n        renderWatch.renderEnd('lineChart immediate');\n        return chart;\n    }\n\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    lines.dispatch.on('elementMouseover.tooltip', function(evt) {\n        if(!evt.series.disableTooltip){\n            tooltip.data(evt).hidden(false);\n        }\n    });\n\n    lines.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.lines = lines;\n    chart.legend = legend;\n    chart.focus = focus;\n    chart.xAxis = xAxis;\n    chart.x2Axis = focus.xAxis\n    chart.yAxis = yAxis;\n    chart.y2Axis = focus.yAxis\n    chart.interactiveLayer = interactiveLayer;\n    chart.tooltip = tooltip;\n    chart.state = state;\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        legendPosition: {get: function(){return legendPosition;}, set: function(_){legendPosition=_;}},\n        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        // Focus options, mostly passed onto focus model.\n        focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},\n        focusHeight:     {get: function(){return focus.height();}, set: function(_){focus.height(_);}},\n        focusShowAxisX:    {get: function(){return focus.showXAxis();}, set: function(_){focus.showXAxis(_);}},\n        focusShowAxisY:    {get: function(){return focus.showYAxis();}, set: function(_){focus.showYAxis(_);}},\n        brushExtent: {get: function(){return focus.brushExtent();}, set: function(_){focus.brushExtent(_);}},\n\n        // options that require extra logic in the setter\n        focusMargin: {get: function(){return focus.margin}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            focus.margin.right  = _.right  !== undefined ? _.right  : focus.margin.right;\n            focus.margin.bottom = _.bottom !== undefined ? _.bottom : focus.margin.bottom;\n            focus.margin.left   = _.left   !== undefined ? _.left   : focus.margin.left;\n        }},\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            lines.duration(duration);\n            focus.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n            lines.color(color);\n            focus.color(color);\n        }},\n        interpolate: {get: function(){return lines.interpolate();}, set: function(_){\n            lines.interpolate(_);\n            focus.interpolate(_);\n        }},\n        xTickFormat: {get: function(){return xAxis.tickFormat();}, set: function(_){\n            xAxis.tickFormat(_);\n            focus.xTickFormat(_);\n        }},\n        yTickFormat: {get: function(){return yAxis.tickFormat();}, set: function(_){\n            yAxis.tickFormat(_);\n            focus.yTickFormat(_);\n        }},\n        x: {get: function(){return lines.x();}, set: function(_){\n            lines.x(_);\n            focus.x(_);\n        }},\n        y: {get: function(){return lines.y();}, set: function(_){\n            lines.y(_);\n            focus.y(_);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( rightAlignYAxis ? 'right' : 'left');\n        }},\n        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){\n            useInteractiveGuideline = _;\n            if (useInteractiveGuideline) {\n                lines.interactive(false);\n                lines.useVoronoi(false);\n            }\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, lines);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.lineWithFocusChart = function() {\n  return nv.models.lineChart()\n    .margin({ bottom: 30 })\n    .focusEnable( true );\n};\nnv.models.linePlusBarChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var lines = nv.models.line()\n        , lines2 = nv.models.line()\n        , bars = nv.models.historicalBar()\n        , bars2 = nv.models.historicalBar()\n        , xAxis = nv.models.axis()\n        , x2Axis = nv.models.axis()\n        , y1Axis = nv.models.axis()\n        , y2Axis = nv.models.axis()\n        , y3Axis = nv.models.axis()\n        , y4Axis = nv.models.axis()\n        , legend = nv.models.legend()\n        , brush = d3.svg.brush()\n        , tooltip = nv.models.tooltip()\n        ;\n\n    var margin = {top: 30, right: 30, bottom: 30, left: 60}\n        , marginTop = null\n        , margin2 = {top: 0, right: 30, bottom: 20, left: 60}\n        , width = null\n        , height = null\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , color = nv.utils.defaultColor()\n        , showLegend = true\n        , focusEnable = true\n        , focusShowAxisY = false\n        , focusShowAxisX = true\n        , focusHeight = 50\n        , extent\n        , brushExtent = null\n        , x\n        , x2\n        , y1\n        , y2\n        , y3\n        , y4\n        , noData = null\n        , dispatch = d3.dispatch('brush', 'stateChange', 'changeState')\n        , transitionDuration = 0\n        , state = nv.utils.state()\n        , defaultState = null\n        , legendLeftAxisHint = ' (left axis)'\n        , legendRightAxisHint = ' (right axis)'\n        , switchYAxisOrder = false\n        ;\n\n    lines.clipEdge(true);\n    lines2.interactive(false);\n    // We don't want any points emitted for the focus chart's scatter graph.\n    lines2.pointActive(function(d) { return false });\n    xAxis.orient('bottom').tickPadding(5);\n    y1Axis.orient('left');\n    y2Axis.orient('right');\n    x2Axis.orient('bottom').tickPadding(5);\n    y3Axis.orient('left');\n    y4Axis.orient('right');\n\n    tooltip.headerEnabled(true).headerFormatter(function(d, i) {\n        return xAxis.tickFormat()(d, i);\n    });\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var getBarsAxis = function() {\n        return switchYAxisOrder\n            ? { main: y2Axis, focus: y4Axis }\n            : { main: y1Axis, focus: y3Axis }\n    }\n\n    var getLinesAxis = function() {\n        return switchYAxisOrder\n            ? { main: y1Axis, focus: y3Axis }\n            : { main: y2Axis, focus: y4Axis }\n    }\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled })\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        }\n    };\n\n    var allDisabled = function(data) {\n      return data.every(function(series) {\n        return series.disabled;\n      });\n    }\n\n    function chart(selection) {\n        selection.each(function(data) {\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight1 = nv.utils.availableHeight(height, container, margin)\n                    - (focusEnable ? focusHeight : 0),\n                availableHeight2 = focusHeight - margin2.top - margin2.bottom;\n\n            chart.update = function() { container.transition().duration(transitionDuration).call(chart); };\n            chart.container = this;\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disableddisabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            var dataBars = data.filter(function(d) { return !d.disabled && d.bar });\n            var dataLines = data.filter(function(d) { return !d.bar }); // removed the !d.disabled clause here to fix Issue #240\n\n            if (dataBars.length && !switchYAxisOrder) {\n                x = bars.xScale();\n            } else {\n                x = lines.xScale();\n            }\n\n            x2 = x2Axis.scale();\n\n            // select the scales and series based on the position of the yAxis\n            y1 = switchYAxisOrder ? lines.yScale() : bars.yScale();\n            y2 = switchYAxisOrder ? bars.yScale() : lines.yScale();\n            y3 = switchYAxisOrder ? lines2.yScale() : bars2.yScale();\n            y4 = switchYAxisOrder ? bars2.yScale() : lines2.yScale();\n\n            var series1 = data\n                .filter(function(d) { return !d.disabled && (switchYAxisOrder ? !d.bar : d.bar) })\n                .map(function(d) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d,i), y: getY(d,i) }\n                    })\n                });\n\n            var series2 = data\n                .filter(function(d) { return !d.disabled && (switchYAxisOrder ? d.bar : !d.bar) })\n                .map(function(d) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d,i), y: getY(d,i) }\n                    })\n                });\n\n            x.range([0, availableWidth]);\n\n            x2  .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x } ))\n                .range([0, availableWidth]);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-linePlusBar').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-linePlusBar').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n\n            // this is the main chart\n            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');\n            focusEnter.append('g').attr('class', 'nv-x nv-axis');\n            focusEnter.append('g').attr('class', 'nv-y1 nv-axis');\n            focusEnter.append('g').attr('class', 'nv-y2 nv-axis');\n            focusEnter.append('g').attr('class', 'nv-barsWrap');\n            focusEnter.append('g').attr('class', 'nv-linesWrap');\n\n            // context chart is where you can focus in\n            var contextEnter = gEnter.append('g').attr('class', 'nv-context');\n            contextEnter.append('g').attr('class', 'nv-x nv-axis');\n            contextEnter.append('g').attr('class', 'nv-y1 nv-axis');\n            contextEnter.append('g').attr('class', 'nv-y2 nv-axis');\n            contextEnter.append('g').attr('class', 'nv-barsWrap');\n            contextEnter.append('g').attr('class', 'nv-linesWrap');\n            contextEnter.append('g').attr('class', 'nv-brushBackground');\n            contextEnter.append('g').attr('class', 'nv-x nv-brush');\n\n            //============================================================\n            // Legend\n            //------------------------------------------------------------\n\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                var legendWidth = legend.align() ? availableWidth / 2 : availableWidth;\n                var legendXPosition = legend.align() ? legendWidth : 0;\n\n                legend.width(legendWidth);\n\n                g.select('.nv-legendWrap')\n                    .datum(data.map(function(series) {\n                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;\n                        if(switchYAxisOrder) {\n                            series.key = series.originalKey + (series.bar ? legendRightAxisHint : legendLeftAxisHint);\n                        } else {\n                            series.key = series.originalKey + (series.bar ? legendLeftAxisHint : legendRightAxisHint);\n                        }\n                        return series;\n                    }))\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    // FIXME: shouldn't this be \"- (focusEnabled ? focusHeight : 0)\"?\n                    availableHeight1 = nv.utils.availableHeight(height, container, margin) - focusHeight;\n                }\n\n                g.select('.nv-legendWrap')\n                    .attr('transform', 'translate(' + legendXPosition + ',' + (-margin.top) +')');\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            //============================================================\n            // Context chart (focus chart) components\n            //------------------------------------------------------------\n\n            // hide or show the focus context chart\n            g.select('.nv-context').style('display', focusEnable ? 'initial' : 'none');\n\n            bars2\n                .width(availableWidth)\n                .height(availableHeight2)\n                .color(data.map(function (d, i) {\n                    return d.color || color(d, i);\n                }).filter(function (d, i) {\n                    return !data[i].disabled && data[i].bar\n                }));\n            lines2\n                .width(availableWidth)\n                .height(availableHeight2)\n                .color(data.map(function (d, i) {\n                    return d.color || color(d, i);\n                }).filter(function (d, i) {\n                    return !data[i].disabled && !data[i].bar\n                }));\n\n            var bars2Wrap = g.select('.nv-context .nv-barsWrap')\n                .datum(dataBars.length ? dataBars : [\n                    {values: []}\n                ]);\n            var lines2Wrap = g.select('.nv-context .nv-linesWrap')\n                .datum(allDisabled(dataLines) ?\n                       [{values: []}] :\n                       dataLines.filter(function(dataLine) {\n                         return !dataLine.disabled;\n                       }));\n\n            g.select('.nv-context')\n                .attr('transform', 'translate(0,' + ( availableHeight1 + margin.bottom + margin2.top) + ')');\n\n            bars2Wrap.transition().call(bars2);\n            lines2Wrap.transition().call(lines2);\n\n            // context (focus chart) axis controls\n            if (focusShowAxisX) {\n                x2Axis\n                    ._ticks( nv.utils.calcTicksX(availableWidth / 100, data))\n                    .tickSize(-availableHeight2, 0);\n                g.select('.nv-context .nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y3.range()[0] + ')');\n                g.select('.nv-context .nv-x.nv-axis').transition()\n                    .call(x2Axis);\n            }\n\n            if (focusShowAxisY) {\n                y3Axis\n                    .scale(y3)\n                    ._ticks( availableHeight2 / 36 )\n                    .tickSize( -availableWidth, 0);\n                y4Axis\n                    .scale(y4)\n                    ._ticks( availableHeight2 / 36 )\n                    .tickSize(dataBars.length ? 0 : -availableWidth, 0); // Show the y2 rules only if y1 has none\n\n                g.select('.nv-context .nv-y3.nv-axis')\n                    .style('opacity', dataBars.length ? 1 : 0)\n                    .attr('transform', 'translate(0,' + x2.range()[0] + ')');\n                g.select('.nv-context .nv-y2.nv-axis')\n                    .style('opacity', dataLines.length ? 1 : 0)\n                    .attr('transform', 'translate(' + x2.range()[1] + ',0)');\n\n                g.select('.nv-context .nv-y1.nv-axis').transition()\n                    .call(y3Axis);\n                g.select('.nv-context .nv-y2.nv-axis').transition()\n                    .call(y4Axis);\n            }\n\n            // Setup Brush\n            brush.x(x2).on('brush', onBrush);\n\n            if (brushExtent) brush.extent(brushExtent);\n\n            var brushBG = g.select('.nv-brushBackground').selectAll('g')\n                .data([brushExtent || brush.extent()]);\n\n            var brushBGenter = brushBG.enter()\n                .append('g');\n\n            brushBGenter.append('rect')\n                .attr('class', 'left')\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('height', availableHeight2);\n\n            brushBGenter.append('rect')\n                .attr('class', 'right')\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('height', availableHeight2);\n\n            var gBrush = g.select('.nv-x.nv-brush')\n                .call(brush);\n            gBrush.selectAll('rect')\n                //.attr('y', -5)\n                .attr('height', availableHeight2);\n            gBrush.selectAll('.resize').append('path').attr('d', resizePath);\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n                    state.disabled = e.disabled;\n                }\n                chart.update();\n            });\n\n            //============================================================\n            // Functions\n            //------------------------------------------------------------\n\n            // Taken from crossfilter (http://square.github.com/crossfilter/)\n            function resizePath(d) {\n                var e = +(d == 'e'),\n                    x = e ? 1 : -1,\n                    y = availableHeight2 / 3;\n                return 'M' + (.5 * x) + ',' + y\n                    + 'A6,6 0 0 ' + e + ' ' + (6.5 * x) + ',' + (y + 6)\n                    + 'V' + (2 * y - 6)\n                    + 'A6,6 0 0 ' + e + ' ' + (.5 * x) + ',' + (2 * y)\n                    + 'Z'\n                    + 'M' + (2.5 * x) + ',' + (y + 8)\n                    + 'V' + (2 * y - 8)\n                    + 'M' + (4.5 * x) + ',' + (y + 8)\n                    + 'V' + (2 * y - 8);\n            }\n\n\n            function updateBrushBG() {\n                if (!brush.empty()) brush.extent(brushExtent);\n                brushBG\n                    .data([brush.empty() ? x2.domain() : brushExtent])\n                    .each(function(d,i) {\n                        var leftWidth = x2(d[0]) - x2.range()[0],\n                            rightWidth = x2.range()[1] - x2(d[1]);\n                        d3.select(this).select('.left')\n                            .attr('width',  leftWidth < 0 ? 0 : leftWidth);\n\n                        d3.select(this).select('.right')\n                            .attr('x', x2(d[1]))\n                            .attr('width', rightWidth < 0 ? 0 : rightWidth);\n                    });\n            }\n\n            function onBrush() {\n                brushExtent = brush.empty() ? null : brush.extent();\n                extent = brush.empty() ? x2.domain() : brush.extent();\n                dispatch.brush({extent: extent, brush: brush});\n                updateBrushBG();\n\n                // Prepare Main (Focus) Bars and Lines\n                bars\n                    .width(availableWidth)\n                    .height(availableHeight1)\n                    .color(data.map(function(d,i) {\n                        return d.color || color(d, i);\n                    }).filter(function(d,i) { return !data[i].disabled && data[i].bar }));\n\n                lines\n                    .width(availableWidth)\n                    .height(availableHeight1)\n                    .color(data.map(function(d,i) {\n                        return d.color || color(d, i);\n                    }).filter(function(d,i) { return !data[i].disabled && !data[i].bar }));\n\n                var focusBarsWrap = g.select('.nv-focus .nv-barsWrap')\n                    .datum(!dataBars.length ? [{values:[]}] :\n                        dataBars\n                            .map(function(d,i) {\n                                return {\n                                    key: d.key,\n                                    values: d.values.filter(function(d,i) {\n                                        return bars.x()(d,i) >= extent[0] && bars.x()(d,i) <= extent[1];\n                                    })\n                                }\n                            })\n                );\n\n                var focusLinesWrap = g.select('.nv-focus .nv-linesWrap')\n                    .datum(allDisabled(dataLines) ? [{values:[]}] :\n                           dataLines\n                           .filter(function(dataLine) { return !dataLine.disabled; })\n                           .map(function(d,i) {\n                                return {\n                                    area: d.area,\n                                    fillOpacity: d.fillOpacity,\n                                    strokeWidth: d.strokeWidth,\n                                    key: d.key,\n                                    values: d.values.filter(function(d,i) {\n                                        return lines.x()(d,i) >= extent[0] && lines.x()(d,i) <= extent[1];\n                                    })\n                                }\n                            })\n                );\n\n                // Update Main (Focus) X Axis\n                if (dataBars.length && !switchYAxisOrder) {\n                    x = bars.xScale();\n                } else {\n                    x = lines.xScale();\n                }\n\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight1, 0);\n\n                xAxis.domain([Math.ceil(extent[0]), Math.floor(extent[1])]);\n\n                g.select('.nv-x.nv-axis').transition().duration(transitionDuration)\n                    .call(xAxis);\n\n                // Update Main (Focus) Bars and Lines\n                focusBarsWrap.transition().duration(transitionDuration).call(bars);\n                focusLinesWrap.transition().duration(transitionDuration).call(lines);\n\n                // Setup and Update Main (Focus) Y Axes\n                g.select('.nv-focus .nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y1.range()[0] + ')');\n\n                y1Axis\n                    .scale(y1)\n                    ._ticks( nv.utils.calcTicksY(availableHeight1/36, data) )\n                    .tickSize(-availableWidth, 0);\n                y2Axis\n                    .scale(y2)\n                    ._ticks( nv.utils.calcTicksY(availableHeight1/36, data) );\n\n                // Show the y2 rules only if y1 has none\n                if(!switchYAxisOrder) {\n                    y2Axis.tickSize(dataBars.length ? 0 : -availableWidth, 0);\n                } else {\n                    y2Axis.tickSize(dataLines.length ? 0 : -availableWidth, 0);\n                }\n\n                // Calculate opacity of the axis\n                var barsOpacity = dataBars.length ? 1 : 0;\n                var linesOpacity = dataLines.length && !allDisabled(dataLines) ? 1 : 0;\n\n                var y1Opacity = switchYAxisOrder ? linesOpacity : barsOpacity;\n                var y2Opacity = switchYAxisOrder ? barsOpacity : linesOpacity;\n\n                g.select('.nv-focus .nv-y1.nv-axis')\n                    .style('opacity', y1Opacity);\n                g.select('.nv-focus .nv-y2.nv-axis')\n                    .style('opacity', y2Opacity)\n                    .attr('transform', 'translate(' + x.range()[1] + ',0)');\n\n                g.select('.nv-focus .nv-y1.nv-axis').transition().duration(transitionDuration)\n                    .call(y1Axis);\n                g.select('.nv-focus .nv-y2.nv-axis').transition().duration(transitionDuration)\n                    .call(y2Axis);\n            }\n\n            onBrush();\n\n        });\n\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    lines.dispatch.on('elementMouseover.tooltip', function(evt) {\n        tooltip\n            .duration(100)\n            .valueFormatter(function(d, i) {\n                return getLinesAxis().main.tickFormat()(d, i);\n            })\n            .data(evt)\n            .hidden(false);\n    });\n\n    lines.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true)\n    });\n\n    bars.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt.value = chart.x()(evt.data);\n        evt['series'] = {\n            value: chart.y()(evt.data),\n            color: evt.color\n        };\n        tooltip\n            .duration(0)\n            .valueFormatter(function(d, i) {\n                return getBarsAxis().main.tickFormat()(d, i);\n            })\n            .data(evt)\n            .hidden(false);\n    });\n\n    bars.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    bars.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.legend = legend;\n    chart.lines = lines;\n    chart.lines2 = lines2;\n    chart.bars = bars;\n    chart.bars2 = bars2;\n    chart.xAxis = xAxis;\n    chart.x2Axis = x2Axis;\n    chart.y1Axis = y1Axis;\n    chart.y2Axis = y2Axis;\n    chart.y3Axis = y3Axis;\n    chart.y4Axis = y4Axis;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        brushExtent:    {get: function(){return brushExtent;}, set: function(_){brushExtent=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},\n        focusHeight:    {get: function(){return focusHeight;}, set: function(_){focusHeight=_;}},\n        focusShowAxisX:    {get: function(){return focusShowAxisX;}, set: function(_){focusShowAxisX=_;}},\n        focusShowAxisY:    {get: function(){return focusShowAxisY;}, set: function(_){focusShowAxisY=_;}},\n        legendLeftAxisHint:    {get: function(){return legendLeftAxisHint;}, set: function(_){legendLeftAxisHint=_;}},\n        legendRightAxisHint:    {get: function(){return legendRightAxisHint;}, set: function(_){legendRightAxisHint=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        focusMargin: {get: function(){return margin2;}, set: function(_){\n            margin2.top    = _.top    !== undefined ? _.top    : margin2.top;\n            margin2.right  = _.right  !== undefined ? _.right  : margin2.right;\n            margin2.bottom = _.bottom !== undefined ? _.bottom : margin2.bottom;\n            margin2.left   = _.left   !== undefined ? _.left   : margin2.left;\n        }},\n        duration: {get: function(){return transitionDuration;}, set: function(_){\n            transitionDuration = _;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n        }},\n        x: {get: function(){return getX;}, set: function(_){\n            getX = _;\n            lines.x(_);\n            lines2.x(_);\n            bars.x(_);\n            bars2.x(_);\n        }},\n        y: {get: function(){return getY;}, set: function(_){\n            getY = _;\n            lines.y(_);\n            lines2.y(_);\n            bars.y(_);\n            bars2.y(_);\n        }},\n        switchYAxisOrder:    {get: function(){return switchYAxisOrder;}, set: function(_){\n            // Switch the tick format for the yAxis\n            if(switchYAxisOrder !== _) {\n                var y1 = y1Axis;\n                y1Axis = y2Axis;\n                y2Axis = y1;\n\n                var y3 = y3Axis;\n                y3Axis = y4Axis;\n                y4Axis = y3;\n            }\n            switchYAxisOrder=_;\n\n            y1Axis.orient('left');\n            y2Axis.orient('right');\n            y3Axis.orient('left');\n            y4Axis.orient('right');\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, lines);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.multiBar = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 960\n        , height = 500\n        , x = d3.scale.ordinal()\n        , y = d3.scale.linear()\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container = null\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove\n        , clipEdge = true\n        , stacked = false\n        , stackOffset = 'zero' // options include 'silhouette', 'wiggle', 'expand', 'zero', or a custom function\n        , color = nv.utils.defaultColor()\n        , hideable = false\n        , barColor = null // adding the ability to set the color for each rather than the whole group\n        , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled\n        , duration = 500\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , groupSpacing = 0.1\n        , fillOpacity = 0.75\n        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x0, y0 //used to store previous scales\n        , renderWatch = nv.utils.renderWatch(dispatch, duration)\n        ;\n\n    var last_datalength = 0;\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n            var nonStackableCount = 0;\n            // This function defines the requirements for render complete\n            var endFn = function(d, i) {\n                if (d.series === data.length - 1 && i === data[0].values.length - 1)\n                    return true;\n                return false;\n            };\n\n            if(hideable && data.length) hideable = [{\n                values: data[0].values.map(function(d) {\n                        return {\n                            x: d.x,\n                            y: 0,\n                            series: d.series,\n                            size: 0.01\n                        };}\n                )}];\n\n            if (stacked) {\n                var parsed = d3.layout.stack()\n                    .offset(stackOffset)\n                    .values(function(d){ return d.values })\n                    .y(getY)\n                (!data.length && hideable ? hideable : data);\n\n                parsed.forEach(function(series, i){\n                    // if series is non-stackable, use un-parsed data\n                    if (series.nonStackable) {\n                        data[i].nonStackableSeries = nonStackableCount++;\n                        parsed[i] = data[i];\n                    } else {\n                        // don't stack this seires on top of the nonStackable seriees\n                        if (i > 0 && parsed[i - 1].nonStackable){\n                            parsed[i].values.map(function(d,j){\n                                d.y0 -= parsed[i - 1].values[j].y;\n                                d.y1 = d.y0 + d.y;\n                            });\n                        }\n                    }\n                });\n                data = parsed;\n            }\n            //add series index and key to each data point for reference\n            data.forEach(function(series, i) {\n                series.values.forEach(function(point) {\n                    point.series = i;\n                    point.key = series.key;\n                });\n            });\n\n            // HACK for negative value stacking\n            if (stacked && data.length > 0) {\n                data[0].values.map(function(d,i) {\n                    var posBase = 0, negBase = 0;\n                    data.map(function(d, idx) {\n                        if (!data[idx].nonStackable) {\n                            var f = d.values[i]\n                            f.size = Math.abs(f.y);\n                            if (f.y<0)  {\n                                f.y1 = negBase;\n                                negBase = negBase - f.size;\n                            } else\n                            {\n                                f.y1 = f.size + posBase;\n                                posBase = posBase + f.size;\n                            }\n                        }\n\n                    });\n                });\n            }\n            // Setup Scales\n            // remap and flatten the data for use in calculating the scales' domains\n            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate\n                data.map(function(d, idx) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1, idx:idx }\n                    })\n                });\n\n            x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))\n                .rangeBands(xRange || [0, availableWidth], groupSpacing);\n\n            y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) {\n                var domain = d.y;\n                // increase the domain range if this series is stackable\n                if (stacked && !data[d.idx].nonStackable) {\n                    if (d.y > 0){\n                        domain = d.y1\n                    } else {\n                        domain = d.y1 + d.y\n                    }\n                }\n                return domain;\n            }).concat(forceY)))\n            .range(yRange || [availableHeight, 0]);\n\n            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n            if (x.domain()[0] === x.domain()[1])\n                x.domain()[0] ?\n                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])\n                    : x.domain([-1,1]);\n\n            if (y.domain()[0] === y.domain()[1])\n                y.domain()[0] ?\n                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])\n                    : y.domain([-1,1]);\n\n            x0 = x0 || x;\n            y0 = y0 || y;\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-multibar').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibar');\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-groups');\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-edge-clip-' + id)\n                .append('rect');\n            wrap.select('#nv-edge-clip-' + id + ' rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');\n\n            var groups = wrap.select('.nv-groups').selectAll('.nv-group')\n                .data(function(d) { return d }, function(d,i) { return i });\n            groups.enter().append('g')\n                .style('stroke-opacity', 1e-6)\n                .style('fill-opacity', 1e-6);\n\n            var exitTransition = renderWatch\n                .transition(groups.exit().selectAll('rect.nv-bar'), 'multibarExit', Math.min(100, duration))\n                .attr('y', function(d, i, j) {\n                    var yVal = y0(0) || 0;\n                    if (stacked) {\n                        if (data[d.series] && !data[d.series].nonStackable) {\n                            yVal = y0(d.y0);\n                        }\n                    }\n                    return yVal;\n                })\n                .attr('height', 0)\n                .remove();\n            if (exitTransition.delay)\n                exitTransition.delay(function(d,i) {\n                    var delay = i * (duration / (last_datalength + 1)) - i;\n                    return delay;\n                });\n            groups\n                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })\n                .classed('hover', function(d) { return d.hover })\n                .style('fill', function(d,i){ return color(d, i) })\n                .style('stroke', function(d,i){ return color(d, i) });\n            groups\n                .style('stroke-opacity', 1)\n                .style('fill-opacity', fillOpacity);\n\n            var bars = groups.selectAll('rect.nv-bar')\n                .data(function(d) { return (hideable && !data.length) ? hideable.values : d.values });\n            bars.exit().remove();\n\n            var barsEnter = bars.enter().append('rect')\n                    .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})\n                    .attr('x', function(d,i,j) {\n                        return stacked && !data[j].nonStackable ? 0 : (j * x.rangeBand() / data.length )\n                    })\n                    .attr('y', function(d,i,j) { return y0(stacked && !data[j].nonStackable ? d.y0 : 0) || 0 })\n                    .attr('height', 0)\n                    .attr('width', function(d,i,j) { return x.rangeBand() / (stacked && !data[j].nonStackable ? 1 : data.length) })\n                    .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })\n                ;\n            bars\n                .style('fill', function(d,i,j){ return color(d, j, i);  })\n                .style('stroke', function(d,i,j){ return color(d, j, i); })\n                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here\n                    d3.select(this).classed('hover', true);\n                    dispatch.elementMouseover({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mouseout', function(d,i) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.elementMouseout({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mousemove', function(d,i) {\n                    dispatch.elementMousemove({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('click', function(d,i) {\n                    var element = this;\n                    dispatch.elementClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\"),\n                        event: d3.event,\n                        element: element\n                    });\n                    d3.event.stopPropagation();\n                })\n                .on('dblclick', function(d,i) {\n                    dispatch.elementDblClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                    d3.event.stopPropagation();\n                });\n            bars\n                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})\n                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',0)'; })\n\n            if (barColor) {\n                if (!disabled) disabled = data.map(function() { return true });\n                bars\n                    .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })\n                    .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });\n            }\n\n            var barSelection =\n                bars.watchTransition(renderWatch, 'multibar', Math.min(250, duration))\n                    .delay(function(d,i) {\n                        return i * duration / data[0].values.length;\n                    });\n            if (stacked){\n                barSelection\n                    .attr('y', function(d,i,j) {\n                        var yVal = 0;\n                        // if stackable, stack it on top of the previous series\n                        if (!data[j].nonStackable) {\n                            yVal = y(d.y1);\n                        } else {\n                            if (getY(d,i) < 0){\n                                yVal = y(0);\n                            } else {\n                                if (y(0) - y(getY(d,i)) < -1){\n                                    yVal = y(0) - 1;\n                                } else {\n                                    yVal = y(getY(d, i)) || 0;\n                                }\n                            }\n                        }\n                        return yVal;\n                    })\n                    .attr('height', function(d,i,j) {\n                        if (!data[j].nonStackable) {\n                            return Math.max(Math.abs(y(d.y+d.y0) - y(d.y0)), 0);\n                        } else {\n                            return Math.max(Math.abs(y(getY(d,i)) - y(0)), 0) || 0;\n                        }\n                    })\n                    .attr('x', function(d,i,j) {\n                        var width = 0;\n                        if (data[j].nonStackable) {\n                            width = d.series * x.rangeBand() / data.length;\n                            if (data.length !== nonStackableCount){\n                                width = data[j].nonStackableSeries * x.rangeBand()/(nonStackableCount*2);\n                            }\n                        }\n                        return width;\n                    })\n                    .attr('width', function(d,i,j){\n                        if (!data[j].nonStackable) {\n                            return x.rangeBand();\n                        } else {\n                            // if all series are nonStacable, take the full width\n                            var width = (x.rangeBand() / nonStackableCount);\n                            // otherwise, nonStackable graph will be only taking the half-width\n                            // of the x rangeBand\n                            if (data.length !== nonStackableCount) {\n                                width = x.rangeBand()/(nonStackableCount*2);\n                            }\n                            return width;\n                        }\n                    });\n            }\n            else {\n                barSelection\n                    .attr('x', function(d,i) {\n                        return d.series * x.rangeBand() / data.length;\n                    })\n                    .attr('width', x.rangeBand() / data.length)\n                    .attr('y', function(d,i) {\n                        return getY(d,i) < 0 ?\n                            y(0) :\n                                y(0) - y(getY(d,i)) < 1 ?\n                            y(0) - 1 :\n                            y(getY(d,i)) || 0;\n                    })\n                    .attr('height', function(d,i) {\n                        return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0;\n                    });\n            }\n\n            //store old scales for use in transitions on update\n            x0 = x.copy();\n            y0 = y.copy();\n\n            // keep track of the last data value length for transition calculations\n            if (data[0] && data[0].values) {\n                last_datalength = data[0].values.length;\n            }\n\n        });\n\n        renderWatch.renderEnd('multibar immediate');\n\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:   {get: function(){return width;}, set: function(_){width=_;}},\n        height:  {get: function(){return height;}, set: function(_){height=_;}},\n        x:       {get: function(){return getX;}, set: function(_){getX=_;}},\n        y:       {get: function(){return getY;}, set: function(_){getY=_;}},\n        xScale:  {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:  {get: function(){return y;}, set: function(_){y=_;}},\n        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},\n        stackOffset: {get: function(){return stackOffset;}, set: function(_){stackOffset=_;}},\n        clipEdge:    {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n        disabled:    {get: function(){return disabled;}, set: function(_){disabled=_;}},\n        id:          {get: function(){return id;}, set: function(_){id=_;}},\n        hideable:    {get: function(){return hideable;}, set: function(_){hideable=_;}},\n        groupSpacing:{get: function(){return groupSpacing;}, set: function(_){groupSpacing=_;}},\n        fillOpacity: {get: function(){return fillOpacity;}, set: function(_){fillOpacity=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        barColor:  {get: function(){return barColor;}, set: function(_){\n            barColor = _ ? nv.utils.getColor(_) : null;\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\nnv.models.multiBarChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var multibar = nv.models.multiBar()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , interactiveLayer = nv.interactiveGuideline()\n        , legend = nv.models.legend()\n        , controls = nv.models.legend()\n        , tooltip = nv.models.tooltip()\n        ;\n\n    var margin = {top: 30, right: 20, bottom: 50, left: 60}\n        , marginTop = null\n        , width = null\n        , height = null\n        , color = nv.utils.defaultColor()\n        , showControls = true\n        , controlLabels = {}\n        , showLegend = true\n        , showXAxis = true\n        , showYAxis = true\n        , rightAlignYAxis = false\n        , reduceXTicks = true // if false a tick will show for every data point\n        , staggerLabels = false\n        , wrapLabels = false\n        , rotateLabels = 0\n        , x //can be accessed via chart.xScale()\n        , y //can be accessed via chart.yScale()\n        , state = nv.utils.state()\n        , defaultState = null\n        , noData = null\n        , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')\n        , controlWidth = function() { return showControls ? 180 : 0 }\n        , duration = 250\n        , useInteractiveGuideline = false\n        ;\n\n    state.stacked = false // DEPRECATED Maintained for backward compatibility\n\n    multibar.stacked(false);\n    xAxis\n        .orient('bottom')\n        .tickPadding(7)\n        .showMaxMin(false)\n        .tickFormat(function(d) { return d })\n    ;\n    yAxis\n        .orient((rightAlignYAxis) ? 'right' : 'left')\n        .tickFormat(d3.format(',.1f'))\n    ;\n\n    tooltip\n        .duration(0)\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        })\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n    interactiveLayer.tooltip\n        .valueFormatter(function(d, i) {\n            return d == null ? \"N/A\" : yAxis.tickFormat()(d, i);\n        })\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n    interactiveLayer.tooltip\n        .valueFormatter(function (d, i) {\n            return d == null ? \"N/A\" : yAxis.tickFormat()(d, i);\n        })\n        .headerFormatter(function (d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n    interactiveLayer.tooltip\n        .duration(0)\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        })\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n    controls.updateState(false);\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n    var stacked = false;\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled }),\n                stacked: stacked\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.stacked !== undefined)\n                stacked = state.stacked;\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        }\n    };\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(multibar);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() {\n                if (duration === 0)\n                    container.call(chart);\n                else\n                    container.transition()\n                        .duration(duration)\n                        .call(chart);\n            };\n            chart.container = this;\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disableddisabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display noData message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = multibar.xScale();\n            y = multibar.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-multiBarWithLegend').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarWithLegend').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis');\n            gEnter.append('g').attr('class', 'nv-barsWrap');\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n            gEnter.append('g').attr('class', 'nv-controlsWrap');\n            gEnter.append('g').attr('class', 'nv-interactive');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                legend.width(availableWidth - controlWidth());\n\n                g.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                g.select('.nv-legendWrap')\n                    .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');\n            }\n\n            // Controls\n            if (!showControls) {\n                 g.select('.nv-controlsWrap').selectAll('*').remove();\n            } else {\n                var controlsData = [\n                    { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },\n                    { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }\n                ];\n\n                controls.width(controlWidth()).color(['#444', '#444', '#444']);\n                g.select('.nv-controlsWrap')\n                    .datum(controlsData)\n                    .attr('transform', 'translate(0,' + (-margin.top) +')')\n                    .call(controls);\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            // Main Chart Component(s)\n            multibar\n                .disabled(data.map(function(series) { return series.disabled }))\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled }));\n\n\n            var barsWrap = g.select('.nv-barsWrap')\n                .datum(data.filter(function(d) { return !d.disabled }));\n\n            barsWrap.call(multibar);\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize(-availableHeight, 0);\n\n                g.select('.nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y.range()[0] + ')');\n                g.select('.nv-x.nv-axis')\n                    .call(xAxis);\n\n                var xTicks = g.select('.nv-x.nv-axis > g').selectAll('g');\n\n                xTicks\n                    .selectAll('line, text')\n                    .style('opacity', 1)\n\n                if (staggerLabels) {\n                    var getTranslate = function(x,y) {\n                        return \"translate(\" + x + \",\" + y + \")\";\n                    };\n\n                    var staggerUp = 5, staggerDown = 17;  //pixels to stagger by\n                    // Issue #140\n                    xTicks\n                        .selectAll(\"text\")\n                        .attr('transform', function(d,i,j) {\n                            return  getTranslate(0, (j % 2 == 0 ? staggerUp : staggerDown));\n                        });\n\n                    var totalInBetweenTicks = d3.selectAll(\".nv-x.nv-axis .nv-wrap g g text\")[0].length;\n                    g.selectAll(\".nv-x.nv-axis .nv-axisMaxMin text\")\n                        .attr(\"transform\", function(d,i) {\n                            return getTranslate(0, (i === 0 || totalInBetweenTicks % 2 !== 0) ? staggerDown : staggerUp);\n                        });\n                }\n\n                if (wrapLabels) {\n                    g.selectAll('.tick text')\n                        .call(nv.utils.wrapTicks, chart.xAxis.rangeBand())\n                }\n\n                if (reduceXTicks)\n                    xTicks\n                        .filter(function(d,i) {\n                            return i % Math.ceil(data[0].values.length / (availableWidth / 100)) !== 0;\n                        })\n                        .selectAll('text, line')\n                        .style('opacity', 0);\n\n                if(rotateLabels)\n                    xTicks\n                        .selectAll('.tick text')\n                        .attr('transform', 'rotate(' + rotateLabels + ' 0,0)')\n                        .style('text-anchor', rotateLabels > 0 ? 'start' : 'end');\n\n                g.select('.nv-x.nv-axis').selectAll('g.nv-axisMaxMin text')\n                    .style('opacity', 1);\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n\n                g.select('.nv-y.nv-axis')\n                    .call(yAxis);\n            }\n\n            //Set up interactive layer\n            if (useInteractiveGuideline) {\n                interactiveLayer\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .margin({left:margin.left, top:margin.top})\n                    .svgContainer(container)\n                    .xScale(x);\n                wrap.select(\".nv-interactive\").call(interactiveLayer);\n            }\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            controls.dispatch.on('legendClick', function(d,i) {\n                if (!d.disabled) return;\n                controlsData = controlsData.map(function(s) {\n                    s.disabled = true;\n                    return s;\n                });\n                d.disabled = false;\n\n                switch (d.key) {\n                    case 'Grouped':\n                    case controlLabels.grouped:\n                        multibar.stacked(false);\n                        break;\n                    case 'Stacked':\n                    case controlLabels.stacked:\n                        multibar.stacked(true);\n                        break;\n                }\n\n                state.stacked = multibar.stacked();\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n                    state.disabled = e.disabled;\n                }\n                if (typeof e.stacked !== 'undefined') {\n                    multibar.stacked(e.stacked);\n                    state.stacked = e.stacked;\n                    stacked = e.stacked;\n                }\n                chart.update();\n            });\n\n            if (useInteractiveGuideline) {\n                interactiveLayer.dispatch.on('elementMousemove', function(e) {\n                    if (e.pointXValue == undefined) return;\n\n                    var singlePoint, pointIndex, pointXLocation, xValue, allData = [];\n                    data\n                        .filter(function(series, i) {\n                            series.seriesIndex = i;\n                            return !series.disabled;\n                        })\n                        .forEach(function(series,i) {\n                            pointIndex = x.domain().indexOf(e.pointXValue)\n\n                            var point = series.values[pointIndex];\n                            if (point === undefined) return;\n\n                            xValue = point.x;\n                            if (singlePoint === undefined) singlePoint = point;\n                            if (pointXLocation === undefined) pointXLocation = e.mouseX\n                            allData.push({\n                                key: series.key,\n                                value: chart.y()(point, pointIndex),\n                                color: color(series,series.seriesIndex),\n                                data: series.values[pointIndex]\n                            });\n                        });\n\n                    interactiveLayer.tooltip\n                        .data({\n                            value: xValue,\n                            index: pointIndex,\n                            series: allData\n                        })();\n\n                    interactiveLayer.renderGuideLine(pointXLocation);\n                });\n\n                interactiveLayer.dispatch.on(\"elementMouseout\",function(e) {\n                    interactiveLayer.tooltip.hidden(true);\n                });\n            }\n            else {\n                multibar.dispatch.on('elementMouseover.tooltip', function(evt) {\n                    evt.value = chart.x()(evt.data);\n                    evt['series'] = {\n                        key: evt.data.key,\n                        value: chart.y()(evt.data),\n                        color: evt.color\n                    };\n                    tooltip.data(evt).hidden(false);\n                });\n\n                multibar.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true);\n                });\n\n                multibar.dispatch.on('elementMousemove.tooltip', function(evt) {\n                    tooltip();\n                });\n            }\n        });\n\n        renderWatch.renderEnd('multibarchart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.multibar = multibar;\n    chart.legend = legend;\n    chart.controls = controls;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.state = state;\n    chart.tooltip = tooltip;\n    chart.interactiveLayer = interactiveLayer;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},\n        controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},\n        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        reduceXTicks:    {get: function(){return reduceXTicks;}, set: function(_){reduceXTicks=_;}},\n        rotateLabels:    {get: function(){return rotateLabels;}, set: function(_){rotateLabels=_;}},\n        staggerLabels:    {get: function(){return staggerLabels;}, set: function(_){staggerLabels=_;}},\n        wrapLabels:   {get: function(){return wrapLabels;}, set: function(_){wrapLabels=!!_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            multibar.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n            renderWatch.reset(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( rightAlignYAxis ? 'right' : 'left');\n        }},\n        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){\n            useInteractiveGuideline = _;\n        }},\n        barColor:  {get: function(){return multibar.barColor;}, set: function(_){\n            multibar.barColor(_);\n            legend.color(function(d,i) {return d3.rgb('#ccc').darker(i * 1.5).toString();})\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, multibar);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.multiBarHorizontal = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 960\n        , height = 500\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container = null\n        , x = d3.scale.ordinal()\n        , y = d3.scale.linear()\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , getYerr = function(d) { return d.yErr }\n        , forceY = [0] // 0 is forced by default.. this makes sense for the majority of bar graphs... user can always do chart.forceY([]) to remove\n        , color = nv.utils.defaultColor()\n        , barColor = null // adding the ability to set the color for each rather than the whole group\n        , disabled // used in conjunction with barColor to communicate from multiBarHorizontalChart what series are disabled\n        , stacked = false\n        , showValues = false\n        , showBarLabels = false\n        , valuePadding = 60\n        , groupSpacing = 0.1\n        , fillOpacity = 0.75\n        , valueFormat = d3.format(',.2f')\n        , delay = 1200\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , duration = 250\n        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x0, y0; //used to store previous scales\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            if (stacked)\n                data = d3.layout.stack()\n                    .offset('zero')\n                    .values(function(d){ return d.values })\n                    .y(getY)\n                (data);\n\n            //add series index and key to each data point for reference\n            data.forEach(function(series, i) {\n                series.values.forEach(function(point) {\n                    point.series = i;\n                    point.key = series.key;\n                });\n            });\n\n            // HACK for negative value stacking\n            if (stacked)\n                data[0].values.map(function(d,i) {\n                    var posBase = 0, negBase = 0;\n                    data.map(function(d) {\n                        var f = d.values[i]\n                        f.size = Math.abs(f.y);\n                        if (f.y<0)  {\n                            f.y1 = negBase - f.size;\n                            negBase = negBase - f.size;\n                        } else\n                        {\n                            f.y1 = posBase;\n                            posBase = posBase + f.size;\n                        }\n                    });\n                });\n\n            // Setup Scales\n            // remap and flatten the data for use in calculating the scales' domains\n            var seriesData = (xDomain && yDomain) ? [] : // if we know xDomain and yDomain, no need to calculate\n                data.map(function(d) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d,i), y: getY(d,i), y0: d.y0, y1: d.y1 }\n                    })\n                });\n\n            x.domain(xDomain || d3.merge(seriesData).map(function(d) { return d.x }))\n                .rangeBands(xRange || [0, availableHeight], groupSpacing);\n\n            y.domain(yDomain || d3.extent(d3.merge(seriesData).map(function(d) { return stacked ? (d.y > 0 ? d.y1 + d.y : d.y1 ) : d.y }).concat(forceY)))\n\n            if (showValues && !stacked)\n                y.range(yRange || [(y.domain()[0] < 0 ? valuePadding : 0), availableWidth - (y.domain()[1] > 0 ? valuePadding : 0) ]);\n            else\n                y.range(yRange || [0, availableWidth]);\n\n            x0 = x0 || x;\n            y0 = y0 || d3.scale.linear().domain(y.domain()).range([y(0),y(0)]);\n\n            // Setup containers and skeleton of chart\n            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-multibarHorizontal').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multibarHorizontal');\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-groups');\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            var groups = wrap.select('.nv-groups').selectAll('.nv-group')\n                .data(function(d) { return d }, function(d,i) { return i });\n            groups.enter().append('g')\n                .style('stroke-opacity', 1e-6)\n                .style('fill-opacity', 1e-6);\n            groups.exit().watchTransition(renderWatch, 'multibarhorizontal: exit groups')\n                .style('stroke-opacity', 1e-6)\n                .style('fill-opacity', 1e-6)\n                .remove();\n            groups\n                .attr('class', function(d,i) { return 'nv-group nv-series-' + i })\n                .classed('hover', function(d) { return d.hover })\n                .style('fill', function(d,i){ return color(d, i) })\n                .style('stroke', function(d,i){ return color(d, i) });\n            groups.watchTransition(renderWatch, 'multibarhorizontal: groups')\n                .style('stroke-opacity', 1)\n                .style('fill-opacity', fillOpacity);\n\n            var bars = groups.selectAll('g.nv-bar')\n                .data(function(d) { return d.values });\n            bars.exit().remove();\n\n            var barsEnter = bars.enter().append('g')\n                .attr('transform', function(d,i,j) {\n                    return 'translate(' + y0(stacked ? d.y0 : 0) + ',' + (stacked ? 0 : (j * x.rangeBand() / data.length ) + x(getX(d,i))) + ')'\n                });\n\n            barsEnter.append('rect')\n                .attr('width', 0)\n                .attr('height', x.rangeBand() / (stacked ? 1 : data.length) )\n\n            bars\n                .on('mouseover', function(d,i) { //TODO: figure out why j works above, but not here\n                    d3.select(this).classed('hover', true);\n                    dispatch.elementMouseover({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mouseout', function(d,i) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.elementMouseout({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mouseout', function(d,i) {\n                    dispatch.elementMouseout({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('mousemove', function(d,i) {\n                    dispatch.elementMousemove({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                })\n                .on('click', function(d,i) {\n                    var element = this;\n                    dispatch.elementClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\"),\n                        event: d3.event,\n                        element: element\n                    });\n                    d3.event.stopPropagation();\n                })\n                .on('dblclick', function(d,i) {\n                    dispatch.elementDblClick({\n                        data: d,\n                        index: i,\n                        color: d3.select(this).style(\"fill\")\n                    });\n                    d3.event.stopPropagation();\n                });\n\n            if (getYerr(data[0],0)) {\n                barsEnter.append('polyline');\n\n                bars.select('polyline')\n                    .attr('fill', 'none')\n                    .attr('points', function(d,i) {\n                        var xerr = getYerr(d,i)\n                            , mid = 0.8 * x.rangeBand() / ((stacked ? 1 : data.length) * 2);\n                        xerr = xerr.length ? xerr : [-Math.abs(xerr), Math.abs(xerr)];\n                        xerr = xerr.map(function(e) { return y(e) - y(0); });\n                        var a = [[xerr[0],-mid], [xerr[0],mid], [xerr[0],0], [xerr[1],0], [xerr[1],-mid], [xerr[1],mid]];\n                        return a.map(function (path) { return path.join(',') }).join(' ');\n                    })\n                    .attr('transform', function(d,i) {\n                        var mid = x.rangeBand() / ((stacked ? 1 : data.length) * 2);\n                        return 'translate(' + (getY(d,i) < 0 ? 0 : y(getY(d,i)) - y(0)) + ', ' + mid + ')'\n                    });\n            }\n\n            barsEnter.append('text');\n\n            if (showValues && !stacked) {\n                bars.select('text')\n                    .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'end' : 'start' })\n                    .attr('y', x.rangeBand() / (data.length * 2))\n                    .attr('dy', '.32em')\n                    .text(function(d,i) {\n                        var t = valueFormat(getY(d,i))\n                            , yerr = getYerr(d,i);\n                        if (yerr === undefined)\n                            return t;\n                        if (!yerr.length)\n                            return t + '±' + valueFormat(Math.abs(yerr));\n                        return t + '+' + valueFormat(Math.abs(yerr[1])) + '-' + valueFormat(Math.abs(yerr[0]));\n                    });\n                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')\n                    .select('text')\n                    .attr('x', function(d,i) { return getY(d,i) < 0 ? -4 : y(getY(d,i)) - y(0) + 4 })\n            } else {\n                bars.selectAll('text').text('');\n            }\n\n            if (showBarLabels && !stacked) {\n                barsEnter.append('text').classed('nv-bar-label',true);\n                bars.select('text.nv-bar-label')\n                    .attr('text-anchor', function(d,i) { return getY(d,i) < 0 ? 'start' : 'end' })\n                    .attr('y', x.rangeBand() / (data.length * 2))\n                    .attr('dy', '.32em')\n                    .text(function(d,i) { return getX(d,i) });\n                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')\n                    .select('text.nv-bar-label')\n                    .attr('x', function(d,i) { return getY(d,i) < 0 ? y(0) - y(getY(d,i)) + 4 : -4 });\n            }\n            else {\n                bars.selectAll('text.nv-bar-label').text('');\n            }\n\n            bars\n                .attr('class', function(d,i) { return getY(d,i) < 0 ? 'nv-bar negative' : 'nv-bar positive'})\n\n            if (barColor) {\n                if (!disabled) disabled = data.map(function() { return true });\n                bars\n                    .style('fill', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); })\n                    .style('stroke', function(d,i,j) { return d3.rgb(barColor(d,i)).darker(  disabled.map(function(d,i) { return i }).filter(function(d,i){ return !disabled[i]  })[j]   ).toString(); });\n            }\n\n            if (stacked)\n                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')\n                    .attr('transform', function(d,i) {\n                        return 'translate(' + y(d.y1) + ',' + x(getX(d,i)) + ')'\n                    })\n                    .select('rect')\n                    .attr('width', function(d,i) {\n                        return Math.abs(y(getY(d,i) + d.y0) - y(d.y0)) || 0\n                    })\n                    .attr('height', x.rangeBand() );\n            else\n                bars.watchTransition(renderWatch, 'multibarhorizontal: bars')\n                    .attr('transform', function(d,i) {\n                        //TODO: stacked must be all positive or all negative, not both?\n                        return 'translate(' +\n                            (getY(d,i) < 0 ? y(getY(d,i)) : y(0))\n                            + ',' +\n                            (d.series * x.rangeBand() / data.length\n                                +\n                                x(getX(d,i)) )\n                            + ')'\n                    })\n                    .select('rect')\n                    .attr('height', x.rangeBand() / data.length )\n                    .attr('width', function(d,i) {\n                        return Math.max(Math.abs(y(getY(d,i)) - y(0)),1) || 0\n                    });\n\n            //store old scales for use in transitions on update\n            x0 = x.copy();\n            y0 = y.copy();\n\n        });\n\n        renderWatch.renderEnd('multibarHorizontal immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:   {get: function(){return width;}, set: function(_){width=_;}},\n        height:  {get: function(){return height;}, set: function(_){height=_;}},\n        x:       {get: function(){return getX;}, set: function(_){getX=_;}},\n        y:       {get: function(){return getY;}, set: function(_){getY=_;}},\n        yErr:       {get: function(){return getYerr;}, set: function(_){getYerr=_;}},\n        xScale:  {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:  {get: function(){return y;}, set: function(_){y=_;}},\n        xDomain: {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain: {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:  {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:  {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        forceY:  {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        stacked: {get: function(){return stacked;}, set: function(_){stacked=_;}},\n        showValues: {get: function(){return showValues;}, set: function(_){showValues=_;}},\n        // this shows the group name, seems pointless?\n        //showBarLabels:    {get: function(){return showBarLabels;}, set: function(_){showBarLabels=_;}},\n        disabled:     {get: function(){return disabled;}, set: function(_){disabled=_;}},\n        id:           {get: function(){return id;}, set: function(_){id=_;}},\n        valueFormat:  {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},\n        valuePadding: {get: function(){return valuePadding;}, set: function(_){valuePadding=_;}},\n        groupSpacing: {get: function(){return groupSpacing;}, set: function(_){groupSpacing=_;}},\n        fillOpacity:  {get: function(){return fillOpacity;}, set: function(_){fillOpacity=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        barColor:  {get: function(){return barColor;}, set: function(_){\n            barColor = _ ? nv.utils.getColor(_) : null;\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.multiBarHorizontalChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var multibar = nv.models.multiBarHorizontal()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , legend = nv.models.legend().height(30)\n        , controls = nv.models.legend().height(30)\n        , tooltip = nv.models.tooltip()\n        ;\n\n    var margin = {top: 30, right: 20, bottom: 50, left: 60}\n        , marginTop = null\n        , width = null\n        , height = null\n        , color = nv.utils.defaultColor()\n        , showControls = true\n        , controlLabels = {}\n        , showLegend = true\n        , showXAxis = true\n        , showYAxis = true\n        , stacked = false\n        , x //can be accessed via chart.xScale()\n        , y //can be accessed via chart.yScale()\n        , state = nv.utils.state()\n        , defaultState = null\n        , noData = null\n        , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd')\n        , controlWidth = function() { return showControls ? 180 : 0 }\n        , duration = 250\n        ;\n\n    state.stacked = false; // DEPRECATED Maintained for backward compatibility\n\n    multibar.stacked(stacked);\n\n    xAxis\n        .orient('left')\n        .tickPadding(5)\n        .showMaxMin(false)\n        .tickFormat(function(d) { return d })\n    ;\n    yAxis\n        .orient('bottom')\n        .tickFormat(d3.format(',.1f'))\n    ;\n\n    tooltip\n        .duration(0)\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        })\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        });\n\n    controls.updateState(false);\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled }),\n                stacked: stacked\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.stacked !== undefined)\n                stacked = state.stacked;\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        }\n    };\n\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(multibar);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() { container.transition().duration(duration).call(chart) };\n            chart.container = this;\n\n            stacked = multibar.stacked();\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disableddisabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = multibar.xScale();\n            y = multibar.yScale().clamp(true);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-multiBarHorizontalChart').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-multiBarHorizontalChart').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis')\n                .append('g').attr('class', 'nv-zeroLine')\n                .append('line');\n            gEnter.append('g').attr('class', 'nv-barsWrap');\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n            gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                legend.width(availableWidth - controlWidth());\n\n                g.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                g.select('.nv-legendWrap')\n                    .attr('transform', 'translate(' + controlWidth() + ',' + (-margin.top) +')');\n            }\n\n            // Controls\n            if (!showControls) {\n                 g.select('.nv-controlsWrap').selectAll('*').remove();\n            } else {\n                var controlsData = [\n                    { key: controlLabels.grouped || 'Grouped', disabled: multibar.stacked() },\n                    { key: controlLabels.stacked || 'Stacked', disabled: !multibar.stacked() }\n                ];\n\n                controls.width(controlWidth()).color(['#444', '#444', '#444']);\n                g.select('.nv-controlsWrap')\n                    .datum(controlsData)\n                    .attr('transform', 'translate(0,' + (-margin.top) +')')\n                    .call(controls);\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            // Main Chart Component(s)\n            multibar\n                .disabled(data.map(function(series) { return series.disabled }))\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled }));\n\n            var barsWrap = g.select('.nv-barsWrap')\n                .datum(data.filter(function(d) { return !d.disabled }));\n\n            barsWrap.transition().call(multibar);\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/24, data) )\n                    .tickSize(-availableWidth, 0);\n\n                g.select('.nv-x.nv-axis').call(xAxis);\n\n                var xTicks = g.select('.nv-x.nv-axis').selectAll('g');\n\n                xTicks\n                    .selectAll('line, text');\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize( -availableHeight, 0);\n\n                g.select('.nv-y.nv-axis')\n                    .attr('transform', 'translate(0,' + availableHeight + ')');\n                g.select('.nv-y.nv-axis').call(yAxis);\n            }\n\n            // Zero line\n            g.select(\".nv-zeroLine line\")\n                .attr(\"x1\", y(0))\n                .attr(\"x2\", y(0))\n                .attr(\"y1\", 0)\n                .attr(\"y2\", -availableHeight)\n            ;\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            controls.dispatch.on('legendClick', function(d,i) {\n                if (!d.disabled) return;\n                controlsData = controlsData.map(function(s) {\n                    s.disabled = true;\n                    return s;\n                });\n                d.disabled = false;\n\n                switch (d.key) {\n                    case 'Grouped':\n                    case controlLabels.grouped:\n                        multibar.stacked(false);\n                        break;\n                    case 'Stacked':\n                    case controlLabels.stacked:\n                        multibar.stacked(true);\n                        break;\n                }\n\n                state.stacked = multibar.stacked();\n                dispatch.stateChange(state);\n                stacked = multibar.stacked();\n\n                chart.update();\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n\n                    state.disabled = e.disabled;\n                }\n\n                if (typeof e.stacked !== 'undefined') {\n                    multibar.stacked(e.stacked);\n                    state.stacked = e.stacked;\n                    stacked = e.stacked;\n                }\n\n                chart.update();\n            });\n        });\n        renderWatch.renderEnd('multibar horizontal chart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    multibar.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt.value = chart.x()(evt.data);\n        evt['series'] = {\n            key: evt.data.key,\n            value: chart.y()(evt.data),\n            color: evt.color\n        };\n        tooltip.data(evt).hidden(false);\n    });\n\n    multibar.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    multibar.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.multibar = multibar;\n    chart.legend = legend;\n    chart.controls = controls;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.state = state;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        showControls: {get: function(){return showControls;}, set: function(_){showControls=_;}},\n        controlLabels: {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},\n        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            multibar.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n        }},\n        barColor:  {get: function(){return multibar.barColor;}, set: function(_){\n            multibar.barColor(_);\n            legend.color(function(d,i) {return d3.rgb('#ccc').darker(i * 1.5).toString();})\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, multibar);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\nnv.models.multiChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 30, right: 20, bottom: 50, left: 60},\n        marginTop = null,\n        color = nv.utils.defaultColor(),\n        width = null,\n        height = null,\n        showLegend = true,\n        noData = null,\n        yDomain1,\n        yDomain2,\n        getX = function(d) { return d.x },\n        getY = function(d) { return d.y},\n        interpolate = 'linear',\n        useVoronoi = true,\n        interactiveLayer = nv.interactiveGuideline(),\n        useInteractiveGuideline = false,\n        legendRightAxisHint = ' (right axis)',\n        duration = 250\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x = d3.scale.linear(),\n        yScale1 = d3.scale.linear(),\n        yScale2 = d3.scale.linear(),\n\n        lines1 = nv.models.line().yScale(yScale1).duration(duration),\n        lines2 = nv.models.line().yScale(yScale2).duration(duration),\n\n        scatters1 = nv.models.scatter().yScale(yScale1).duration(duration),\n        scatters2 = nv.models.scatter().yScale(yScale2).duration(duration),\n\n        bars1 = nv.models.multiBar().stacked(false).yScale(yScale1).duration(duration),\n        bars2 = nv.models.multiBar().stacked(false).yScale(yScale2).duration(duration),\n\n        stack1 = nv.models.stackedArea().yScale(yScale1).duration(duration),\n        stack2 = nv.models.stackedArea().yScale(yScale2).duration(duration),\n\n        xAxis = nv.models.axis().scale(x).orient('bottom').tickPadding(5).duration(duration),\n        yAxis1 = nv.models.axis().scale(yScale1).orient('left').duration(duration),\n        yAxis2 = nv.models.axis().scale(yScale2).orient('right').duration(duration),\n\n        legend = nv.models.legend().height(30),\n        tooltip = nv.models.tooltip(),\n        dispatch = d3.dispatch();\n\n    var charts = [lines1, lines2, scatters1, scatters2, bars1, bars2, stack1, stack2];\n\n    function chart(selection) {\n        selection.each(function(data) {\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n\n            chart.update = function() { container.transition().call(chart); };\n            chart.container = this;\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            var dataLines1 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 1});\n            var dataLines2 = data.filter(function(d) {return d.type == 'line' && d.yAxis == 2});\n            var dataScatters1 = data.filter(function(d) {return d.type == 'scatter' && d.yAxis == 1});\n            var dataScatters2 = data.filter(function(d) {return d.type == 'scatter' && d.yAxis == 2});\n            var dataBars1 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 1});\n            var dataBars2 =  data.filter(function(d) {return d.type == 'bar'  && d.yAxis == 2});\n            var dataStack1 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 1});\n            var dataStack2 = data.filter(function(d) {return d.type == 'area' && d.yAxis == 2});\n\n            // Display noData message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container);\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            var series1 = data.filter(function(d) {return !d.disabled && d.yAxis == 1})\n                .map(function(d) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d), y: getY(d) }\n                    })\n                });\n\n            var series2 = data.filter(function(d) {return !d.disabled && d.yAxis == 2})\n                .map(function(d) {\n                    return d.values.map(function(d,i) {\n                        return { x: getX(d), y: getY(d) }\n                    })\n                });\n\n            x   .domain(d3.extent(d3.merge(series1.concat(series2)), function(d) { return d.x }))\n                .range([0, availableWidth]);\n\n            var wrap = container.selectAll('g.wrap.multiChart').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'wrap nvd3 multiChart').append('g');\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y1 nv-axis');\n            gEnter.append('g').attr('class', 'nv-y2 nv-axis');\n            gEnter.append('g').attr('class', 'stack1Wrap');\n            gEnter.append('g').attr('class', 'stack2Wrap');\n            gEnter.append('g').attr('class', 'bars1Wrap');\n            gEnter.append('g').attr('class', 'bars2Wrap');\n            gEnter.append('g').attr('class', 'scatters1Wrap');\n            gEnter.append('g').attr('class', 'scatters2Wrap');\n            gEnter.append('g').attr('class', 'lines1Wrap');\n            gEnter.append('g').attr('class', 'lines2Wrap');\n            gEnter.append('g').attr('class', 'legendWrap');\n            gEnter.append('g').attr('class', 'nv-interactive');\n\n            var g = wrap.select('g');\n\n            var color_array = data.map(function(d,i) {\n                return data[i].color || color(d, i);\n            });\n\n            // Legend\n            if (!showLegend) {\n                g.select('.legendWrap').selectAll('*').remove();\n            } else {\n                var legendWidth = legend.align() ? availableWidth / 2 : availableWidth;\n                var legendXPosition = legend.align() ? legendWidth : 0;\n\n                legend.width(legendWidth);\n                legend.color(color_array);\n\n                g.select('.legendWrap')\n                    .datum(data.map(function(series) {\n                        series.originalKey = series.originalKey === undefined ? series.key : series.originalKey;\n                        series.key = series.originalKey + (series.yAxis == 1 ? '' : legendRightAxisHint);\n                        return series;\n                    }))\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                g.select('.legendWrap')\n                    .attr('transform', 'translate(' + legendXPosition + ',' + (-margin.top) +')');\n            }\n\n            lines1\n                .width(availableWidth)\n                .height(availableHeight)\n                .interpolate(interpolate)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'line'}));\n            lines2\n                .width(availableWidth)\n                .height(availableHeight)\n                .interpolate(interpolate)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'line'}));\n            scatters1\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'scatter'}));\n            scatters2\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'scatter'}));\n            bars1\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'bar'}));\n            bars2\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'bar'}));\n            stack1\n                .width(availableWidth)\n                .height(availableHeight)\n                .interpolate(interpolate)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 1 && data[i].type == 'area'}));\n            stack2\n                .width(availableWidth)\n                .height(availableHeight)\n                .interpolate(interpolate)\n                .color(color_array.filter(function(d,i) { return !data[i].disabled && data[i].yAxis == 2 && data[i].type == 'area'}));\n\n            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            var lines1Wrap = g.select('.lines1Wrap')\n                .datum(dataLines1.filter(function(d){return !d.disabled}));\n            var scatters1Wrap = g.select('.scatters1Wrap')\n                .datum(dataScatters1.filter(function(d){return !d.disabled}));\n            var bars1Wrap = g.select('.bars1Wrap')\n                .datum(dataBars1.filter(function(d){return !d.disabled}));\n            var stack1Wrap = g.select('.stack1Wrap')\n                .datum(dataStack1.filter(function(d){return !d.disabled}));\n            var lines2Wrap = g.select('.lines2Wrap')\n                .datum(dataLines2.filter(function(d){return !d.disabled}));\n            var scatters2Wrap = g.select('.scatters2Wrap')\n                .datum(dataScatters2.filter(function(d){return !d.disabled}));\n            var bars2Wrap = g.select('.bars2Wrap')\n                .datum(dataBars2.filter(function(d){return !d.disabled}));\n            var stack2Wrap = g.select('.stack2Wrap')\n                .datum(dataStack2.filter(function(d){return !d.disabled}));\n\n            var extraValue1 = dataStack1.length ? dataStack1.map(function(a){return a.values}).reduce(function(a,b){\n                return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})\n            }).concat([{x:0, y:0}]) : [];\n            var extraValue2 = dataStack2.length ? dataStack2.map(function(a){return a.values}).reduce(function(a,b){\n                return a.map(function(aVal,i){return {x: aVal.x, y: aVal.y + b[i].y}})\n            }).concat([{x:0, y:0}]) : [];\n\n            yScale1 .domain(yDomain1 || d3.extent(d3.merge(series1).concat(extraValue1), function(d) { return d.y } ))\n                .range([0, availableHeight]);\n\n            yScale2 .domain(yDomain2 || d3.extent(d3.merge(series2).concat(extraValue2), function(d) { return d.y } ))\n                .range([0, availableHeight]);\n\n            lines1.yDomain(yScale1.domain());\n            scatters1.yDomain(yScale1.domain());\n            bars1.yDomain(yScale1.domain());\n            stack1.yDomain(yScale1.domain());\n\n            lines2.yDomain(yScale2.domain());\n            scatters2.yDomain(yScale2.domain());\n            bars2.yDomain(yScale2.domain());\n            stack2.yDomain(yScale2.domain());\n\n            if(dataStack1.length){d3.transition(stack1Wrap).call(stack1);}\n            if(dataStack2.length){d3.transition(stack2Wrap).call(stack2);}\n\n            if(dataBars1.length){d3.transition(bars1Wrap).call(bars1);}\n            if(dataBars2.length){d3.transition(bars2Wrap).call(bars2);}\n\n            if(dataLines1.length){d3.transition(lines1Wrap).call(lines1);}\n            if(dataLines2.length){d3.transition(lines2Wrap).call(lines2);}\n\n            if(dataScatters1.length){d3.transition(scatters1Wrap).call(scatters1);}\n            if(dataScatters2.length){d3.transition(scatters2Wrap).call(scatters2);}\n\n            xAxis\n                ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                .tickSize(-availableHeight, 0);\n\n            g.select('.nv-x.nv-axis')\n                .attr('transform', 'translate(0,' + availableHeight + ')');\n            d3.transition(g.select('.nv-x.nv-axis'))\n                .call(xAxis);\n\n            yAxis1\n                ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                .tickSize( -availableWidth, 0);\n\n\n            d3.transition(g.select('.nv-y1.nv-axis'))\n                .call(yAxis1);\n\n            yAxis2\n                ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                .tickSize( -availableWidth, 0);\n\n            d3.transition(g.select('.nv-y2.nv-axis'))\n                .call(yAxis2);\n\n            g.select('.nv-y1.nv-axis')\n                .classed('nv-disabled', series1.length ? false : true)\n                .attr('transform', 'translate(' + x.range()[0] + ',0)');\n\n            g.select('.nv-y2.nv-axis')\n                .classed('nv-disabled', series2.length ? false : true)\n                .attr('transform', 'translate(' + x.range()[1] + ',0)');\n\n            legend.dispatch.on('stateChange', function(newState) {\n                chart.update();\n            });\n\n            if(useInteractiveGuideline){\n                interactiveLayer\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .margin({left:margin.left, top:margin.top})\n                    .svgContainer(container)\n                    .xScale(x);\n                wrap.select(\".nv-interactive\").call(interactiveLayer);\n            }\n\n            //============================================================\n            // Event Handling/Dispatching\n            //------------------------------------------------------------\n\n            function mouseover_line(evt) {\n                var yaxis = data[evt.seriesIndex].yAxis === 2 ? yAxis2 : yAxis1;\n                evt.value = evt.point.x;\n                evt.series = {\n                    value: evt.point.y,\n                    color: evt.point.color,\n                    key: evt.series.key\n                };\n                tooltip\n                    .duration(0)\n                    .headerFormatter(function(d, i) {\n                    \treturn xAxis.tickFormat()(d, i);\n                    })\n                    .valueFormatter(function(d, i) {\n                        return yaxis.tickFormat()(d, i);\n                    })\n                    .data(evt)\n                    .hidden(false);\n            }\n\n            function mouseover_scatter(evt) {\n                var yaxis = data[evt.seriesIndex].yAxis === 2 ? yAxis2 : yAxis1;\n                evt.value = evt.point.x;\n                evt.series = {\n                    value: evt.point.y,\n                    color: evt.point.color,\n                    key: evt.series.key\n                };\n                tooltip\n                    .duration(100)\n                    .headerFormatter(function(d, i) {\n                    \treturn xAxis.tickFormat()(d, i);\n                    })\n                    .valueFormatter(function(d, i) {\n                        return yaxis.tickFormat()(d, i);\n                    })\n                    .data(evt)\n                    .hidden(false);\n            }\n\n            function mouseover_stack(evt) {\n                var yaxis = data[evt.seriesIndex].yAxis === 2 ? yAxis2 : yAxis1;\n                evt.point['x'] = stack1.x()(evt.point);\n                evt.point['y'] = stack1.y()(evt.point);\n                tooltip\n                    .duration(0)\n                    .headerFormatter(function(d, i) {\n                    \treturn xAxis.tickFormat()(d, i);\n                    })\n                    .valueFormatter(function(d, i) {\n                        return yaxis.tickFormat()(d, i);\n                    })\n                    .data(evt)\n                    .hidden(false);\n            }\n\n            function mouseover_bar(evt) {\n                var yaxis = data[evt.data.series].yAxis === 2 ? yAxis2 : yAxis1;\n\n                evt.value = bars1.x()(evt.data);\n                evt['series'] = {\n                    value: bars1.y()(evt.data),\n                    color: evt.color,\n                    key: evt.data.key\n                };\n                tooltip\n                    .duration(0)\n                    .headerFormatter(function(d, i) {\n                    \treturn xAxis.tickFormat()(d, i);\n                    })\n                    .valueFormatter(function(d, i) {\n                        return yaxis.tickFormat()(d, i);\n                    })\n                    .data(evt)\n                    .hidden(false);\n            }\n\n\n\n            function clearHighlights() {\n              for(var i=0, il=charts.length; i < il; i++){\n                var chart = charts[i];\n                try {\n                  chart.clearHighlights();\n                } catch(e){}\n              }\n            }\n\n            function highlightPoint(serieIndex, pointIndex, b){\n              for(var i=0, il=charts.length; i < il; i++){\n                var chart = charts[i];\n                try {\n                  chart.highlightPoint(serieIndex, pointIndex, b);\n                } catch(e){}\n              }\n            }\n\n            if(useInteractiveGuideline){\n                interactiveLayer.dispatch.on('elementMousemove', function(e) {\n                    clearHighlights();\n                    var singlePoint, pointIndex, pointXLocation, allData = [];\n                    data\n                    .filter(function(series, i) {\n                        series.seriesIndex = i;\n                        return !series.disabled;\n                    })\n                    .forEach(function(series,i) {\n                        var extent = x.domain();\n                        var currentValues = series.values.filter(function(d,i) {\n                            return chart.x()(d,i) >= extent[0] && chart.x()(d,i) <= extent[1];\n                        });\n\n                        pointIndex = nv.interactiveBisect(currentValues, e.pointXValue, chart.x());\n                        var point = currentValues[pointIndex];\n                        var pointYValue = chart.y()(point, pointIndex);\n                        if (pointYValue !== null) {\n                            highlightPoint(i, pointIndex, true);\n                        }\n                        if (point === undefined) return;\n                        if (singlePoint === undefined) singlePoint = point;\n                        if (pointXLocation === undefined) pointXLocation = x(chart.x()(point,pointIndex));\n                        allData.push({\n                            key: series.key,\n                            value: pointYValue,\n                            color: color(series,series.seriesIndex),\n                            data: point,\n                            yAxis: series.yAxis == 2 ? yAxis2 : yAxis1\n                        });\n                    });\n\n                    var defaultValueFormatter = function(d,i) {\n                        var yAxis = allData[i].yAxis;\n                        return d == null ? \"N/A\" : yAxis.tickFormat()(d);\n                    };\n\n                    interactiveLayer.tooltip\n                        .headerFormatter(function(d, i) {\n                            return xAxis.tickFormat()(d, i);\n                        })\n                        .valueFormatter(interactiveLayer.tooltip.valueFormatter() || defaultValueFormatter)\n                        .data({\n                            value: chart.x()( singlePoint,pointIndex ),\n                            index: pointIndex,\n                            series: allData\n                        })();\n\n                    interactiveLayer.renderGuideLine(pointXLocation);\n                });\n\n                interactiveLayer.dispatch.on(\"elementMouseout\",function(e) {\n                    clearHighlights();\n                });\n            } else {\n                lines1.dispatch.on('elementMouseover.tooltip', mouseover_line);\n                lines2.dispatch.on('elementMouseover.tooltip', mouseover_line);\n                lines1.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true)\n                });\n                lines2.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true)\n                });\n\n                scatters1.dispatch.on('elementMouseover.tooltip', mouseover_scatter);\n                scatters2.dispatch.on('elementMouseover.tooltip', mouseover_scatter);\n                scatters1.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true)\n                });\n                scatters2.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true)\n                });\n\n                stack1.dispatch.on('elementMouseover.tooltip', mouseover_stack);\n                stack2.dispatch.on('elementMouseover.tooltip', mouseover_stack);\n                stack1.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true)\n                });\n                stack2.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true)\n                });\n\n                bars1.dispatch.on('elementMouseover.tooltip', mouseover_bar);\n                bars2.dispatch.on('elementMouseover.tooltip', mouseover_bar);\n\n                bars1.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true);\n                });\n                bars2.dispatch.on('elementMouseout.tooltip', function(evt) {\n                    tooltip.hidden(true);\n                });\n                bars1.dispatch.on('elementMousemove.tooltip', function(evt) {\n                    tooltip();\n                });\n                bars2.dispatch.on('elementMousemove.tooltip', function(evt) {\n                    tooltip();\n                });\n            }\n        });\n\n        return chart;\n    }\n\n    //============================================================\n    // Global getters and setters\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.legend = legend;\n    chart.lines1 = lines1;\n    chart.lines2 = lines2;\n    chart.scatters1 = scatters1;\n    chart.scatters2 = scatters2;\n    chart.bars1 = bars1;\n    chart.bars2 = bars2;\n    chart.stack1 = stack1;\n    chart.stack2 = stack2;\n    chart.xAxis = xAxis;\n    chart.yAxis1 = yAxis1;\n    chart.yAxis2 = yAxis2;\n    chart.tooltip = tooltip;\n    chart.interactiveLayer = interactiveLayer;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        yDomain1:      {get: function(){return yDomain1;}, set: function(_){yDomain1=_;}},\n        yDomain2:    {get: function(){return yDomain2;}, set: function(_){yDomain2=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},\n        legendRightAxisHint:    {get: function(){return legendRightAxisHint;}, set: function(_){legendRightAxisHint=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        x: {get: function(){return getX;}, set: function(_){\n            getX = _;\n            lines1.x(_);\n            lines2.x(_);\n            scatters1.x(_);\n            scatters2.x(_);\n            bars1.x(_);\n            bars2.x(_);\n            stack1.x(_);\n            stack2.x(_);\n        }},\n        y: {get: function(){return getY;}, set: function(_){\n            getY = _;\n            lines1.y(_);\n            lines2.y(_);\n            scatters1.y(_);\n            scatters2.y(_);\n            stack1.y(_);\n            stack2.y(_);\n            bars1.y(_);\n            bars2.y(_);\n        }},\n        useVoronoi: {get: function(){return useVoronoi;}, set: function(_){\n            useVoronoi=_;\n            lines1.useVoronoi(_);\n            lines2.useVoronoi(_);\n            stack1.useVoronoi(_);\n            stack2.useVoronoi(_);\n        }},\n\n        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){\n            useInteractiveGuideline = _;\n            if (useInteractiveGuideline) {\n                lines1.interactive(false);\n                lines1.useVoronoi(false);\n                lines2.interactive(false);\n                lines2.useVoronoi(false);\n                stack1.interactive(false);\n                stack1.useVoronoi(false);\n                stack2.interactive(false);\n                stack2.useVoronoi(false);\n                scatters1.interactive(false);\n                scatters2.interactive(false);\n            }\n        }},\n\n        duration: {get: function(){return duration;}, set: function(_) {\n            duration = _;\n            [lines1, lines2, stack1, stack2, scatters1, scatters2, xAxis, yAxis1, yAxis2].forEach(function(model){\n              model.duration(duration);\n            });\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.ohlcBar = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = null\n        , height = null\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container = null\n        , x = d3.scale.linear()\n        , y = d3.scale.linear()\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , getOpen = function(d) { return d.open }\n        , getClose = function(d) { return d.close }\n        , getHigh = function(d) { return d.high }\n        , getLow = function(d) { return d.low }\n        , forceX = []\n        , forceY = []\n        , padData     = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart\n        , clipEdge = true\n        , color = nv.utils.defaultColor()\n        , interactive = false\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd', 'chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove')\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    function chart(selection) {\n        selection.each(function(data) {\n            container = d3.select(this);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            nv.utils.initSVG(container);\n\n            // ohlc bar width.\n            var w = (availableWidth / data[0].values.length) * .9;\n\n            // Setup Scales\n            x.domain(xDomain || d3.extent(data[0].values.map(getX).concat(forceX) ));\n\n            if (padData)\n                x.range(xRange || [availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);\n            else\n                x.range(xRange || [5 + w/2, availableWidth - w/2 - 5]);\n\n            y.domain(yDomain || [\n                    d3.min(data[0].values.map(getLow).concat(forceY)),\n                    d3.max(data[0].values.map(getHigh).concat(forceY))\n                ]\n            ).range(yRange || [availableHeight, 0]);\n\n            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n            if (x.domain()[0] === x.domain()[1])\n                x.domain()[0] ?\n                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])\n                    : x.domain([-1,1]);\n\n            if (y.domain()[0] === y.domain()[1])\n                y.domain()[0] ?\n                    y.domain([y.domain()[0] + y.domain()[0] * 0.01, y.domain()[1] - y.domain()[1] * 0.01])\n                    : y.domain([-1,1]);\n\n            // Setup containers and skeleton of chart\n            var wrap = d3.select(this).selectAll('g.nv-wrap.nv-ohlcBar').data([data[0].values]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-ohlcBar');\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-ticks');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            container\n                .on('click', function(d,i) {\n                    dispatch.chartClick({\n                        data: d,\n                        index: i,\n                        pos: d3.event,\n                        id: id\n                    });\n                });\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-chart-clip-path-' + id)\n                .append('rect');\n\n            wrap.select('#nv-chart-clip-path-' + id + ' rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            g   .attr('clip-path', clipEdge ? 'url(#nv-chart-clip-path-' + id + ')' : '');\n\n            var ticks = wrap.select('.nv-ticks').selectAll('.nv-tick')\n                .data(function(d) { return d });\n            ticks.exit().remove();\n\n            ticks.enter().append('path')\n                .attr('class', function(d,i,j) { return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i })\n                .attr('d', function(d,i) {\n                    return 'm0,0l0,'\n                        + (y(getOpen(d,i))\n                            - y(getHigh(d,i)))\n                        + 'l'\n                        + (-w/2)\n                        + ',0l'\n                        + (w/2)\n                        + ',0l0,'\n                        + (y(getLow(d,i)) - y(getOpen(d,i)))\n                        + 'l0,'\n                        + (y(getClose(d,i))\n                            - y(getLow(d,i)))\n                        + 'l'\n                        + (w/2)\n                        + ',0l'\n                        + (-w/2)\n                        + ',0z';\n                })\n                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })\n                .attr('fill', function(d,i) { return color[0]; })\n                .attr('stroke', function(d,i) { return color[0]; })\n                .attr('x', 0 )\n                .attr('y', function(d,i) {  return y(Math.max(0, getY(d,i))) })\n                .attr('height', function(d,i) { return Math.abs(y(getY(d,i)) - y(0)) });\n\n            // the bar colors are controlled by CSS currently\n            ticks.attr('class', function(d,i,j) {\n                return (getOpen(d,i) > getClose(d,i) ? 'nv-tick negative' : 'nv-tick positive') + ' nv-tick-' + j + '-' + i;\n            });\n\n            d3.transition(ticks)\n                .attr('transform', function(d,i) { return 'translate(' + x(getX(d,i)) + ',' + y(getHigh(d,i)) + ')'; })\n                .attr('d', function(d,i) {\n                    var w = (availableWidth / data[0].values.length) * .9;\n                    return 'm0,0l0,'\n                        + (y(getOpen(d,i))\n                            - y(getHigh(d,i)))\n                        + 'l'\n                        + (-w/2)\n                        + ',0l'\n                        + (w/2)\n                        + ',0l0,'\n                        + (y(getLow(d,i))\n                            - y(getOpen(d,i)))\n                        + 'l0,'\n                        + (y(getClose(d,i))\n                            - y(getLow(d,i)))\n                        + 'l'\n                        + (w/2)\n                        + ',0l'\n                        + (-w/2)\n                        + ',0z';\n                });\n        });\n\n        return chart;\n    }\n\n\n    //Create methods to allow outside functions to highlight a specific bar.\n    chart.highlightPoint = function(pointIndex, isHoverOver) {\n        chart.clearHighlights();\n        container.select(\".nv-ohlcBar .nv-tick-0-\" + pointIndex)\n            .classed(\"hover\", isHoverOver)\n        ;\n    };\n\n    chart.clearHighlights = function() {\n        container.select(\".nv-ohlcBar .nv-tick.hover\")\n            .classed(\"hover\", false)\n        ;\n    };\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:    {get: function(){return width;}, set: function(_){width=_;}},\n        height:   {get: function(){return height;}, set: function(_){height=_;}},\n        xScale:   {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:   {get: function(){return y;}, set: function(_){y=_;}},\n        xDomain:  {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain:  {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:   {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:   {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        forceX:   {get: function(){return forceX;}, set: function(_){forceX=_;}},\n        forceY:   {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        padData:  {get: function(){return padData;}, set: function(_){padData=_;}},\n        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n        id:       {get: function(){return id;}, set: function(_){id=_;}},\n        interactive: {get: function(){return interactive;}, set: function(_){interactive=_;}},\n\n        x:     {get: function(){return getX;}, set: function(_){getX=_;}},\n        y:     {get: function(){return getY;}, set: function(_){getY=_;}},\n        open:  {get: function(){return getOpen();}, set: function(_){getOpen=_;}},\n        close: {get: function(){return getClose();}, set: function(_){getClose=_;}},\n        high:  {get: function(){return getHigh;}, set: function(_){getHigh=_;}},\n        low:   {get: function(){return getLow;}, set: function(_){getLow=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    != undefined ? _.top    : margin.top;\n            margin.right  = _.right  != undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   != undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    return chart;\n};\n// Code adapted from Jason Davies' \"Parallel Coordinates\"\n// http://bl.ocks.org/jasondavies/1341281\nnv.models.parallelCoordinates = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 30, right: 0, bottom: 10, left: 0}\n        , width = null\n        , height = null\n        , availableWidth = null\n        , availableHeight = null\n        , x = d3.scale.ordinal()\n        , y = {}\n        , undefinedValuesLabel = \"undefined values\"\n        , dimensionData = []\n        , enabledDimensions = []\n        , dimensionNames = []\n        , displayBrush = true\n        , color = nv.utils.defaultColor()\n        , filters = []\n        , active = []\n        , dragging = []\n        , axisWithUndefinedValues = []\n        , lineTension = 1\n        , foreground\n        , background\n        , dimensions\n        , line = d3.svg.line()\n        , axis = d3.svg.axis()\n        , dispatch = d3.dispatch('brushstart', 'brush', 'brushEnd', 'dimensionsOrder', \"stateChange\", 'elementClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd', 'activeChanged')\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var container = d3.select(this);\n            availableWidth = nv.utils.availableWidth(width, container, margin);\n            availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            nv.utils.initSVG(container);\n\n           //Convert old data to new format (name, values)\n            if (data[0].values === undefined) {\n                var newData = [];\n                data.forEach(function (d) {\n                        var val = {};\n                        var key = Object.keys(d);\n                        key.forEach(function (k) { if (k !== \"name\") val[k] = d[k] });\n                        newData.push({ key: d.name, values: val });\n                });\n                data = newData;\n            }\n\n            var dataValues = data.map(function (d) {return d.values});\n            if (active.length === 0) {\n                active = data;\n            }; //set all active before first brush call\n            \n            dimensionNames = dimensionData.sort(function (a, b) { return a.currentPosition - b.currentPosition; }).map(function (d) { return d.key });\n            enabledDimensions = dimensionData.filter(function (d) { return !d.disabled; });\n            \n            // Setup Scales\n            x.rangePoints([0, availableWidth], 1).domain(enabledDimensions.map(function (d) { return d.key; }));\n\n            //Set as true if all values on an axis are missing.\n            // Extract the list of dimensions and create a scale for each.\n            var oldDomainMaxValue = {};\n            var displayMissingValuesline = false;\n            var currentTicks = [];\n            \n            dimensionNames.forEach(function(d) {\n                var extent = d3.extent(dataValues, function (p) { return +p[d]; });\n                var min = extent[0];\n                var max = extent[1];\n                var onlyUndefinedValues = false;\n                //If there is no values to display on an axis, set the extent to 0\n                if (isNaN(min) || isNaN(max)) {\n                    onlyUndefinedValues = true;\n                    min = 0;\n                    max = 0;\n                }\n                //Scale axis if there is only one value\n                if (min === max) {\n                    min = min - 1;\n                    max = max + 1;\n                }\n                var f = filters.filter(function (k) { return k.dimension == d; });\n                if (f.length !== 0) {\n                    //If there is only NaN values, keep the existing domain.\n                    if (onlyUndefinedValues) {\n                        min = y[d].domain()[0];\n                        max = y[d].domain()[1];\n                    }\n                        //If the brush extent is > max (< min), keep the extent value.\n                    else if (!f[0].hasOnlyNaN && displayBrush) {\n                        min = min > f[0].extent[0] ? f[0].extent[0] : min;\n                        max = max < f[0].extent[1] ? f[0].extent[1] : max;\n                    }\n                        //If there is NaN values brushed be sure the brush extent is on the domain.\n                    else if (f[0].hasNaN) {\n                        max = max < f[0].extent[1] ? f[0].extent[1] : max;\n                        oldDomainMaxValue[d] = y[d].domain()[1];\n                        displayMissingValuesline = true;\n                    }\n                }\n                //Use 90% of (availableHeight - 12) for the axis range, 12 reprensenting the space necessary to display \"undefined values\" text.\n                //The remaining 10% are used to display the missingValue line.\n                y[d] = d3.scale.linear()\n                    .domain([min, max])\n                    .range([(availableHeight - 12) * 0.9, 0]);\n\n                axisWithUndefinedValues = [];\n                y[d].brush = d3.svg.brush().y(y[d]).on('brushstart', brushstart).on('brush', brush).on('brushend', brushend);\n            });\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinates').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinates');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-parallelCoordinates background');\n            gEnter.append('g').attr('class', 'nv-parallelCoordinates foreground');\n            gEnter.append('g').attr('class', 'nv-parallelCoordinates missingValuesline');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            line.interpolate('cardinal').tension(lineTension);\n            axis.orient('left');\n            var axisDrag = d3.behavior.drag()\n                        .on('dragstart', dragStart)\n                        .on('drag', dragMove)\n                        .on('dragend', dragEnd);\n\n            //Add missing value line at the bottom of the chart\n            var missingValuesline, missingValueslineText;\n            var step = x.range()[1] - x.range()[0];\n            step = isNaN(step) ? x.range()[0] : step;\n            if (!isNaN(step)) {\n                var lineData = [0 + step / 2, availableHeight - 12, availableWidth - step / 2, availableHeight - 12];\n                missingValuesline = wrap.select('.missingValuesline').selectAll('line').data([lineData]);\n                missingValuesline.enter().append('line');\n                missingValuesline.exit().remove();\n                missingValuesline.attr(\"x1\", function(d) { return d[0]; })\n                        .attr(\"y1\", function(d) { return d[1]; })\n                        .attr(\"x2\", function(d) { return d[2]; })\n                        .attr(\"y2\", function(d) { return d[3]; });\n    \n                //Add the text \"undefined values\" under the missing value line\n                missingValueslineText = wrap.select('.missingValuesline').selectAll('text').data([undefinedValuesLabel]);\n                missingValueslineText.append('text').data([undefinedValuesLabel]);\n                missingValueslineText.enter().append('text');\n                missingValueslineText.exit().remove();\n                missingValueslineText.attr(\"y\", availableHeight)\n                        //To have the text right align with the missingValues line, substract 92 representing the text size.\n                        .attr(\"x\", availableWidth - 92 - step / 2)\n                        .text(function(d) { return d; });\n            }\n            // Add grey background lines for context.\n            background = wrap.select('.background').selectAll('path').data(data);\n            background.enter().append('path');\n            background.exit().remove();\n            background.attr('d', path);\n\n            // Add blue foreground lines for focus.\n            foreground = wrap.select('.foreground').selectAll('path').data(data);\n            foreground.enter().append('path')\n            foreground.exit().remove();\n            foreground.attr('d', path)\n                .style(\"stroke-width\", function (d, i) {\n                if (isNaN(d.strokeWidth)) { d.strokeWidth = 1;} return d.strokeWidth;})\n                .attr('stroke', function (d, i) { return d.color || color(d, i); });\n            foreground.on(\"mouseover\", function (d, i) {\n                d3.select(this).classed('hover', true).style(\"stroke-width\", d.strokeWidth + 2 + \"px\").style(\"stroke-opacity\", 1);\n                dispatch.elementMouseover({\n                    label: d.name,\n                    color: d.color || color(d, i),\n                    values: d.values,\n                    dimensions: enabledDimensions\n                });\n\n            });\n            foreground.on(\"mouseout\", function (d, i) {\n                d3.select(this).classed('hover', false).style(\"stroke-width\", d.strokeWidth + \"px\").style(\"stroke-opacity\", 0.7);\n                dispatch.elementMouseout({\n                    label: d.name,\n                    index: i\n                });\n            });\n            foreground.on('mousemove', function (d, i) {\n                dispatch.elementMousemove();\n            });\n            foreground.on('click', function (d) {\n                dispatch.elementClick({\n                    id: d.id\n                });\n            });\n            // Add a group element for each dimension.\n            dimensions = g.selectAll('.dimension').data(enabledDimensions);\n            var dimensionsEnter = dimensions.enter().append('g').attr('class', 'nv-parallelCoordinates dimension');\n\n            dimensions.attr('transform', function(d) { return 'translate(' + x(d.key) + ',0)'; });\n            dimensionsEnter.append('g').attr('class', 'nv-axis');\n\n            // Add an axis and title.\n            dimensionsEnter.append('text')\n                .attr('class', 'nv-label')\n                .style(\"cursor\", \"move\")\n                .attr('dy', '-1em')\n                .attr('text-anchor', 'middle')\n                .on(\"mouseover\", function(d, i) {\n                    dispatch.elementMouseover({\n                        label: d.tooltip || d.key,\n                        color: d.color \n                    });\n                })\n                .on(\"mouseout\", function(d, i) {\n                    dispatch.elementMouseout({\n                        label: d.tooltip\n                    });\n                })\n                .on('mousemove', function (d, i) {\n                    dispatch.elementMousemove();\n                })\n                .call(axisDrag);\n\n            dimensionsEnter.append('g').attr('class', 'nv-brushBackground');\n            dimensions.exit().remove();\n            dimensions.select('.nv-label').text(function (d) { return d.key });\n\n            // Add and store a brush for each axis.\n            restoreBrush(displayBrush);\n\n            var actives = dimensionNames.filter(function (p) { return !y[p].brush.empty(); }),\n                    extents = actives.map(function (p) { return y[p].brush.extent(); });\n            var formerActive = active.slice(0);\n\n            //Restore active values\n            active = [];\n            foreground.style(\"display\", function (d) {\n                var isActive = actives.every(function (p, i) {\n                    if ((isNaN(d.values[p]) || isNaN(parseFloat(d.values[p]))) && extents[i][0] == y[p].brush.y().domain()[0]) {\n                        return true;\n                    }\n                    return (extents[i][0] <= d.values[p] && d.values[p] <= extents[i][1]) && !isNaN(parseFloat(d.values[p]));\n                });\n                if (isActive)\n                    active.push(d);\n                return !isActive ? \"none\" : null;\n\n            });\n\n            if (filters.length > 0 || !nv.utils.arrayEquals(active, formerActive)) {\n               dispatch.activeChanged(active);\n            }\n\n            // Returns the path for a given data point.\n            function path(d) {\n                return line(enabledDimensions.map(function (p) {\n                    //If value if missing, put the value on the missing value line\n                    if (isNaN(d.values[p.key]) || isNaN(parseFloat(d.values[p.key])) || displayMissingValuesline) {\n                        var domain = y[p.key].domain();\n                        var range = y[p.key].range();\n                        var min = domain[0] - (domain[1] - domain[0]) / 9;\n\n                        //If it's not already the case, allow brush to select undefined values\n                        if (axisWithUndefinedValues.indexOf(p.key) < 0) {\n\n                            var newscale = d3.scale.linear().domain([min, domain[1]]).range([availableHeight - 12, range[1]]);\n                            y[p.key].brush.y(newscale);\n                            axisWithUndefinedValues.push(p.key);\n                        }\n                        if (isNaN(d.values[p.key]) || isNaN(parseFloat(d.values[p.key]))) {\n                            return [x(p.key), y[p.key](min)];\n                        }\n                    }\n\n                    //If parallelCoordinate contain missing values show the missing values line otherwise, hide it.\n                    if (missingValuesline !== undefined) {\n                        if (axisWithUndefinedValues.length > 0 || displayMissingValuesline) {\n                            missingValuesline.style(\"display\", \"inline\");\n                            missingValueslineText.style(\"display\", \"inline\");\n                        } else {\n                            missingValuesline.style(\"display\", \"none\");\n                            missingValueslineText.style(\"display\", \"none\");\n                        }\n                    }\n                    return [x(p.key), y[p.key](d.values[p.key])];\n                }));\n            }\n\n            function restoreBrush(visible) {\n                filters.forEach(function (f) {\n                    //If filter brushed NaN values, keep the brush on the bottom of the axis.\n                    var brushDomain = y[f.dimension].brush.y().domain();\n                    if (f.hasOnlyNaN) {\n                        f.extent[1] = (y[f.dimension].domain()[1] - brushDomain[0]) * (f.extent[1] - f.extent[0]) / (oldDomainMaxValue[f.dimension] - f.extent[0]) + brushDomain[0];\n                    }\n                    if (f.hasNaN) {\n                        f.extent[0] = brushDomain[0];\n                    }\n                    if (visible)\n                        y[f.dimension].brush.extent(f.extent);\n                });\n                \n                dimensions.select('.nv-brushBackground')\n                    .each(function (d) {\n                        d3.select(this).call(y[d.key].brush);\n\n                    })\n                    .selectAll('rect')\n                    .attr('x', -8)\n                    .attr('width', 16);\n                \n                updateTicks();\n            }\n            \n            // Handles a brush event, toggling the display of foreground lines.\n            function brushstart() {\n                //If brush aren't visible, show it before brushing again.\n                if (displayBrush === false) {\n                    displayBrush = true;\n                    restoreBrush(true);\n                }\n            }\n            \n            // Handles a brush event, toggling the display of foreground lines.\n            function brush() {\n                actives = dimensionNames.filter(function (p) { return !y[p].brush.empty(); });\n                extents = actives.map(function(p) { return y[p].brush.extent(); });\n\n                filters = []; //erase current filters\n                actives.forEach(function(d,i) {\n                    filters[i] = {\n                        dimension: d,\n                        extent: extents[i],\n                        hasNaN: false,\n                        hasOnlyNaN: false\n                    }\n                });\n\n                active = []; //erase current active list\n                foreground.style('display', function(d) {\n                    var isActive = actives.every(function(p, i) {\n                        if ((isNaN(d.values[p]) || isNaN(parseFloat(d.values[p]))) && extents[i][0] == y[p].brush.y().domain()[0]) return true;\n                        return (extents[i][0] <= d.values[p] && d.values[p] <= extents[i][1]) && !isNaN(parseFloat(d.values[p]));\n                    });\n                    if (isActive) active.push(d);\n                    return isActive ? null : 'none';\n                });\n                \n                updateTicks();\n                \n                dispatch.brush({\n                    filters: filters,\n                    active: active\n                });\n            }\n            function brushend() {\n                var hasActiveBrush = actives.length > 0 ? true : false;\n                filters.forEach(function (f) {\n                    if (f.extent[0] === y[f.dimension].brush.y().domain()[0] && axisWithUndefinedValues.indexOf(f.dimension) >= 0)\n                        f.hasNaN = true;\n                    if (f.extent[1] < y[f.dimension].domain()[0])\n                        f.hasOnlyNaN = true;\n                });\n                dispatch.brushEnd(active, hasActiveBrush);\n            }           \n            function updateTicks() {\n                dimensions.select('.nv-axis')\n                    .each(function (d, i) {\n                        var f = filters.filter(function (k) { return k.dimension == d.key; });\n                        currentTicks[d.key] = y[d.key].domain();\n                        \n                        //If brush are available, display brush extent\n                        if (f.length != 0 && displayBrush)\n                        {\n                            currentTicks[d.key] = [];\n                            if (f[0].extent[1] > y[d.key].domain()[0]) \n                                currentTicks[d.key] = [f[0].extent[1]];\n                            if (f[0].extent[0] >= y[d.key].domain()[0])\n                                currentTicks[d.key].push(f[0].extent[0]);    \n                        }\n                            \n                        d3.select(this).call(axis.scale(y[d.key]).tickFormat(d.format).tickValues(currentTicks[d.key]));\n                });\n            }\n            function dragStart(d) {\n                dragging[d.key] = this.parentNode.__origin__ = x(d.key);\n                background.attr(\"visibility\", \"hidden\");\n            }\n            function dragMove(d) {\n                dragging[d.key] = Math.min(availableWidth, Math.max(0, this.parentNode.__origin__ += d3.event.x));\n                foreground.attr(\"d\", path);\n                enabledDimensions.sort(function (a, b) { return dimensionPosition(a.key) - dimensionPosition(b.key); });\n                enabledDimensions.forEach(function (d, i) { return d.currentPosition = i; });\n                x.domain(enabledDimensions.map(function (d) { return d.key; }));\n                dimensions.attr(\"transform\", function(d) { return \"translate(\" + dimensionPosition(d.key) + \")\"; });\n            }\n            function dragEnd(d, i) {\n                delete this.parentNode.__origin__;\n                delete dragging[d.key];\n                d3.select(this.parentNode).attr(\"transform\", \"translate(\" + x(d.key) + \")\");\n                foreground\n                  .attr(\"d\", path);\n                background\n                  .attr(\"d\", path)\n                  .attr(\"visibility\", null);\n\n                dispatch.dimensionsOrder(enabledDimensions);\n            }\n            function dimensionPosition(d) {\n                var v = dragging[d];\n                return v == null ? x(d) : v;\n            }\n        });\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:         {get: function(){return width;},           set: function(_){width= _;}},\n        height:        {get: function(){return height;},          set: function(_){height= _;}},\n        dimensionData: { get: function () { return dimensionData; }, set: function (_) { dimensionData = _; } },\n        displayBrush: { get: function () { return displayBrush; }, set: function (_) { displayBrush = _; } },\n        filters: { get: function () { return filters; }, set: function (_) { filters = _; } },\n        active: { get: function () { return active; }, set: function (_) { active = _; } },\n        lineTension:   {get: function(){return lineTension;},     set: function(_){lineTension = _;}},\n        undefinedValuesLabel : {get: function(){return undefinedValuesLabel;}, set: function(_){undefinedValuesLabel=_;}},\n        \n        // deprecated options\n        dimensions: {get: function () { return dimensionData.map(function (d){return d.key}); }, set: function (_) {\n            // deprecated after 1.8.1\n            nv.deprecated('dimensions', 'use dimensionData instead');\n            if (dimensionData.length === 0) {\n                _.forEach(function (k) { dimensionData.push({ key: k }) })\n            } else {\n                _.forEach(function (k, i) { dimensionData[i].key= k })\n            }\n        }},\n        dimensionNames: {get: function () { return dimensionData.map(function (d){return d.key}); }, set: function (_) {\n            // deprecated after 1.8.1\n            nv.deprecated('dimensionNames', 'use dimensionData instead');\n            dimensionNames = [];\n            if (dimensionData.length === 0) {\n                _.forEach(function (k) { dimensionData.push({ key: k }) })\n            } else {\n                _.forEach(function (k, i) { dimensionData[i].key = k })\n            }\n \n        }},\n        dimensionFormats: {get: function () { return dimensionData.map(function (d) { return d.format }); }, set: function (_) {\n            // deprecated after 1.8.1\n            nv.deprecated('dimensionFormats', 'use dimensionData instead');\n            if (dimensionData.length === 0) {\n                _.forEach(function (f) { dimensionData.push({ format: f }) })\n            } else {\n                _.forEach(function (f, i) { dimensionData[i].format = f })\n            }\n\n        }},\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    =  _.top    !== undefined ? _.top    : margin.top;\n            margin.right  =  _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom =  _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   =  _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n    nv.utils.initOptions(chart);\n    return chart;\n};\nnv.models.parallelCoordinatesChart = function () {\n        \"use strict\";\n        //============================================================\n        // Public Variables with Default Settings\n        //------------------------------------------------------------\n\n        var parallelCoordinates = nv.models.parallelCoordinates()\n        var legend = nv.models.legend()\n        var tooltip = nv.models.tooltip();\n        var dimensionTooltip = nv.models.tooltip();\n\n        var margin = { top: 0, right: 0, bottom: 0, left: 0 }\n        , marginTop = null\n        , width = null\n        , height = null\n        , showLegend = true\n        , color = nv.utils.defaultColor()\n        , state = nv.utils.state()\n        , dimensionData = []\n        , displayBrush = true\n        , defaultState = null\n        , noData = null\n        , nanValue = \"undefined\"\n        , dispatch = d3.dispatch('dimensionsOrder', 'brushEnd', 'stateChange', 'changeState', 'renderEnd')\n        , controlWidth = function () { return showControls ? 180 : 0 }\n        ;\n\n\t    //============================================================\n\n\t\t//============================================================\n        // Private Variables\n        //------------------------------------------------------------\n\n        var renderWatch = nv.utils.renderWatch(dispatch);\n\n        var stateGetter = function(data) {\n            return function() {\n                return {\n                    active: data.map(function(d) { return !d.disabled })\n                };\n            }\n        };\n\n        var stateSetter = function(data) {\n            return function(state) {\n                if(state.active !== undefined) {\n                    data.forEach(function(series, i) {\n                        series.disabled = !state.active[i];\n                    });\n                }\n            }\n        };\n\n        tooltip.contentGenerator(function(data) {\n            var str = '<table><thead><tr><td class=\"legend-color-guide\"><div style=\"background-color:' + data.color + '\"></div></td><td><strong>' + data.key + '</strong></td></tr></thead>';\n            if(data.series.length !== 0)\n            {\n                str = str + '<tbody><tr><td height =\"10px\"></td></tr>';\n                data.series.forEach(function(d){\n                    str = str + '<tr><td class=\"legend-color-guide\"><div style=\"background-color:' + d.color + '\"></div></td><td class=\"key\">' + d.key + '</td><td class=\"value\">' + d.value + '</td></tr>';\n                });\n                str = str + '</tbody>';\n            }\n            str = str + '</table>';\n            return str;\n        });\n\n        //============================================================\n        // Chart function\n        //------------------------------------------------------------\n\n        function chart(selection) {\n            renderWatch.reset();\n            renderWatch.models(parallelCoordinates);\n\n            selection.each(function(data) {\n                var container = d3.select(this);\n                nv.utils.initSVG(container);\n\n                var that = this;\n\n                var availableWidth = nv.utils.availableWidth(width, container, margin),\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n\n                chart.update = function() { container.call(chart); };\n                chart.container = this;\n\n                state.setter(stateSetter(dimensionData), chart.update)\n                    .getter(stateGetter(dimensionData))\n                    .update();\n\n                //set state.disabled\n                state.disabled = dimensionData.map(function (d) { return !!d.disabled });\n\n                //Keep dimensions position in memory\n                dimensionData = dimensionData.map(function (d) {d.disabled = !!d.disabled; return d});\n                dimensionData.forEach(function (d, i) {\n                    d.originalPosition = isNaN(d.originalPosition) ? i : d.originalPosition;\n                    d.currentPosition = isNaN(d.currentPosition) ? i : d.currentPosition;\n                });\n\n               if (!defaultState) {\n                    var key;\n                    defaultState = {};\n                    for(key in state) {\n                        if(state[key] instanceof Array)\n                            defaultState[key] = state[key].slice(0);\n                        else\n                            defaultState[key] = state[key];\n                    }\n                }\n\n                // Display No Data message if there's nothing to show.\n                if(!data || !data.length) {\n                    nv.utils.noData(chart, container);\n                    return chart;\n                } else {\n                    container.selectAll('.nv-noData').remove();\n                }\n\n                //------------------------------------------------------------\n                // Setup containers and skeleton of chart\n\n                var wrap = container.selectAll('g.nv-wrap.nv-parallelCoordinatesChart').data([data]);\n                var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-parallelCoordinatesChart').append('g');\n\n                var g = wrap.select('g');\n\n                gEnter.append('g').attr('class', 'nv-parallelCoordinatesWrap');\n                gEnter.append('g').attr('class', 'nv-legendWrap');\n\n                g.select(\"rect\")\n                    .attr(\"width\", availableWidth)\n                    .attr(\"height\", (availableHeight > 0) ? availableHeight : 0);\n\n                // Legend\n                if (!showLegend) {\n                    g.select('.nv-legendWrap').selectAll('*').remove();\n                } else {\n                    legend.width(availableWidth)\n                        .color(function (d) { return \"rgb(188,190,192)\"; });\n\n                    g.select('.nv-legendWrap')\n                        .datum(dimensionData.sort(function (a, b) { return a.originalPosition - b.originalPosition; }))\n                        .call(legend);\n\n                    if (!marginTop && legend.height() !== margin.top) {\n                        margin.top = legend.height();\n                        availableHeight = nv.utils.availableHeight(height, container, margin);\n                    }\n                    wrap.select('.nv-legendWrap')\n                       .attr('transform', 'translate( 0 ,' + (-margin.top) + ')');\n                }\n                wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n                // Main Chart Component(s)\n                parallelCoordinates\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .dimensionData(dimensionData)\n                    .displayBrush(displayBrush);\n\n\t\t        var parallelCoordinatesWrap = g.select('.nv-parallelCoordinatesWrap ')\n                  .datum(data);\n\n\t\t        parallelCoordinatesWrap.transition().call(parallelCoordinates);\n\n\t\t\t\t//============================================================\n                // Event Handling/Dispatching (in chart's scope)\n                //------------------------------------------------------------\n                //Display reset brush button\n\t\t        parallelCoordinates.dispatch.on('brushEnd', function (active, hasActiveBrush) {\n\t\t            if (hasActiveBrush) {\n\t\t                displayBrush = true;\n\t\t                dispatch.brushEnd(active);\n\t\t            } else {\n\n\t\t                displayBrush = false;\n\t\t            }\n\t\t        });\n\n\t\t        legend.dispatch.on('stateChange', function(newState) {\n\t\t            for(var key in newState) {\n\t\t                state[key] = newState[key];\n\t\t            }\n\t\t            dispatch.stateChange(state);\n\t\t            chart.update();\n\t\t        });\n\n                //Update dimensions order and display reset sorting button\n\t\t        parallelCoordinates.dispatch.on('dimensionsOrder', function (e) {\n\t\t            dimensionData.sort(function (a, b) { return a.currentPosition - b.currentPosition; });\n\t\t            var isSorted = false;\n\t\t            dimensionData.forEach(function (d, i) {\n\t\t                d.currentPosition = i;\n\t\t                if (d.currentPosition !== d.originalPosition)\n\t\t                    isSorted = true;\n\t\t            });\n\t\t            dispatch.dimensionsOrder(dimensionData, isSorted);\n\t\t        });\n\n\t\t\t\t// Update chart from a state object passed to event handler\n                dispatch.on('changeState', function (e) {\n\n                    if (typeof e.disabled !== 'undefined') {\n                        dimensionData.forEach(function (series, i) {\n                            series.disabled = e.disabled[i];\n                        });\n                        state.disabled = e.disabled;\n                    }\n                    chart.update();\n                });\n            });\n\n            renderWatch.renderEnd('parraleleCoordinateChart immediate');\n            return chart;\n        }\n\n\t\t//============================================================\n        // Event Handling/Dispatching (out of chart's scope)\n        //------------------------------------------------------------\n\n        parallelCoordinates.dispatch.on('elementMouseover.tooltip', function (evt) {\n            var tp = {\n                key: evt.label,\n                color: evt.color,\n                series: []\n             }\n            if(evt.values){\n                Object.keys(evt.values).forEach(function (d) {\n                    var dim = evt.dimensions.filter(function (dd) {return dd.key === d;})[0];\n                    if(dim){\n                        var v;\n                        if (isNaN(evt.values[d]) || isNaN(parseFloat(evt.values[d]))) {\n                            v = nanValue;\n                        } else {\n                            v = dim.format(evt.values[d]);\n                        }\n                        tp.series.push({ idx: dim.currentPosition, key: d, value: v, color: dim.color });\n                    }\n                });\n                tp.series.sort(function(a,b) {return a.idx - b.idx});\n             }\n            tooltip.data(tp).hidden(false);\n        });\n\n        parallelCoordinates.dispatch.on('elementMouseout.tooltip', function(evt) {\n            tooltip.hidden(true)\n        });\n\n        parallelCoordinates.dispatch.on('elementMousemove.tooltip', function () {\n            tooltip();\n        });\n\t\t //============================================================\n        // Expose Public Variables\n        //------------------------------------------------------------\n\n\t\t// expose chart's sub-components\n        chart.dispatch = dispatch;\n        chart.parallelCoordinates = parallelCoordinates;\n        chart.legend = legend;\n        chart.tooltip = tooltip;\n        chart.options = nv.utils.optionsFunc.bind(chart);\n\n        chart._options = Object.create({}, {\n            // simple options, just get/set the necessary values\n            width: { get: function () { return width; }, set: function (_) { width = _; } },\n            height: { get: function () { return height; }, set: function (_) { height = _; } },\n            showLegend: { get: function () { return showLegend; }, set: function (_) { showLegend = _; } },\n            defaultState: { get: function () { return defaultState; }, set: function (_) { defaultState = _; } },\n            dimensionData: { get: function () { return dimensionData; }, set: function (_) { dimensionData = _; } },\n            displayBrush: { get: function () { return displayBrush; }, set: function (_) { displayBrush = _; } },\n            noData: { get: function () { return noData; }, set: function (_) { noData = _; } },\n            nanValue: { get: function () { return nanValue; }, set: function (_) { nanValue = _; } },\n\n            // options that require extra logic in the setter\n            margin: {\n                get: function () { return margin; },\n                set: function (_) {\n                    if (_.top !== undefined) {\n                        margin.top = _.top;\n                        marginTop = _.top;\n                    }\n                    margin.right = _.right !== undefined ? _.right : margin.right;\n                    margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n                    margin.left = _.left !== undefined ? _.left : margin.left;\n                }\n            },\n            color: {get: function(){return color;}, set: function(_){\n                    color = nv.utils.getColor(_);\n                    legend.color(color);\n                    parallelCoordinates.color(color);\n                }}\n        });\n\n        nv.utils.inheritOptions(chart, parallelCoordinates);\n        nv.utils.initOptions(chart);\n\n        return chart;\n    };\nnv.models.pie = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 500\n        , height = 500\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container = null\n        , color = nv.utils.defaultColor()\n        , valueFormat = d3.format(',.2f')\n        , showLabels = true\n        , labelsOutside = false\n        , labelType = \"key\"\n        , labelThreshold = .02 //if slice percentage is under this, don't show label\n        , donut = false\n        , title = false\n        , growOnHover = true\n        , titleOffset = 0\n        , labelSunbeamLayout = false\n        , startAngle = false\n        , padAngle = false\n        , endAngle = false\n        , cornerRadius = 0\n        , donutRatio = 0.5\n        , duration = 250\n        , arcsRadius = []\n        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'elementMousemove', 'renderEnd')\n        ;\n\n    var arcs = [];\n    var arcsOver = [];\n\n    //============================================================\n    // chart function\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right\n                , availableHeight = height - margin.top - margin.bottom\n                , radius = Math.min(availableWidth, availableHeight) / 2\n                , arcsRadiusOuter = []\n                , arcsRadiusInner = []\n                ;\n\n            container = d3.select(this)\n            if (arcsRadius.length === 0) {\n                var outer = radius - radius / 5;\n                var inner = donutRatio * radius;\n                for (var i = 0; i < data[0].length; i++) {\n                    arcsRadiusOuter.push(outer);\n                    arcsRadiusInner.push(inner);\n                }\n            } else {\n                if(growOnHover){\n                    arcsRadiusOuter = arcsRadius.map(function (d) { return (d.outer - d.outer / 5) * radius; });\n                    arcsRadiusInner = arcsRadius.map(function (d) { return (d.inner - d.inner / 5) * radius; });\n                    donutRatio = d3.min(arcsRadius.map(function (d) { return (d.inner - d.inner / 5); }));\n                } else {\n                    arcsRadiusOuter = arcsRadius.map(function (d) { return d.outer * radius; });\n                    arcsRadiusInner = arcsRadius.map(function (d) { return d.inner * radius; });\n                    donutRatio = d3.min(arcsRadius.map(function (d) { return d.inner; }));\n                }\n            }\n            nv.utils.initSVG(container);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('.nv-wrap.nv-pie').data(data);\n            var wrapEnter = wrap.enter().append('g').attr('class','nvd3 nv-wrap nv-pie nv-chart-' + id);\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n            var g_pie = gEnter.append('g').attr('class', 'nv-pie');\n            gEnter.append('g').attr('class', 'nv-pieLabels');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n            g.select('.nv-pie').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');\n            g.select('.nv-pieLabels').attr('transform', 'translate(' + availableWidth / 2 + ',' + availableHeight / 2 + ')');\n\n            //\n            container.on('click', function(d,i) {\n                dispatch.chartClick({\n                    data: d,\n                    index: i,\n                    pos: d3.event,\n                    id: id\n                });\n            });\n\n            arcs = [];\n            arcsOver = [];\n            for (var i = 0; i < data[0].length; i++) {\n\n                var arc = d3.svg.arc().outerRadius(arcsRadiusOuter[i]);\n                var arcOver = d3.svg.arc().outerRadius(arcsRadiusOuter[i] + 5);\n\n                if (startAngle !== false) {\n                    arc.startAngle(startAngle);\n                    arcOver.startAngle(startAngle);\n                }\n                if (endAngle !== false) {\n                    arc.endAngle(endAngle);\n                    arcOver.endAngle(endAngle);\n                }\n                if (donut) {\n                    arc.innerRadius(arcsRadiusInner[i]);\n                    arcOver.innerRadius(arcsRadiusInner[i]);\n                }\n\n                if (arc.cornerRadius && cornerRadius) {\n                    arc.cornerRadius(cornerRadius);\n                    arcOver.cornerRadius(cornerRadius);\n                }\n\n                arcs.push(arc);\n                arcsOver.push(arcOver);\n            }\n\n            // Setup the Pie chart and choose the data element\n            var pie = d3.layout.pie()\n                .sort(null)\n                .value(function(d) { return d.disabled ? 0 : getY(d) });\n\n            // padAngle added in d3 3.5\n            if (pie.padAngle && padAngle) {\n                pie.padAngle(padAngle);\n            }\n\n            // if title is specified and donut, put it in the middle\n            if (donut && title) {\n                g_pie.append(\"text\").attr('class', 'nv-pie-title');\n\n                wrap.select('.nv-pie-title')\n                    .style(\"text-anchor\", \"middle\")\n                    .text(function (d) {\n                        return title;\n                    })\n                    .style(\"font-size\", (Math.min(availableWidth, availableHeight)) * donutRatio * 2 / (title.length + 2) + \"px\")\n                    .attr(\"dy\", \"0.35em\") // trick to vertically center text\n                    .attr('transform', function(d, i) {\n                        return 'translate(0, '+ titleOffset + ')';\n                    });\n            }\n\n            var slices = wrap.select('.nv-pie').selectAll('.nv-slice').data(pie);\n            var pieLabels = wrap.select('.nv-pieLabels').selectAll('.nv-label').data(pie);\n\n            slices.exit().remove();\n            pieLabels.exit().remove();\n\n            var ae = slices.enter().append('g');\n            ae.attr('class', 'nv-slice');\n            ae.on('mouseover', function(d, i) {\n                d3.select(this).classed('hover', true);\n                if (growOnHover) {\n                    d3.select(this).select(\"path\").transition()\n                        .duration(70)\n                        .attr(\"d\", arcsOver[i]);\n                }\n                dispatch.elementMouseover({\n                    data: d.data,\n                    index: i,\n                    color: d3.select(this).style(\"fill\"),\n                    percent: (d.endAngle - d.startAngle) / (2 * Math.PI)\n                });\n            });\n            ae.on('mouseout', function(d, i) {\n                d3.select(this).classed('hover', false);\n                if (growOnHover) {\n                    d3.select(this).select(\"path\").transition()\n                        .duration(50)\n                        .attr(\"d\", arcs[i]);\n                }\n                dispatch.elementMouseout({data: d.data, index: i});\n            });\n            ae.on('mousemove', function(d, i) {\n                dispatch.elementMousemove({data: d.data, index: i});\n            });\n            ae.on('click', function(d, i) {\n                var element = this;\n                dispatch.elementClick({\n                    data: d.data,\n                    index: i,\n                    color: d3.select(this).style(\"fill\"),\n                    event: d3.event,\n                    element: element\n                });\n            });\n            ae.on('dblclick', function(d, i) {\n                dispatch.elementDblClick({\n                    data: d.data,\n                    index: i,\n                    color: d3.select(this).style(\"fill\")\n                });\n            });\n\n            slices.attr('fill', function(d,i) { return color(d.data, i); });\n            slices.attr('stroke', function(d,i) { return color(d.data, i); });\n\n            var paths = ae.append('path').each(function(d) {\n                this._current = d;\n            });\n\n            slices.select('path')\n                .transition()\n                .duration(duration)\n                .attr('d', function (d, i) { return arcs[i](d); })\n                .attrTween('d', arcTween);\n\n            if (showLabels) {\n                // This does the normal label\n                var labelsArc = [];\n                for (var i = 0; i < data[0].length; i++) {\n                    labelsArc.push(arcs[i]);\n\n                    if (labelsOutside) {\n                        if (donut) {\n                            labelsArc[i] = d3.svg.arc().outerRadius(arcs[i].outerRadius());\n                            if (startAngle !== false) labelsArc[i].startAngle(startAngle);\n                            if (endAngle !== false) labelsArc[i].endAngle(endAngle);\n                        }\n                    } else if (!donut) {\n                            labelsArc[i].innerRadius(0);\n                    }\n                }\n\n                pieLabels.enter().append(\"g\").classed(\"nv-label\",true).each(function(d,i) {\n                    var group = d3.select(this);\n\n                    group.attr('transform', function (d, i) {\n                        if (labelSunbeamLayout) {\n                            d.outerRadius = arcsRadiusOuter[i] + 10; // Set Outer Coordinate\n                            d.innerRadius = arcsRadiusOuter[i] + 15; // Set Inner Coordinate\n                            var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);\n                            if ((d.startAngle + d.endAngle) / 2 < Math.PI) {\n                                rotateAngle -= 90;\n                            } else {\n                                rotateAngle += 90;\n                            }\n                            return 'translate(' + labelsArc[i].centroid(d) + ') rotate(' + rotateAngle + ')';\n                        } else {\n                            d.outerRadius = radius + 10; // Set Outer Coordinate\n                            d.innerRadius = radius + 15; // Set Inner Coordinate\n                            return 'translate(' + labelsArc[i].centroid(d) + ')'\n                        }\n                    });\n\n                    group.append('rect')\n                        .style('stroke', '#fff')\n                        .style('fill', '#fff')\n                        .attr(\"rx\", 3)\n                        .attr(\"ry\", 3);\n\n                    group.append('text')\n                        .style('text-anchor', labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle') //center the text on it's origin or begin/end if orthogonal aligned\n                        .style('fill', '#000')\n                });\n\n                var labelLocationHash = {};\n                var avgHeight = 14;\n                var avgWidth = 140;\n                var createHashKey = function(coordinates) {\n                    return Math.floor(coordinates[0]/avgWidth) * avgWidth + ',' + Math.floor(coordinates[1]/avgHeight) * avgHeight;\n                };\n                var getSlicePercentage = function(d) {\n                    return (d.endAngle - d.startAngle) / (2 * Math.PI);\n                };\n\n                pieLabels.watchTransition(renderWatch, 'pie labels').attr('transform', function (d, i) {\n                    if (labelSunbeamLayout) {\n                        d.outerRadius = arcsRadiusOuter[i] + 10; // Set Outer Coordinate\n                        d.innerRadius = arcsRadiusOuter[i] + 15; // Set Inner Coordinate\n                        var rotateAngle = (d.startAngle + d.endAngle) / 2 * (180 / Math.PI);\n                        if ((d.startAngle + d.endAngle) / 2 < Math.PI) {\n                            rotateAngle -= 90;\n                        } else {\n                            rotateAngle += 90;\n                        }\n                        return 'translate(' + labelsArc[i].centroid(d) + ') rotate(' + rotateAngle + ')';\n                    } else {\n                        d.outerRadius = radius + 10; // Set Outer Coordinate\n                        d.innerRadius = radius + 15; // Set Inner Coordinate\n\n                        /*\n                        Overlapping pie labels are not good. What this attempts to do is, prevent overlapping.\n                        Each label location is hashed, and if a hash collision occurs, we assume an overlap.\n                        Adjust the label's y-position to remove the overlap.\n                        */\n                        var center = labelsArc[i].centroid(d);\n                        var percent = getSlicePercentage(d);\n                        if (d.value && percent >= labelThreshold) {\n                            var hashKey = createHashKey(center);\n                            if (labelLocationHash[hashKey]) {\n                                center[1] -= avgHeight;\n                            }\n                            labelLocationHash[createHashKey(center)] = true;\n                        }\n                        return 'translate(' + center + ')'\n                    }\n                });\n\n                pieLabels.select(\".nv-label text\")\n                    .style('text-anchor', function(d,i) {\n                        //center the text on it's origin or begin/end if orthogonal aligned\n                        return labelSunbeamLayout ? ((d.startAngle + d.endAngle) / 2 < Math.PI ? 'start' : 'end') : 'middle';\n                    })\n                    .text(function(d, i) {\n                        var percent = getSlicePercentage(d);\n                        var label = '';\n                        if (!d.value || percent < labelThreshold) return '';\n\n                        if(typeof labelType === 'function') {\n                            label = labelType(d, i, {\n                                'key': getX(d.data),\n                                'value': getY(d.data),\n                                'percent': valueFormat(percent)\n                            });\n                        } else {\n                            switch (labelType) {\n                                case 'key':\n                                    label = getX(d.data);\n                                    break;\n                                case 'value':\n                                    label = valueFormat(getY(d.data));\n                                    break;\n                                case 'percent':\n                                    label = d3.format('%')(percent);\n                                    break;\n                            }\n                        }\n                        return label;\n                    })\n                ;\n            }\n\n\n            // Computes the angle of an arc, converting from radians to degrees.\n            function angle(d) {\n                var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;\n                return a > 90 ? a - 180 : a;\n            }\n\n            function arcTween(a, idx) {\n                a.endAngle = isNaN(a.endAngle) ? 0 : a.endAngle;\n                a.startAngle = isNaN(a.startAngle) ? 0 : a.startAngle;\n                if (!donut) a.innerRadius = 0;\n                var i = d3.interpolate(this._current, a);\n                this._current = i(0);\n                return function (t) {\n                    return arcs[idx](i(t));\n                };\n            }\n        });\n\n        renderWatch.renderEnd('pie immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        arcsRadius: { get: function () { return arcsRadius; }, set: function (_) { arcsRadius = _; } },\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=_;}},\n        title:      {get: function(){return title;}, set: function(_){title=_;}},\n        titleOffset:    {get: function(){return titleOffset;}, set: function(_){titleOffset=_;}},\n        labelThreshold: {get: function(){return labelThreshold;}, set: function(_){labelThreshold=_;}},\n        valueFormat:    {get: function(){return valueFormat;}, set: function(_){valueFormat=_;}},\n        x:          {get: function(){return getX;}, set: function(_){getX=_;}},\n        id:         {get: function(){return id;}, set: function(_){id=_;}},\n        endAngle:   {get: function(){return endAngle;}, set: function(_){endAngle=_;}},\n        startAngle: {get: function(){return startAngle;}, set: function(_){startAngle=_;}},\n        padAngle:   {get: function(){return padAngle;}, set: function(_){padAngle=_;}},\n        cornerRadius: {get: function(){return cornerRadius;}, set: function(_){cornerRadius=_;}},\n        donutRatio:   {get: function(){return donutRatio;}, set: function(_){donutRatio=_;}},\n        labelsOutside: {get: function(){return labelsOutside;}, set: function(_){labelsOutside=_;}},\n        labelSunbeamLayout: {get: function(){return labelSunbeamLayout;}, set: function(_){labelSunbeamLayout=_;}},\n        donut:              {get: function(){return donut;}, set: function(_){donut=_;}},\n        growOnHover:        {get: function(){return growOnHover;}, set: function(_){growOnHover=_;}},\n\n        // depreciated after 1.7.1\n        pieLabelsOutside: {get: function(){return labelsOutside;}, set: function(_){\n            labelsOutside=_;\n            nv.deprecated('pieLabelsOutside', 'use labelsOutside instead');\n        }},\n        // depreciated after 1.7.1\n        donutLabelsOutside: {get: function(){return labelsOutside;}, set: function(_){\n            labelsOutside=_;\n            nv.deprecated('donutLabelsOutside', 'use labelsOutside instead');\n        }},\n        // deprecated after 1.7.1\n        labelFormat: {get: function(){ return valueFormat;}, set: function(_) {\n            valueFormat=_;\n            nv.deprecated('labelFormat','use valueFormat instead');\n        }},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = typeof _.top    != 'undefined' ? _.top    : margin.top;\n            margin.right  = typeof _.right  != 'undefined' ? _.right  : margin.right;\n            margin.bottom = typeof _.bottom != 'undefined' ? _.bottom : margin.bottom;\n            margin.left   = typeof _.left   != 'undefined' ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n        }},\n        y: {get: function(){return getY;}, set: function(_){\n            getY=d3.functor(_);\n        }},\n        color: {get: function(){return color;}, set: function(_){\n            color=nv.utils.getColor(_);\n        }},\n        labelType:          {get: function(){return labelType;}, set: function(_){\n            labelType= _ || 'key';\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    return chart;\n};\nnv.models.pieChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var pie = nv.models.pie();\n    var legend = nv.models.legend();\n    var tooltip = nv.models.tooltip();\n\n    var margin = {top: 30, right: 20, bottom: 20, left: 20}\n        , marginTop = null\n        , width = null\n        , height = null\n        , showTooltipPercent = false\n        , showLegend = true\n        , legendPosition = \"top\"\n        , color = nv.utils.defaultColor()\n        , state = nv.utils.state()\n        , defaultState = null\n        , noData = null\n        , duration = 250\n        , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd')\n        ;\n\n    tooltip\n        .duration(0)\n        .headerEnabled(false)\n        .valueFormatter(function(d, i) {\n            return pie.valueFormat()(d, i);\n        });\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled })\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.active !== undefined) {\n                data.forEach(function (series, i) {\n                    series.disabled = !state.active[i];\n                });\n            }\n        }\n    };\n\n    //============================================================\n    // Chart function\n    //------------------------------------------------------------\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(pie);\n\n        selection.each(function(data) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            var that = this;\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() { container.transition().call(chart); };\n            chart.container = this;\n\n            state.setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            //set state.disabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length) {\n                nv.utils.noData(chart, container);\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-pieChart').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-pieChart').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-pieWrap');\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                if (legendPosition === \"top\") {\n                    legend.width( availableWidth ).key(pie.x());\n\n                    wrap.select('.nv-legendWrap')\n                        .datum(data)\n                        .call(legend);\n\n                    if (!marginTop && legend.height() !== margin.top) {\n                        margin.top = legend.height();\n                        availableHeight = nv.utils.availableHeight(height, container, margin);\n                    }\n\n                    wrap.select('.nv-legendWrap')\n                        .attr('transform', 'translate(0,' + (-margin.top) +')');\n                } else if (legendPosition === \"right\") {\n                    var legendWidth = nv.models.legend().width();\n                    if (availableWidth / 2 < legendWidth) {\n                        legendWidth = (availableWidth / 2)\n                    }\n                    legend.height(availableHeight).key(pie.x());\n                    legend.width(legendWidth);\n                    availableWidth -= legend.width();\n\n                    wrap.select('.nv-legendWrap')\n                        .datum(data)\n                        .call(legend)\n                        .attr('transform', 'translate(' + (availableWidth) +',0)');\n                }\n            }\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            // Main Chart Component(s)\n            pie.width(availableWidth).height(availableHeight);\n            var pieWrap = g.select('.nv-pieWrap').datum([data]);\n            d3.transition(pieWrap).call(pie);\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState) {\n                    state[key] = newState[key];\n                }\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n                    state.disabled = e.disabled;\n                }\n                chart.update();\n            });\n        });\n\n        renderWatch.renderEnd('pieChart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    pie.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt['series'] = {\n            key: chart.x()(evt.data),\n            value: chart.y()(evt.data),\n            color: evt.color,\n            percent: evt.percent\n        };\n        if (!showTooltipPercent) {\n            delete evt.percent;\n            delete evt.series.percent;\n        }\n        tooltip.data(evt).hidden(false);\n    });\n\n    pie.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    pie.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.legend = legend;\n    chart.dispatch = dispatch;\n    chart.pie = pie;\n    chart.tooltip = tooltip;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    // use Object get/set functionality to map between vars and chart functions\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:              {get: function(){return width;},                set: function(_){width=_;}},\n        height:             {get: function(){return height;},               set: function(_){height=_;}},\n        noData:             {get: function(){return noData;},               set: function(_){noData=_;}},\n        showTooltipPercent: {get: function(){return showTooltipPercent;},   set: function(_){showTooltipPercent=_;}},\n        showLegend:         {get: function(){return showLegend;},           set: function(_){showLegend=_;}},\n        legendPosition:     {get: function(){return legendPosition;},       set: function(_){legendPosition=_;}},\n        defaultState:       {get: function(){return defaultState;},         set: function(_){defaultState=_;}},\n\n        // options that require extra logic in the setter\n        color: {get: function(){return color;}, set: function(_){\n            color = _;\n            legend.color(color);\n            pie.color(color);\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            pie.duration(duration);\n        }},\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }}\n    });\n    nv.utils.inheritOptions(chart, pie);\n    nv.utils.initOptions(chart);\n    return chart;\n};\nnv.models.sankey = function() {\n    'use strict';\n\n    // Sources:\n    // - https://bost.ocks.org/mike/sankey/\n    // - https://github.com/soxofaan/d3-plugin-captain-sankey\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var sankey = {},\n        nodeWidth = 24,\n        nodePadding = 8,\n        size = [1, 1],\n        nodes = [],\n        links = [],\n        sinksRight = true;\n\n    var layout = function(iterations) {\n        computeNodeLinks();\n        computeNodeValues();\n        computeNodeBreadths();\n        computeNodeDepths(iterations);\n    };\n\n    var relayout = function() {\n        computeLinkDepths();\n    };\n\n    // SVG path data generator, to be used as 'd' attribute on 'path' element selection.\n    var link = function() {\n        var curvature = .5;\n\n        function link(d) {\n\n            var x0 = d.source.x + d.source.dx,\n                x1 = d.target.x,\n                xi = d3.interpolateNumber(x0, x1),\n                x2 = xi(curvature),\n                x3 = xi(1 - curvature),\n                y0 = d.source.y + d.sy + d.dy / 2,\n                y1 = d.target.y + d.ty + d.dy / 2;\n            var linkPath = 'M' + x0 + ',' + y0\n                + 'C' + x2 + ',' + y0\n                + ' ' + x3 + ',' + y1\n                + ' ' + x1 + ',' + y1;\n            return linkPath;\n        }\n\n        link.curvature = function(_) {\n            if (!arguments.length) return curvature;\n            curvature = +_;\n            return link;\n        };\n\n        return link;\n    };\n\n    // Y-position of the middle of a node.\n    var center = function(node) {\n        return node.y + node.dy / 2;\n    };\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    // Populate the sourceLinks and targetLinks for each node.\n    // Also, if the source and target are not objects, assume they are indices.\n    function computeNodeLinks() {\n        nodes.forEach(function(node) {\n            // Links that have this node as source.\n            node.sourceLinks = [];\n            // Links that have this node as target.\n            node.targetLinks = [];\n        });\n        links.forEach(function(link) {\n            var source = link.source,\n                target = link.target;\n            if (typeof source === 'number') source = link.source = nodes[link.source];\n            if (typeof target === 'number') target = link.target = nodes[link.target];\n            source.sourceLinks.push(link);\n            target.targetLinks.push(link);\n        });\n    }\n\n    // Compute the value (size) of each node by summing the associated links.\n    function computeNodeValues() {\n        nodes.forEach(function(node) {\n            node.value = Math.max(\n                d3.sum(node.sourceLinks, value),\n                d3.sum(node.targetLinks, value)\n            );\n        });\n    }\n\n    // Iteratively assign the breadth (x-position) for each node.\n    // Nodes are assigned the maximum breadth of incoming neighbors plus one;\n    // nodes with no incoming links are assigned breadth zero, while\n    // nodes with no outgoing links are assigned the maximum breadth.\n    function computeNodeBreadths() {\n        //\n        var remainingNodes = nodes,\n            nextNodes,\n            x = 0;\n\n        // Work from left to right.\n        // Keep updating the breath (x-position) of nodes that are target of recently updated nodes.\n        //\n        while (remainingNodes.length && x < nodes.length) {\n            nextNodes = [];\n            remainingNodes.forEach(function(node) {\n                node.x = x;\n                node.dx = nodeWidth;\n                node.sourceLinks.forEach(function(link) {\n                    if (nextNodes.indexOf(link.target) < 0) {\n                        nextNodes.push(link.target);\n                    }\n                });\n            });\n            remainingNodes = nextNodes;\n            ++x;\n            //\n        }\n\n        // Optionally move pure sinks always to the right.\n        if (sinksRight) {\n            moveSinksRight(x);\n        }\n\n        scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));\n    }\n\n    function moveSourcesRight() {\n        nodes.forEach(function(node) {\n            if (!node.targetLinks.length) {\n                node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;\n            }\n        });\n    }\n\n    function moveSinksRight(x) {\n        nodes.forEach(function(node) {\n            if (!node.sourceLinks.length) {\n                node.x = x - 1;\n            }\n        });\n    }\n\n    function scaleNodeBreadths(kx) {\n        nodes.forEach(function(node) {\n            node.x *= kx;\n        });\n    }\n\n    // Compute the depth (y-position) for each node.\n    function computeNodeDepths(iterations) {\n        // Group nodes by breath.\n        var nodesByBreadth = d3.nest()\n            .key(function(d) { return d.x; })\n            .sortKeys(d3.ascending)\n            .entries(nodes)\n            .map(function(d) { return d.values; });\n\n        //\n        initializeNodeDepth();\n        resolveCollisions();\n        computeLinkDepths();\n        for (var alpha = 1; iterations > 0; --iterations) {\n            relaxRightToLeft(alpha *= .99);\n            resolveCollisions();\n            computeLinkDepths();\n            relaxLeftToRight(alpha);\n            resolveCollisions();\n            computeLinkDepths();\n        }\n\n        function initializeNodeDepth() {\n            // Calculate vertical scaling factor.\n            var ky = d3.min(nodesByBreadth, function(nodes) {\n                return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);\n            });\n\n            nodesByBreadth.forEach(function(nodes) {\n                nodes.forEach(function(node, i) {\n                    node.y = i;\n                    node.dy = node.value * ky;\n                });\n            });\n\n            links.forEach(function(link) {\n                link.dy = link.value * ky;\n            });\n        }\n\n        function relaxLeftToRight(alpha) {\n            nodesByBreadth.forEach(function(nodes, breadth) {\n                nodes.forEach(function(node) {\n                    if (node.targetLinks.length) {\n                        // Value-weighted average of the y-position of source node centers linked to this node.\n                        var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);\n                        node.y += (y - center(node)) * alpha;\n                    }\n                });\n            });\n\n            function weightedSource(link) {\n                return (link.source.y + link.sy + link.dy / 2) * link.value;\n            }\n        }\n\n        function relaxRightToLeft(alpha) {\n            nodesByBreadth.slice().reverse().forEach(function(nodes) {\n                nodes.forEach(function(node) {\n                    if (node.sourceLinks.length) {\n                        // Value-weighted average of the y-positions of target nodes linked to this node.\n                        var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);\n                        node.y += (y - center(node)) * alpha;\n                    }\n                });\n            });\n\n            function weightedTarget(link) {\n                return (link.target.y + link.ty + link.dy / 2) * link.value;\n            }\n        }\n\n        function resolveCollisions() {\n            nodesByBreadth.forEach(function(nodes) {\n                var node,\n                    dy,\n                    y0 = 0,\n                    n = nodes.length,\n                    i;\n\n                // Push any overlapping nodes down.\n                nodes.sort(ascendingDepth);\n                for (i = 0; i < n; ++i) {\n                    node = nodes[i];\n                    dy = y0 - node.y;\n                    if (dy > 0) node.y += dy;\n                    y0 = node.y + node.dy + nodePadding;\n                }\n\n                // If the bottommost node goes outside the bounds, push it back up.\n                dy = y0 - nodePadding - size[1];\n                if (dy > 0) {\n                    y0 = node.y -= dy;\n\n                    // Push any overlapping nodes back up.\n                    for (i = n - 2; i >= 0; --i) {\n                        node = nodes[i];\n                        dy = node.y + node.dy + nodePadding - y0;\n                        if (dy > 0) node.y -= dy;\n                        y0 = node.y;\n                    }\n                }\n            });\n        }\n\n        function ascendingDepth(a, b) {\n            return a.y - b.y;\n        }\n    }\n\n    // Compute y-offset of the source endpoint (sy) and target endpoints (ty) of links,\n    // relative to the source/target node's y-position.\n    function computeLinkDepths() {\n        nodes.forEach(function(node) {\n            node.sourceLinks.sort(ascendingTargetDepth);\n            node.targetLinks.sort(ascendingSourceDepth);\n        });\n        nodes.forEach(function(node) {\n            var sy = 0, ty = 0;\n            node.sourceLinks.forEach(function(link) {\n                link.sy = sy;\n                sy += link.dy;\n            });\n            node.targetLinks.forEach(function(link) {\n                link.ty = ty;\n                ty += link.dy;\n            });\n        });\n\n        function ascendingSourceDepth(a, b) {\n            return a.source.y - b.source.y;\n        }\n\n        function ascendingTargetDepth(a, b) {\n            return a.target.y - b.target.y;\n        }\n    }\n\n    // Value property accessor.\n    function value(x) {\n        return x.value;\n    }\n\n    sankey.options = nv.utils.optionsFunc.bind(sankey);\n    sankey._options = Object.create({}, {\n        nodeWidth:    {get: function(){return nodeWidth;},   set: function(_){nodeWidth=+_;}},\n        nodePadding:  {get: function(){return nodePadding;}, set: function(_){nodePadding=_;}},\n        nodes:        {get: function(){return nodes;},       set: function(_){nodes=_;}},\n        links:        {get: function(){return links ;},      set: function(_){links=_;}},\n        size:         {get: function(){return size;},        set: function(_){size=_;}},\n        sinksRight:   {get: function(){return sinksRight;},  set: function(_){sinksRight=_;}},\n\n        layout:       {get: function(){layout(32);},         set: function(_){layout(_);}},\n        relayout:     {get: function(){relayout();},         set: function(_){}},\n        center:       {get: function(){return center();},    set: function(_){\n            if(typeof _ === 'function'){\n                center=_;\n            }\n        }},\n        link:         {get: function(){return link();},      set: function(_){\n            if(typeof _ === 'function'){\n                link=_;\n            }\n            return link();\n        }}\n    });\n\n    nv.utils.initOptions(sankey);\n\n    return sankey;\n};\nnv.models.sankeyChart = function() {\n    \"use strict\";\n\n    // Sources:\n    // - https://bost.ocks.org/mike/sankey/\n    // - https://github.com/soxofaan/d3-plugin-captain-sankey\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 5, right: 0, bottom: 5, left: 0}\n        , sankey = nv.models.sankey()\n        , width = 600\n        , height = 400\n        , nodeWidth = 36\n        , nodePadding =  40\n        , units = 'units'\n        , center = undefined\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var formatNumber = d3.format(',.0f');    // zero decimal places\n    var format = function(d) {\n        return formatNumber(d) + ' ' + units;\n    };\n    var color = d3.scale.category20();\n    var linkTitle = function(d){\n        return d.source.name + ' → ' + d.target.name + '\\n' + format(d.value);\n    };\n    var nodeFillColor = function(d){\n        return d.color = color(d.name.replace(/ .*/, ''));\n    };\n    var nodeStrokeColor = function(d){\n        return d3.rgb(d.color).darker(2);\n    };\n    var nodeTitle = function(d){\n        return d.name + '\\n' + format(d.value);\n    };\n\n    var showError = function(element, message) {\n        element.append('text')\n            .attr('x', 0)\n            .attr('y', 0)\n            .attr('class', 'nvd3-sankey-chart-error')\n            .attr('text-anchor', 'middle')\n            .text(message);\n    };\n\n    function chart(selection) {\n        selection.each(function(data) {\n\n            var testData = {\n                nodes:\n                    [\n                        {'node': 1, 'name': 'Test 1'},\n                        {'node': 2, 'name': 'Test 2'},\n                        {'node': 3, 'name': 'Test 3'},\n                        {'node': 4, 'name': 'Test 4'},\n                        {'node': 5, 'name': 'Test 5'},\n                        {'node': 6, 'name': 'Test 6'}\n                    ],\n                links:\n                    [\n                        {'source': 0, 'target': 1, 'value': 2295},\n                        {'source': 0, 'target': 5, 'value': 1199},\n                        {'source': 1, 'target': 2, 'value': 1119},\n                        {'source': 1, 'target': 5, 'value': 1176},\n                        {'source': 2, 'target': 3, 'value': 487},\n                        {'source': 2, 'target': 5, 'value': 632},\n                        {'source': 3, 'target': 4, 'value': 301},\n                        {'source': 3, 'target': 5, 'value': 186}\n                    ]\n            };\n\n            // Error handling\n            var isDataValid = false;\n            var dataAvailable = false;\n\n            // check if data is valid\n            if(\n                (typeof data['nodes'] === 'object' && data['nodes'].length) >= 0 &&\n                (typeof data['links'] === 'object' && data['links'].length) >= 0\n            ){\n                isDataValid = true;\n            }\n\n            // check if data is available\n            if(\n                data['nodes'] && data['nodes'].length > 0 &&\n                data['links'] && data['links'].length > 0\n            ) {\n                dataAvailable = true;\n            }\n\n            // show error\n            if(!isDataValid) {\n                console.error('NVD3 Sankey chart error:', 'invalid data format for', data);\n                console.info('Valid data format is: ', testData, JSON.stringify(testData));\n                showError(selection, 'Error loading chart, data is invalid');\n                return false;\n            }\n\n            // TODO use nv.utils.noData\n            if(!dataAvailable) {\n                showError(selection, 'No data available');\n                return false;\n            }\n\n            // No errors, continue\n\n            // append the svg canvas to the page\n            var svg = selection.append('svg')\n                .attr('width', width)\n                .attr('height', height)\n                .append('g')\n                .attr('class', 'nvd3 nv-wrap nv-sankeyChart');\n\n            // Set the sankey diagram properties\n            sankey\n                .nodeWidth(nodeWidth)\n                .nodePadding(nodePadding)\n                .size([width, height]);\n\n            var path = sankey.link();\n\n            sankey\n                .nodes(data.nodes)\n                .links(data.links)\n                .layout(32)\n                .center(center);\n\n            // add in the links\n            var link = svg.append('g').selectAll('.link')\n                .data(data.links)\n                .enter().append('path')\n                .attr('class', 'link')\n                .attr('d', path)\n                .style('stroke-width', function(d) { return Math.max(1, d.dy); })\n            .sort(function(a,b) { return b.dy - a.dy; });\n\n            // add the link titles\n            link.append('title')\n                .text(linkTitle);\n\n            // add in the nodes\n            var node = svg.append('g').selectAll('.node')\n                .data(data.nodes)\n                .enter().append('g')\n                .attr('class', 'node')\n                .attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })\n                .call(\n                    d3.behavior\n                        .drag()\n                        .origin(function(d) { return d; })\n                        .on('dragstart', function() {\n                            this.parentNode.appendChild(this);\n                        })\n                        .on('drag', dragmove)\n                );\n\n            // add the rectangles for the nodes\n            node.append('rect')\n                .attr('height', function(d) { return d.dy; })\n                .attr('width', sankey.nodeWidth())\n                .style('fill', nodeFillColor)\n                .style('stroke', nodeStrokeColor)\n                .append('title')\n                .text(nodeTitle);\n\n            // add in the title for the nodes\n            node.append('text')\n                .attr('x', -6)\n                .attr('y', function(d) { return d.dy / 2; })\n                .attr('dy', '.35em')\n                .attr('text-anchor', 'end')\n                .attr('transform', null)\n                .text(function(d) { return d.name; })\n                .filter(function(d) { return d.x < width / 2; })\n                .attr('x', 6 + sankey.nodeWidth())\n                .attr('text-anchor', 'start');\n\n            // the function for moving the nodes\n            function dragmove(d) {\n                d3.select(this).attr('transform',\n                'translate(' + d.x + ',' + (\n                    d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))\n                ) + ')');\n                sankey.relayout();\n                link.attr('d', path);\n            }\n        });\n\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        units:           {get: function(){return units;},       set: function(_){units=_;}},\n        width:           {get: function(){return width;},       set: function(_){width=_;}},\n        height:          {get: function(){return height;},      set: function(_){height=_;}},\n        format:          {get: function(){return format;},      set: function(_){format=_;}},\n        linkTitle:       {get: function(){return linkTitle;},   set: function(_){linkTitle=_;}},\n        nodeWidth:       {get: function(){return nodeWidth;},   set: function(_){nodeWidth=_;}},\n        nodePadding:     {get: function(){return nodePadding;}, set: function(_){nodePadding=_;}},\n        center:          {get: function(){return center},       set: function(_){center=_}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        nodeStyle: {get: function(){return {};}, set: function(_){\n            nodeFillColor   = _.fillColor   !== undefined ? _.fillColor   : nodeFillColor;\n            nodeStrokeColor = _.strokeColor !== undefined ? _.strokeColor : nodeStrokeColor;\n            nodeTitle       = _.title       !== undefined ? _.title       : nodeTitle;\n        }}\n\n    });\n\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.scatter = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin       = {top: 0, right: 0, bottom: 0, left: 0}\n        , width        = null\n        , height       = null\n        , color        = nv.utils.defaultColor() // chooses color\n        , pointBorderColor = null\n        , id           = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't select one\n        , container    = null\n        , x            = d3.scale.linear()\n        , y            = d3.scale.linear()\n        , z            = d3.scale.linear() //linear because d3.svg.shape.size is treated as area\n        , getX         = function(d) { return d.x } // accessor to get the x value\n        , getY         = function(d) { return d.y } // accessor to get the y value\n        , getSize      = function(d) { return d.size || 1} // accessor to get the point size\n        , getShape     = function(d) { return d.shape || 'circle' } // accessor to get point shape\n        , forceX       = [] // List of numbers to Force into the X scale (ie. 0, or a max / min, etc.)\n        , forceY       = [] // List of numbers to Force into the Y scale\n        , forceSize    = [] // List of numbers to Force into the Size scale\n        , interactive  = true // If true, plots a voronoi overlay for advanced point intersection\n        , pointActive  = function(d) { return !d.notActive } // any points that return false will be filtered out\n        , padData      = false // If true, adds half a data points width to front and back, for lining up a line chart with a bar chart\n        , padDataOuter = .1 //outerPadding to imitate ordinal scale outer padding\n        , clipEdge     = false // if true, masks points within x and y scale\n        , clipVoronoi  = true // if true, masks each point with a circle... can turn off to slightly increase performance\n        , showVoronoi  = false // display the voronoi areas\n        , clipRadius   = function() { return 25 } // function to get the radius for voronoi point clips\n        , xDomain      = null // Override x domain (skips the calculation from data)\n        , yDomain      = null // Override y domain\n        , xRange       = null // Override x range\n        , yRange       = null // Override y range\n        , sizeDomain   = null // Override point size domain\n        , sizeRange    = null\n        , singlePoint  = false\n        , dispatch     = d3.dispatch('elementClick', 'elementDblClick', 'elementMouseover', 'elementMouseout', 'renderEnd')\n        , useVoronoi   = true\n        , duration     = 250\n        , interactiveUpdateDelay = 300\n        , showLabels    = false\n        ;\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x0, y0, z0 // used to store previous scales\n        , width0\n        , height0\n        , timeoutID\n        , needsUpdate = false // Flag for when the points are visually updating, but the interactive layer is behind, to disable tooltips\n        , renderWatch = nv.utils.renderWatch(dispatch, duration)\n        , _sizeRange_def = [16, 256]\n        , _cache = {}\n        ;\n\n    function getCache(d) {\n        var key, val;\n        key = d[0].series + ':' + d[1];\n        val = _cache[key] = _cache[key] || {};\n        return val;\n    }\n\n    function delCache(d) {\n        var key, val;\n        key = d[0].series + ':' + d[1];\n        delete _cache[key];\n    }\n\n    function getDiffs(d) {\n        var i, key, val,\n            cache = getCache(d),\n            diffs = false;\n        for (i = 1; i < arguments.length; i += 2) {\n            key = arguments[i];\n            val = arguments[i + 1](d[0], d[1]);\n            if (cache[key] !== val || !cache.hasOwnProperty(key)) {\n                cache[key] = val;\n                diffs = true;\n            }\n        }\n        return diffs;\n    }\n\n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            container = d3.select(this);\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            nv.utils.initSVG(container);\n\n            //add series index to each data point for reference\n            data.forEach(function(series, i) {\n                series.values.forEach(function(point) {\n                    point.series = i;\n                });\n            });\n\n            // Setup Scales\n            var logScale = chart.yScale().name === d3.scale.log().name ? true : false;\n            // remap and flatten the data for use in calculating the scales' domains\n            var seriesData = (xDomain && yDomain && sizeDomain) ? [] : // if we know xDomain and yDomain and sizeDomain, no need to calculate.... if Size is constant remember to set sizeDomain to speed up performance\n                d3.merge(\n                    data.map(function(d) {\n                        return d.values.map(function(d,i) {\n                            return { x: getX(d,i), y: getY(d,i), size: getSize(d,i) }\n                        })\n                    })\n                );\n\n            x   .domain(xDomain || d3.extent(seriesData.map(function(d) { return d.x; }).concat(forceX)))\n\n            if (padData && data[0])\n                x.range(xRange || [(availableWidth * padDataOuter +  availableWidth) / (2 *data[0].values.length), availableWidth - availableWidth * (1 + padDataOuter) / (2 * data[0].values.length)  ]);\n            //x.range([availableWidth * .5 / data[0].values.length, availableWidth * (data[0].values.length - .5)  / data[0].values.length ]);\n            else\n                x.range(xRange || [0, availableWidth]);\n\n             if (logScale) {\n                    var min = d3.min(seriesData.map(function(d) { if (d.y !== 0) return d.y; }));\n                    y.clamp(true)\n                        .domain(yDomain || d3.extent(seriesData.map(function(d) {\n                            if (d.y !== 0) return d.y;\n                            else return min * 0.1;\n                        }).concat(forceY)))\n                        .range(yRange || [availableHeight, 0]);\n                } else {\n                        y.domain(yDomain || d3.extent(seriesData.map(function (d) { return d.y;}).concat(forceY)))\n                        .range(yRange || [availableHeight, 0]);\n                }\n\n            z   .domain(sizeDomain || d3.extent(seriesData.map(function(d) { return d.size }).concat(forceSize)))\n                .range(sizeRange || _sizeRange_def);\n\n            // If scale's domain don't have a range, slightly adjust to make one... so a chart can show a single data point\n            singlePoint = x.domain()[0] === x.domain()[1] || y.domain()[0] === y.domain()[1];\n\n            if (x.domain()[0] === x.domain()[1])\n                x.domain()[0] ?\n                    x.domain([x.domain()[0] - x.domain()[0] * 0.01, x.domain()[1] + x.domain()[1] * 0.01])\n                    : x.domain([-1,1]);\n\n            if (y.domain()[0] === y.domain()[1])\n                y.domain()[0] ?\n                    y.domain([y.domain()[0] - y.domain()[0] * 0.01, y.domain()[1] + y.domain()[1] * 0.01])\n                    : y.domain([-1,1]);\n\n            if ( isNaN(x.domain()[0])) {\n                x.domain([-1,1]);\n            }\n\n            if ( isNaN(y.domain()[0])) {\n                y.domain([-1,1]);\n            }\n\n            x0 = x0 || x;\n            y0 = y0 || y;\n            z0 = z0 || z;\n\n            var scaleDiff = x(1) !== x0(1) || y(1) !== y0(1) || z(1) !== z0(1);\n\n            width0 = width0 || width;\n            height0 = height0 || height;\n\n            var sizeDiff = width0 !== width || height0 !== height;\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-scatter').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatter nv-chart-' + id);\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            wrap.classed('nv-single-point', singlePoint);\n            gEnter.append('g').attr('class', 'nv-groups');\n            gEnter.append('g').attr('class', 'nv-point-paths');\n            wrapEnter.append('g').attr('class', 'nv-point-clips');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-edge-clip-' + id)\n                .append('rect')\n                .attr('transform', 'translate( -10, -10)');\n                \n            wrap.select('#nv-edge-clip-' + id + ' rect')\n                .attr('width', availableWidth + 20)\n                .attr('height', (availableHeight > 0) ? availableHeight + 20 : 0);\n\n            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');\n\n            function updateInteractiveLayer() {\n                // Always clear needs-update flag regardless of whether or not\n                // we will actually do anything (avoids needless invocations).\n                needsUpdate = false;\n\n                if (!interactive) return false;\n\n                // inject series and point index for reference into voronoi\n                if (useVoronoi === true) {\n                    var vertices = d3.merge(data.map(function(group, groupIndex) {\n                            return group.values\n                                .map(function(point, pointIndex) {\n                                    // *Adding noise to make duplicates very unlikely\n                                    // *Injecting series and point index for reference\n                                    /* *Adding a 'jitter' to the points, because there's an issue in d3.geom.voronoi.\n                                     */\n                                    var pX = getX(point,pointIndex);\n                                    var pY = getY(point,pointIndex);\n\n                                    return [nv.utils.NaNtoZero(x(pX))+ Math.random() * 1e-4,\n                                            nv.utils.NaNtoZero(y(pY))+ Math.random() * 1e-4,\n                                        groupIndex,\n                                        pointIndex, point]; //temp hack to add noise until I think of a better way so there are no duplicates\n                                })\n                                .filter(function(pointArray, pointIndex) {\n                                    return pointActive(pointArray[4], pointIndex); // Issue #237.. move filter to after map, so pointIndex is correct!\n                                })\n                        })\n                    );\n\n                    if (vertices.length == 0) return false;  // No active points, we're done\n                    if (vertices.length < 3) {\n                        // Issue #283 - Adding 2 dummy points to the voronoi b/c voronoi requires min 3 points to work\n                        vertices.push([x.range()[0] - 20, y.range()[0] - 20, null, null]);\n                        vertices.push([x.range()[1] + 20, y.range()[1] + 20, null, null]);\n                        vertices.push([x.range()[0] - 20, y.range()[0] + 20, null, null]);\n                        vertices.push([x.range()[1] + 20, y.range()[1] - 20, null, null]);\n                    }\n\n                    // keep voronoi sections from going more than 10 outside of graph\n                    // to avoid overlap with other things like legend etc\n                    var bounds = d3.geom.polygon([\n                        [-10,-10],\n                        [-10,height + 10],\n                        [width + 10,height + 10],\n                        [width + 10,-10]\n                    ]);\n\n                    var voronoi = d3.geom.voronoi(vertices).map(function(d, i) {\n                        return {\n                            'data': bounds.clip(d),\n                            'series': vertices[i][2],\n                            'point': vertices[i][3]\n                        }\n                    });\n\n                    // nuke all voronoi paths on reload and recreate them\n                    wrap.select('.nv-point-paths').selectAll('path').remove();\n                    var pointPaths = wrap.select('.nv-point-paths').selectAll('path').data(voronoi);\n                    var vPointPaths = pointPaths\n                        .enter().append(\"svg:path\")\n                        .attr(\"d\", function(d) {\n                            if (!d || !d.data || d.data.length === 0)\n                                return 'M 0 0';\n                            else\n                                return \"M\" + d.data.join(\",\") + \"Z\";\n                        })\n                        .attr(\"id\", function(d,i) {\n                            return \"nv-path-\"+i; })\n                        .attr(\"clip-path\", function(d,i) { return \"url(#nv-clip-\"+id+\"-\"+i+\")\"; })\n                        ;\n\n                    // good for debugging point hover issues\n                    if (showVoronoi) {\n                        vPointPaths.style(\"fill\", d3.rgb(230, 230, 230))\n                            .style('fill-opacity', 0.4)\n                            .style('stroke-opacity', 1)\n                            .style(\"stroke\", d3.rgb(200,200,200));\n                    }\n\n                    if (clipVoronoi) {\n                        // voronoi sections are already set to clip,\n                        // just create the circles with the IDs they expect\n                        wrap.select('.nv-point-clips').selectAll('*').remove(); // must do * since it has sub-dom\n                        var pointClips = wrap.select('.nv-point-clips').selectAll('clipPath').data(vertices);\n                        var vPointClips = pointClips\n                            .enter().append(\"svg:clipPath\")\n                            .attr(\"id\", function(d, i) { return \"nv-clip-\"+id+\"-\"+i;})\n                            .append(\"svg:circle\")\n                            .attr('cx', function(d) { return d[0]; })\n                            .attr('cy', function(d) { return d[1]; })\n                            .attr('r', clipRadius);\n                    }\n\n                    var mouseEventCallback = function(el, d, mDispatch) {\n                        if (needsUpdate) return 0;\n                        var series = data[d.series];\n                        if (series === undefined) return;\n                        var point  = series.values[d.point];\n                        point['color'] = color(series, d.series);\n\n                        // standardize attributes for tooltip.\n                        point['x'] = getX(point);\n                        point['y'] = getY(point);\n\n                        // can't just get box of event node since it's actually a voronoi polygon\n                        var box = container.node().getBoundingClientRect();\n                        var scrollTop  = window.pageYOffset || document.documentElement.scrollTop;\n                        var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;\n\n                        var pos = {\n                            left: x(getX(point, d.point)) + box.left + scrollLeft + margin.left + 10,\n                            top: y(getY(point, d.point)) + box.top + scrollTop + margin.top + 10\n                        };\n\n                        mDispatch({\n                            point: point,\n                            series: series,\n                            pos: pos,\n                            relativePos: [x(getX(point, d.point)) + margin.left, y(getY(point, d.point)) + margin.top],\n                            seriesIndex: d.series,\n                            pointIndex: d.point,\n                            event: d3.event,\n                            element: el\n                        });\n                    };\n\n                    pointPaths\n                        .on('click', function(d) {\n                            mouseEventCallback(this, d, dispatch.elementClick);\n                        })\n                        .on('dblclick', function(d) {\n                            mouseEventCallback(this, d, dispatch.elementDblClick);\n                        })\n                        .on('mouseover', function(d) {\n                            mouseEventCallback(this, d, dispatch.elementMouseover);\n                        })\n                        .on('mouseout', function(d, i) {\n                            mouseEventCallback(this, d, dispatch.elementMouseout);\n                        });\n\n                } else {\n                    // add event handlers to points instead voronoi paths\n                    wrap.select('.nv-groups').selectAll('.nv-group')\n                        .selectAll('.nv-point')\n                        //.data(dataWithPoints)\n                        //.style('pointer-events', 'auto') // recativate events, disabled by css\n                        .on('click', function(d,i) {\n                            //nv.log('test', d, i);\n                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n                            var series = data[d.series],\n                                point  = series.values[i];\n                            var element = this;\n                            dispatch.elementClick({\n                                point: point,\n                                series: series,\n                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top], //TODO: make this pos base on the page\n                                relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],\n                                seriesIndex: d.series,\n                                pointIndex: i,\n                                event: d3.event,\n                                element: element\n                            });\n                        })\n                        .on('dblclick', function(d,i) {\n                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n                            var series = data[d.series],\n                                point  = series.values[i];\n\n                            dispatch.elementDblClick({\n                                point: point,\n                                series: series,\n                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],//TODO: make this pos base on the page\n                                relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],\n                                seriesIndex: d.series,\n                                pointIndex: i\n                            });\n                        })\n                        .on('mouseover', function(d,i) {\n                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n                            var series = data[d.series],\n                                point  = series.values[i];\n\n                            dispatch.elementMouseover({\n                                point: point,\n                                series: series,\n                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],//TODO: make this pos base on the page\n                                relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],\n                                seriesIndex: d.series,\n                                pointIndex: i,\n                                color: color(d, i)\n                            });\n                        })\n                        .on('mouseout', function(d,i) {\n                            if (needsUpdate || !data[d.series]) return 0; //check if this is a dummy point\n                            var series = data[d.series],\n                                point  = series.values[i];\n\n                            dispatch.elementMouseout({\n                                point: point,\n                                series: series,\n                                pos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],//TODO: make this pos base on the page\n                                relativePos: [x(getX(point, i)) + margin.left, y(getY(point, i)) + margin.top],\n                                seriesIndex: d.series,\n                                pointIndex: i,\n                                color: color(d, i)\n                            });\n                        });\n                }\n            }\n\n            needsUpdate = true;\n            var groups = wrap.select('.nv-groups').selectAll('.nv-group')\n                .data(function(d) { return d }, function(d) { return d.key });\n            groups.enter().append('g')\n                .style('stroke-opacity', 1e-6)\n                .style('fill-opacity', 1e-6);\n            groups.exit()\n                .remove();\n            groups\n                .attr('class', function(d,i) {\n                    return (d.classed || '') + ' nv-group nv-series-' + i;\n                })\n                .classed('nv-noninteractive', !interactive)\n                .classed('hover', function(d) { return d.hover });\n            groups.watchTransition(renderWatch, 'scatter: groups')\n                .style('fill', function(d,i) { return color(d, i) })\n                .style('stroke', function(d,i) { return d.pointBorderColor || pointBorderColor || color(d, i) })\n                .style('stroke-opacity', 1)\n                .style('fill-opacity', .5);\n\n            // create the points, maintaining their IDs from the original data set\n            var points = groups.selectAll('path.nv-point')\n                .data(function(d) {\n                    return d.values.map(\n                        function (point, pointIndex) {\n                            return [point, pointIndex]\n                        }).filter(\n                            function(pointArray, pointIndex) {\n                                return pointActive(pointArray[0], pointIndex)\n                            })\n                    });\n            points.enter().append('path')\n                .attr('class', function (d) {\n                    return 'nv-point nv-point-' + d[1];\n                })\n                .style('fill', function (d) { return d.color })\n                .style('stroke', function (d) { return d.color })\n                .attr('transform', function(d) {\n                    return 'translate(' + nv.utils.NaNtoZero(x0(getX(d[0],d[1]))) + ',' + nv.utils.NaNtoZero(y0(getY(d[0],d[1]))) + ')'\n                })\n                .attr('d',\n                    nv.utils.symbol()\n                    .type(function(d) { return getShape(d[0]); })\n                    .size(function(d) { return z(getSize(d[0],d[1])) })\n            );\n            points.exit().each(delCache).remove();\n            groups.exit().selectAll('path.nv-point')\n                .watchTransition(renderWatch, 'scatter exit')\n                .attr('transform', function(d) {\n                    return 'translate(' + nv.utils.NaNtoZero(x(getX(d[0],d[1]))) + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')'\n                })\n                .remove();\n            // Update points position only if \"x\" or \"y\" have changed\n            points.filter(function (d) { return scaleDiff || sizeDiff || getDiffs(d, 'x', getX, 'y', getY); })\n                .watchTransition(renderWatch, 'scatter points')\n                .attr('transform', function(d) {\n                    //nv.log(d, getX(d[0],d[1]), x(getX(d[0],d[1])));\n                    return 'translate(' + nv.utils.NaNtoZero(x(getX(d[0],d[1]))) + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')'\n                });\n            // Update points appearance only if \"shape\" or \"size\" have changed\n            points.filter(function (d) { return scaleDiff || sizeDiff || getDiffs(d, 'shape', getShape, 'size', getSize); })\n                .watchTransition(renderWatch, 'scatter points')\n                .attr('d',\n                    nv.utils.symbol()\n                    .type(function(d) { return getShape(d[0]); })\n                    .size(function(d) { return z(getSize(d[0],d[1])) })\n            );\n\n            // add label a label to scatter chart\n            if(showLabels)\n            {\n                var titles =  groups.selectAll('.nv-label')\n                    .data(function(d) {\n                        return d.values.map(\n                            function (point, pointIndex) {\n                                return [point, pointIndex]\n                            }).filter(\n                                function(pointArray, pointIndex) {\n                                    return pointActive(pointArray[0], pointIndex)\n                                })\n                        });\n\n                titles.enter().append('text')\n                    .style('fill', function (d,i) {\n                        return d.color })\n                    .style('stroke-opacity', 0)\n                    .style('fill-opacity', 1)\n                    .attr('transform', function(d) {\n                        var dx = nv.utils.NaNtoZero(x0(getX(d[0],d[1]))) + Math.sqrt(z(getSize(d[0],d[1]))/Math.PI) + 2;\n                        return 'translate(' + dx + ',' + nv.utils.NaNtoZero(y0(getY(d[0],d[1]))) + ')';\n                    })\n                    .text(function(d,i){\n                        return d[0].label;});\n\n                titles.exit().remove();\n                groups.exit().selectAll('path.nv-label')\n                    .watchTransition(renderWatch, 'scatter exit')\n                    .attr('transform', function(d) {\n                        var dx = nv.utils.NaNtoZero(x(getX(d[0],d[1])))+ Math.sqrt(z(getSize(d[0],d[1]))/Math.PI)+2;\n                        return 'translate(' + dx + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')';\n                    })\n                    .remove();\n               titles.each(function(d) {\n                  d3.select(this)\n                    .classed('nv-label', true)\n                    .classed('nv-label-' + d[1], false)\n                    .classed('hover',false);\n                });\n                titles.watchTransition(renderWatch, 'scatter labels')\n                    .attr('transform', function(d) {\n                        var dx = nv.utils.NaNtoZero(x(getX(d[0],d[1])))+ Math.sqrt(z(getSize(d[0],d[1]))/Math.PI)+2;\n                        return 'translate(' + dx + ',' + nv.utils.NaNtoZero(y(getY(d[0],d[1]))) + ')'\n                    });\n            }\n\n            // Delay updating the invisible interactive layer for smoother animation\n            if( interactiveUpdateDelay )\n            {\n                clearTimeout(timeoutID); // stop repeat calls to updateInteractiveLayer\n                timeoutID = setTimeout(updateInteractiveLayer, interactiveUpdateDelay );\n            }\n            else\n            {\n                updateInteractiveLayer();\n            }\n\n            //store old scales for use in transitions on update\n            x0 = x.copy();\n            y0 = y.copy();\n            z0 = z.copy();\n\n            width0 = width;\n            height0 = height;\n\n        });\n        renderWatch.renderEnd('scatter immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    // utility function calls provided by this chart\n    chart._calls = new function() {\n        this.clearHighlights = function () {\n            nv.dom.write(function() {\n                container.selectAll(\".nv-point.hover\").classed(\"hover\", false);\n            });\n            return null;\n        };\n        this.highlightPoint = function (seriesIndex, pointIndex, isHoverOver) {\n            nv.dom.write(function() {\n                container.select('.nv-groups')\n                  .selectAll(\".nv-series-\" + seriesIndex)\n                  .selectAll(\".nv-point-\" + pointIndex)\n                  .classed(\"hover\", isHoverOver);\n            });\n        };\n    };\n\n    // trigger calls from events too\n    dispatch.on('elementMouseover.point', function(d) {\n        if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,true);\n    });\n\n    dispatch.on('elementMouseout.point', function(d) {\n        if (interactive) chart._calls.highlightPoint(d.seriesIndex,d.pointIndex,false);\n    });\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:        {get: function(){return width;}, set: function(_){width=_;}},\n        height:       {get: function(){return height;}, set: function(_){height=_;}},\n        xScale:       {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:       {get: function(){return y;}, set: function(_){y=_;}},\n        pointScale:   {get: function(){return z;}, set: function(_){z=_;}},\n        xDomain:      {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain:      {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        pointDomain:  {get: function(){return sizeDomain;}, set: function(_){sizeDomain=_;}},\n        xRange:       {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:       {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        pointRange:   {get: function(){return sizeRange;}, set: function(_){sizeRange=_;}},\n        forceX:       {get: function(){return forceX;}, set: function(_){forceX=_;}},\n        forceY:       {get: function(){return forceY;}, set: function(_){forceY=_;}},\n        forcePoint:   {get: function(){return forceSize;}, set: function(_){forceSize=_;}},\n        interactive:  {get: function(){return interactive;}, set: function(_){interactive=_;}},\n        pointActive:  {get: function(){return pointActive;}, set: function(_){pointActive=_;}},\n        padDataOuter: {get: function(){return padDataOuter;}, set: function(_){padDataOuter=_;}},\n        padData:      {get: function(){return padData;}, set: function(_){padData=_;}},\n        clipEdge:     {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n        clipVoronoi:  {get: function(){return clipVoronoi;}, set: function(_){clipVoronoi=_;}},\n        clipRadius:   {get: function(){return clipRadius;}, set: function(_){clipRadius=_;}},\n        showVoronoi:   {get: function(){return showVoronoi;}, set: function(_){showVoronoi=_;}},\n        id:           {get: function(){return id;}, set: function(_){id=_;}},\n        interactiveUpdateDelay: {get:function(){return interactiveUpdateDelay;}, set: function(_){interactiveUpdateDelay=_;}},\n        showLabels: {get: function(){return showLabels;}, set: function(_){ showLabels = _;}},\n        pointBorderColor: {get: function(){return pointBorderColor;}, set: function(_){pointBorderColor=_;}},\n\n        // simple functor options\n        x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},\n        y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},\n        pointSize: {get: function(){return getSize;}, set: function(_){getSize = d3.functor(_);}},\n        pointShape: {get: function(){return getShape;}, set: function(_){getShape = d3.functor(_);}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n        }},\n        color: {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        useVoronoi: {get: function(){return useVoronoi;}, set: function(_){\n            useVoronoi = _;\n            if (useVoronoi === false) {\n                clipVoronoi = false;\n            }\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    return chart;\n};\n\nnv.models.scatterChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var scatter      = nv.models.scatter()\n        , xAxis        = nv.models.axis()\n        , yAxis        = nv.models.axis()\n        , legend       = nv.models.legend()\n        , distX        = nv.models.distribution()\n        , distY        = nv.models.distribution()\n        , tooltip      = nv.models.tooltip()\n        ;\n\n    var margin       = {top: 30, right: 20, bottom: 50, left: 75}\n        , marginTop = null\n        , width        = null\n        , height       = null\n        , container    = null\n        , color        = nv.utils.defaultColor()\n        , x            = scatter.xScale()\n        , y            = scatter.yScale()\n        , showDistX    = false\n        , showDistY    = false\n        , showLegend   = true\n        , showXAxis    = true\n        , showYAxis    = true\n        , rightAlignYAxis = false\n        , state = nv.utils.state()\n        , defaultState = null\n        , dispatch = d3.dispatch('stateChange', 'changeState', 'renderEnd')\n        , noData       = null\n        , duration = 250\n        , showLabels    = false\n        ;\n\n    scatter.xScale(x).yScale(y);\n    xAxis.orient('bottom').tickPadding(10);\n    yAxis\n        .orient((rightAlignYAxis) ? 'right' : 'left')\n        .tickPadding(10)\n    ;\n    distX.axis('x');\n    distY.axis('y');\n    tooltip\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        })\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        });\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var x0, y0\n        , renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled })\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        }\n    };\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(scatter);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n        if (showDistX) renderWatch.models(distX);\n        if (showDistY) renderWatch.models(distY);\n\n        selection.each(function(data) {\n            var that = this;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() {\n                if (duration === 0)\n                    container.call(chart);\n                else\n                    container.transition().duration(duration).call(chart);\n            };\n            chart.container = this;\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disableddisabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display noData message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container);\n                renderWatch.renderEnd('scatter immediate');\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            // Setup Scales\n            x = scatter.xScale();\n            y = scatter.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-scatterChart').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-scatterChart nv-chart-' + scatter.id());\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            // background for pointer events\n            gEnter.append('rect').attr('class', 'nvd3 nv-background').style(\"pointer-events\",\"none\");\n\n            gEnter.append('g').attr('class', 'nv-x nv-axis');\n            gEnter.append('g').attr('class', 'nv-y nv-axis');\n            gEnter.append('g').attr('class', 'nv-scatterWrap');\n            gEnter.append('g').attr('class', 'nv-regressionLinesWrap');\n            gEnter.append('g').attr('class', 'nv-distWrap');\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                var legendWidth = availableWidth;\n                legend.width(legendWidth);\n\n                wrap.select('.nv-legendWrap')\n                    .datum(data)\n                    .call(legend);\n\n                if (!marginTop && legend.height() !== margin.top) {\n                    margin.top = legend.height();\n                    availableHeight = nv.utils.availableHeight(height, container, margin);\n                }\n\n                wrap.select('.nv-legendWrap')\n                    .attr('transform', 'translate(0' + ',' + (-margin.top) +')');\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            // Main Chart Component(s)\n            scatter\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    d.color = d.color || color(d, i);\n                    return d.color;\n                }).filter(function(d,i) { return !data[i].disabled }))\n                .showLabels(showLabels);\n\n            wrap.select('.nv-scatterWrap')\n                .datum(data.filter(function(d) { return !d.disabled }))\n                .call(scatter);\n\n\n            wrap.select('.nv-regressionLinesWrap')\n                .attr('clip-path', 'url(#nv-edge-clip-' + scatter.id() + ')');\n\n            var regWrap = wrap.select('.nv-regressionLinesWrap').selectAll('.nv-regLines')\n                .data(function (d) {\n                    return d;\n                });\n\n            regWrap.enter().append('g').attr('class', 'nv-regLines');\n\n            var regLine = regWrap.selectAll('.nv-regLine')\n                .data(function (d) {\n                    return [d]\n                });\n\n            regLine.enter()\n                .append('line').attr('class', 'nv-regLine')\n                .style('stroke-opacity', 0);\n\n            // don't add lines unless we have slope and intercept to use\n            regLine.filter(function(d) {\n                return d.intercept && d.slope;\n            })\n                .watchTransition(renderWatch, 'scatterPlusLineChart: regline')\n                .attr('x1', x.range()[0])\n                .attr('x2', x.range()[1])\n                .attr('y1', function (d, i) {\n                    return y(x.domain()[0] * d.slope + d.intercept)\n                })\n                .attr('y2', function (d, i) {\n                    return y(x.domain()[1] * d.slope + d.intercept)\n                })\n                .style('stroke', function (d, i, j) {\n                    return color(d, j)\n                })\n                .style('stroke-opacity', function (d, i) {\n                    return (d.disabled || typeof d.slope === 'undefined' || typeof d.intercept === 'undefined') ? 0 : 1\n                });\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis\n                    .scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize( -availableHeight , 0);\n\n                g.select('.nv-x.nv-axis')\n                    .attr('transform', 'translate(0,' + y.range()[0] + ')')\n                    .call(xAxis);\n            }\n\n            if (showYAxis) {\n                yAxis\n                    .scale(y)\n                    ._ticks( nv.utils.calcTicksY(availableHeight/36, data) )\n                    .tickSize( -availableWidth, 0);\n\n                g.select('.nv-y.nv-axis')\n                    .call(yAxis);\n            }\n\n            // Setup Distribution\n            if (showDistX) {\n                distX\n                    .getData(scatter.x())\n                    .scale(x)\n                    .width(availableWidth)\n                    .color(data.map(function(d,i) {\n                        return d.color || color(d, i);\n                    }).filter(function(d,i) { return !data[i].disabled }));\n                gEnter.select('.nv-distWrap').append('g')\n                    .attr('class', 'nv-distributionX');\n                g.select('.nv-distributionX')\n                    .attr('transform', 'translate(0,' + y.range()[0] + ')')\n                    .datum(data.filter(function(d) { return !d.disabled }))\n                    .call(distX);\n            }\n\n            if (showDistY) {\n                distY\n                    .getData(scatter.y())\n                    .scale(y)\n                    .width(availableHeight)\n                    .color(data.map(function(d,i) {\n                        return d.color || color(d, i);\n                    }).filter(function(d,i) { return !data[i].disabled }));\n                gEnter.select('.nv-distWrap').append('g')\n                    .attr('class', 'nv-distributionY');\n                g.select('.nv-distributionY')\n                    .attr('transform', 'translate(' + (rightAlignYAxis ? availableWidth : -distY.size() ) + ',0)')\n                    .datum(data.filter(function(d) { return !d.disabled }))\n                    .call(distY);\n            }\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n                if (typeof e.disabled !== 'undefined') {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n                    state.disabled = e.disabled;\n                }\n                chart.update();\n            });\n\n            // mouseover needs availableHeight so we just keep scatter mouse events inside the chart block\n            scatter.dispatch.on('elementMouseout.tooltip', function(evt) {\n                tooltip.hidden(true);\n                container.select('.nv-chart-' + scatter.id() + ' .nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)\n                    .attr('y1', 0);\n                container.select('.nv-chart-' + scatter.id() + ' .nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)\n                    .attr('x2', distY.size());\n            });\n\n            scatter.dispatch.on('elementMouseover.tooltip', function(evt) {\n                container.select('.nv-series-' + evt.seriesIndex + ' .nv-distx-' + evt.pointIndex)\n                    .attr('y1', evt.relativePos[1] - availableHeight);\n                container.select('.nv-series-' + evt.seriesIndex + ' .nv-disty-' + evt.pointIndex)\n                    .attr('x2', evt.relativePos[0] + distX.size());\n                tooltip.data(evt).hidden(false);\n            });\n\n            //store old scales for use in transitions on update\n            x0 = x.copy();\n            y0 = y.copy();\n\n        });\n\n        renderWatch.renderEnd('scatter with line immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.scatter = scatter;\n    chart.legend = legend;\n    chart.xAxis = xAxis;\n    chart.yAxis = yAxis;\n    chart.distX = distX;\n    chart.distY = distY;\n    chart.tooltip = tooltip;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        container:  {get: function(){return container;}, set: function(_){container=_;}},\n        showDistX:  {get: function(){return showDistX;}, set: function(_){showDistX=_;}},\n        showDistY:  {get: function(){return showDistY;}, set: function(_){showDistY=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        showXAxis:  {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:  {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        defaultState:     {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:     {get: function(){return noData;}, set: function(_){noData=_;}},\n        duration:   {get: function(){return duration;}, set: function(_){duration=_;}},\n        showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( (_) ? 'right' : 'left');\n        }},\n        color: {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n            distX.color(color);\n            distY.color(color);\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, scatter);\n    nv.utils.initOptions(chart);\n    return chart;\n};\n\nnv.models.sparkline = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 2, right: 0, bottom: 2, left: 0}\n        , width = 400\n        , height = 32\n        , container = null\n        , animate = true\n        , x = d3.scale.linear()\n        , y = d3.scale.linear()\n        , getX = function(d) { return d.x }\n        , getY = function(d) { return d.y }\n        , color = nv.utils.getColor(['#000'])\n        , xDomain\n        , yDomain\n        , xRange\n        , yRange\n        , showMinMaxPoints = true\n        , showCurrentPoint = true\n        , dispatch = d3.dispatch('renderEnd')\n        ;\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n    \n    function chart(selection) {\n        renderWatch.reset();\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            // Setup Scales\n            x   .domain(xDomain || d3.extent(data, getX ))\n                .range(xRange || [0, availableWidth]);\n\n            y   .domain(yDomain || d3.extent(data, getY ))\n                .range(yRange || [availableHeight, 0]);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-sparkline').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparkline');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')\n\n            var paths = wrap.selectAll('path')\n                .data(function(d) { return [d] });\n            paths.enter().append('path');\n            paths.exit().remove();\n            paths\n                .style('stroke', function(d,i) { return d.color || color(d, i) })\n                .attr('d', d3.svg.line()\n                    .x(function(d,i) { return x(getX(d,i)) })\n                    .y(function(d,i) { return y(getY(d,i)) })\n            );\n\n            // TODO: Add CURRENT data point (Need Min, Mac, Current / Most recent)\n            var points = wrap.selectAll('circle.nv-point')\n                .data(function(data) {\n                    var yValues = data.map(function(d, i) { return getY(d,i); });\n                    function pointIndex(index) {\n                        if (index != -1) {\n                            var result = data[index];\n                            result.pointIndex = index;\n                            return result;\n                        } else {\n                            return null;\n                        }\n                    }\n                    var maxPoint = pointIndex(yValues.lastIndexOf(y.domain()[1])),\n                        minPoint = pointIndex(yValues.indexOf(y.domain()[0])),\n                        currentPoint = pointIndex(yValues.length - 1);\n                    return [(showMinMaxPoints ? minPoint : null), (showMinMaxPoints ? maxPoint : null), (showCurrentPoint ? currentPoint : null)].filter(function (d) {return d != null;});\n                });\n            points.enter().append('circle');\n            points.exit().remove();\n            points\n                .attr('cx', function(d,i) { return x(getX(d,d.pointIndex)) })\n                .attr('cy', function(d,i) { return y(getY(d,d.pointIndex)) })\n                .attr('r', 2)\n                .attr('class', function(d,i) {\n                    return getX(d, d.pointIndex) == x.domain()[1] ? 'nv-point nv-currentValue' :\n                            getY(d, d.pointIndex) == y.domain()[0] ? 'nv-point nv-minValue' : 'nv-point nv-maxValue'\n                });\n        });\n        \n        renderWatch.renderEnd('sparkline immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:            {get: function(){return width;}, set: function(_){width=_;}},\n        height:           {get: function(){return height;}, set: function(_){height=_;}},\n        xDomain:          {get: function(){return xDomain;}, set: function(_){xDomain=_;}},\n        yDomain:          {get: function(){return yDomain;}, set: function(_){yDomain=_;}},\n        xRange:           {get: function(){return xRange;}, set: function(_){xRange=_;}},\n        yRange:           {get: function(){return yRange;}, set: function(_){yRange=_;}},\n        xScale:           {get: function(){return x;}, set: function(_){x=_;}},\n        yScale:           {get: function(){return y;}, set: function(_){y=_;}},\n        animate:          {get: function(){return animate;}, set: function(_){animate=_;}},\n        showMinMaxPoints: {get: function(){return showMinMaxPoints;}, set: function(_){showMinMaxPoints=_;}},\n        showCurrentPoint: {get: function(){return showCurrentPoint;}, set: function(_){showCurrentPoint=_;}},\n\n        //functor options\n        x: {get: function(){return getX;}, set: function(_){getX=d3.functor(_);}},\n        y: {get: function(){return getY;}, set: function(_){getY=d3.functor(_);}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }}\n    });\n\n    chart.dispatch = dispatch;\n    nv.utils.initOptions(chart);\n    return chart;\n};\n\nnv.models.sparklinePlus = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var sparkline = nv.models.sparkline();\n\n    var margin = {top: 15, right: 100, bottom: 10, left: 50}\n        , width = null\n        , height = null\n        , x\n        , y\n        , index = []\n        , paused = false\n        , xTickFormat = d3.format(',r')\n        , yTickFormat = d3.format(',.2f')\n        , showLastValue = true\n        , alignValue = true\n        , rightAlignValue = false\n        , noData = null\n        , dispatch = d3.dispatch('renderEnd')\n        ;\n        \n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(sparkline);\n        selection.each(function(data) {\n            var container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() { container.call(chart); };\n            chart.container = this;\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            var currentValue = sparkline.y()(data[data.length-1], data.length-1);\n\n            // Setup Scales\n            x = sparkline.xScale();\n            y = sparkline.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-sparklineplus').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-sparklineplus');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-sparklineWrap');\n            gEnter.append('g').attr('class', 'nv-valueWrap');\n            gEnter.append('g').attr('class', 'nv-hoverArea');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            // Main Chart Component(s)\n            var sparklineWrap = g.select('.nv-sparklineWrap');\n\n            sparkline.width(availableWidth).height(availableHeight);\n            sparklineWrap.call(sparkline);\n\n            if (showLastValue) {\n                var valueWrap = g.select('.nv-valueWrap');\n                var value = valueWrap.selectAll('.nv-currentValue')\n                    .data([currentValue]);\n\n                value.enter().append('text').attr('class', 'nv-currentValue')\n                    .attr('dx', rightAlignValue ? -8 : 8)\n                    .attr('dy', '.9em')\n                    .style('text-anchor', rightAlignValue ? 'end' : 'start');\n\n                value\n                    .attr('x', availableWidth + (rightAlignValue ? margin.right : 0))\n                    .attr('y', alignValue ? function (d) {\n                        return y(d)\n                    } : 0)\n                    .style('fill', sparkline.color()(data[data.length - 1], data.length - 1))\n                    .text(yTickFormat(currentValue));\n            }\n\n            gEnter.select('.nv-hoverArea').append('rect')\n                .on('mousemove', sparklineHover)\n                .on('click', function() { paused = !paused })\n                .on('mouseout', function() { index = []; updateValueLine(); });\n\n            g.select('.nv-hoverArea rect')\n                .attr('transform', function(d) { return 'translate(' + -margin.left + ',' + -margin.top + ')' })\n                .attr('width', availableWidth + margin.left + margin.right)\n                .attr('height', availableHeight + margin.top);\n\n            //index is currently global (within the chart), may or may not keep it that way\n            function updateValueLine() {\n                if (paused) return;\n\n                var hoverValue = g.selectAll('.nv-hoverValue').data(index);\n\n                var hoverEnter = hoverValue.enter()\n                    .append('g').attr('class', 'nv-hoverValue')\n                    .style('stroke-opacity', 0)\n                    .style('fill-opacity', 0);\n\n                hoverValue.exit()\n                    .transition().duration(250)\n                    .style('stroke-opacity', 0)\n                    .style('fill-opacity', 0)\n                    .remove();\n\n                hoverValue\n                    .attr('transform', function(d) { return 'translate(' + x(sparkline.x()(data[d],d)) + ',0)' })\n                    .transition().duration(250)\n                    .style('stroke-opacity', 1)\n                    .style('fill-opacity', 1);\n\n                if (!index.length) return;\n\n                hoverEnter.append('line')\n                    .attr('x1', 0)\n                    .attr('y1', -margin.top)\n                    .attr('x2', 0)\n                    .attr('y2', availableHeight);\n\n                hoverEnter.append('text').attr('class', 'nv-xValue')\n                    .attr('x', -6)\n                    .attr('y', -margin.top)\n                    .attr('text-anchor', 'end')\n                    .attr('dy', '.9em');\n\n                g.select('.nv-hoverValue .nv-xValue')\n                    .text(xTickFormat(sparkline.x()(data[index[0]], index[0])));\n\n                hoverEnter.append('text').attr('class', 'nv-yValue')\n                    .attr('x', 6)\n                    .attr('y', -margin.top)\n                    .attr('text-anchor', 'start')\n                    .attr('dy', '.9em');\n\n                g.select('.nv-hoverValue .nv-yValue')\n                    .text(yTickFormat(sparkline.y()(data[index[0]], index[0])));\n            }\n\n            function sparklineHover() {\n                if (paused) return;\n\n                var pos = d3.mouse(this)[0] - margin.left;\n\n                function getClosestIndex(data, x) {\n                    var distance = Math.abs(sparkline.x()(data[0], 0) - x);\n                    var closestIndex = 0;\n                    for (var i = 0; i < data.length; i++){\n                        if (Math.abs(sparkline.x()(data[i], i) - x) < distance) {\n                            distance = Math.abs(sparkline.x()(data[i], i) - x);\n                            closestIndex = i;\n                        }\n                    }\n                    return closestIndex;\n                }\n\n                index = [getClosestIndex(data, Math.round(x.invert(pos)))];\n                updateValueLine();\n            }\n\n        });\n        renderWatch.renderEnd('sparklinePlus immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.sparkline = sparkline;\n\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:           {get: function(){return width;}, set: function(_){width=_;}},\n        height:          {get: function(){return height;}, set: function(_){height=_;}},\n        xTickFormat:     {get: function(){return xTickFormat;}, set: function(_){xTickFormat=_;}},\n        yTickFormat:     {get: function(){return yTickFormat;}, set: function(_){yTickFormat=_;}},\n        showLastValue:   {get: function(){return showLastValue;}, set: function(_){showLastValue=_;}},\n        alignValue:      {get: function(){return alignValue;}, set: function(_){alignValue=_;}},\n        rightAlignValue: {get: function(){return rightAlignValue;}, set: function(_){rightAlignValue=_;}},\n        noData:          {get: function(){return noData;}, set: function(_){noData=_;}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, sparkline);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.stackedArea = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 960\n        , height = 500\n        , color = nv.utils.defaultColor() // a function that computes the color\n        , id = Math.floor(Math.random() * 100000) //Create semi-unique ID incase user doesn't selet one\n        , container = null\n        , getX = function(d) { return d.x } // accessor to get the x value from a data point\n        , getY = function(d) { return d.y } // accessor to get the y value from a data point\n        , defined = function(d,i) { return !isNaN(getY(d,i)) && getY(d,i) !== null } // allows a line to be not continuous when it is not defined\n        , style = 'stack'\n        , offset = 'zero'\n        , order = 'default'\n        , interpolate = 'linear'  // controls the line interpolation\n        , clipEdge = false // if true, masks lines within x and y scale\n        , x //can be accessed via chart.xScale()\n        , y //can be accessed via chart.yScale()\n        , scatter = nv.models.scatter()\n        , duration = 250\n        , dispatch =  d3.dispatch('areaClick', 'areaMouseover', 'areaMouseout','renderEnd', 'elementClick', 'elementMouseover', 'elementMouseout')\n        ;\n\n    scatter\n        .pointSize(2.2) // default size\n        .pointDomain([2.2, 2.2]) // all the same size by default\n    ;\n\n    /************************************\n     * offset:\n     *   'wiggle' (stream)\n     *   'zero' (stacked)\n     *   'expand' (normalize to 100%)\n     *   'silhouette' (simple centered)\n     *\n     * order:\n     *   'inside-out' (stream)\n     *   'default' (input order)\n     ************************************/\n\n    var renderWatch = nv.utils.renderWatch(dispatch, duration);\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(scatter);\n        selection.each(function(data) {\n            var availableWidth = width - margin.left - margin.right,\n                availableHeight = height - margin.top - margin.bottom;\n\n            container = d3.select(this);\n            nv.utils.initSVG(container);\n\n            // Setup Scales\n            x = scatter.xScale();\n            y = scatter.yScale();\n\n            var dataRaw = data;\n            // Injecting point index into each point because d3.layout.stack().out does not give index\n            data.forEach(function(aseries, i) {\n                aseries.seriesIndex = i;\n                aseries.values = aseries.values.map(function(d, j) {\n                    d.index = j;\n                    d.seriesIndex = i;\n                    return d;\n                });\n            });\n\n            var dataFiltered = data.filter(function(series) {\n                return !series.disabled;\n            });\n\n            data = d3.layout.stack()\n                .order(order)\n                .offset(offset)\n                .values(function(d) { return d.values })  //TODO: make values customizeable in EVERY model in this fashion\n                .x(getX)\n                .y(getY)\n                .out(function(d, y0, y) {\n                    d.display = {\n                        y: y,\n                        y0: y0\n                    };\n                })\n            (dataFiltered);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-stackedarea').data([data]);\n            var wrapEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedarea');\n            var defsEnter = wrapEnter.append('defs');\n            var gEnter = wrapEnter.append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-areaWrap');\n            gEnter.append('g').attr('class', 'nv-scatterWrap');\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n            \n            // If the user has not specified forceY, make sure 0 is included in the domain\n            // Otherwise, use user-specified values for forceY\n            if (scatter.forceY().length == 0) {\n                scatter.forceY().push(0);\n            }\n            \n            scatter\n                .width(availableWidth)\n                .height(availableHeight)\n                .x(getX)\n                .y(function(d) {\n                    if (d.display !== undefined) { return d.display.y + d.display.y0; }\n                })\n                .color(data.map(function(d,i) {\n                    d.color = d.color || color(d, d.seriesIndex);\n                    return d.color;\n                }));\n\n            var scatterWrap = g.select('.nv-scatterWrap')\n                .datum(data);\n\n            scatterWrap.call(scatter);\n\n            defsEnter.append('clipPath')\n                .attr('id', 'nv-edge-clip-' + id)\n                .append('rect');\n\n            wrap.select('#nv-edge-clip-' + id + ' rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            g.attr('clip-path', clipEdge ? 'url(#nv-edge-clip-' + id + ')' : '');\n\n            var area = d3.svg.area()\n                .defined(defined)\n                .x(function(d,i)  { return x(getX(d,i)) })\n                .y0(function(d) {\n                    return y(d.display.y0)\n                })\n                .y1(function(d) {\n                    return y(d.display.y + d.display.y0)\n                })\n                .interpolate(interpolate);\n\n            var zeroArea = d3.svg.area()\n                .defined(defined)\n                .x(function(d,i)  { return x(getX(d,i)) })\n                .y0(function(d) { return y(d.display.y0) })\n                .y1(function(d) { return y(d.display.y0) });\n\n            var path = g.select('.nv-areaWrap').selectAll('path.nv-area')\n                .data(function(d) { return d });\n\n            path.enter().append('path').attr('class', function(d,i) { return 'nv-area nv-area-' + i })\n                .attr('d', function(d,i){\n                    return zeroArea(d.values, d.seriesIndex);\n                })\n                .on('mouseover', function(d,i) {\n                    d3.select(this).classed('hover', true);\n                    dispatch.areaMouseover({\n                        point: d,\n                        series: d.key,\n                        pos: [d3.event.pageX, d3.event.pageY],\n                        seriesIndex: d.seriesIndex\n                    });\n                })\n                .on('mouseout', function(d,i) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.areaMouseout({\n                        point: d,\n                        series: d.key,\n                        pos: [d3.event.pageX, d3.event.pageY],\n                        seriesIndex: d.seriesIndex\n                    });\n                })\n                .on('click', function(d,i) {\n                    d3.select(this).classed('hover', false);\n                    dispatch.areaClick({\n                        point: d,\n                        series: d.key,\n                        pos: [d3.event.pageX, d3.event.pageY],\n                        seriesIndex: d.seriesIndex\n                    });\n                });\n\n            path.exit().remove();\n            path.style('fill', function(d,i){\n                    return d.color || color(d, d.seriesIndex)\n                })\n                .style('stroke', function(d,i){ return d.color || color(d, d.seriesIndex) });\n            path.watchTransition(renderWatch,'stackedArea path')\n                .attr('d', function(d,i) {\n                    return area(d.values,i)\n                });\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            scatter.dispatch.on('elementMouseover.area', function(e) {\n                g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', true);\n            });\n            scatter.dispatch.on('elementMouseout.area', function(e) {\n                g.select('.nv-chart-' + id + ' .nv-area-' + e.seriesIndex).classed('hover', false);\n            });\n\n            //Special offset functions\n            chart.d3_stackedOffset_stackPercent = function(stackData) {\n                var n = stackData.length,    //How many series\n                    m = stackData[0].length,     //how many points per series\n                    i,\n                    j,\n                    o,\n                    y0 = [];\n\n                for (j = 0; j < m; ++j) { //Looping through all points\n                    for (i = 0, o = 0; i < dataRaw.length; i++) { //looping through all series\n                        o += getY(dataRaw[i].values[j]); //total y value of all series at a certian point in time.\n                    }\n\n                    if (o) for (i = 0; i < n; i++) { //(total y value of all series at point in time i) != 0\n                        stackData[i][j][1] /= o;\n                    } else { //(total y value of all series at point in time i) == 0\n                        for (i = 0; i < n; i++) {\n                            stackData[i][j][1] = 0;\n                        }\n                    }\n                }\n                for (j = 0; j < m; ++j) y0[j] = 0;\n                return y0;\n            };\n\n        });\n\n        renderWatch.renderEnd('stackedArea immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Global getters and setters\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.scatter = scatter;\n\n    scatter.dispatch.on('elementClick', function(){ dispatch.elementClick.apply(this, arguments); });\n    scatter.dispatch.on('elementMouseover', function(){ dispatch.elementMouseover.apply(this, arguments); });\n    scatter.dispatch.on('elementMouseout', function(){ dispatch.elementMouseout.apply(this, arguments); });\n\n    chart.interpolate = function(_) {\n        if (!arguments.length) return interpolate;\n        interpolate = _;\n        return chart;\n    };\n\n    chart.duration = function(_) {\n        if (!arguments.length) return duration;\n        duration = _;\n        renderWatch.reset(duration);\n        scatter.duration(duration);\n        return chart;\n    };\n\n    chart.dispatch = dispatch;\n    chart.scatter = scatter;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        defined: {get: function(){return defined;}, set: function(_){defined=_;}},\n        clipEdge: {get: function(){return clipEdge;}, set: function(_){clipEdge=_;}},\n        offset:      {get: function(){return offset;}, set: function(_){offset=_;}},\n        order:    {get: function(){return order;}, set: function(_){order=_;}},\n        interpolate:    {get: function(){return interpolate;}, set: function(_){interpolate=_;}},\n\n        // simple functor options\n        x:     {get: function(){return getX;}, set: function(_){getX = d3.functor(_);}},\n        y:     {get: function(){return getY;}, set: function(_){getY = d3.functor(_);}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n        }},\n        style: {get: function(){return style;}, set: function(_){\n            style = _;\n            switch (style) {\n                case 'stack':\n                    chart.offset('zero');\n                    chart.order('default');\n                    break;\n                case 'stream':\n                    chart.offset('wiggle');\n                    chart.order('inside-out');\n                    break;\n                case 'stream-center':\n                    chart.offset('silhouette');\n                    chart.order('inside-out');\n                    break;\n                case 'expand':\n                    chart.offset('expand');\n                    chart.order('default');\n                    break;\n                case 'stack_percent':\n                    chart.offset(chart.d3_stackedOffset_stackPercent);\n                    chart.order('default');\n                    break;\n            }\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            scatter.duration(duration);\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, scatter);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.stackedAreaChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var stacked = nv.models.stackedArea()\n        , xAxis = nv.models.axis()\n        , yAxis = nv.models.axis()\n        , legend = nv.models.legend()\n        , controls = nv.models.legend()\n        , interactiveLayer = nv.interactiveGuideline()\n        , tooltip = nv.models.tooltip()\n        , focus = nv.models.focus(nv.models.stackedArea())\n        ;\n\n    var margin = {top: 10, right: 25, bottom: 50, left: 60}\n        , marginTop = null\n        , width = null\n        , height = null\n        , color = nv.utils.defaultColor()\n        , showControls = true\n        , showLegend = true\n        , legendPosition = 'top'\n        , showXAxis = true\n        , showYAxis = true\n        , rightAlignYAxis = false\n        , focusEnable = false\n        , useInteractiveGuideline = false\n        , showTotalInTooltip = true\n        , totalLabel = 'TOTAL'\n        , x //can be accessed via chart.xScale()\n        , y //can be accessed via chart.yScale()\n        , state = nv.utils.state()\n        , defaultState = null\n        , noData = null\n        , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd')\n        , controlWidth = 250\n        , controlOptions = ['Stacked','Stream','Expanded']\n        , controlLabels = {}\n        , duration = 250\n        ;\n\n    state.style = stacked.style();\n    xAxis.orient('bottom').tickPadding(7);\n    yAxis.orient((rightAlignYAxis) ? 'right' : 'left');\n\n    tooltip\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        })\n        .valueFormatter(function(d, i) {\n            return yAxis.tickFormat()(d, i);\n        });\n\n    interactiveLayer.tooltip\n        .headerFormatter(function(d, i) {\n            return xAxis.tickFormat()(d, i);\n        })\n        .valueFormatter(function(d, i) {\n            return d == null ? \"N/A\" : yAxis.tickFormat()(d, i);\n        });\n\n    var oldYTickFormat = null,\n        oldValueFormatter = null;\n\n    controls.updateState(false);\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n    var style = stacked.style();\n\n    var stateGetter = function(data) {\n        return function(){\n            return {\n                active: data.map(function(d) { return !d.disabled }),\n                style: stacked.style()\n            };\n        }\n    };\n\n    var stateSetter = function(data) {\n        return function(state) {\n            if (state.style !== undefined)\n                style = state.style;\n            if (state.active !== undefined)\n                data.forEach(function(series,i) {\n                    series.disabled = !state.active[i];\n                });\n        }\n    };\n\n    var percentFormatter = d3.format('%');\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(stacked);\n        if (showXAxis) renderWatch.models(xAxis);\n        if (showYAxis) renderWatch.models(yAxis);\n\n        selection.each(function(data) {\n            var container = d3.select(this),\n                that = this;\n            nv.utils.initSVG(container);\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin),\n                availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);\n\n            chart.update = function() { container.transition().duration(duration).call(chart); };\n            chart.container = this;\n\n            state\n                .setter(stateSetter(data), chart.update)\n                .getter(stateGetter(data))\n                .update();\n\n            // DEPRECATED set state.disabled\n            state.disabled = data.map(function(d) { return !!d.disabled });\n\n            if (!defaultState) {\n                var key;\n                defaultState = {};\n                for (key in state) {\n                    if (state[key] instanceof Array)\n                        defaultState[key] = state[key].slice(0);\n                    else\n                        defaultState[key] = state[key];\n                }\n            }\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length || !data.filter(function(d) { return d.values.length }).length) {\n                nv.utils.noData(chart, container)\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n            // Setup Scales\n            x = stacked.xScale();\n            y = stacked.yScale();\n\n            // Setup containers and skeleton of chart\n            var wrap = container.selectAll('g.nv-wrap.nv-stackedAreaChart').data([data]);\n            var gEnter = wrap.enter().append('g').attr('class', 'nvd3 nv-wrap nv-stackedAreaChart').append('g');\n            var g = wrap.select('g');\n\n            gEnter.append('g').attr('class', 'nv-legendWrap');\n            gEnter.append('g').attr('class', 'nv-controlsWrap');\n\n            var focusEnter = gEnter.append('g').attr('class', 'nv-focus');\n            focusEnter.append('g').attr('class', 'nv-background').append('rect');\n            focusEnter.append('g').attr('class', 'nv-x nv-axis');\n            focusEnter.append('g').attr('class', 'nv-y nv-axis');\n            focusEnter.append('g').attr('class', 'nv-stackedWrap');\n            focusEnter.append('g').attr('class', 'nv-interactive');\n\n            // g.select(\"rect\").attr(\"width\",availableWidth).attr(\"height\",availableHeight);\n\n            var contextEnter = gEnter.append('g').attr('class', 'nv-focusWrap');\n\n            // Legend\n            if (!showLegend) {\n                g.select('.nv-legendWrap').selectAll('*').remove();\n            } else {\n                var legendWidth = (showControls && legendPosition === 'top') ? availableWidth - controlWidth : availableWidth;\n\n                legend.width(legendWidth);\n                g.select('.nv-legendWrap').datum(data).call(legend);\n\n                if (legendPosition === 'bottom') {\n                \t// constant from axis.js, plus some margin for better layout\n                \tvar xAxisHeight = (showXAxis ? 12 : 0) + 10;\n                   \tmargin.bottom = Math.max(legend.height() + xAxisHeight, margin.bottom);\n                   \tavailableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);\n                \tvar legendTop = availableHeight + xAxisHeight;\n                    g.select('.nv-legendWrap')\n                        .attr('transform', 'translate(0,' + legendTop +')');\n                } else if (legendPosition === 'top') {\n                    if (!marginTop && margin.top != legend.height()) {\n                        margin.top = legend.height();\n                        availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);\n                    }\n\n                    g.select('.nv-legendWrap')\n                    \t.attr('transform', 'translate(' + (availableWidth-legendWidth) + ',' + (-margin.top) +')');\n                }\n            }\n\n            // Controls\n            if (!showControls) {\n                 g.select('.nv-controlsWrap').selectAll('*').remove();\n            } else {\n                var controlsData = [\n                    {\n                        key: controlLabels.stacked || 'Stacked',\n                        metaKey: 'Stacked',\n                        disabled: stacked.style() != 'stack',\n                        style: 'stack'\n                    },\n                    {\n                        key: controlLabels.stream || 'Stream',\n                        metaKey: 'Stream',\n                        disabled: stacked.style() != 'stream',\n                        style: 'stream'\n                    },\n                    {\n                        key: controlLabels.expanded || 'Expanded',\n                        metaKey: 'Expanded',\n                        disabled: stacked.style() != 'expand',\n                        style: 'expand'\n                    },\n                    {\n                        key: controlLabels.stack_percent || 'Stack %',\n                        metaKey: 'Stack_Percent',\n                        disabled: stacked.style() != 'stack_percent',\n                        style: 'stack_percent'\n                    }\n                ];\n\n                controlWidth = (controlOptions.length/3) * 260;\n                controlsData = controlsData.filter(function(d) {\n                    return controlOptions.indexOf(d.metaKey) !== -1;\n                });\n\n                controls\n                    .width( controlWidth )\n                    .color(['#444', '#444', '#444']);\n\n                g.select('.nv-controlsWrap')\n                    .datum(controlsData)\n                    .call(controls);\n\n                var requiredTop = Math.max(controls.height(), showLegend && (legendPosition === 'top') ? legend.height() : 0);\n\n                if ( margin.top != requiredTop ) {\n                    margin.top = requiredTop;\n                    availableHeight = nv.utils.availableHeight(height, container, margin) - (focusEnable ? focus.height() : 0);\n                }\n\n                g.select('.nv-controlsWrap')\n                    .attr('transform', 'translate(0,' + (-margin.top) +')');\n            }\n\n            wrap.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');\n\n            if (rightAlignYAxis) {\n                g.select(\".nv-y.nv-axis\")\n                    .attr(\"transform\", \"translate(\" + availableWidth + \",0)\");\n            }\n\n            //Set up interactive layer\n            if (useInteractiveGuideline) {\n                interactiveLayer\n                    .width(availableWidth)\n                    .height(availableHeight)\n                    .margin({left: margin.left, top: margin.top})\n                    .svgContainer(container)\n                    .xScale(x);\n                wrap.select(\".nv-interactive\").call(interactiveLayer);\n            }\n\n            g.select('.nv-focus .nv-background rect')\n                .attr('width', availableWidth)\n                .attr('height', availableHeight);\n\n            stacked\n                .width(availableWidth)\n                .height(availableHeight)\n                .color(data.map(function(d,i) {\n                    return d.color || color(d, i);\n                }).filter(function(d,i) { return !data[i].disabled; }));\n\n            var stackedWrap = g.select('.nv-focus .nv-stackedWrap')\n                .datum(data.filter(function(d) { return !d.disabled; }));\n\n            // Setup Axes\n            if (showXAxis) {\n                xAxis.scale(x)\n                    ._ticks( nv.utils.calcTicksX(availableWidth/100, data) )\n                    .tickSize( -availableHeight, 0);\n            }\n\n            if (showYAxis) {\n                var ticks;\n                if (stacked.offset() === 'wiggle') {\n                    ticks = 0;\n                }\n                else {\n                    ticks = nv.utils.calcTicksY(availableHeight/36, data);\n                }\n                yAxis.scale(y)\n                    ._ticks(ticks)\n                    .tickSize(-availableWidth, 0);\n            }\n\n            //============================================================\n            // Update Axes\n            //============================================================\n            function updateXAxis() {\n                if(showXAxis) {\n                    g.select('.nv-focus .nv-x.nv-axis')\n                        .attr('transform', 'translate(0,' + availableHeight + ')')\n                        .transition()\n                        .duration(duration)\n                        .call(xAxis)\n                        ;\n                }\n            }\n\n            function updateYAxis() {\n                if(showYAxis) {\n                    if (stacked.style() === 'expand' || stacked.style() === 'stack_percent') {\n                        var currentFormat = yAxis.tickFormat();\n\n                        if ( !oldYTickFormat || currentFormat !== percentFormatter )\n                            oldYTickFormat = currentFormat;\n\n                        //Forces the yAxis to use percentage in 'expand' mode.\n                        yAxis.tickFormat(percentFormatter);\n                    }\n                    else {\n                        if (oldYTickFormat) {\n                            yAxis.tickFormat(oldYTickFormat);\n                            oldYTickFormat = null;\n                        }\n                    }\n\n                    g.select('.nv-focus .nv-y.nv-axis')\n                    .transition().duration(0)\n                    .call(yAxis);\n                }\n            }\n\n            //============================================================\n            // Update Focus\n            //============================================================\n            if(!focusEnable) {\n                stackedWrap.transition().call(stacked);\n                updateXAxis();\n                updateYAxis();\n            } else {\n                focus.width(availableWidth);\n                g.select('.nv-focusWrap')\n                    .attr('transform', 'translate(0,' + ( availableHeight + margin.bottom + focus.margin().top) + ')')\n                    .datum(data.filter(function(d) { return !d.disabled; }))\n                    .call(focus);\n                var extent = focus.brush.empty() ? focus.xDomain() : focus.brush.extent();\n                if(extent !== null){\n                    onBrush(extent);\n                }\n            }\n\n            //============================================================\n            // Event Handling/Dispatching (in chart's scope)\n            //------------------------------------------------------------\n\n            stacked.dispatch.on('areaClick.toggle', function(e) {\n                if (data.filter(function(d) { return !d.disabled }).length === 1)\n                    data.forEach(function(d) {\n                        d.disabled = false;\n                    });\n                else\n                    data.forEach(function(d,i) {\n                        d.disabled = (i != e.seriesIndex);\n                    });\n\n                state.disabled = data.map(function(d) { return !!d.disabled });\n                dispatch.stateChange(state);\n\n                chart.update();\n            });\n\n            legend.dispatch.on('stateChange', function(newState) {\n                for (var key in newState)\n                    state[key] = newState[key];\n                dispatch.stateChange(state);\n                chart.update();\n            });\n\n            controls.dispatch.on('legendClick', function(d,i) {\n                if (!d.disabled) return;\n\n                controlsData = controlsData.map(function(s) {\n                    s.disabled = true;\n                    return s;\n                });\n                d.disabled = false;\n\n                stacked.style(d.style);\n\n\n                state.style = stacked.style();\n                dispatch.stateChange(state);\n\n                chart.update();\n            });\n\n            interactiveLayer.dispatch.on('elementMousemove', function(e) {\n                stacked.clearHighlights();\n                var singlePoint, pointIndex, pointXLocation, allData = [], valueSum = 0, allNullValues = true;\n                data\n                    .filter(function(series, i) {\n                        series.seriesIndex = i;\n                        return !series.disabled;\n                    })\n                    .forEach(function(series,i) {\n                        pointIndex = nv.interactiveBisect(series.values, e.pointXValue, chart.x());\n                        var point = series.values[pointIndex];\n                        var pointYValue = chart.y()(point, pointIndex);\n                        if (pointYValue != null) {\n                            stacked.highlightPoint(i, pointIndex, true);\n                        }\n                        if (typeof point === 'undefined') return;\n                        if (typeof singlePoint === 'undefined') singlePoint = point;\n                        if (typeof pointXLocation === 'undefined') pointXLocation = chart.xScale()(chart.x()(point,pointIndex));\n\n                        //If we are in 'expand' mode, use the stacked percent value instead of raw value.\n                        var tooltipValue = (stacked.style() == 'expand') ? point.display.y : chart.y()(point,pointIndex);\n                        allData.push({\n                            key: series.key,\n                            value: tooltipValue,\n                            color: color(series,series.seriesIndex),\n                            point: point\n                        });\n\n                        if (showTotalInTooltip && stacked.style() != 'expand' && tooltipValue != null) {\n                          valueSum += tooltipValue;\n                          allNullValues = false;\n                        };\n                    });\n\n                allData.reverse();\n\n                //Highlight the tooltip entry based on which stack the mouse is closest to.\n                if (allData.length > 2) {\n                    var yValue = chart.yScale().invert(e.mouseY);\n                    var yDistMax = Infinity, indexToHighlight = null;\n                    allData.forEach(function(series,i) {\n\n                        //To handle situation where the stacked area chart is negative, we need to use absolute values\n                        //when checking if the mouse Y value is within the stack area.\n                        yValue = Math.abs(yValue);\n                        var stackedY0 = Math.abs(series.point.display.y0);\n                        var stackedY = Math.abs(series.point.display.y);\n                        if ( yValue >= stackedY0 && yValue <= (stackedY + stackedY0))\n                        {\n                            indexToHighlight = i;\n                            return;\n                        }\n                    });\n                    if (indexToHighlight != null)\n                        allData[indexToHighlight].highlight = true;\n                }\n\n                //If we are not in 'expand' mode, add a 'Total' row to the tooltip.\n                if (showTotalInTooltip && stacked.style() != 'expand' && allData.length >= 2 && !allNullValues) {\n                    allData.push({\n                        key: totalLabel,\n                        value: valueSum,\n                        total: true\n                    });\n                }\n\n                var xValue = chart.x()(singlePoint,pointIndex);\n\n                var valueFormatter = interactiveLayer.tooltip.valueFormatter();\n                // Keeps track of the tooltip valueFormatter if the chart changes to expanded view\n                if (stacked.style() === 'expand' || stacked.style() === 'stack_percent') {\n                    if ( !oldValueFormatter ) {\n                        oldValueFormatter = valueFormatter;\n                    }\n                    //Forces the tooltip to use percentage in 'expand' mode.\n                    valueFormatter = d3.format(\".1%\");\n                }\n                else {\n                    if (oldValueFormatter) {\n                        valueFormatter = oldValueFormatter;\n                        oldValueFormatter = null;\n                    }\n                }\n\n                interactiveLayer.tooltip\n                    .valueFormatter(valueFormatter)\n                    .data(\n                    {\n                        value: xValue,\n                        series: allData\n                    }\n                )();\n\n                interactiveLayer.renderGuideLine(pointXLocation);\n\n            });\n\n            interactiveLayer.dispatch.on(\"elementMouseout\",function(e) {\n                stacked.clearHighlights();\n            });\n\n            /* Update `main' graph on brush update. */\n            focus.dispatch.on(\"onBrush\", function(extent) {\n                onBrush(extent);\n            });\n\n            // Update chart from a state object passed to event handler\n            dispatch.on('changeState', function(e) {\n\n                if (typeof e.disabled !== 'undefined' && data.length === e.disabled.length) {\n                    data.forEach(function(series,i) {\n                        series.disabled = e.disabled[i];\n                    });\n\n                    state.disabled = e.disabled;\n                }\n\n                if (typeof e.style !== 'undefined') {\n                    stacked.style(e.style);\n                    style = e.style;\n                }\n\n                chart.update();\n            });\n\n            //============================================================\n            // Functions\n            //------------------------------------------------------------\n\n            function onBrush(extent) {\n                // Update Main (Focus)\n                var stackedWrap = g.select('.nv-focus .nv-stackedWrap')\n                    .datum(\n                    data.filter(function(d) { return !d.disabled; })\n                        .map(function(d,i) {\n                            return {\n                                key: d.key,\n                                area: d.area,\n                                classed: d.classed,\n                                values: d.values.filter(function(d,i) {\n                                    return stacked.x()(d,i) >= extent[0] && stacked.x()(d,i) <= extent[1];\n                                }),\n                                disableTooltip: d.disableTooltip\n                            };\n                        })\n                );\n                stackedWrap.transition().duration(duration).call(stacked);\n\n                // Update Main (Focus) Axes\n                updateXAxis();\n                updateYAxis();\n            }\n\n        });\n\n        renderWatch.renderEnd('stacked Area chart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    stacked.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt.point['x'] = stacked.x()(evt.point);\n        evt.point['y'] = stacked.y()(evt.point);\n        tooltip.data(evt).hidden(false);\n    });\n\n    stacked.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true)\n    });\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.stacked = stacked;\n    chart.legend = legend;\n    chart.controls = controls;\n    chart.xAxis = xAxis;\n    chart.x2Axis = focus.xAxis;\n    chart.yAxis = yAxis;\n    chart.y2Axis = focus.yAxis;\n    chart.interactiveLayer = interactiveLayer;\n    chart.tooltip = tooltip;\n    chart.focus = focus;\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        showLegend: {get: function(){return showLegend;}, set: function(_){showLegend=_;}},\n        legendPosition: {get: function(){return legendPosition;}, set: function(_){legendPosition=_;}},\n        showXAxis:      {get: function(){return showXAxis;}, set: function(_){showXAxis=_;}},\n        showYAxis:    {get: function(){return showYAxis;}, set: function(_){showYAxis=_;}},\n        defaultState:    {get: function(){return defaultState;}, set: function(_){defaultState=_;}},\n        noData:    {get: function(){return noData;}, set: function(_){noData=_;}},\n        showControls:    {get: function(){return showControls;}, set: function(_){showControls=_;}},\n        controlLabels:    {get: function(){return controlLabels;}, set: function(_){controlLabels=_;}},\n        controlOptions:    {get: function(){return controlOptions;}, set: function(_){controlOptions=_;}},\n        showTotalInTooltip:      {get: function(){return showTotalInTooltip;}, set: function(_){showTotalInTooltip=_;}},\n        totalLabel:      {get: function(){return totalLabel;}, set: function(_){totalLabel=_;}},\n        focusEnable:    {get: function(){return focusEnable;}, set: function(_){focusEnable=_;}},\n        focusHeight:     {get: function(){return focus.height();}, set: function(_){focus.height(_);}},\n        brushExtent: {get: function(){return focus.brushExtent();}, set: function(_){focus.brushExtent(_);}},\n\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            if (_.top !== undefined) {\n                margin.top = _.top;\n                marginTop = _.top;\n            }\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n        }},\n        focusMargin: {get: function(){return focus.margin}, set: function(_){\n            focus.margin.top    = _.top    !== undefined ? _.top    : focus.margin.top;\n            focus.margin.right  = _.right  !== undefined ? _.right  : focus.margin.right;\n            focus.margin.bottom = _.bottom !== undefined ? _.bottom : focus.margin.bottom;\n            focus.margin.left   = _.left   !== undefined ? _.left   : focus.margin.left;\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            stacked.duration(duration);\n            xAxis.duration(duration);\n            yAxis.duration(duration);\n        }},\n        color:  {get: function(){return color;}, set: function(_){\n            color = nv.utils.getColor(_);\n            legend.color(color);\n            stacked.color(color);\n            focus.color(color);\n        }},\n        x: {get: function(){return stacked.x();}, set: function(_){\n            stacked.x(_);\n            focus.x(_);\n        }},\n        y: {get: function(){return stacked.y();}, set: function(_){\n            stacked.y(_);\n            focus.y(_);\n        }},\n        rightAlignYAxis: {get: function(){return rightAlignYAxis;}, set: function(_){\n            rightAlignYAxis = _;\n            yAxis.orient( rightAlignYAxis ? 'right' : 'left');\n        }},\n        useInteractiveGuideline: {get: function(){return useInteractiveGuideline;}, set: function(_){\n            useInteractiveGuideline = !!_;\n            chart.interactive(!_);\n            chart.useVoronoi(!_);\n            stacked.scatter.interactive(!_);\n        }}\n    });\n\n    nv.utils.inheritOptions(chart, stacked);\n    nv.utils.initOptions(chart);\n\n    return chart;\n};\n\nnv.models.stackedAreaWithFocusChart = function() {\n  return nv.models.stackedAreaChart()\n    .margin({ bottom: 30 })\n    .focusEnable( true );\n};\n// based on http://bl.ocks.org/kerryrodden/477c1bfb081b783f80ad\nnv.models.sunburst = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var margin = {top: 0, right: 0, bottom: 0, left: 0}\n        , width = 600\n        , height = 600\n        , mode = \"count\"\n        , modes = {count: function(d) { return 1; }, value: function(d) { return d.value || d.size }, size: function(d) { return d.value || d.size }}\n        , id = Math.floor(Math.random() * 10000) //Create semi-unique ID in case user doesn't select one\n        , container = null\n        , color = nv.utils.defaultColor()\n        , showLabels = false\n        , labelFormat = function(d){if(mode === 'count'){return d.name + ' #' + d.value}else{return d.name + ' ' + (d.value || d.size)}}\n        , labelThreshold = 0.02\n        , sort = function(d1, d2){return d1.name > d2.name;}\n        , key = function(d,i){return d.name;}\n        , groupColorByParent = true\n        , duration = 500\n        , dispatch = d3.dispatch('chartClick', 'elementClick', 'elementDblClick', 'elementMousemove', 'elementMouseover', 'elementMouseout', 'renderEnd');\n\n    //============================================================\n    // aux functions and setup\n    //------------------------------------------------------------\n\n    var x = d3.scale.linear().range([0, 2 * Math.PI]);\n    var y = d3.scale.sqrt();\n\n    var partition = d3.layout.partition().sort(sort);\n\n    var node, availableWidth, availableHeight, radius;\n    var prevPositions = {};\n\n    var arc = d3.svg.arc()\n        .startAngle(function(d) {return Math.max(0, Math.min(2 * Math.PI, x(d.x))) })\n        .endAngle(function(d) {return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))) })\n        .innerRadius(function(d) {return Math.max(0, y(d.y)) })\n        .outerRadius(function(d) {return Math.max(0, y(d.y + d.dy)) });\n\n    function rotationToAvoidUpsideDown(d) {\n        var centerAngle = computeCenterAngle(d);\n        if(centerAngle > 90){\n            return 180;\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function computeCenterAngle(d) {\n        var startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));\n        var endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));\n        var centerAngle = (((startAngle + endAngle) / 2) * (180 / Math.PI)) - 90;\n        return centerAngle;\n    }\n\n    function computeNodePercentage(d) {\n        var startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));\n        var endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));\n        return (endAngle - startAngle) / (2 * Math.PI);\n    }\n\n    function labelThresholdMatched(d) {\n        var startAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x)));\n        var endAngle = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));\n\n        var size = endAngle - startAngle;\n        return size > labelThreshold;\n    }\n\n    // When zooming: interpolate the scales.\n    function arcTweenZoom(e,i) {\n        var xd = d3.interpolate(x.domain(), [node.x, node.x + node.dx]),\n        yd = d3.interpolate(y.domain(), [node.y, 1]),\n        yr = d3.interpolate(y.range(), [node.y ? 20 : 0, radius]);\n\n        if (i === 0) {\n            return function() {return arc(e);}\n        }\n        else {\n            return function (t) {\n                x.domain(xd(t));\n                y.domain(yd(t)).range(yr(t));\n                return arc(e);\n            }\n        };\n    }\n\n    function arcTweenUpdate(d) {\n        var ipo = d3.interpolate({x: d.x0, dx: d.dx0, y: d.y0, dy: d.dy0}, d);\n\n        return function (t) {\n            var b = ipo(t);\n\n            d.x0 = b.x;\n            d.dx0 = b.dx;\n            d.y0 = b.y;\n            d.dy0 = b.dy;\n\n            return arc(b);\n        };\n    }\n\n    function updatePrevPosition(node) {\n        var k = key(node);\n        if(! prevPositions[k]) prevPositions[k] = {};\n        var pP = prevPositions[k];\n        pP.dx = node.dx;\n        pP.x = node.x;\n        pP.dy = node.dy;\n        pP.y = node.y;\n    }\n\n    function storeRetrievePrevPositions(nodes) {\n        nodes.forEach(function(n){\n            var k = key(n);\n            var pP = prevPositions[k];\n            //console.log(k,n,pP);\n            if( pP ){\n                n.dx0 = pP.dx;\n                n.x0 = pP.x;\n                n.dy0 = pP.dy;\n                n.y0 = pP.y;\n            }\n            else {\n                n.dx0 = n.dx;\n                n.x0 = n.x;\n                n.dy0 = n.dy;\n                n.y0 = n.y;\n            }\n            updatePrevPosition(n);\n        });\n    }\n\n    function zoomClick(d) {\n        var labels = container.selectAll('text')\n        var path = container.selectAll('path')\n\n        // fade out all text elements\n        labels.transition().attr(\"opacity\",0);\n\n        // to allow reference to the new center node\n        node = d;\n\n        path.transition()\n            .duration(duration)\n            .attrTween(\"d\", arcTweenZoom)\n            .each('end', function(e) {\n                // partially taken from here: http://bl.ocks.org/metmajer/5480307\n                // check if the animated element's data e lies within the visible angle span given in d\n                if(e.x >= d.x && e.x < (d.x + d.dx) ){\n                    if(e.depth >= d.depth){\n                        // get a selection of the associated text element\n                        var parentNode = d3.select(this.parentNode);\n                        var arcText = parentNode.select('text');\n\n                        // fade in the text element and recalculate positions\n                        arcText.transition().duration(duration)\n                        .text( function(e){return labelFormat(e) })\n                        .attr(\"opacity\", function(d){\n                            if(labelThresholdMatched(d)) {\n                                return 1;\n                            }\n                            else {\n                                return 0;\n                            }\n                        })\n                        .attr(\"transform\", function() {\n                            var width = this.getBBox().width;\n                            if(e.depth === 0)\n                            return \"translate(\" + (width / 2 * - 1) + \",0)\";\n                            else if(e.depth === d.depth){\n                                return \"translate(\" + (y(e.y) + 5) + \",0)\";\n                            }\n                            else {\n                                var centerAngle = computeCenterAngle(e);\n                                var rotation = rotationToAvoidUpsideDown(e);\n                                if (rotation === 0) {\n                                    return 'rotate('+ centerAngle +')translate(' + (y(e.y) + 5) + ',0)';\n                                }\n                                else {\n                                    return 'rotate('+ centerAngle +')translate(' + (y(e.y) + width + 5) + ',0)rotate(' + rotation + ')';\n                                }\n                            }\n                        });\n                    }\n                }\n            })\n    }\n\n    //============================================================\n    // chart function\n    //------------------------------------------------------------\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    function chart(selection) {\n        renderWatch.reset();\n\n        selection.each(function(data) {\n            container = d3.select(this);\n            availableWidth = nv.utils.availableWidth(width, container, margin);\n            availableHeight = nv.utils.availableHeight(height, container, margin);\n            radius = Math.min(availableWidth, availableHeight) / 2;\n\n            y.range([0, radius]);\n\n            // Setup containers and skeleton of chart\n            var wrap = container.select('g.nvd3.nv-wrap.nv-sunburst');\n            if( !wrap[0][0] ) {\n                wrap = container.append('g')\n                    .attr('class', 'nvd3 nv-wrap nv-sunburst nv-chart-' + id)\n                    .attr('transform', 'translate(' + ((availableWidth / 2) + margin.left + margin.right) + ',' + ((availableHeight / 2) + margin.top + margin.bottom) + ')');\n            } else {\n                wrap.attr('transform', 'translate(' + ((availableWidth / 2) + margin.left + margin.right) + ',' + ((availableHeight / 2) + margin.top + margin.bottom) + ')');\n            }\n\n            container.on('click', function (d, i) {\n                dispatch.chartClick({\n                    data: d,\n                    index: i,\n                    pos: d3.event,\n                    id: id\n                });\n            });\n\n            partition.value(modes[mode] || modes[\"count\"]);\n\n            //reverse the drawing order so that the labels of inner\n            //arcs are drawn on top of the outer arcs.\n            var nodes = partition.nodes(data[0]).reverse()\n\n            storeRetrievePrevPositions(nodes);\n            var cG = wrap.selectAll('.arc-container').data(nodes, key)\n\n            //handle new datapoints\n            var cGE = cG.enter()\n                .append(\"g\")\n                .attr(\"class\",'arc-container')\n\n            cGE.append(\"path\")\n                .attr(\"d\", arc)\n                .style(\"fill\", function (d) {\n                    if (d.color) {\n                        return d.color;\n                    }\n                    else if (groupColorByParent) {\n                        return color((d.children ? d : d.parent).name);\n                    }\n                    else {\n                        return color(d.name);\n                    }\n                })\n                .style(\"stroke\", \"#FFF\")\n                .on(\"click\", function(d,i){\n                    zoomClick(d);\n                    dispatch.elementClick({\n                        data: d,\n                        index: i\n                    })\n                })\n                .on('mouseover', function(d,i){\n                    d3.select(this).classed('hover', true).style('opacity', 0.8);\n                    dispatch.elementMouseover({\n                        data: d,\n                        color: d3.select(this).style(\"fill\"),\n                        percent: computeNodePercentage(d)\n                    });\n                })\n                .on('mouseout', function(d,i){\n                    d3.select(this).classed('hover', false).style('opacity', 1);\n                    dispatch.elementMouseout({\n                        data: d\n                    });\n                })\n                .on('mousemove', function(d,i){\n                    dispatch.elementMousemove({\n                        data: d\n                    });\n                });\n\n            ///Iterating via each and selecting based on the this\n            ///makes it work ... a cG.selectAll('path') doesn't.\n            ///Without iteration the data (in the element) didn't update.\n            cG.each(function(d){\n                d3.select(this).select('path')\n                    .transition()\n                    .duration(duration)\n                    .attrTween('d', arcTweenUpdate);\n            });\n\n            if(showLabels){\n                //remove labels first and add them back\n                cG.selectAll('text').remove();\n\n                //this way labels are on top of newly added arcs\n                cG.append('text')\n                    .text( function(e){ return labelFormat(e)})\n                    .transition()\n                    .duration(duration)\n                    .attr(\"opacity\", function(d){\n                        if(labelThresholdMatched(d)) {\n                            return 1;\n                        }\n                        else {\n                            return 0;\n                        }\n                    })\n                    .attr(\"transform\", function(d) {\n                        var width = this.getBBox().width;\n                        if(d.depth === 0){\n                            return \"rotate(0)translate(\" + (width / 2 * -1) + \",0)\";\n                        }\n                        else {\n                            var centerAngle = computeCenterAngle(d);\n                            var rotation = rotationToAvoidUpsideDown(d);\n                            if (rotation === 0) {\n                                return 'rotate('+ centerAngle +')translate(' + (y(d.y) + 5) + ',0)';\n                            }\n                            else {\n                                return 'rotate('+ centerAngle +')translate(' + (y(d.y) + width + 5) + ',0)rotate(' + rotation + ')';\n                            }\n                        }\n                    });\n            }\n\n            //zoom out to the center when the data is updated.\n            zoomClick(nodes[nodes.length - 1])\n\n\n            //remove unmatched elements ...\n            cG.exit()\n                .transition()\n                .duration(duration)\n                .attr('opacity',0)\n                .each('end',function(d){\n                    var k = key(d);\n                    prevPositions[k] = undefined;\n                })\n                .remove();\n        });\n\n\n        renderWatch.renderEnd('sunburst immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    chart.dispatch = dispatch;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        width:      {get: function(){return width;}, set: function(_){width=_;}},\n        height:     {get: function(){return height;}, set: function(_){height=_;}},\n        mode:       {get: function(){return mode;}, set: function(_){mode=_;}},\n        id:         {get: function(){return id;}, set: function(_){id=_;}},\n        duration:   {get: function(){return duration;}, set: function(_){duration=_;}},\n        groupColorByParent: {get: function(){return groupColorByParent;}, set: function(_){groupColorByParent=!!_;}},\n        showLabels: {get: function(){return showLabels;}, set: function(_){showLabels=!!_}},\n        labelFormat: {get: function(){return labelFormat;}, set: function(_){labelFormat=_}},\n        labelThreshold: {get: function(){return labelThreshold;}, set: function(_){labelThreshold=_}},\n        sort: {get: function(){return sort;}, set: function(_){sort=_}},\n        key: {get: function(){return key;}, set: function(_){key=_}},\n        // options that require extra logic in the setter\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    != undefined ? _.top    : margin.top;\n            margin.right  = _.right  != undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom != undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   != undefined ? _.left   : margin.left;\n        }},\n        color: {get: function(){return color;}, set: function(_){\n            color=nv.utils.getColor(_);\n        }}\n    });\n\n    nv.utils.initOptions(chart);\n    return chart;\n};\nnv.models.sunburstChart = function() {\n    \"use strict\";\n\n    //============================================================\n    // Public Variables with Default Settings\n    //------------------------------------------------------------\n\n    var sunburst = nv.models.sunburst();\n    var tooltip = nv.models.tooltip();\n\n    var margin = {top: 30, right: 20, bottom: 20, left: 20}\n        , width = null\n        , height = null\n        , color = nv.utils.defaultColor()\n        , showTooltipPercent = false\n        , id = Math.round(Math.random() * 100000)\n        , defaultState = null\n        , noData = null\n        , duration = 250\n        , dispatch = d3.dispatch('stateChange', 'changeState','renderEnd');\n\n\n    //============================================================\n    // Private Variables\n    //------------------------------------------------------------\n\n    var renderWatch = nv.utils.renderWatch(dispatch);\n\n    tooltip\n        .duration(0)\n        .headerEnabled(false)\n        .valueFormatter(function(d){return d;});\n\n    //============================================================\n    // Chart function\n    //------------------------------------------------------------\n\n    function chart(selection) {\n        renderWatch.reset();\n        renderWatch.models(sunburst);\n\n        selection.each(function(data) {\n            var container = d3.select(this);\n\n            nv.utils.initSVG(container);\n\n            var availableWidth = nv.utils.availableWidth(width, container, margin);\n            var availableHeight = nv.utils.availableHeight(height, container, margin);\n\n            chart.update = function() {\n                if (duration === 0) {\n                    container.call(chart);\n                } else {\n                    container.transition().duration(duration).call(chart);\n                }\n            };\n            chart.container = container;\n\n            // Display No Data message if there's nothing to show.\n            if (!data || !data.length) {\n                nv.utils.noData(chart, container);\n                return chart;\n            } else {\n                container.selectAll('.nv-noData').remove();\n            }\n\n            sunburst.width(availableWidth).height(availableHeight).margin(margin);\n            container.call(sunburst);\n        });\n\n        renderWatch.renderEnd('sunburstChart immediate');\n        return chart;\n    }\n\n    //============================================================\n    // Event Handling/Dispatching (out of chart's scope)\n    //------------------------------------------------------------\n\n    sunburst.dispatch.on('elementMouseover.tooltip', function(evt) {\n        evt.series = {\n            key: evt.data.name,\n            value: (evt.data.value || evt.data.size),\n            color: evt.color,\n            percent: evt.percent\n        };\n        if (!showTooltipPercent) {\n            delete evt.percent;\n            delete evt.series.percent;\n        }\n        tooltip.data(evt).hidden(false);\n    });\n\n    sunburst.dispatch.on('elementMouseout.tooltip', function(evt) {\n        tooltip.hidden(true);\n    });\n\n    sunburst.dispatch.on('elementMousemove.tooltip', function(evt) {\n        tooltip();\n    });\n\n    //============================================================\n    // Expose Public Variables\n    //------------------------------------------------------------\n\n    // expose chart's sub-components\n    chart.dispatch = dispatch;\n    chart.sunburst = sunburst;\n    chart.tooltip = tooltip;\n    chart.options = nv.utils.optionsFunc.bind(chart);\n\n    // use Object get/set functionality to map between vars and chart functions\n    chart._options = Object.create({}, {\n        // simple options, just get/set the necessary values\n        noData:             {get: function(){return noData;},               set: function(_){noData=_;}},\n        defaultState:       {get: function(){return defaultState;},         set: function(_){defaultState=_;}},\n        showTooltipPercent: {get: function(){return showTooltipPercent;},   set: function(_){showTooltipPercent=_;}},\n\n        // options that require extra logic in the setter\n        color: {get: function(){return color;}, set: function(_){\n            color = _;\n            sunburst.color(color);\n        }},\n        duration: {get: function(){return duration;}, set: function(_){\n            duration = _;\n            renderWatch.reset(duration);\n            sunburst.duration(duration);\n        }},\n        margin: {get: function(){return margin;}, set: function(_){\n            margin.top    = _.top    !== undefined ? _.top    : margin.top;\n            margin.right  = _.right  !== undefined ? _.right  : margin.right;\n            margin.bottom = _.bottom !== undefined ? _.bottom : margin.bottom;\n            margin.left   = _.left   !== undefined ? _.left   : margin.left;\n            sunburst.margin(margin);\n        }}\n    });\n    nv.utils.inheritOptions(chart, sunburst);\n    nv.utils.initOptions(chart);\n    return chart;\n\n};\n\nnv.version = \"1.8.5\";\n})();\n//# sourceMappingURL=nv.d3.js.map"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQvYXBwL2dyYXBoL2N1cnZlcy5qcyIsImNsaWVudC9hcHAvZ3JhcGgvZ3Jvd3RoLmpzIiwiY2xpZW50L2FwcC9ncmFwaC9pbmRleC5qcyIsImNsaWVudC9hcHAvZ3JhcGgvdXRpbHMuanMiLCJjbGllbnQvYXBwL2dyb3d0aC1tYXNzLWNoYXJ0LmpzIiwiY2xpZW50L2FwcC9pbmRleC5qcyIsImNsaWVudC9hcHAvcGFnZS5qcyIsImNsaWVudC9wYWdlcy9za3l3b2xmL2dyb3d0aEZ1bmN0aW9ucy5qcyIsImNsaWVudC9wYWdlcy9za3l3b2xmL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1udW1iZXItdmFsdWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWNvcHktd2l0aGluLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWZyb20taXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1yZWR1Y2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi10by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMtaXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW5oZXJpdC1pZi1yZXF1aXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1zdGVwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fa2V5b2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWF0aC1leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21hdGgtbG9nMXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tYXRoLXNpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWZvcmNlZC1wYW0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3BhcnRpYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wYXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVwbGFjZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zYW1lLXZhbHVlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWh0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctcGFkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXJlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190eXBlZC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3R5cGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZGVsYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZGljdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5mdW5jdGlvbi5wYXJ0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLm51bWJlci5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5vYmplY3QuY2xhc3NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5vYmplY3QuZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLm9iamVjdC5pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUub2JqZWN0Lm1ha2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUucmVnZXhwLmVzY2FwZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5zdHJpbmcuZXNjYXBlLWh0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuc3RyaW5nLnVuZXNjYXBlLWh0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5jb3B5LXdpdGhpbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmV2ZXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZmlsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5maW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2guanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuam9pbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuc29tZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnNvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5zcGVjaWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZGF0ZS5ub3cuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWlzby1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5kYXRlLnRvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmFjb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5hc2luaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguYXRhbmguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNicnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmNsejMyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5jb3NoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5leHBtMS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5oeXBvdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGguaW11bC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXRoLmxvZzFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5sb2cyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC5zaW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50YW5oLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubWF0aC50cnVuYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLWZpbml0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1zYWZlLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIubWF4LXNhZmUtaW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWZsb2F0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYubnVtYmVyLnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci50by1wcmVjaXNpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1mcm96ZW4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QucHJldmVudC1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNlYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5wYXJzZS1mbG9hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnBhcnNlLWludC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnByb21pc2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5jb25zdHJ1Y3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5lbnVtZXJhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5oYXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0Lm93bi1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVmbGVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5mbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5tYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNlYXJjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuYW5jaG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmJpZy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ibGluay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5ib2xkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmNvZGUtcG9pbnQtYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuZW5kcy13aXRoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRjb2xvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mb250c2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaXRhbGljcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5saW5rLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnJhdy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc21hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RhcnRzLXdpdGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLnN1Yi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5zdXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcudHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmFycmF5LWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmRhdGEtdmlldy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5mbG9hdDY0LWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYudHlwZWQuaW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC5pbnQzMi1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50MzItYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi50eXBlZC51aW50OC1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnR5cGVkLnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LndlYWstc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGguaWFkZGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXRoLmltdWxoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcubWF0aC5pc3ViaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hdGgudW11bGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0Lmxvb2t1cC1zZXR0ZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZGVmaW5lLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5kZWxldGUtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5nZXQtbWV0YWRhdGEuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnJlZmxlY3QuaGFzLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5oYXMtb3duLW1ldGFkYXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLmF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLm1hdGNoLWFsbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtZW5kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1zdGFydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN0cmluZy50cmltLWxlZnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3lzdGVtLmdsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmltbWVkaWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnRpbWVycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvZDMvZDMuanMiLCJub2RlX21vZHVsZXMvbnZkMy9idWlsZC9udi5kMy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQUVBOzs7Ozs7OztBQVFBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7UUFFZ0IsWSxHQUFBLFk7UUFJQSxNLEdBQUEsTTtRQUlBLEksR0FBQSxJO1FBSUEsSSxHQUFBLEk7UUFJQSxLLEdBQUEsSztRQVNBLFUsR0FBQSxVO1FBTUEsTSxHQUFBLE07UUFPQSxJLEdBQUEsSTtRQUlBLEssR0FBQSxLO1FBS0EsRyxHQUFBLEc7UUFNQSxLLEdBQUEsSztRQU1BLFMsR0FBQSxTO1FBWUEsUSxHQUFBLFE7UUFZQSxjLEdBQUEsYztBQW5GVCxTQUFTLFlBQVQsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBaUM7QUFDdkMsUUFBTyxDQUFDLElBQUksQ0FBTCxJQUFVLENBQVYsR0FBYyxJQUFJLENBQXpCO0FBQ0E7O0FBRU0sU0FBUyxNQUFULENBQWlCLENBQWpCLEVBQXFCO0FBQzNCLFFBQU8sQ0FBUDtBQUNBOztBQUVNLFNBQVMsSUFBVCxDQUFlLENBQWYsRUFBbUI7QUFDekIsUUFBTyxJQUFJLENBQVg7QUFDQTs7QUFFTSxTQUFTLElBQVQsQ0FBZSxDQUFmLEVBQW1CO0FBQ3pCLFFBQU8sSUFBSSxDQUFKLEdBQVEsQ0FBZjtBQUNBOztBQUVNLFNBQVMsS0FBVCxDQUFnQixDQUFoQixFQUFvQjtBQUMxQixLQUFJLEtBQUssSUFBSSxDQUFiO0FBQ0EsUUFBTyxLQUFLLEVBQVo7QUFDQTs7QUFJRDs7QUFFTyxTQUFTLFVBQVQsQ0FBcUIsR0FBckIsRUFBMkI7QUFDakMsUUFBTyxTQUFTLFNBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBOEI7QUFDcEMsU0FBTyxhQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsSUFBSyxDQUFMLENBQXBCLENBQVA7QUFDQSxFQUZEO0FBR0E7O0FBRU0sU0FBUyxNQUFULENBQWlCLFFBQWpCLEVBQTJCLEdBQTNCLEVBQWdDLEdBQWhDLEVBQXNDO0FBQzVDLFFBQU8sU0FBUyxRQUFULENBQW1CLENBQW5CLEVBQXVCO0FBQzdCLFNBQU8sU0FBVSxJQUFLLENBQUwsQ0FBVixFQUFvQixJQUFLLENBQUwsQ0FBcEIsRUFBOEIsQ0FBOUIsQ0FBUDtBQUNBO0FBQ0EsRUFIRDtBQUlBOztBQUVNLFNBQVMsSUFBVCxDQUFlLEdBQWYsRUFBb0IsR0FBcEIsRUFBMEI7QUFDaEMsUUFBTyxPQUFRLFlBQVIsRUFBc0IsR0FBdEIsRUFBMkIsR0FBM0IsQ0FBUDtBQUNBOztBQUVNLFNBQVMsS0FBVCxDQUFnQixHQUFoQixFQUFxQixHQUFyQixFQUEyQjtBQUNqQyxLQUFJLE9BQU8sS0FBTSxJQUFOLEVBQVksSUFBSyxJQUFMLENBQVosQ0FBWDtBQUNBLFFBQU8sT0FBUSxXQUFZLElBQVosQ0FBUixFQUE0QixHQUE1QixFQUFpQyxHQUFqQyxDQUFQO0FBQ0E7O0FBRU0sU0FBUyxHQUFULENBQWMsRUFBZCxFQUFtQjtBQUN6QixRQUFPLFNBQVMsS0FBVCxDQUFnQixDQUFoQixFQUFvQjtBQUMxQixTQUFPLElBQUksR0FBSSxJQUFJLENBQVIsQ0FBWDtBQUNBLEVBRkQ7QUFHQTs7QUFFTSxTQUFTLEtBQVQsQ0FBZ0IsQ0FBaEIsRUFBb0I7QUFDMUIsUUFBTyxTQUFTLE9BQVQsQ0FBa0IsQ0FBbEIsRUFBc0I7QUFDNUIsU0FBTyxLQUFLLEdBQUwsQ0FBVSxDQUFWLEVBQWEsQ0FBYixDQUFQO0FBQ0EsRUFGRDtBQUdBOztBQUVNLFNBQVMsU0FBVCxDQUFvQixFQUFwQixFQUF5QjtBQUMvQixRQUFPLFNBQVMsV0FBVCxDQUFzQixDQUF0QixFQUEwQjtBQUNoQyxNQUFJLEtBQUssQ0FBVCxFQUFhLE9BQU8sQ0FBUCxDQUFiLEtBQ0ssSUFBSSxLQUFLLENBQVQsRUFBYSxPQUFPLENBQVAsQ0FBYixLQUNBLE9BQU8sR0FBSSxDQUFKLENBQVA7QUFDTCxFQUpEO0FBS0E7O0FBSUQ7O0FBRU8sU0FBUyxRQUFULENBQW1CLEVBQW5CLEVBQXVCLEVBQXZCLEVBQTJCLEVBQTNCLEVBQStCLEVBQS9CLEVBQW1DLEVBQW5DLEVBQXdDO0FBQzlDLEtBQUksUUFBUSxLQUFLLEVBQWpCO0FBQ0EsS0FBSSxRQUFRLEtBQUssRUFBakI7QUFDQSxLQUFJLE1BQU0sVUFBVyxFQUFYLENBQVY7QUFDQSxRQUFPLFNBQVMsU0FBVCxDQUFvQixDQUFwQixFQUF3QjtBQUM5QixNQUFJLFVBQVUsQ0FBQyxJQUFJLEVBQUwsSUFBVyxLQUF6QjtBQUNBLFNBQU8sSUFBSyxPQUFMLElBQWlCLEtBQWpCLEdBQXlCLEVBQWhDO0FBQ0EsRUFIRDtBQUlBOztBQUVEO0FBQ0E7QUFDTyxTQUFTLGNBQVQsQ0FBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUMsRUFBakMsRUFBcUMsRUFBckMsRUFBeUMsRUFBekMsRUFBNkMsV0FBN0MsRUFBMkQ7QUFDakUsS0FBSSxnQkFBZ0IsS0FBSyxFQUF6QjtBQUNBLEtBQUksUUFBUSxnQkFBZ0IsV0FBNUI7QUFDQSxLQUFJLFlBQVksQ0FBQyxRQUFRLGFBQVQsSUFBMEIsQ0FBMUM7QUFDQSxLQUFJLE1BQU0sS0FBSyxTQUFmO0FBQ0EsS0FBSSxNQUFNLEtBQUssU0FBZjtBQUNBLFFBQU8sU0FBVSxFQUFWLEVBQWMsR0FBZCxFQUFtQixHQUFuQixFQUF3QixFQUF4QixFQUE0QixFQUE1QixDQUFQO0FBQ0E7Ozs7Ozs7O1FDakVlLGEsR0FBQSxhO1FBZUEsaUIsR0FBQSxpQjtBQXhEaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsRUFBVCxDQUFhLENBQWIsRUFBZ0IsR0FBaEIsRUFBcUIsRUFBckIsRUFBMEI7QUFDekIsU0FBTyxJQUFJLENBQUMsS0FBSyxHQUFOLEtBQWMsSUFBSSxHQUFsQixDQUFYO0FBQ0E7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUJPLFNBQVMsYUFBVCxDQUF3QixDQUF4QixFQUEyQixHQUEzQixFQUFnQyxFQUFoQyxFQUFvQyxDQUFwQyxFQUF1QyxDQUF2QyxFQUEyQztBQUNqRCxNQUFJLElBQUksR0FBSSxDQUFKLEVBQU8sR0FBUCxFQUFZLEVBQVosQ0FBUjtBQUNBLFNBQU8sU0FBUyxRQUFULENBQW1CLENBQW5CLEVBQXVCO0FBQzdCLFdBQU8sS0FBSyxJQUFJLElBQUksS0FBSyxHQUFMLENBQVMsQ0FBQyxDQUFELEdBQUssQ0FBTCxHQUFTLENBQWxCLENBQWIsQ0FBUDtBQUNBLEdBRkQ7QUFHQTs7QUFFRDs7Ozs7O0FBTUEsSUFBTSx3QkFBd0IsUUFBOUI7O0FBRU8sU0FBUyxpQkFBVCxDQUE0QixDQUE1QixFQUErQixHQUEvQixFQUFvQyxFQUFwQyxFQUF3QyxHQUF4QyxFQUE4QztBQUNuRCxTQUFPLGNBQWUsQ0FBZixFQUFrQixHQUFsQixFQUF1QixFQUF2QixFQUEyQixxQkFBM0IsRUFBa0QsTUFBTSxFQUF4RCxDQUFQO0FBQ0Q7Ozs7Ozs7Ozs7QUMxREQ7O0lBQVksTTs7QUFDWjs7SUFBWSxNOztBQUNaOztJQUFZLEs7Ozs7UUFHVixNLEdBQUEsTTtRQUNBLE0sR0FBQSxNO1FBQ0EsSyxHQUFBLEs7Ozs7Ozs7Ozs7Ozs7O1FDRmMsRyxHQUFBLEc7UUFTQSxJLEdBQUEsSTtRQXdGQSxVLEdBQUEsVTtRQStCQSxPLEdBQUEsTzs7QUFySWhCOztJQUFZLEU7O0FBQ1o7Ozs7Ozs7O0FBRUE7O0FBRU8sU0FBUyxHQUFULEdBQXVCO0FBQUEsb0NBQU4sR0FBTTtBQUFOLE9BQU07QUFBQTs7QUFDN0IsU0FBTyxTQUFTLFdBQVQsQ0FBc0IsQ0FBdEIsRUFBMEI7QUFDaEMsV0FBTyxJQUFJLE1BQUosQ0FDTixTQUFTLEtBQVQsQ0FBZ0IsR0FBaEIsRUFBcUIsRUFBckIsRUFBMEI7QUFBRSxhQUFPLE1BQU0sR0FBSSxDQUFKLENBQWI7QUFBdUIsS0FEN0MsRUFFTixDQUZNLENBQVA7QUFJQSxHQUxEO0FBTUE7O0FBRU0sU0FBUyxJQUFULEdBQXdCO0FBQUEscUNBQU4sR0FBTTtBQUFOLE9BQU07QUFBQTs7QUFDOUIsU0FBTyxTQUFTLFlBQVQsQ0FBdUIsQ0FBdkIsRUFBMkI7QUFDakMsV0FBTyxJQUFJLFdBQUosQ0FDTixTQUFTLE1BQVQsQ0FBaUIsR0FBakIsRUFBc0IsRUFBdEIsRUFBMkI7QUFBRSxhQUFPLEdBQUksR0FBSixDQUFQO0FBQW1CLEtBRDFDLEVBRU4sQ0FGTSxDQUFQO0FBSUEsR0FMRDtBQU1BOztBQUlEOztBQUVBOzs7Ozs7OztJQU9hLFUsV0FBQSxVO0FBQ1gsc0JBQVksS0FBWixFQUFtQjtBQUFBOztBQUNqQixRQUFJLEtBQUosRUFBVztBQUNULGNBQVEsSUFBSSxJQUFKLENBQVMsS0FBVCxDQUFSO0FBQ0QsS0FGRCxNQUdLO0FBQ0gsY0FBUSxJQUFJLElBQUosRUFBUjtBQUNEOztBQUVELFNBQUssTUFBTCxHQUFjO0FBQ1osWUFBTSxNQUFNLFdBQU4sRUFETTtBQUVaLGFBQU8sTUFBTSxRQUFOLEtBQW1CLENBRmQ7QUFHWixXQUFLLE1BQU0sT0FBTjtBQUhPLEtBQWQ7O0FBTUEsU0FBSyxNQUFMLEdBQWMsR0FBRyxNQUFILENBQVUsS0FBVixDQUFkO0FBQ0Q7Ozs7aUNBRVksTSxFQUFRO0FBQ25CO0FBQ0E7QUFDQSxVQUFNLGFBQWEsU0FBUyxFQUE1Qjs7QUFFQSxVQUFNLGdCQUFnQixLQUFLLE1BQUwsQ0FBWSxHQUFaLEdBQWtCLENBQWxCLEdBQXNCLFVBQTVDO0FBQ0EsVUFBTSxrQkFBa0IsS0FBSyxNQUFMLENBQVksS0FBWixHQUFvQixDQUFwQixHQUF3QixLQUFLLEtBQUwsQ0FBVyxnQkFBZ0IsRUFBM0IsQ0FBaEQ7QUFDQSxVQUFNLGlCQUFpQixLQUFLLE1BQUwsQ0FBWSxJQUFaLEdBQW1CLEtBQUssS0FBTCxDQUFXLGtCQUFrQixFQUE3QixDQUExQzs7QUFFQSxhQUFPO0FBQ0w7QUFDQSxhQUFNLGdCQUFnQixFQUFqQixHQUF1QixDQUZ2QjtBQUdMLGVBQVEsa0JBQWtCLEVBQW5CLEdBQXlCLENBSDNCO0FBSUwsY0FBTTtBQUpELE9BQVA7QUFNRDs7O3dDQUVtQjtBQUFBOztBQUNsQixhQUFPLGFBQUs7QUFDVixZQUFNLFNBQVMsTUFBSyxZQUFMLENBQWtCLENBQWxCLENBQWY7QUFDQSxlQUFVLE9BQU8sSUFBakIsU0FBeUIsTUFBSyxNQUFMLENBQVksT0FBTyxLQUFuQixDQUF6QixTQUFzRCxNQUFLLE1BQUwsQ0FBWSxPQUFPLEdBQW5CLENBQXREO0FBQ0QsT0FIRDtBQUlEOzs7Ozs7QUFLSDs7QUFFQTs7Ozs7OztBQUtPLElBQU0sc0NBQWUsR0FBRyxLQUFILENBQVMsTUFBVCxHQUFrQixNQUFsQixDQUF5QixDQUFFLENBQUYsRUFBSyxDQUFMLENBQXpCLEVBQW1DLEtBQW5DLENBQXlDLENBQUUsQ0FBRixFQUFLLEdBQUwsQ0FBekMsQ0FBckI7O0FBRVA7Ozs7Ozs7Ozs7Ozs7O0FBY08sU0FBUyxVQUFULENBQXFCLFlBQXJCLEVBQW1DLFNBQW5DLEVBQStDO0FBQ3BELFNBQU87QUFFTDtBQUNBLEtBQUcsS0FBSCxDQUFTLE1BQVQsR0FDRyxNQURILENBQ1csWUFEWCxFQUVHLEtBRkgsQ0FFVSxVQUFVLEdBQVYsQ0FBZTtBQUFBLFdBQUssS0FBSyxHQUFMLENBQVUsQ0FBVixFQUFhLElBQUUsQ0FBZixDQUFMO0FBQUEsR0FBZixDQUZWLENBSEssQ0FBUDtBQU9EOztBQUlEOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ08sU0FBUyxPQUFULENBQWtCLFFBQWxCLEVBQTZCO0FBQ2xDLE1BQUksQ0FBRSxRQUFGLElBQWMsQ0FBRSxTQUFTLE1BQTdCLEVBQXNDO0FBQ3BDLFVBQU0sSUFBSSxLQUFKLGlEQUFOO0FBQ0Q7O0FBRUQsNkJBQ0csT0FBTyxRQURWLGNBQ3NCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSxRQUFJLFFBQVE7QUFDVixpQkFBVyxLQUREO0FBRVYsZUFBUyxJQUZDO0FBR1Y7QUFDQSxpQkFBVyxTQUFTLE1BQVQsRUFKRDtBQUtWO0FBQ0EsWUFBTSxJQU5JO0FBT1Y7QUFDQSxTQUFHO0FBUk8sS0FBWjs7QUFXQSxhQUFTLElBQVQsR0FBZ0I7QUFDZCxVQUFNLGlCQUNKLE1BQU0sT0FBTixHQUNFLGFBQWMsS0FBZCxDQURGLEdBRUUsS0FISjs7QUFNQSxVQUFNLGlCQUNKLGVBQWUsT0FBZixHQUNFLGlCQUFrQixjQUFsQixDQURGLEdBRUUsYUFBYyxjQUFkLENBSEo7O0FBTUEsVUFBTSxZQUFZO0FBQ2hCLGNBQU0sZUFBZSxPQUFmLElBQTBCLGVBQWUsU0FEL0I7QUFFaEIsZUFBTyxlQUFlO0FBRk4sT0FBbEI7O0FBS0EsY0FBUSxjQUFSO0FBQ0EsYUFBTyxTQUFQO0FBQ0Q7O0FBRUQsV0FBTyxFQUFFLFVBQUYsRUFBUDtBQUNELEdBeENIO0FBMENEOztBQUVEO0FBQ0EsU0FBUyxZQUFULENBQXVCLEtBQXZCLEVBQStCO0FBQzdCO0FBQ0EsTUFBTSxPQUFPLE1BQU0sU0FBTixDQUFnQixLQUFoQixFQUFiOztBQUVBLE1BQUksQ0FBRSxJQUFOLEVBQWEsb0JBQVksS0FBWixJQUFtQixVQUFuQixFQUF5QixTQUFTLElBQWxDOztBQUViLHNCQUNLLEtBREw7QUFFRSxjQUZGO0FBR0UsYUFBUyxLQUhYO0FBSUUsT0FBRyxLQUFLLElBQUwsSUFBYSxJQUFiLEdBQW9CLEtBQUssSUFBekIsR0FBZ0MsTUFBTTtBQUozQztBQU1EOztBQUVELFNBQVMsd0JBQVQsQ0FBbUMsSUFBbkMsRUFBMEM7QUFDeEMsTUFBSSxLQUFLLFNBQUwsSUFBa0IsSUFBdEIsRUFBNkIsT0FBTyxLQUFLLFNBQVo7QUFDN0IsU0FBTyxDQUFQO0FBQ0Q7O0FBRUQsU0FBUyxZQUFULENBQXVCLEtBQXZCLEVBQStCO0FBQzdCLE1BQU0sUUFBUSxNQUFNLENBQU4sR0FBVSx5QkFBMEIsTUFBTSxJQUFoQyxDQUF4QjtBQUNBLE1BQU0sYUFBYSxTQUFTLE1BQU0sSUFBTixDQUFXLEVBQXZDOztBQUVBLHNCQUNLLEtBREw7QUFFRSxhQUFTLFVBRlg7QUFHRSxVQUFNLGFBQWEsSUFBYixHQUFvQixNQUFNLElBSGxDO0FBSUUsT0FBRztBQUpMO0FBTUQ7O0FBRUQsU0FBUyxnQkFBVCxDQUEyQixLQUEzQixFQUFtQztBQUNqQyxzQkFDSyxLQURMO0FBRUUsZUFBVztBQUZiO0FBSUQ7Ozs7Ozs7Ozs7O2tCQ3JOdUIsVzs7QUFOeEI7O0lBQVksRTs7QUFDWjs7SUFBWSxFOzs7O0FBRVo7QUFDQTs7QUFFZSxTQUFTLFdBQVQsQ0FBc0IsT0FBdEIsRUFBZ0M7QUFDOUMsV0FBVSxPQUFPLE1BQVAsQ0FBYztBQUN2QjtBQUNBLGFBQVcsSUFGWTtBQUd2QixVQUFRLElBSGU7QUFJckIsU0FBTztBQUNMLFVBQU8sY0FERjtBQUVMLFlBRkssdUJBRU87QUFDVixXQUFPLEdBQUcsTUFBSCxDQUFXLE1BQVgsQ0FBUDtBQUNEO0FBSkksR0FKYztBQVVyQixhQUFXO0FBQ1QsVUFBTyx1QkFERTtBQUVULFlBRlMsdUJBRUc7QUFDVixRQUFNLE1BQU0sR0FBRyxNQUFILENBQVcsTUFBWCxDQUFaO0FBQ0EsV0FBTztBQUFBLFlBQVEsSUFBSyxDQUFMLENBQVI7QUFBQSxLQUFQO0FBQ0Q7QUFMUSxHQVZVO0FBaUJyQixlQUFhO0FBQ1gsVUFBTyw0QkFESTtBQUVYLFlBRlcsdUJBRUM7QUFDVixRQUFNLE1BQU0sR0FBRyxNQUFILENBQVcsTUFBWCxDQUFaO0FBQ0EsV0FBTztBQUFBLFlBQVEsSUFBSyxDQUFMLENBQVI7QUFBQSxLQUFQO0FBQ0Q7QUFMVTtBQWpCUSxFQUFkLEVBd0JQLE9BeEJPLENBQVY7O0FBMEJBLEtBQUksQ0FBRSxRQUFRLFNBQWQsRUFBMEI7QUFDekIsUUFBTSxJQUFJLEtBQUosdURBQU47QUFDQTs7QUFFRCxLQUFJLFFBQVEsSUFBWjtBQUNBLEtBQUksY0FBYyxFQUFsQjs7QUFFQSxLQUFJLGNBQWM7QUFDakIsTUFEaUIsa0JBQ1E7QUFBQSxPQUFuQixXQUFtQix1RUFBTCxFQUFLOztBQUN4QixPQUFJLGVBQWU7QUFDbEI7QUFDQSw2QkFBeUIsSUFGUDtBQUdsQixpQkFBYSxLQUhLO0FBSWxCO0FBQ0EsWUFBUSxFQUFFLE1BQU0sRUFBUixFQUFZLE9BQU8sRUFBbkIsRUFBdUIsUUFBUSxFQUEvQjtBQUxVLElBQW5COztBQVFBLE9BQUksUUFBUSxNQUFaLEVBQXFCO0FBQ3BCLGlCQUFhLE1BQWIsR0FBc0IsUUFBUSxNQUE5QjtBQUNBOztBQUVELFdBQVEsR0FBRyxNQUFILENBQVUsZ0JBQVYsR0FDTixPQURNLENBQ0csWUFESCxDQUFSOztBQUlBLFNBQU0sS0FBTixDQUNFLFNBREYsQ0FDYSxRQUFRLEtBQVIsQ0FBYyxLQUQzQixFQUVFLFVBRkYsQ0FFYyxRQUFRLEtBQVIsQ0FBYyxTQUFkLEVBRmQ7O0FBS0EsU0FBTSxNQUFOLENBQ0UsU0FERixDQUNhLFFBQVEsS0FBUixDQUFjLEtBRDNCLEVBRUUsVUFGRixDQUVjLFFBQVEsS0FBUixDQUFjLFNBQWQsRUFGZDs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBTSxNQUFOLENBQ0UsU0FERixDQUNhLFFBQVEsV0FBUixDQUFvQixLQURqQyxFQUVFLFVBRkYsQ0FFYyxRQUFRLFdBQVIsQ0FBb0IsU0FBcEIsRUFGZDs7QUFLQSxTQUFNLE1BQU4sQ0FDRSxTQURGLENBQ2EsUUFBUSxTQUFSLENBQWtCLEtBRC9CLEVBRUUsVUFGRixDQUVjLFFBQVEsU0FBUixDQUFrQixTQUFsQixFQUZkOztBQUtBLFNBQU0sSUFBTixDQUNFLE1BREYsQ0FDUyxDQUFFLENBQUYsQ0FEVCxFQUVFLE9BRkYsQ0FFVyxLQUZYOztBQUtBLE9BQUksWUFBWSxNQUFoQixFQUF5QjtBQUN4QixTQUFLLFVBQUwsQ0FBaUIsV0FBakI7QUFDQTs7QUFFRCxVQUFPLElBQVA7QUFDQSxHQXZEZ0I7QUF5RGpCLFlBekRpQixzQkF5REwsSUF6REssRUF5REU7QUFDbEIsaUJBQWMsSUFBZDtBQUNBLFdBQVEsU0FBUixDQUFrQixLQUFsQixDQUF5QixXQUF6QixFQUF1QyxJQUF2QyxDQUE2QyxLQUE3QztBQUNBLFFBQUssTUFBTDtBQUNBLFVBQU8sSUFBUDtBQUNBLEdBOURnQjtBQWdFakIsUUFoRWlCLG9CQWdFUjtBQUNSLFNBQU0sTUFBTjtBQUNBLFVBQU8sSUFBUDtBQUNBLEdBbkVnQjtBQXFFakIsVUFyRWlCLHNCQXFFTjtBQUNWLFVBQU8sS0FBUDtBQUNBLEdBdkVnQjtBQXlFakIsU0F6RWlCLHFCQXlFUDtBQUNULFVBQU87QUFDTixXQUFPLFdBQVksTUFBTSxLQUFOLENBQWEsT0FBYixDQUFaLENBREQ7QUFFTixZQUFRLFdBQVksTUFBTSxLQUFOLENBQWEsUUFBYixDQUFaO0FBRkYsSUFBUDtBQUlBLEdBOUVnQjtBQWdGakIsa0JBaEZpQiw4QkFnRkU7QUFDbEIsT0FBSSxPQUFPLEtBQUssT0FBTCxFQUFYO0FBQ0EsT0FBSSxzQkFBYyxNQUFNLE1BQU4sRUFBZCxDQUFKOztBQUVBLE9BQUksZ0JBQWdCO0FBQ25CLE9BQUcsT0FBTyxJQURTO0FBRW5CLE9BQUcsT0FBTyxHQUZTO0FBR25CLFdBQU8sS0FBSyxLQUFMLEdBQWEsT0FBTyxJQUFwQixHQUEyQixPQUFPLEtBSHRCO0FBSW5CLFlBQVEsS0FBSyxNQUFMLEdBQWMsT0FBTyxHQUFyQixHQUEyQixPQUFPO0FBSnZCLElBQXBCOztBQU9BLGlCQUFjLEVBQWQsR0FBbUIsY0FBYyxDQUFkLEdBQWtCLGNBQWMsS0FBbkQ7QUFDQSxpQkFBYyxFQUFkLEdBQW1CLGNBQWMsQ0FBZCxHQUFrQixjQUFjLE1BQW5EOztBQUVBLFVBQU8sYUFBUDtBQUNBO0FBL0ZnQixFQUFsQjs7QUFrR0EsUUFBTyxXQUFQO0FBQ0E7Ozs7Ozs7Ozs7QUMzSUQ7O0FBRUE7O0lBQVksSzs7QUFDWjs7OztBQUNBOztJQUFZLEk7Ozs7OztBQUVaLElBQU0sUUFBUTtBQUNaO0FBRFksQ0FBZDs7UUFLRSxLLEdBQUEsSztRQUNBLEssR0FBQSxLO1FBQ0EsSSxHQUFBLEk7Ozs7Ozs7O1FDYmMsTyxHQUFBLE87QUFBVCxTQUFTLE9BQVQsR0FBbUI7QUFDeEIsTUFBTSxXQUFXO0FBQ2YscUJBQWlCLFNBQVMsY0FBVCxDQUF3QixtQkFBeEIsQ0FERjtBQUVmLGlCQUFhLFNBQVMsY0FBVCxDQUF3QixvQkFBeEIsQ0FGRTtBQUdmLHNCQUFrQixTQUFTLGNBQVQsQ0FBd0IsMEJBQXhCLENBSEg7QUFJZixpQkFBYSxTQUFTLGNBQVQsQ0FBd0Isb0JBQXhCLENBSkU7QUFLZixpQkFBYSxTQUFTLGNBQVQsQ0FBd0Isb0JBQXhCLENBTEU7QUFNZixnQkFBWSxTQUFTLGNBQVQsQ0FBd0IsWUFBeEI7QUFORyxHQUFqQjs7QUFTQSxTQUFPO0FBQ0wsc0JBREs7O0FBR0wsbUJBQWUsb0JBSFY7O0FBS0wsWUFMSyxvQkFLSSxTQUxKLEVBS2U7QUFDbEIsZUFBUyxLQUFULEdBQWlCLFNBQWpCO0FBQ0EsZUFBUyxlQUFULENBQXlCLFNBQXpCLEdBQXFDLFNBQXJDO0FBQ0QsS0FSSTtBQVVMLGlCQVZLLHlCQVVTLFNBVlQsRUFVb0I7QUFDdkIsZUFBUyxnQkFBVCxDQUEwQixTQUExQixHQUFzQyxTQUF0QztBQUNELEtBWkk7QUFjTCx5QkFkSyxpQ0FjaUIsSUFkakIsRUFjdUI7QUFDMUIsZUFBUyxXQUFULENBQXFCLFNBQXJCLEdBQWlDLElBQWpDO0FBQ0Q7QUFoQkksR0FBUDtBQWtCRDs7Ozs7Ozs7O1FDTmUsYSxHQUFBLGE7UUFLQSxpQixHQUFBLGlCO1FBUUEsbUIsR0FBQSxtQjs7QUFuQ2hCOztBQU1PLElBQU0sb0NBQWM7QUFDekIsdUJBQXFCO0FBQ25CO0FBQ0EsU0FBSyxDQUZjLEVBRVg7QUFDUixPQUFHLENBSGdCLEVBR2I7QUFDTixTQUFLLENBSmM7QUFLbkIsUUFBSSxLQUFHLEVBQUgsR0FBUSxDQUxPLEVBS0o7QUFDZixTQUFLLENBTmMsRUFNWDtBQUNSLFFBQUksQ0FQZSxFQU9aO0FBQ1A7QUFDQTtBQUNBLFNBQUssR0FWYyxFQVVUO0FBQ1YsU0FBSyxHQVhjLENBV1Q7QUFYUztBQURJLENBQXBCOztBQWdCQSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsRUFBZ0M7QUFBQSw4QkFDVCxRQUFRLG1CQURDO0FBQUEsTUFDN0IsR0FENkIseUJBQzdCLEdBRDZCO0FBQUEsTUFDeEIsQ0FEd0IseUJBQ3hCLENBRHdCO0FBQUEsTUFDckIsR0FEcUIseUJBQ3JCLEdBRHFCO0FBQUEsTUFDaEIsRUFEZ0IseUJBQ2hCLEVBRGdCOztBQUVyQyxTQUFPLFdBQU0sTUFBTixDQUFhLGlCQUFiLENBQStCLENBQS9CLEVBQWtDLEdBQWxDLEVBQXVDLEVBQXZDLEVBQTJDLEdBQTNDLENBQVA7QUFDRDs7QUFFTSxTQUFTLGlCQUFULENBQTJCLE9BQTNCLEVBQW9DO0FBQUEsK0JBQ2IsUUFBUSxtQkFESztBQUFBLE1BQ2pDLENBRGlDLDBCQUNqQyxDQURpQztBQUFBLE1BQzlCLEVBRDhCLDBCQUM5QixFQUQ4QjtBQUFBLE1BQzFCLEdBRDBCLDBCQUMxQixHQUQwQjtBQUFBLE1BQ3JCLEdBRHFCLDBCQUNyQixHQURxQjs7QUFFekMsU0FBTyxXQUFNLEtBQU4sQ0FBWSxVQUFaLENBQ0wsQ0FBQyxFQUFELEVBQUssQ0FBTCxDQURLLEVBRUwsQ0FBQyxHQUFELEVBQU0sR0FBTixDQUZLLENBQVA7QUFJRDs7QUFFTSxTQUFTLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDO0FBQzNDLFNBQU87QUFBQSxXQUFLLElBQUksUUFBUSxtQkFBUixDQUE0QixFQUFyQztBQUFBLEdBQVA7QUFDRDs7Ozs7QUNyQ0Q7O0lBQVksRTs7QUFDWjs7SUFBWSxFOztBQUVaOztBQU1BOztJQUFZLE07Ozs7OztBQUdaLElBQU0sY0FBYyxVQUFLLE9BQUwsRUFBcEI7QUFDQSxJQUFNLHdCQUFzQixZQUFZLGFBQXhDO0FBQ0EsSUFBTSxtQkFBbUIsR0FBRyxNQUFILENBQVUsZUFBVixDQUF6Qjs7QUFFQSxJQUFNLFFBQVEsV0FBTSxLQUFOLENBQVksT0FBWixDQUFvQixDQUNoQyxFQUFFLE1BQU0sQ0FBUixFQUFXLElBQUksS0FBSyxHQUFwQixFQUF5QixXQUFXLEdBQXBDLEVBRGdDLENBQXBCLENBQWQ7O0FBSUEsU0FBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCLE1BQTFCLEVBQWtDO0FBQ2hDLFNBQU8sNkJBQUksS0FBSixHQUFXLEdBQVgsQ0FBZTtBQUFBLFdBQU07QUFDMUIsU0FBRyxDQUR1QjtBQUUxQixTQUFHLE9BQU8sQ0FBUDtBQUZ1QixLQUFOO0FBQUEsR0FBZixDQUFQO0FBSUQ7O0FBRUQsSUFBTSxvQkFBb0IsT0FBTyxhQUFQLENBQXFCLE9BQU8sV0FBNUIsQ0FBMUI7QUFDQSxJQUFNLHVCQUF1QixPQUFPLGlCQUFQLENBQXlCLE9BQU8sV0FBaEMsQ0FBN0I7O0FBRUEsSUFBTSxZQUFZLENBQ2hCO0FBQ0UsVUFBUSxVQUFVLEtBQVYsRUFBaUIsV0FBTSxLQUFOLENBQVksSUFBWixDQUN2QixPQUFPLG1CQUFQLENBQTJCLE9BQU8sV0FBbEMsQ0FEdUIsRUFFdkIsaUJBRnVCLENBQWpCLENBRFY7QUFLRSxPQUFLLFFBTFA7QUFNRSxTQUFPO0FBTlQsQ0FEZ0IsRUFTaEI7QUFDRSxVQUFRLFVBQVUsS0FBVixFQUFpQixXQUFNLEtBQU4sQ0FBWSxHQUFaLENBQ3ZCLFdBQU0sS0FBTixDQUFZLElBQVosQ0FDRSxvQkFERixFQUVFLGlCQUZGLENBRHVCO0FBS3ZCO0FBQ0EsYUFBTSxNQUFOLENBQWEsY0FBYixDQUNFLFdBQU0sTUFBTixDQUFhLEtBQWIsQ0FDRSxXQUFNLE1BQU4sQ0FBYSxJQURmLEVBRUUsV0FBTSxNQUFOLENBQWEsR0FBYixDQUFpQixXQUFNLE1BQU4sQ0FBYSxJQUE5QixDQUZGLENBREYsRUFLRSxDQUxGLEVBS0ssRUFMTCxFQUtTLENBTFQsRUFLWSxPQUFPLFdBQVAsQ0FBbUIsbUJBQW5CLENBQXVDLEdBQXZDLEdBQTZDLE9BQU8sV0FBUCxDQUFtQixtQkFBbkIsQ0FBdUMsR0FMaEcsRUFNRSxHQU5GLENBTnVCLENBQWpCLENBRFY7QUFnQkUsT0FBSyxJQWhCUDtBQWlCRSxPQUFLLE1BakJQO0FBa0JFLFNBQU87QUFsQlQsQ0FUZ0IsQ0FBbEI7O0FBK0JBLElBQU0sOEJBQThCLElBQUksV0FBTSxLQUFOLENBQVksVUFBaEIsQ0FBMkIsWUFBM0IsQ0FBcEM7O0FBRUEsSUFBTSxjQUFjLFdBQU0scUJBQU4sQ0FBNEI7QUFDOUMsYUFBVyxnQkFEbUM7QUFFOUMsVUFBUSxDQUFDLENBQUQsRUFBSSxHQUFKLENBRnNDO0FBRzlDLFNBQU87QUFDTCxXQUFPLE1BREY7QUFFTCxhQUZLLHVCQUVPO0FBQ1YsVUFBTSxNQUFNLEdBQUcsTUFBSCxDQUFVLE1BQVYsQ0FBWjtBQUNBLFVBQU0sT0FBTyw0QkFBNEIsaUJBQTVCLEVBQWI7QUFDQSxhQUFPLGFBQUs7QUFDVixZQUFNLE9BQU8sS0FBSyxLQUFMLENBQVcsSUFBSSxFQUFmLENBQWI7QUFDQSxZQUFNLE9BQU8sSUFBSSxFQUFqQjtBQUNBLGVBQVUsS0FBSyxDQUFMLENBQVYsV0FBdUIsSUFBdkIsVUFBZ0MsSUFBSSxJQUFKLENBQWhDO0FBQ0QsT0FKRDtBQUtEO0FBVkksR0FIdUM7QUFlOUMsYUFBVztBQUNULFdBQU8sdUJBREU7QUFFVCxhQUZTLHVCQUVHO0FBQ1YsVUFBTSxNQUFNLEdBQUcsTUFBSCxDQUFXLE1BQVgsQ0FBWjtBQUNBLGFBQU87QUFBQSxlQUFRLElBQUksQ0FBSixDQUFSO0FBQUEsT0FBUDtBQUNEO0FBTFEsR0FmbUM7QUFzQjlDLGVBQWE7QUFDWCxXQUFPLG9CQURJO0FBRVgsYUFGVyx1QkFFQztBQUNWLFVBQU0sTUFBTSxHQUFHLE1BQUgsQ0FBVyxNQUFYLENBQVo7QUFDQSxhQUFPO0FBQUEsZUFBUSxJQUFJLENBQUosQ0FBUjtBQUFBLE9BQVA7QUFDRDtBQUxVO0FBdEJpQyxDQUE1QixDQUFwQjs7QUErQkEsR0FBRyxRQUFILENBQVksWUFBTTtBQUNoQixNQUFNLFlBQVksWUFBWSxJQUFaLENBQWlCLFNBQWpCLEVBQTRCLFFBQTVCLEVBQWxCO0FBQ0EsS0FBRyxLQUFILENBQVMsWUFBVCxDQUFzQjtBQUFBLFdBQU0sWUFBWSxNQUFaLEVBQU47QUFBQSxHQUF0QjtBQUNBLFNBQU8sU0FBUDtBQUNELENBSkQ7O0FBTUEsWUFBWSxRQUFaLENBQXFCLFlBQXJCO0FBQ0EsWUFBWSxhQUFaLENBQTBCLHNCQUExQjtBQUNBLFlBQVkscUJBQVo7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7O0FDQUE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7O0FDRkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKlxuVHlwaWNhbCB1c2Ugb2YgdGhlc2UgZnVuY3Rpb25zOlxuXG5pbXBvcnQgKiBhcyBjIGZyb20gJ2N1cnZlcyc7XG5sZXQgc2lnbW9pZDIgPSBjLmxlcnAoIGMucXVhZCwgYy5pbnYoIGMucXVhZCApICk7XG5sZXQgc2lnbW9pZDJQaWVjZXdpc2UgPSBjLnNjYWxlZEZuKCBzaWdtb2lkMiwgMCwgMjUsIDEsIDEzICk7XG4gKi9cblxuLy8vLy8vLy8gQmFzaWMgRnVuY3Rpb25zXG5cbi8vIFRoZXNlIGZ1bmN0aW9ucyBhcmUgYWxsIHVuc2NhbGVkLCBhbmQgc2hvdWxkIGFsbCBoYXZlOlxuLy8gLSBkb21haW4gb2YgWzAsIDFdXG4vLyAtIHJhbmdlIG9mIFswLCAxXVxuXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJwTGluZWFyKCBhLCBiLCB0ICkge1xuXHRyZXR1cm4gKDEgLSB0KSAqIGEgKyB0ICogYjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhciggdCApIHtcblx0cmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWFkKCB0ICkge1xuXHRyZXR1cm4gdCAqIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjdWJlKCB0ICkge1xuXHRyZXR1cm4gdCAqIHQgKiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVhcnQoIHQgKSB7XG5cdGxldCB0MiA9IHQgKiB0O1xuXHRyZXR1cm4gdDIgKiB0Mjtcbn1cblxuXG5cbi8vLy8vLy8vIEhpZ2hlciBPcmRlciBGdW5jdGlvbnNcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycFdpdGgoIHRmbiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGludGVycEFyYiggYSwgYiwgdCApIHtcblx0XHRyZXR1cm4gaW50ZXJwTGluZWFyKCBhLCBiLCB0Zm4oIHQgKSApO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnAoIGZuSW50ZXJwLCBmbkEsIGZuQiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGludGVycEF0KCB0ICkge1xuXHRcdHJldHVybiBmbkludGVycCggZm5BKCB0ICksIGZuQiggdCApLCB0ICk7XG5cdFx0Ly8gcmV0dXJuIGxlcnAoIGZuQSggdCApLCBmbkIoIHQgKSwgZm5JbnRlcnAoIDAsIDEsIHQgKSApO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKCBmbkEsIGZuQiApIHtcblx0cmV0dXJuIGludGVycCggaW50ZXJwTGluZWFyLCBmbkEsIGZuQiApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcXVlcnAoIGZuQSwgZm5CICkge1xuXHRsZXQgaXFmbiA9IGxlcnAoIHF1YWQsIGludiggcXVhZCApICk7XG5cdHJldHVybiBpbnRlcnAoIGludGVycFdpdGgoIGlxZm4gKSwgZm5BLCBmbkIgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludiggZm4gKSB7XG5cdHJldHVybiBmdW5jdGlvbiBpbnZGbiggdCApIHtcblx0XHRyZXR1cm4gMSAtIGZuKCAxIC0gdCApO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG93ZXIoIG4gKSB7XG5cdHJldHVybiBmdW5jdGlvbiBwb3dlck9mKCB0ICkge1xuXHRcdHJldHVybiBNYXRoLnBvdyggdCwgbiApO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGllY2V3aXNlKCBmbiApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIHBpZWNld2lzZUF0KCB0ICkge1xuXHRcdGlmKCB0IDw9IDAgKSByZXR1cm4gMDtcblx0XHRlbHNlIGlmKCB0ID49IDEgKSByZXR1cm4gMTtcblx0XHRlbHNlIHJldHVybiBmbiggdCApO1xuXHR9XG59XG5cblxuXG4vLy8vLy8vLyBQaWVjZXdpc2UgZnVuY3Rpb25zIHRvIHVzZSBpbiBncmFwaHMuXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZWRGbiggZm4sIHQwLCB0MSwgZjAsIGYxICkge1xuXHRsZXQgdFNwYW4gPSB0MSAtIHQwO1xuXHRsZXQgZlNwYW4gPSBmMSAtIGYwO1xuXHRsZXQgcGZuID0gcGllY2V3aXNlKCBmbiApO1xuXHRyZXR1cm4gZnVuY3Rpb24gc2lnbW9pZEF0KCB0ICkge1xuXHRcdGxldCB0U2NhbGVkID0gKHQgLSB0MCkgLyB0U3Bhbjtcblx0XHRyZXR1cm4gcGZuKCB0U2NhbGVkICkgKiBmU3BhbiArIGYwO1xuXHR9XG59XG5cbi8vIFBhZGRzIHRoZSB0LXZhbHVlIG91dCBieSB0aGUgZ2l2ZW4gcHJvcG9ydGlvbiBmcmFjUGFkZGluZy5cbi8vIGZyYWNQYWRkaW5nID0gMS4yIHdvdWxkIHNjYWxlIHRoZSB0IGRvbWFpbiBieSAxLjIuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVkUGFkZGVkRm4oIGZuLCB0MCwgdDEsIGYwLCBmMSwgZnJhY1BhZGRpbmcgKSB7XG5cdGxldCB0U3BhblVuc2NhbGVkID0gdDEgLSB0MDtcblx0bGV0IHRTcGFuID0gdFNwYW5VbnNjYWxlZCAqIGZyYWNQYWRkaW5nO1xuXHRsZXQgdFNwYW5EaWZmID0gKHRTcGFuIC0gdFNwYW5VbnNjYWxlZCkgLyAyO1xuXHRsZXQgdDBkID0gdDAgLSB0U3BhbkRpZmY7XG5cdGxldCB0MWQgPSB0MSArIHRTcGFuRGlmZjtcblx0cmV0dXJuIHNjYWxlZEZuKCBmbiwgdDBkLCB0MWQsIGYwLCBmMSApO1xufVxuIiwiLy8gaHR0cDovL2ZpbGUuc2NpcnAub3JnL0h0bWwvMi0yODYwMDA4XzM4ODQyLmh0bVxuLy8gaHR0cDovL2ZpbGUuc2NpcnAub3JnL0h0bWwvMi0yODYwMDA4L2NlNTk2ZTBiLWM4ZDEtNDIwOS05OTBhLWVkYjNmYjVkODE0Ny5qcGdcblxuLy8gTW9ub21vbGVjdWxhci4gIEl0J3MgYmFzaWNhbGx5IHRoZSBsZXNzZXIgc2lkZSBvZiBhbiBleHBvbmVudGlhbCBncmFwaCBmbGlwcGVkIHVwc2lkZSBkb3duLiAoMSAtIGV4cCgtdCkpXG4vLyBBIC0gVG9wIGFzeW1wdG90ZVxuLy8gayAtIC4uLiBzb21ldGhpbmcuICBBIHR3ZWFrIHBhcmFtZXRlciBJIGd1ZXNzLlxuLy8gQiAtIERlcml2ZWQgdmFsdWUuLj8gIEZvciBtb25vbW9sZWN1bGFyIGl0J3MgaW4gdGhlIGRvbWFpbiBvZiAoMCwgMSlcbi8vICAgICBMb29raW5nIGF0IHRoZSBtYXRoLCBpZiBpdCdzIG5vdCAxIHRoZW4gd2UgZG9uJ3QgcmVhY2ggZnVsbCBncm93dGggb2YgQS5cblxuLy8gRnJvbSBjYWxjOlxuLy8gZGVmaW5lIEIwKCBBLCBBX0wsIFMgKSA9IDEgLSAoUyAtIEFfTCkgLyAoQSAtIEFfTClcbi8vIGRlZmluZSBrKCB0LCBTLCBBLCBBX0wsIEIgKSA9ICgtIGxuKCAoMSAtIChTIC0gQV9MKSAvIChBIC0gQV9MKSkgLyBCICkgLyB0KVxuLy8gZGVmaW5lIG1vbm9tb2xlY3VsYXIoIHQsIEEsIEFfTCwgQiwgayApID0gQV9MICsgKEEgLSBBX0wpICogKDEgLSBCICogZXhwKC1rICogdCkpXG5cbmZ1bmN0aW9uIEIwKCBBLCBBX0wsIFMwICkge1xuXHRyZXR1cm4gMSAtIChTMCAtIEFfTCkgLyAoQSAtIEFfTCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gb2YgdGltZSB3aGljaCByZXR1cm5zIHRoZSBsaW5lYXIgZ3Jvd3RoIHZhbHVlIGF0IHRoYXRcbiAqIHBhcnRpY3VsYXIgdGltZSB1c2luZyBhIGJhc2ljIG1vbm9tb2xlY3VsYXIgZ3Jvd3RoIG1vZGVsLCBiYXNpY2FsbHkgYW4gdXBzaWRlXG4gKiBkb3duIGJhY2t3YXJkcyBleHBvbmVudGlhbCBncmFwaC5cbiAqXG4gKiBOb3RlIHRoYXQgdGltZSBoZXJlIGlzIG1lYXN1cmVkIGluIG1vbnRocy5cbiAqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IEFcbiAqICAgICAgICAgVG9wIGFzeW1wdG90ZSwgdGhlIG1heGltdW0gdmFsdWUgdGhhdCB0aGUgZ3JhcGggdGVuZHMgdG93YXJkcy5cbiAqICAgICAgICAgU2luY2UgdGhpcyBpcyBhIGxpbmVhciBncm93dGggc2NhbGUsIGl0J3MgdXNlZnVsIHRvIHNldCBpdCB0byAxLlxuICogQHBhcmFtICB7bnVtYmVyfSBBX0xcbiAqICAgICAgICAgTG93ZXIgYm91bmRzLiAgVXN1YWxseSAwLlxuICogQHBhcmFtICB7bnVtYmVyfSBTMFxuICogICAgICAgICBJbml0aWFsIGxpbmVhciBzaXplLCByZWxhdGl2ZSB0byBBLlxuICogQHBhcmFtICB7bnVtYmVyfSBrXG4gKiAgICAgICAgIFRpbWUgc2NhbGUuXG4gKiAgICAgICAgIEdpdmVuIGs9fjAuMTM1LCBTMD1+MC4yMDUsIEFfTCA9IDAsIEEgPSAxLFxuICogICAgICAgICB0aGVuIGYodD0yMCk9fjAuOTUgYW5kIGYodD0zNSk9fjAuOTkuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRcbiAqICAgICAgICAgVGltZSBkaWxhdGlvbiBmYWN0b3IuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvZiB0aW1lIGluIG1vbnRocyB0aGF0IHJldHVybnMgYSBsaW5lYXIgZmFjdG9yXG4gKiAgICAgICAgICAgICAgICAgICAgb2YgZ3Jvd3RoIGF0IHRoYXQgZ2l2ZW4gdGltZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vbm9tb2xlY3VsYXIoIEEsIEFfTCwgUzAsIGssIGQgKSB7XG5cdGxldCBCID0gQjAoIEEsIEFfTCwgUzAgKTtcblx0cmV0dXJuIGZ1bmN0aW9uIGdyb3d0aEF0KCB0ICkge1xuXHRcdHJldHVybiBBICogKDEgLSBCICogTWF0aC5leHAoLWsgKiB0IC8gZCkpO1xuXHR9O1xufVxuXG4vKipcbiAqIEEgayB2YWx1ZSB0aGF0LCBpbiB0aGUgYmFzaWMgbW9ub21vbGVjdWxhciBmdW5jdGlvbiBhYm92ZSxcbiAqIEdpdmVuIGs9fjAuMTM1LCBTMD1+MC4yMDUsIEFfTCA9IDAsIEEgPSAxLFxuICogdGhlbiBmKHQ9MjApPX4wLjk1IGFuZCBmKHQ9MzUpPX4wLjk5LlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuY29uc3QgTU9OT01PTEVDVUxBUl85NV9UMV9LID0gMC4xMzU2NjI7XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vbW9sZWN1bGFyOTV0MSggQSwgQV9MLCBTMCwgdDk1ICkge1xuICByZXR1cm4gbW9ub21vbGVjdWxhciggQSwgQV9MLCBTMCwgTU9OT01PTEVDVUxBUl85NV9UMV9LLCB0OTUgLyAyMCApO1xufVxuIiwiaW1wb3J0ICogYXMgY3VydmVzIGZyb20gJy4vY3VydmVzJztcbmltcG9ydCAqIGFzIGdyb3d0aCBmcm9tICcuL2dyb3d0aCc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IHtcbiAgY3VydmVzLFxuICBncm93dGgsXG4gIHV0aWxzLFxufTtcbiIsImltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcbmltcG9ydCB7IGN1YmUgfSBmcm9tICcuL2N1cnZlcyc7XG5cbi8vLy8vLy8vIENvbXBvc2Vyc1xuXG5leHBvcnQgZnVuY3Rpb24gc3VtKCAuLi5mbnMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBzdW1tYXRpb25BdCggdCApIHtcblx0XHRyZXR1cm4gZm5zLnJlZHVjZShcblx0XHRcdGZ1bmN0aW9uIHN1bUZuKCByZXMsIGZuICkgeyByZXR1cm4gcmVzICsgZm4oIHQgKTsgfSxcblx0XHRcdDBcblx0XHQpO1xuXHR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcCggLi4uZm5zICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gY29wb3NpdGlvbkF0KCB0ICkge1xuXHRcdHJldHVybiBmbnMucmVkdWNlUmlnaHQoXG5cdFx0XHRmdW5jdGlvbiBjb21wRm4oIHJlcywgZm4gKSB7IHJldHVybiBmbiggcmVzICk7IH0sXG5cdFx0XHR0XG5cdFx0KTtcblx0fVxufVxuXG5cblxuLy8vLy8vLy8gRGF0ZVxuXG4vKipcbiAqIFRyYWNrIG5vcm1hbGl6ZWQgbW9udGhzIGFuZCB5ZWFycyxcbiAqIG1vcmUgb3IgbGVzcyBpZ25vcmluZyB0aGF0IG1vbnRocyBoYXZlIGRpZmZlcmVudCBudW1iZXJzIG9mIGRheXNcbiAqIG9yIHRoYXQgeWVhcnMgYXJlIDM2NS4yNWFuZGNoYW5nZSBkYXlzIGxvbmcsIG5vdCAzNjAgZGF5cy5cbiAqIFNpbmNlIGdyYXBocyBtYWRlIGluIHRoaXMgcGFja2FnZSB0cmFjayBieSBtb250aHMgYWZ0ZXIgYmlydGggcmF0aGVyIHRoYW5cbiAqIGV4YWN0IG51bWJlcnMgb2YgZGF5cywgdGhpcyBpcyBhIHJlYXNvbmFibGUgY29tcHJvbWlzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBzZXVkb0RhdGUge1xuICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgIGlmIChzdGFydCkge1xuICAgICAgc3RhcnQgPSBuZXcgRGF0ZShzdGFydCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0ID0ge1xuICAgICAgeWVhcjogc3RhcnQuZ2V0RnVsbFllYXIoKSxcbiAgICAgIG1vbnRoOiBzdGFydC5nZXRNb250aCgpICsgMSxcbiAgICAgIGRheTogc3RhcnQuZ2V0RGF0ZSgpLFxuICAgIH07XG5cbiAgICB0aGlzLl9kbUZtdCA9IGQzLmZvcm1hdCgnMDJkJyk7XG4gIH1cblxuICBvZmZzZXRNb250aHMob2Zmc2V0KSB7XG4gICAgLy8gU2luY2UgdGhpcyBpcyBwc2V1ZG90aW1lLCB3ZSBjYW4ganVzdCBmcmVlbHkgY29udmVydCB0byBkYXlzIGJ5XG4gICAgLy8gbXVsdGlwbHlpbmcgYnkgYSBmaXhlZCBmYWN0b3Igb2YgMzAuXG4gICAgY29uc3Qgb2Zmc2V0RGF5cyA9IG9mZnNldCAqIDMwO1xuXG4gICAgY29uc3QgZGF5V2l0aEV4Y2VzcyA9IHRoaXMuX3N0YXJ0LmRheSAtIDEgKyBvZmZzZXREYXlzO1xuICAgIGNvbnN0IG1vbnRoV2l0aEV4Y2VzcyA9IHRoaXMuX3N0YXJ0Lm1vbnRoIC0gMSArIE1hdGguZmxvb3IoZGF5V2l0aEV4Y2VzcyAvIDMwKTtcbiAgICBjb25zdCB5ZWFyV2l0aEV4Y2VzcyA9IHRoaXMuX3N0YXJ0LnllYXIgKyBNYXRoLmZsb29yKG1vbnRoV2l0aEV4Y2VzcyAvIDEyKTtcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBtb2R1bG8gYWZ0ZXIgYWxsIGNhcnJ5LW92ZXJzIGhhdmUgYmVlbiBhY2NvdW50ZWQgZm9yLlxuICAgICAgZGF5OiAoZGF5V2l0aEV4Y2VzcyAlIDMwKSArIDEsXG4gICAgICBtb250aDogKG1vbnRoV2l0aEV4Y2VzcyAlIDEyKSArIDEsXG4gICAgICB5ZWFyOiB5ZWFyV2l0aEV4Y2VzcyxcbiAgICB9O1xuICB9XG5cbiAgcmVsYXRpdmVGb3JtYXR0ZXIoKSB7XG4gICAgcmV0dXJuIHQgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXRNb250aHModCk7XG4gICAgICByZXR1cm4gYCR7b2Zmc2V0LnllYXJ9LSR7dGhpcy5fZG1GbXQob2Zmc2V0Lm1vbnRoKX0tJHt0aGlzLl9kbUZtdChvZmZzZXQuZGF5KX1gO1xuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vIFNvbWUgdXNlZnVsIHNjYWxlcy5cblxuLyoqXG4gKiBDb252ZW5pZW5jZSBzY2FsZSBmdW5jdGlvbiB0byBjb252ZXJ0IGEgcHJvZ3Jlc3MgKFswLCAxXSlcbiAqIHRvIGEgcGVyY2VudC4gKFswLCAxMDBdKVxuICogQHR5cGUge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgY29uc3QgcGVyY2VudFNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFsgMCwgMSBdKS5yYW5nZShbIDAsIDEwMCBdKTtcblxuLyoqXG4gKiBTaW1wbGUgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSBsaW5lYXItZGltZW5zaW9uIGRvbWFpbiBhbmQgYSBtYXNzIHJhbmdlXG4gKiBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHMgYSBsaW5lYXIgZGltZW5zaW9uIGFuZCByZXR1cm5zIHRoZVxuICogY3ViaWMgbWFzcyBmb3IgaXQuXG4gKiBAcGFyYW0gIHtBcnJheTxudW1iZXI+fSBsaW5lYXJEb21haW5cbiAqICAgICAgICAgQSB0d28tZWxlbWVudCBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgbG93ZXIgYm91bmQgb2ZcbiAqICAgICAgICAgdGhlIGlucHV0IGRvbWFpbiBhbmQgdGhlIHNlY29uZCBlbGVtZW50IGlzIHRoZSB1cHBlci5cbiAqICAgICAgICAgWW91IGNhbiBzdGlsbCBwYXNzIHZhbHVlcyBvdXRzaWRlIG9mIHRoaXMgZG9tYWluIGFuZCByZWNlaXZlIGFuXG4gKiAgICAgICAgIGFwcHJvcHJpYXRlIHZhbHVlIGJhY2suXG4gKiBAcGFyYW0gIHtBcnJheTxudW1iZXI+fSBtYXNzUmFuZ2VcbiAqICAgICAgICAgQSB0d28tZWxlbWVudCBhcnJheSB3aGVyZSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgbG93ZXIgYm91bmQgb2ZcbiAqICAgICAgICAgdGhlIG91dHB1dCBtYXNzIHJhbmdlIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGxpbmVhci10by1jdWJpYyBzY2FsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1YmljU2NhbGUoIGxpbmVhckRvbWFpbiwgbWFzc1JhbmdlICkge1xuICByZXR1cm4gY29tcChcbiAgICBjdWJlLFxuICAgIC8vIEMgPSAoKEwgLSBMMCkgLyAoTDEgLSBMMCkgKiAoQzFeMS8zIC0gQzBeMS8zKSleM1xuICAgIGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAuZG9tYWluKCBsaW5lYXJEb21haW4gKVxuICAgICAgLnJhbmdlKCBtYXNzUmFuZ2UubWFwKCByID0+IE1hdGgucG93KCByLCAxLzMgKSApIClcbiAgKTtcbn1cblxuXG5cbi8vLy8vLy8vIFNwYW5zXG5cbi8qXG50eXBlIFNwYW5EZWYgPSB7XG4gIC8vIFZhbHVlIHRoaXMgc3BhbiBzdGFydHMgZnJvbS5cbiAgLy8gQXQgbGVhc3QgdGhlIGZpcnN0IHNwYW4gbXVzdCBoYXZlIGEgdmFsdWUgaGVyZSBvciBlbHNlXG4gIC8vIGFsbCBvZiB0aGUgcmV0dXJuZWQgdmFsdWVzIHdpbGwgYmUgTmFOLlxuICAvLyBGb3IgYWxsIHNwYW5zIGFmdGVyIHRoZSBmaXJzdCwgdGhpcyBkZWZhdWx0cyB0byB0aGUgbGFzdCB2YWx1ZVxuICAvLyB5aWVsZGVkIGZvciB0aGUgbGFzdCBzcGFuLlxuICBmcm9tPzogbnVtYmVyLFxuICAvLyBWYWx1ZSB0aGlzIHNwYW4gcnVucyB1bnRpbC5cbiAgdG86IG51bWJlcixcbiAgLy8gU2l6ZSBvZiBlYWNoIGluY3JlbWVudC5cbiAgLy8gZGVmYXVsdHMgdG8gMS5cbiAgaW5jcmVtZW50PzogbnVtYmVyLFxufTtcbiAqL1xuXG4vLyBUaGlzIGlzIGN1cnJlbnRseSBwcmV0dHkgY3J1ZGUsIHVzaW5nIGl0IHdpdGggZmxvYXQgdmFsdWVzIG1heSBsZWFkIHRvIG9kZGl0aWVzLlxuZXhwb3J0IGZ1bmN0aW9uIHNwYW5uZXIoIHNwYW5EZWZzICkge1xuICBpZiggISBzcGFuRGVmcyB8fCAhIHNwYW5EZWZzLmxlbmd0aCApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoIGBzcGFubmVyIHJlcXVpcmVzIGFuIGFycmF5IG9mIHNwYW4gZGVmaW5pdGlvbnNgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgLy8gaW5pdCBzdGF0ZSBoZXJlLFxuICAgICAgLy8gY3JlYXRlIG5leHQoKSBzdGVwcGVyLlxuICAgICAgLy8gcmV0dXJuIGZpcnN0IGl0ZXJhdGlvbi4gKGJ5IGNhbGxpbmcgbmV4dCgpIHRoZSBmaXJzdCB0aW1lIGlmIHBvc3NpYmxlLilcblxuICAgICAgbGV0IHN0YXRlID0ge1xuICAgICAgICBmaW5hbGl6ZWQ6IGZhbHNlLFxuICAgICAgICBzdG9wcGVkOiB0cnVlLFxuICAgICAgICAvLyBSZW1haW5pbmcgc3BhbnMgdG8gZ28gdGhyb3VnaCBhZnRlciB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgIHJlc3RTcGFuczogc3BhbkRlZnMuY29uY2F0KCksXG4gICAgICAgIC8vIEN1cnJlbnQgc3Bhbi5cbiAgICAgICAgc3BhbjogbnVsbCxcbiAgICAgICAgLy8gTmV4dCB2YWx1ZS5cbiAgICAgICAgdDogdW5kZWZpbmVkLFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVBZnRlckluaXQgPSAoXG4gICAgICAgICAgc3RhdGUuc3RvcHBlZFxuICAgICAgICAgID8gc3Bhbm5lcl9pbml0KCBzdGF0ZSApXG4gICAgICAgICAgOiBzdGF0ZVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlQWZ0ZXJTdGVwID0gKFxuICAgICAgICAgIHN0YXRlQWZ0ZXJJbml0LnN0b3BwZWRcbiAgICAgICAgICA/IHNwYW5uZXJfZmluYWxpemUoIHN0YXRlQWZ0ZXJJbml0IClcbiAgICAgICAgICA6IHNwYW5uZXJfc3RlcCggc3RhdGVBZnRlckluaXQgKVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbiA9IHtcbiAgICAgICAgICBkb25lOiBzdGF0ZUFmdGVySW5pdC5zdG9wcGVkICYmIHN0YXRlQWZ0ZXJJbml0LmZpbmFsaXplZCxcbiAgICAgICAgICB2YWx1ZTogc3RhdGVBZnRlckluaXQudCxcbiAgICAgICAgfTtcblxuICAgICAgICBzdGF0ZSA9IHN0YXRlQWZ0ZXJTdGVwO1xuICAgICAgICByZXR1cm4gaXRlcmF0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyBuZXh0IH07XG4gICAgfSxcbiAgfTtcbn1cblxuLy8gZnVuY3Rpb24gc3Bhbm5lcl9pbml0KHsgdCwgcmVzdFNwYW5zLCBmaW5hbGl6ZWQgfSkge1xuZnVuY3Rpb24gc3Bhbm5lcl9pbml0KCBzdGF0ZSApIHtcbiAgLy8gTXV0YXRpb24uLi5cbiAgY29uc3Qgc3BhbiA9IHN0YXRlLnJlc3RTcGFucy5zaGlmdCgpO1xuXG4gIGlmKCAhIHNwYW4gKSByZXR1cm4geyAuLi5zdGF0ZSwgc3Bhbiwgc3RvcHBlZDogdHJ1ZSB9O1xuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgc3BhbixcbiAgICBzdG9wcGVkOiBmYWxzZSxcbiAgICB0OiBzcGFuLmZyb20gIT0gbnVsbCA/IHNwYW4uZnJvbSA6IHN0YXRlLnQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNwYW5uZXJfZ2V0U3BhbkluY3JlbWVudCggc3BhbiApIHtcbiAgaWYoIHNwYW4uaW5jcmVtZW50ICE9IG51bGwgKSByZXR1cm4gc3Bhbi5pbmNyZW1lbnQ7XG4gIHJldHVybiAxO1xufVxuXG5mdW5jdGlvbiBzcGFubmVyX3N0ZXAoIHN0YXRlICkge1xuICBjb25zdCBuZXh0VCA9IHN0YXRlLnQgKyBzcGFubmVyX2dldFNwYW5JbmNyZW1lbnQoIHN0YXRlLnNwYW4gKTtcbiAgY29uc3Qgc3BhbklzRG9uZSA9IG5leHRUID49IHN0YXRlLnNwYW4udG87XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zdGF0ZSxcbiAgICBzdG9wcGVkOiBzcGFuSXNEb25lLFxuICAgIHNwYW46IHNwYW5Jc0RvbmUgPyBudWxsIDogc3RhdGUuc3BhbixcbiAgICB0OiBuZXh0VCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3Bhbm5lcl9maW5hbGl6ZSggc3RhdGUgKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgZmluYWxpemVkOiB0cnVlLFxuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0ICogYXMgbnYgZnJvbSAnbnZkMyc7XG5cbi8vIFRoaXMgaXMgYSBmYWN0b3J5IHRvIGdhdGhlciBhbGwgdGhlIG52IHJlbGF0ZWQgc3R1ZmYgaW50byBvbmUgcGxhY2UuXG4vLyBBbGwgdGhlIGludGVyYWN0aW9uIGlzIGhhbGRsZWQgZWxzZXdoZXJlLlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBncm93dGhDaGFydCggb3B0aW9ucyApIHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdC8vIFRoZSBlbGVtZW50IGludG8gd2hpY2ggdGhlIGNoYXJ0IHdpbGwgZ28uXG5cdFx0c2VsZWN0aW9uOiBudWxsLFxuXHRcdGZvcmNlWTogbnVsbCxcbiAgICB4QXhpczoge1xuICAgICAgbGFiZWw6IFwiQWdlIChtb250aHMpXCIsXG4gICAgICBmb3JtYXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiBkMy5mb3JtYXQoICcuMDJmJyApO1xuICAgICAgfSxcbiAgICB9LFxuICAgIHlBeGlzTWFzczoge1xuICAgICAgbGFiZWw6IFwiQXBwcm94aW1hdGUgQm9keSBNYXNzXCIsXG4gICAgICBmb3JtYXR0ZXIoKSB7XG4gICAgICAgIGNvbnN0IGZtdCA9IGQzLmZvcm1hdCggJy4wMWYnICk7XG4gICAgICAgIHJldHVybiB2ID0+IGAke2ZtdCggdiApfWtnYDtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB5QXhpc0xpbmVhcjoge1xuICAgICAgbGFiZWw6IFwiUGVyY2VudCBMaW5lYXIgQm9keSBHcm93dGhcIixcbiAgICAgIGZvcm1hdHRlcigpIHtcbiAgICAgICAgY29uc3QgZm10ID0gZDMuZm9ybWF0KCAnLjAxZicgKTtcbiAgICAgICAgcmV0dXJuIHYgPT4gYCR7Zm10KCB2ICl9JWA7XG4gICAgICB9LFxuICAgIH0sXG5cdH0sIG9wdGlvbnMgKTtcblxuXHRpZiggISBvcHRpb25zLnNlbGVjdGlvbiApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIGBncm93dGhDaGFydCBtdXN0IGJlIHByb3ZpZGVkIGEgZDMgZWxlbWVudCBzZWxlY3Rpb25gICk7XG5cdH1cblxuXHRsZXQgY2hhcnQgPSBudWxsO1xuXHRsZXQgY3VycmVudERhdGEgPSBbXTtcblxuXHRsZXQgY2hhcnRPYmplY3QgPSB7XG5cdFx0aW5pdCggaW5pdGlhbERhdGEgPSBbXSApIHtcblx0XHRcdGxldCBjaGFydE9wdGlvbnMgPSB7XG5cdFx0XHRcdC8vIGR1cmF0aW9uOiAyNTAsXG5cdFx0XHRcdHVzZUludGVyYWN0aXZlR3VpZGVsaW5lOiB0cnVlLFxuXHRcdFx0XHRmb2N1c0VuYWJsZTogZmFsc2UsXG5cdFx0XHRcdC8vIG1hcmdpbjogeyByaWdodDogNDUsIGJvdHRvbTogNDAgfSxcblx0XHRcdFx0bWFyZ2luOiB7IGxlZnQ6IDY1LCByaWdodDogODAsIGJvdHRvbTogNDAgfSxcblx0XHRcdH07XG5cblx0XHRcdGlmKCBvcHRpb25zLmZvcmNlWSApIHtcblx0XHRcdFx0Y2hhcnRPcHRpb25zLmZvcmNlWSA9IG9wdGlvbnMuZm9yY2VZO1xuXHRcdFx0fVxuXG5cdFx0XHRjaGFydCA9IG52Lm1vZGVscy5saW5lUGx1c0JhckNoYXJ0KClcblx0XHRcdFx0Lm9wdGlvbnMoIGNoYXJ0T3B0aW9ucyApXG5cdFx0XHRcdDtcblxuXHRcdFx0Y2hhcnQueEF4aXNcblx0XHRcdFx0LmF4aXNMYWJlbCggb3B0aW9ucy54QXhpcy5sYWJlbCApXG5cdFx0XHRcdC50aWNrRm9ybWF0KCBvcHRpb25zLnhBeGlzLmZvcm1hdHRlcigpIClcblx0XHRcdFx0O1xuXG5cdFx0XHRjaGFydC54MkF4aXNcblx0XHRcdFx0LmF4aXNMYWJlbCggb3B0aW9ucy54QXhpcy5sYWJlbCApXG5cdFx0XHRcdC50aWNrRm9ybWF0KCBvcHRpb25zLnhBeGlzLmZvcm1hdHRlcigpIClcblx0XHRcdFx0O1xuXG5cdFx0XHQvLyBjaGFydC55QXhpc1xuXHRcdFx0Ly8gXHQuYXhpc0xhYmVsKCAnTGluZWFyIERpbWVuc2lvbiBHcm93dGgnIClcblx0XHRcdC8vIFx0LnRpY2tGb3JtYXQoIGQzLmZvcm1hdCggJy4wM2YnICkgKVxuXHRcdFx0Ly8gXHQ7XG5cblx0XHRcdC8vIFRFTVA6IEp1c3QgY29tcGFyaW5nIHBlcmNlbnRzLlxuXHRcdFx0Ly8gbGV0IHlBRiA9IGQzLmZvcm1hdCggJy4wMWYnICk7XG5cdFx0XHRjaGFydC55MkF4aXNcblx0XHRcdFx0LmF4aXNMYWJlbCggb3B0aW9ucy55QXhpc0xpbmVhci5sYWJlbCApXG5cdFx0XHRcdC50aWNrRm9ybWF0KCBvcHRpb25zLnlBeGlzTGluZWFyLmZvcm1hdHRlcigpIClcblx0XHRcdFx0O1xuXG5cdFx0XHRjaGFydC55MUF4aXNcblx0XHRcdFx0LmF4aXNMYWJlbCggb3B0aW9ucy55QXhpc01hc3MubGFiZWwgKVxuXHRcdFx0XHQudGlja0Zvcm1hdCggb3B0aW9ucy55QXhpc01hc3MuZm9ybWF0dGVyKCkgKVxuXHRcdFx0XHQ7XG5cblx0XHRcdGNoYXJ0LmJhcnNcblx0XHRcdFx0LmZvcmNlWShbIDAgXSlcblx0XHRcdFx0LnBhZERhdGEoIGZhbHNlIClcblx0XHRcdFx0O1xuXG5cdFx0XHRpZiggaW5pdGlhbERhdGEubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZURhdGEoIGluaXRpYWxEYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVEYXRhKCBkYXRhICkge1xuXHRcdFx0Y3VycmVudERhdGEgPSBkYXRhO1xuXHRcdFx0b3B0aW9ucy5zZWxlY3Rpb24uZGF0dW0oIGN1cnJlbnREYXRhICkuY2FsbCggY2hhcnQgKTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0dXBkYXRlKCkge1xuXHRcdFx0Y2hhcnQudXBkYXRlKCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0Z2V0Q2hhcnQoKSB7XG5cdFx0XHRyZXR1cm4gY2hhcnQ7XG5cdFx0fSxcblxuXHRcdGdldFNpemUoKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR3aWR0aDogcGFyc2VGbG9hdCggY2hhcnQuc3R5bGUoICd3aWR0aCcgKSApLFxuXHRcdFx0XHRoZWlnaHQ6IHBhcnNlRmxvYXQoIGNoYXJ0LnN0eWxlKCAnaGVpZ2h0JyApICksXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRnZXREcmF3aW5nQm91bmRzKCkge1xuXHRcdFx0bGV0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcblx0XHRcdGxldCBtYXJnaW4gPSB7IC4uLmNoYXJ0Lm1hcmdpbigpIH07XG5cblx0XHRcdGxldCBkcmF3aW5nQm91bmRzID0ge1xuXHRcdFx0XHR4OiBtYXJnaW4ubGVmdCxcblx0XHRcdFx0eTogbWFyZ2luLnRvcCxcblx0XHRcdFx0d2lkdGg6IHNpemUud2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcblx0XHRcdFx0aGVpZ2h0OiBzaXplLmhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tLFxuXHRcdFx0fTtcblxuXHRcdFx0ZHJhd2luZ0JvdW5kcy54MiA9IGRyYXdpbmdCb3VuZHMueCArIGRyYXdpbmdCb3VuZHMud2lkdGg7XG5cdFx0XHRkcmF3aW5nQm91bmRzLnkyID0gZHJhd2luZ0JvdW5kcy55ICsgZHJhd2luZ0JvdW5kcy5oZWlnaHQ7XG5cblx0XHRcdHJldHVybiBkcmF3aW5nQm91bmRzO1xuXHRcdH0sXG5cdH07XG5cblx0cmV0dXJuIGNoYXJ0T2JqZWN0O1xufVxuIiwiaW1wb3J0ICdjb3JlLWpzJztcblxuaW1wb3J0ICogYXMgZ3JhcGggZnJvbSAnLi9ncmFwaCc7XG5pbXBvcnQgY3JlYXRlR3Jvd3RoTWFzc0NoYXJ0IGZyb20gJy4vZ3Jvd3RoLW1hc3MtY2hhcnQnO1xuaW1wb3J0ICogYXMgcGFnZSBmcm9tICcuL3BhZ2UnO1xuXG5jb25zdCBjaGFydCA9IHtcbiAgY3JlYXRlR3Jvd3RoTWFzc0NoYXJ0LFxufTtcblxuZXhwb3J0IHtcbiAgZ3JhcGgsXG4gIGNoYXJ0LFxuICBwYWdlLFxufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRQYWdlKCkge1xuICBjb25zdCBlbGVtZW50cyA9IHtcbiAgICBwYWdlSGVhZGVyVGl0bGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYWdlLWhlYWRlci10aXRsZScpLFxuICAgIHBhbmVsSGVhZGVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQtcGFuZWwtaGVhZGVyJyksXG4gICAgcGFuZWxIZWFkZXJUaXRsZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0LXBhbmVsLWhlYWRlci10aXRsZScpLFxuICAgIGNoYXJ0Q2FudmFzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaHllbmEtY2hhcnQtY2FudmFzJyksXG4gICAgcGFuZWxGb290ZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydC1wYW5lbC1mb290ZXInKSxcbiAgICBwYWdlRm9vdGVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGFnZUZvb3RlcicpLFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZWxlbWVudHMsXG5cbiAgICBjaGFydENhbnZhc0lkOiAnaHllbmEtY2hhcnQtY2FudmFzJyxcblxuICAgIHNldFRpdGxlKG5leHRUaXRsZSkge1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBuZXh0VGl0bGU7XG4gICAgICBlbGVtZW50cy5wYWdlSGVhZGVyVGl0bGUuaW5uZXJUZXh0ID0gbmV4dFRpdGxlO1xuICAgIH0sXG5cbiAgICBzZXRQYW5lbFRpdGxlKG5leHRUaXRsZSkge1xuICAgICAgZWxlbWVudHMucGFuZWxIZWFkZXJUaXRsZS5pbm5lclRleHQgPSBuZXh0VGl0bGU7XG4gICAgfSxcblxuICAgIHNldFBhbmVsRm9vdGVyQ29udGVudChodG1sKSB7XG4gICAgICBlbGVtZW50cy5wYW5lbEZvb3Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBncmFwaCxcbiAgLy8gY2hhcnQsXG4gIC8vIHBhZ2UsXG59IGZyb20gJy4uLy4uL2FwcCc7XG5cbmV4cG9ydCBjb25zdCBiYXNlU2t5d29sZiA9IHtcbiAgbW9ub21vbGVjdWxhclBhcmFtczoge1xuICAgIC8vIDk1JSBsaW5lYXIgZ3Jvd3RoIGF0IDEyIG1vbnRocy5cbiAgICB0OTU6IDksIC8vbW9udGhzXG4gICAgQTogMSwgLy9yZWxhdGl2ZSBwcm9ncmVzc1xuICAgIEFfTDogMCxcbiAgICBTMDogMTUvMTIgLyA3LCAvL2Z0XG4gICAgbXQwOiA1LCAvL2xic1xuICAgIFNBOiA3LCAvL2Z0XG4gICAgLy8gTk9URTogVGhpcyBpcyB0aGUgYm9keSBtYXNzIGF0IHRoZSBlbmQgb2Ygc2tlbGV0YWwgZ3Jvd3RoLlxuICAgIC8vIEFmdGVyIHRoYXQsIHRoZSBib2R5IGNvbnRpbnVlcyB0byBidWlsZCBtdXNjbGUgbWFzcy5cbiAgICBtQTE6IDEzNywgLy9sYnNcbiAgICBtQTI6IDI1MCwgLy9sYnNcbiAgfSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb25vbW9sZWN1bGFyKHNreXdvbGYpIHtcbiAgY29uc3QgeyB0OTUsIEEsIEFfTCwgUzAgfSA9IHNreXdvbGYubW9ub21vbGVjdWxhclBhcmFtcztcbiAgcmV0dXJuIGdyYXBoLmdyb3d0aC5tb25vbW9sZWN1bGFyOTV0MShBLCBBX0wsIFMwLCB0OTUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyVG9NYXNzU2NhbGUoc2t5d29sZikge1xuICBjb25zdCB7IEEsIFMwLCBtdDAsIG1BMSB9ID0gc2t5d29sZi5tb25vbW9sZWN1bGFyUGFyYW1zO1xuICByZXR1cm4gZ3JhcGgudXRpbHMuY3ViaWNTY2FsZShcbiAgICBbUzAsIEFdLFxuICAgIFttdDAsIG1BMV1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclRvSGVpZ2h0U2NhbGUoc2t5d29sZikge1xuICByZXR1cm4gbCA9PiBsICogc2t5d29sZi5tb25vbW9sZWN1bGFyUGFyYW1zLlNBO1xufVxuIiwiaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0ICogYXMgbnYgZnJvbSAnbnZkMyc7XG5cbmltcG9ydCB7XG4gIGdyYXBoLFxuICBjaGFydCxcbiAgcGFnZSxcbn0gZnJvbSAnLi4vLi4vYXBwJztcblxuaW1wb3J0ICogYXMgZ3Jvd3RoIGZyb20gJy4vZ3Jvd3RoRnVuY3Rpb25zJztcblxuXG5jb25zdCBjdXJyZW50UGFnZSA9IHBhZ2UuZ2V0UGFnZSgpO1xuY29uc3QgQ0FOVkFTX1NFTEVDVE9SID0gYCMke2N1cnJlbnRQYWdlLmNoYXJ0Q2FudmFzSWR9YDtcbmNvbnN0IENBTlZBU19TRUxFQ1RJT04gPSBkMy5zZWxlY3QoQ0FOVkFTX1NFTEVDVE9SKTtcblxuY29uc3Qgc3BhbnMgPSBncmFwaC51dGlscy5zcGFubmVyKFtcbiAgeyBmcm9tOiAwLCB0bzogMTIgKiAyLjUsIGluY3JlbWVudDogMC41IH0sXG5dKTtcblxuZnVuY3Rpb24gcmVpZnlEYXRhKHNwYW5zLCBkYXRhRm4pIHtcbiAgcmV0dXJuIFsuLi5zcGFuc10ubWFwKHQgPT4gKHtcbiAgICB4OiB0LFxuICAgIHk6IGRhdGFGbih0KSxcbiAgfSkpO1xufVxuXG5jb25zdCBiYXNlU2t5d29sZkdyb3d0aCA9IGdyb3d0aC5tb25vbW9sZWN1bGFyKGdyb3d0aC5iYXNlU2t5d29sZik7XG5jb25zdCBiYXNlU2t5d29sZk1hc3NTY2FsZSA9IGdyb3d0aC5saW5lYXJUb01hc3NTY2FsZShncm93dGguYmFzZVNreXdvbGYpO1xuXG5jb25zdCBjaGFydERhdGEgPSBbXG4gIHtcbiAgICB2YWx1ZXM6IHJlaWZ5RGF0YShzcGFucywgZ3JhcGgudXRpbHMuY29tcChcbiAgICAgIGdyb3d0aC5saW5lYXJUb0hlaWdodFNjYWxlKGdyb3d0aC5iYXNlU2t5d29sZiksXG4gICAgICBiYXNlU2t5d29sZkdyb3d0aCxcbiAgICApKSxcbiAgICBrZXk6IFwiSGVpZ2h0XCIsXG4gICAgY29sb3I6ICcjQ0U0MDUwJ1xuICB9LFxuICB7XG4gICAgdmFsdWVzOiByZWlmeURhdGEoc3BhbnMsIGdyYXBoLnV0aWxzLnN1bShcbiAgICAgIGdyYXBoLnV0aWxzLmNvbXAoXG4gICAgICAgIGJhc2VTa3l3b2xmTWFzc1NjYWxlLFxuICAgICAgICBiYXNlU2t5d29sZkdyb3d0aCxcbiAgICAgICksXG4gICAgICAvLyBhZGQgYW55IHNpZ21vaWRzIGhlcmUuLi5cbiAgICAgIGdyYXBoLmN1cnZlcy5zY2FsZWRQYWRkZWRGbihcbiAgICAgICAgZ3JhcGguY3VydmVzLnF1ZXJwKFxuICAgICAgICAgIGdyYXBoLmN1cnZlcy5xdWFkLFxuICAgICAgICAgIGdyYXBoLmN1cnZlcy5pbnYoZ3JhcGguY3VydmVzLnF1YWQpXG4gICAgICAgICksXG4gICAgICAgIDYsIDI0LCAwLCBncm93dGguYmFzZVNreXdvbGYubW9ub21vbGVjdWxhclBhcmFtcy5tQTIgLSBncm93dGguYmFzZVNreXdvbGYubW9ub21vbGVjdWxhclBhcmFtcy5tQTEsXG4gICAgICAgIDEuNVxuICAgICAgKVxuICAgICkpLFxuICAgIGJhcjogdHJ1ZSxcbiAgICBrZXk6IFwiTWFzc1wiLFxuICAgIGNvbG9yOiAnIzMzOTBBNScsXG4gIH0sXG5dO1xuXG5jb25zdCBkYW5BbmRYaXJhaHNCYWJiaWVzQmlydGhEYXkgPSBuZXcgZ3JhcGgudXRpbHMuUHNldWRvRGF0ZSgnMjAxNy0wNC0wMScpO1xuXG5jb25zdCBncm93dGhDaGFydCA9IGNoYXJ0LmNyZWF0ZUdyb3d0aE1hc3NDaGFydCh7XG4gIHNlbGVjdGlvbjogQ0FOVkFTX1NFTEVDVElPTixcbiAgZm9yY2VZOiBbMCwgNy41XSxcbiAgeEF4aXM6IHtcbiAgICBsYWJlbDogXCJEYXRlXCIsXG4gICAgZm9ybWF0dGVyKCkge1xuICAgICAgY29uc3QgZm10ID0gZDMuZm9ybWF0KCcuMDFmJyk7XG4gICAgICBjb25zdCBkZm10ID0gZGFuQW5kWGlyYWhzQmFiYmllc0JpcnRoRGF5LnJlbGF0aXZlRm9ybWF0dGVyKCk7XG4gICAgICByZXR1cm4gdiA9PiB7XG4gICAgICAgIGNvbnN0IHlvZmYgPSBNYXRoLmZsb29yKHYgLyAxMik7XG4gICAgICAgIGNvbnN0IG1vZmYgPSB2ICUgMTI7XG4gICAgICAgIHJldHVybiBgJHtkZm10KHYpfSAoKyR7eW9mZn15LyR7Zm10KG1vZmYpfW0pYDtcbiAgICAgIH07XG4gICAgfSxcbiAgfSxcbiAgeUF4aXNNYXNzOiB7XG4gICAgbGFiZWw6IFwiQXBwcm94aW1hdGUgQm9keSBNYXNzXCIsXG4gICAgZm9ybWF0dGVyKCkge1xuICAgICAgY29uc3QgZm10ID0gZDMuZm9ybWF0KCAnLjAxZicgKTtcbiAgICAgIHJldHVybiB2ID0+IGAke2ZtdCh2KX0gbGJzYDtcbiAgICB9LFxuICB9LFxuICB5QXhpc0xpbmVhcjoge1xuICAgIGxhYmVsOiBcIkhlaWdodCBTdGFuZGluZyBVcFwiLFxuICAgIGZvcm1hdHRlcigpIHtcbiAgICAgIGNvbnN0IGZtdCA9IGQzLmZvcm1hdCggJy4wMWYnICk7XG4gICAgICByZXR1cm4gdiA9PiBgJHtmbXQodil9IGZ0YDtcbiAgICB9LFxuICB9LFxufSk7XG5cbm52LmFkZEdyYXBoKCgpID0+IHtcbiAgY29uc3QgY2hhcnRJbnN0ID0gZ3Jvd3RoQ2hhcnQuaW5pdChjaGFydERhdGEpLmdldENoYXJ0KCk7XG4gIG52LnV0aWxzLndpbmRvd1Jlc2l6ZSgoKSA9PiBncm93dGhDaGFydC51cGRhdGUoKSk7XG4gIHJldHVybiBjaGFydEluc3Q7XG59KTtcblxuY3VycmVudFBhZ2Uuc2V0VGl0bGUoXCJTa3l3b2x2ZXMhXCIpO1xuY3VycmVudFBhZ2Uuc2V0UGFuZWxUaXRsZShcIkRhbiBhbmQgWGlyYWgncyBLaWRzXCIpO1xuY3VycmVudFBhZ2Uuc2V0UGFuZWxGb290ZXJDb250ZW50KGBcbiAgPHA+VGhlaXIga2lkcyB3ZXJlIGJvcm4gb24gQXByaWwgMSwgMjAxNyBvdXIgdGltZSwgYW5kIHRoZSBkYXRlIHZhbHVlcyBwcm92aWRlZCByZWZsZWN0IHRoYXQuXG4gICAgSG93ZXZlciwgcmVsYXRpdmUgdGltZS1vZmZzZXRzIGFyZSBwcm92aWRlZCBmb3IgbW9yZSBnZW5lcmFsIHJlZmVyZW5jZS5cbiAgICBOb3RlIHRoYXQgdGhlIGNhbGN1bGF0ZWQgZGF0ZXMgYXJlIHRoZW1zZWx2ZXMgbm9ybWFsaXplZCBhcHByb3hpbWF0aW9ucyB0aGF0IGFyZSBkZXNpZ25lZFxuICAgIHRvIGZpdCB0aGUgeWVhcmx5IGN5Y2xlIG1vcmUgdGhhbiBleGFjdCBtb250aHMvZGF5cy48L3A+XG4gIDxwPlRoZSB2YWx1ZXMgcHJlc2VudGVkIGhlcmUgYXJlIHN0aWxsIGEgd29yayBpbiBwcm9ncmVzcyBwZW5kaW5nIGZlZWRiYWNrIGFuZCByZXNlYXJjaC48L3A+XG4gIDxwPlRoZSBiYXJzIGFuZCBsZWZ0IGF4aXMgaW5kaWNhdGUgdGhlIGFwcHJveGltYXRlIGJvZHkgbWFzcyBleHBlY3RlZCBhdCBhIGdpdmVuIGFnZS5cbiAgICBUaGUgbGluZSBhbmQgcmlnaHQgYXhpcyBpbmRpY2F0ZSB0aGUgbGluZWFyIGdyb3d0aCwgZXhwcmVzc2VkIGFzIHRoZWlyIGhlaWdodCBpbiBmZWV0IHN0YW5kaW5nIHVwLlxuICAgIFRoZSBib2R5IG1hc3MgaXMgZGVyaXZlZCBmcm9tIHRoZSA8ZW0+dW48L2VtPm5vcm1hbGl6ZWQgbGluZWFyIGdyb3d0aC48L3A+XG4gIDxwPkFnZSBhcyBpbmRpY2F0ZWQgaGVyZSBpcyBpbiBtb250aHMgc2luY2UgYmlydGgsIG5vdCBjb25jZXB0aW9uLiAgVGhpcyBpcyB3aHkgdGhlIG51bWJlcnMgZG9uJ3Qgc3RhcnQgYXQgMC48L3A+XG5gKTtcbiIsInJlcXVpcmUoJy4vc2hpbScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2NvcmUuZGljdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2NvcmUuZGVsYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9jb3JlLmZ1bmN0aW9uLnBhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9jb3JlLm9iamVjdC5pcy1vYmplY3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9jb3JlLm9iamVjdC5jbGFzc29mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvY29yZS5vYmplY3QuZGVmaW5lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvY29yZS5vYmplY3QubWFrZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2NvcmUubnVtYmVyLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvY29yZS5yZWdleHAuZXNjYXBlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvY29yZS5zdHJpbmcuZXNjYXBlLWh0bWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9jb3JlLnN0cmluZy51bmVzY2FwZS1odG1sJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbW9kdWxlcy9fY29yZScpOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZih0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59OyIsInZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIG1zZyl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnbnVtYmVyJyAmJiBjb2YoaXQpICE9ICdOdW1iZXInKXRocm93IFR5cGVFcnJvcihtc2cpO1xuICByZXR1cm4gK2l0O1xufTsiLCIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKVxuICAsIEFycmF5UHJvdG8gID0gQXJyYXkucHJvdG90eXBlO1xuaWYoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKXJlcXVpcmUoJy4vX2hpZGUnKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKXtcbiAgaWYoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSB8fCAoZm9yYmlkZGVuRmllbGQgIT09IHVuZGVmaW5lZCAmJiBmb3JiaWRkZW5GaWVsZCBpbiBpdCkpe1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBbXS5jb3B5V2l0aGluIHx8IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0Lyo9IDAqLywgc3RhcnQvKj0gMCwgZW5kID0gQGxlbmd0aCovKXtcbiAgdmFyIE8gICAgID0gdG9PYmplY3QodGhpcylcbiAgICAsIGxlbiAgID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCB0byAgICA9IHRvSW5kZXgodGFyZ2V0LCBsZW4pXG4gICAgLCBmcm9tICA9IHRvSW5kZXgoc3RhcnQsIGxlbilcbiAgICAsIGVuZCAgID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWRcbiAgICAsIGNvdW50ID0gTWF0aC5taW4oKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogdG9JbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pXG4gICAgLCBpbmMgICA9IDE7XG4gIGlmKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCl7XG4gICAgaW5jICA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICAgKz0gY291bnQgLSAxO1xuICB9XG4gIHdoaWxlKGNvdW50LS0gPiAwKXtcbiAgICBpZihmcm9tIGluIE8pT1t0b10gPSBPW2Zyb21dO1xuICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgIHRvICAgKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTsiLCIvLyAyMi4xLjMuNiBBcnJheS5wcm90b3R5cGUuZmlsbCh2YWx1ZSwgc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aClcbid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9JbmRleCAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKXtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoaXMpXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGFMZW4gICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ICA9IHRvSW5kZXgoYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIGxlbmd0aClcbiAgICAsIGVuZCAgICA9IGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkXG4gICAgLCBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvSW5kZXgoZW5kLCBsZW5ndGgpO1xuICB3aGlsZShlbmRQb3MgPiBpbmRleClPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdGVyLCBJVEVSQVRPUil7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07IiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTsiLCIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJylcbiAgLy8gRVMzIHdyb25nIGhlcmVcbiAgLCBBUkcgPSBjb2YoZnVuY3Rpb24oKXsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGNyZWF0ZSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKVxuICAsIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBhbkluc3RhbmNlICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJylcbiAgLCBzdGVwICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgc2V0U3BlY2llcyAgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgZmFzdEtleSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleVxuICAsIFNJWkUgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbih0aGF0LCBrZXkpe1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpLCBlbnRyeTtcbiAgaWYoaW5kZXggIT09ICdGJylyZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKXtcbiAgICBpZihlbnRyeS5rID09IGtleSlyZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKXtcbiAgICAgICAgZm9yKHZhciB0aGF0ID0gdGhpcywgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubil7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYoZW50cnkucCllbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICB2YXIgdGhhdCAgPSB0aGlzXG4gICAgICAgICAgLCBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmKGVudHJ5KXtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5cbiAgICAgICAgICAgICwgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYocHJldilwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmKG5leHQpbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZih0aGF0Ll9mID09IGVudHJ5KXRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmKHRoYXQuX2wgPT0gZW50cnkpdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgICAgICBhbkluc3RhbmNlKHRoaXMsIEMsICdmb3JFYWNoJyk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKVxuICAgICAgICAgICwgZW50cnk7XG4gICAgICAgIHdoaWxlKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZil7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZShlbnRyeSAmJiBlbnRyeS5yKWVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KXtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZihERVNDUklQVE9SUylkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiBkZWZpbmVkKHRoaXNbU0laRV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSlcbiAgICAgICwgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYoZW50cnkpe1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYoIXRoYXQuX2YpdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYocHJldilwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYoaW5kZXggIT09ICdGJyl0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbihDLCBOQU1FLCBJU19NQVApe1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbihpdGVyYXRlZCwga2luZCl7XG4gICAgICB0aGlzLl90ID0gaXRlcmF0ZWQ7ICAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7IC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24oKXtcbiAgICAgIHZhciB0aGF0ICA9IHRoaXNcbiAgICAgICAgLCBraW5kICA9IHRoYXQuX2tcbiAgICAgICAgLCBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlKGVudHJ5ICYmIGVudHJ5LnIpZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpe1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJyAsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59OyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgZnJvbSAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSl7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKXtcbiAgICBpZihjbGFzc29mKHRoaXMpICE9IE5BTUUpdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBnZXRXZWFrICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5nZXRXZWFrXG4gICwgYW5PYmplY3QgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBmb3JPZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2Zvci1vZicpXG4gICwgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJylcbiAgLCAkaGFzICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgYXJyYXlGaW5kICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg1KVxuICAsIGFycmF5RmluZEluZGV4ICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNilcbiAgLCBpZCAgICAgICAgICAgICAgICA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbih0aGF0KXtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24oc3RvcmUsIGtleSl7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbn07XG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbihrZXkpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KXJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpe1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmKGVudHJ5KWVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgaW5kZXggPSBhcnJheUZpbmRJbmRleCh0aGlzLmEsIGZ1bmN0aW9uKGl0KXtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmKH5pbmRleCl0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24od3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUil7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGl0ZXJhYmxlKXtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMy4zLjIgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjQuMy4zIFdlYWtTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbihrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpe1xuICAgICAgICBpZighaXNPYmplY3Qoa2V5KSlyZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZihkYXRhID09PSB0cnVlKXJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHRoaXMpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uKHRoYXQsIGtleSwgdmFsdWUpe1xuICAgIHZhciBkYXRhID0gZ2V0V2Vhayhhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICBpZihkYXRhID09PSB0cnVlKXVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIHJlZGVmaW5lQWxsICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBtZXRhICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKVxuICAsIGZvck9mICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBhbkluc3RhbmNlICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJylcbiAgLCBpc09iamVjdCAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJGl0ZXJEZXRlY3QgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgICAgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTkFNRSwgd3JhcHBlciwgbWV0aG9kcywgY29tbW9uLCBJU19NQVAsIElTX1dFQUspe1xuICB2YXIgQmFzZSAgPSBnbG9iYWxbTkFNRV1cbiAgICAsIEMgICAgID0gQmFzZVxuICAgICwgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnXG4gICAgLCBwcm90byA9IEMgJiYgQy5wcm90b3R5cGVcbiAgICAsIE8gICAgID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbihLRVkpe1xuICAgIHZhciBmbiA9IHByb3RvW0tFWV07XG4gICAgcmVkZWZpbmUocHJvdG8sIEtFWSxcbiAgICAgIEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uKGEpe1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSl7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChhKSA/IGZhbHNlIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChhKXtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpOyByZXR1cm4gdGhpczsgfVxuICAgICAgICA6IGZ1bmN0aW9uIHNldChhLCBiKXsgZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEsIGIpOyByZXR1cm4gdGhpczsgfVxuICAgICk7XG4gIH07XG4gIGlmKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgbmV3IEMoKS5lbnRyaWVzKCkubmV4dCgpO1xuICB9KSkpe1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgICAgICAgICAgICAgPSBuZXcgQ1xuICAgICAgLy8gZWFybHkgaW1wbGVtZW50YXRpb25zIG5vdCBzdXBwb3J0cyBjaGFpbmluZ1xuICAgICAgLCBIQVNOVF9DSEFJTklORyAgICAgICA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2VcbiAgICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgICAgLCBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uKCl7IGluc3RhbmNlLmhhcygxKTsgfSlcbiAgICAgIC8vIG1vc3QgZWFybHkgaW1wbGVtZW50YXRpb25zIGRvZXNuJ3Qgc3VwcG9ydHMgaXRlcmFibGVzLCBtb3N0IG1vZGVybiAtIG5vdCBjbG9zZSBpdCBjb3JyZWN0bHlcbiAgICAgICwgQUNDRVBUX0lURVJBQkxFUyAgICAgPSAkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXsgbmV3IEMoaXRlcik7IH0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICAgICwgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgICB2YXIgJGluc3RhbmNlID0gbmV3IEMoKVxuICAgICAgICAgICwgaW5kZXggICAgID0gNTtcbiAgICAgICAgd2hpbGUoaW5kZXgtLSkkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gICAgICB9KTtcbiAgICBpZighQUNDRVBUX0lURVJBQkxFUyl7IFxuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCBpdGVyYWJsZSl7XG4gICAgICAgIGFuSW5zdGFuY2UodGFyZ2V0LCBDLCBOQU1FKTtcbiAgICAgICAgdmFyIHRoYXQgPSBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSwgdGFyZ2V0LCBDKTtcbiAgICAgICAgaWYoaXRlcmFibGUgIT0gdW5kZWZpbmVkKWZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmKFRIUk9XU19PTl9QUklNSVRJVkVTIHx8IEJVR0dZX1pFUk8pe1xuICAgICAgZml4TWV0aG9kKCdkZWxldGUnKTtcbiAgICAgIGZpeE1ldGhvZCgnaGFzJyk7XG4gICAgICBJU19NQVAgJiYgZml4TWV0aG9kKCdnZXQnKTtcbiAgICB9XG4gICAgaWYoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORylmaXhNZXRob2QoQURERVIpO1xuICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgc2hvdWxkIG5vdCBjb250YWlucyAuY2xlYXIgbWV0aG9kXG4gICAgaWYoSVNfV0VBSyAmJiBwcm90by5jbGVhcilkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYoIUlTX1dFQUspY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTsiLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0ge3ZlcnNpb246ICcyLjQuMCd9O1xuaWYodHlwZW9mIF9fZSA9PSAnbnVtYmVyJylfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgY3JlYXRlRGVzYyAgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iamVjdCwgaW5kZXgsIHZhbHVlKXtcbiAgaWYoaW5kZXggaW4gb2JqZWN0KSRkZWZpbmVQcm9wZXJ0eS5mKG9iamVjdCwgaW5kZXgsIGNyZWF0ZURlc2MoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG59OyIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgTlVNQkVSICAgICAgPSAnbnVtYmVyJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihoaW50KXtcbiAgaWYoaGludCAhPT0gJ3N0cmluZycgJiYgaGludCAhPT0gTlVNQkVSICYmIGhpbnQgIT09ICdkZWZhdWx0Jyl0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBoaW50Jyk7XG4gIHJldHVybiB0b1ByaW1pdGl2ZShhbk9iamVjdCh0aGlzKSwgaGludCAhPSBOVU1CRVIpO1xufTsiLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ID09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50XG4gIC8vIGluIG9sZCBJRSB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0J1xuICAsIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59OyIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpOyIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHJlc3VsdCAgICAgPSBnZXRLZXlzKGl0KVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYoZ2V0U3ltYm9scyl7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KVxuICAgICAgLCBpc0VudW0gID0gcElFLmZcbiAgICAgICwgaSAgICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKHN5bWJvbHMubGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGNvcmUgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBjdHggICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIHNvdXJjZSl7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GXG4gICAgLCBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HXG4gICAgLCBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TXG4gICAgLCBJU19QUk9UTyAgPSB0eXBlICYgJGV4cG9ydC5QXG4gICAgLCBJU19CSU5EICAgPSB0eXBlICYgJGV4cG9ydC5CXG4gICAgLCB0YXJnZXQgICAgPSBJU19HTE9CQUwgPyBnbG9iYWwgOiBJU19TVEFUSUMgPyBnbG9iYWxbbmFtZV0gfHwgKGdsb2JhbFtuYW1lXSA9IHt9KSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV1cbiAgICAsIGV4cG9ydHMgICA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pXG4gICAgLCBleHBQcm90byAgPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KVxuICAgICwga2V5LCBvd24sIG91dCwgZXhwO1xuICBpZihJU19HTE9CQUwpc291cmNlID0gbmFtZTtcbiAgZm9yKGtleSBpbiBzb3VyY2Upe1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmKHRhcmdldClyZWRlZmluZSh0YXJnZXQsIGtleSwgb3V0LCB0eXBlICYgJGV4cG9ydC5VKTtcbiAgICAvLyBleHBvcnRcbiAgICBpZihleHBvcnRzW2tleV0gIT0gb3V0KWhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmKElTX1BST1RPICYmIGV4cFByb3RvW2tleV0gIT0gb3V0KWV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgIFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OyIsInZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVkpe1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2goZSl7XG4gICAgdHJ5IHtcbiAgICAgIHJlW01BVENIXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuICEnLy4vJ1tLRVldKHJlKTtcbiAgICB9IGNhdGNoKGYpeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIHRydWU7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZXhlYyl7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoKGUpe1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcbnZhciBoaWRlICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGZhaWxzICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgd2tzICAgICAgPSByZXF1aXJlKCcuL193a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGxlbmd0aCwgZXhlYyl7XG4gIHZhciBTWU1CT0wgICA9IHdrcyhLRVkpXG4gICAgLCBmbnMgICAgICA9IGV4ZWMoZGVmaW5lZCwgU1lNQk9MLCAnJ1tLRVldKVxuICAgICwgc3RyZm4gICAgPSBmbnNbMF1cbiAgICAsIHJ4Zm4gICAgID0gZm5zWzFdO1xuICBpZihmYWlscyhmdW5jdGlvbigpe1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSkpe1xuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24oc3RyaW5nLCBhcmcpeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uKHN0cmluZyl7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMi41LjMgZ2V0IFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpe1xuICB2YXIgdGhhdCAgID0gYW5PYmplY3QodGhpcylcbiAgICAsIHJlc3VsdCA9ICcnO1xuICBpZih0aGF0Lmdsb2JhbCkgICAgIHJlc3VsdCArPSAnZyc7XG4gIGlmKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYodGhhdC5tdWx0aWxpbmUpICByZXN1bHQgKz0gJ20nO1xuICBpZih0aGF0LnVuaWNvZGUpICAgIHJlc3VsdCArPSAndSc7XG4gIGlmKHRoYXQuc3RpY2t5KSAgICAgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwidmFyIGN0eCAgICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBjYWxsICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9MZW5ndGggICAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGdldEl0ZXJGbiAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKVxuICAsIEJSRUFLICAgICAgID0ge31cbiAgLCBSRVRVUk4gICAgICA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhYmxlLCBlbnRyaWVzLCBmbiwgdGhhdCwgSVRFUkFUT1Ipe1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbigpeyByZXR1cm4gaXRlcmFibGU7IH0gOiBnZXRJdGVyRm4oaXRlcmFibGUpXG4gICAgLCBmICAgICAgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSlcbiAgICAsIGluZGV4ICA9IDBcbiAgICAsIGxlbmd0aCwgc3RlcCwgaXRlcmF0b3IsIHJlc3VsdDtcbiAgaWYodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYoaXNBcnJheUl0ZXIoaXRlckZuKSlmb3IobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4Kyspe1xuICAgIHJlc3VsdCA9IGVudHJpZXMgPyBmKGFuT2JqZWN0KHN0ZXAgPSBpdGVyYWJsZVtpbmRleF0pWzBdLCBzdGVwWzFdKSA6IGYoaXRlcmFibGVbaW5kZXhdKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgKXtcbiAgICByZXN1bHQgPSBjYWxsKGl0ZXJhdG9yLCBmLCBzdGVwLnZhbHVlLCBlbnRyaWVzKTtcbiAgICBpZihyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKXJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLICA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCBJVEVSQVRPUiAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCIvLyAyMC4xLjIuMyBOdW1iZXIuaXNJbnRlZ2VyKG51bWJlcilcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmxvb3IgICAgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpe1xuICByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIi8vIDcuMi44IElzUmVnRXhwKGFyZ3VtZW50KVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBjb2YgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgTUFUQ0ggICAgPSByZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjb2YoaXQpID09ICdSZWdFeHAnKTtcbn07IiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpe1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2goZSl7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZihyZXQgIT09IHVuZGVmaW5lZClhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZGVzY3JpcHRvciAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKVxucmVxdWlyZSgnLi9faGlkZScpKEl0ZXJhdG9yUHJvdG90eXBlLCByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7bmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KX0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHJlZGVmaW5lICAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIEl0ZXJhdG9ycyAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIElURVJBVE9SICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBCVUdHWSAgICAgICAgICA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKSAvLyBTYWZhcmkgaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gICwgRkZfSVRFUkFUT1IgICAgPSAnQEBpdGVyYXRvcidcbiAgLCBLRVlTICAgICAgICAgICA9ICdrZXlzJ1xuICAsIFZBTFVFUyAgICAgICAgID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKXtcbiAgJGl0ZXJDcmVhdGUoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpO1xuICB2YXIgZ2V0TWV0aG9kID0gZnVuY3Rpb24oa2luZCl7XG4gICAgaWYoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaChraW5kKXtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICB9O1xuICB2YXIgVEFHICAgICAgICA9IE5BTUUgKyAnIEl0ZXJhdG9yJ1xuICAgICwgREVGX1ZBTFVFUyA9IERFRkFVTFQgPT0gVkFMVUVTXG4gICAgLCBWQUxVRVNfQlVHID0gZmFsc2VcbiAgICAsIHByb3RvICAgICAgPSBCYXNlLnByb3RvdHlwZVxuICAgICwgJG5hdGl2ZSAgICA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXVxuICAgICwgJGRlZmF1bHQgICA9ICRuYXRpdmUgfHwgZ2V0TWV0aG9kKERFRkFVTFQpXG4gICAgLCAkZW50cmllcyAgID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZFxuICAgICwgJGFueU5hdGl2ZSA9IE5BTUUgPT0gJ0FycmF5JyA/IHByb3RvLmVudHJpZXMgfHwgJG5hdGl2ZSA6ICRuYXRpdmVcbiAgICAsIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYoJGFueU5hdGl2ZSl7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZigkYW55TmF0aXZlLmNhbGwobmV3IEJhc2UpKTtcbiAgICBpZihJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSl7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyhJdGVyYXRvclByb3RvdHlwZSwgVEFHLCB0cnVlKTtcbiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lc1xuICAgICAgaWYoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZihERUZfVkFMVUVTICYmICRuYXRpdmUgJiYgJG5hdGl2ZS5uYW1lICE9PSBWQUxVRVMpe1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmKCghTElCUkFSWSB8fCBGT1JDRUQpICYmIChCVUdHWSB8fCBWQUxVRVNfQlVHIHx8ICFwcm90b1tJVEVSQVRPUl0pKXtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddICA9IHJldHVyblRoaXM7XG4gIGlmKERFRkFVTFQpe1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6ICBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6ICAgIElTX1NFVCAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICRlbnRyaWVzXG4gICAgfTtcbiAgICBpZihGT1JDRUQpZm9yKGtleSBpbiBtZXRob2RzKXtcbiAgICAgIGlmKCEoa2V5IGluIHByb3RvKSlyZWRlZmluZShwcm90bywga2V5LCBtZXRob2RzW2tleV0pO1xuICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZHM7XG59OyIsInZhciBJVEVSQVRPUiAgICAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uKCl7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uKCl7IHRocm93IDI7IH0pO1xufSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMsIHNraXBDbG9zaW5nKXtcbiAgaWYoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpcmV0dXJuIGZhbHNlO1xuICB2YXIgc2FmZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBhcnIgID0gWzddXG4gICAgICAsIGl0ZXIgPSBhcnJbSVRFUkFUT1JdKCk7XG4gICAgaXRlci5uZXh0ID0gZnVuY3Rpb24oKXsgcmV0dXJuIHtkb25lOiBzYWZlID0gdHJ1ZX07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCl7IHJldHVybiBpdGVyOyB9O1xuICAgIGV4ZWMoYXJyKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkb25lLCB2YWx1ZSl7XG4gIHJldHVybiB7dmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmV9O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHt9OyIsInZhciBnZXRLZXlzICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIGVsKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBrZXlzICAgPSBnZXRLZXlzKE8pXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaW5kZXggID0gMFxuICAgICwga2V5O1xuICB3aGlsZShsZW5ndGggPiBpbmRleClpZihPW2tleSA9IGtleXNbaW5kZXgrK11dID09PSBlbClyZXR1cm4ga2V5O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlOyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG0xID0gTWF0aC5leHBtMTtcbm1vZHVsZS5leHBvcnRzID0gKCEkZXhwbTFcbiAgLy8gT2xkIEZGIGJ1Z1xuICB8fCAkZXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8ICRleHBtMSgxMCkgPCAyMjAyNS40NjU3OTQ4MDY3MTY1MTY4XG4gIC8vIFRvciBCcm93c2VyIGJ1Z1xuICB8fCAkZXhwbTEoLTJlLTE3KSAhPSAtMmUtMTdcbikgPyBmdW5jdGlvbiBleHBtMSh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogeCA+IC0xZS02ICYmIHggPCAxZS02ID8geCArIHggKiB4IC8gMiA6IE1hdGguZXhwKHgpIC0gMTtcbn0gOiAkZXhwbTE7IiwiLy8gMjAuMi4yLjIwIE1hdGgubG9nMXAoeClcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5sb2cxcCB8fCBmdW5jdGlvbiBsb2cxcCh4KXtcbiAgcmV0dXJuICh4ID0gK3gpID4gLTFlLTggJiYgeCA8IDFlLTggPyB4IC0geCAqIHggLyAyIDogTWF0aC5sb2coMSArIHgpO1xufTsiLCIvLyAyMC4yLjIuMjggTWF0aC5zaWduKHgpXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpe1xuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59OyIsInZhciBNRVRBICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJylcbiAgLCBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaGFzICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIHNldERlc2MgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGlkICAgICAgID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uKGl0KXtcbiAgc2V0RGVzYyhpdCwgTUVUQSwge3ZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfX0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24oaXQsIGNyZWF0ZSl7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uKGl0LCBjcmVhdGUpe1xuICBpZighaGFzKGl0LCBNRVRBKSl7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZighaXNFeHRlbnNpYmxlKGl0KSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmKCFjcmVhdGUpcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbihpdCl7XG4gIGlmKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSlzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogICAgICBNRVRBLFxuICBORUVEOiAgICAgZmFsc2UsXG4gIGZhc3RLZXk6ICBmYXN0S2V5LFxuICBnZXRXZWFrOiAgZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59OyIsInZhciBNYXAgICAgID0gcmVxdWlyZSgnLi9lczYubWFwJylcbiAgLCAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaGFyZWQgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ21ldGFkYXRhJylcbiAgLCBzdG9yZSAgID0gc2hhcmVkLnN0b3JlIHx8IChzaGFyZWQuc3RvcmUgPSBuZXcgKHJlcXVpcmUoJy4vZXM2LndlYWstbWFwJykpKTtcblxudmFyIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSwgY3JlYXRlKXtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIGlmKCF0YXJnZXRNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHN0b3JlLnNldCh0YXJnZXQsIHRhcmdldE1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH1cbiAgdmFyIGtleU1ldGFkYXRhID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KHRhcmdldEtleSk7XG4gIGlmKCFrZXlNZXRhZGF0YSl7XG4gICAgaWYoIWNyZWF0ZSlyZXR1cm4gdW5kZWZpbmVkO1xuICAgIHRhcmdldE1ldGFkYXRhLnNldCh0YXJnZXRLZXksIGtleU1ldGFkYXRhID0gbmV3IE1hcCk7XG4gIH0gcmV0dXJuIGtleU1ldGFkYXRhO1xufTtcbnZhciBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIGZhbHNlKTtcbiAgcmV0dXJuIG1ldGFkYXRhTWFwID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGFkYXRhTWFwLmhhcyhNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgZmFsc2UpO1xuICByZXR1cm4gbWV0YWRhdGFNYXAgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG1ldGFkYXRhTWFwLmdldChNZXRhZGF0YUtleSk7XG59O1xudmFyIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCl7XG4gIGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgdHJ1ZSkuc2V0KE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlKTtcbn07XG52YXIgb3JkaW5hcnlPd25NZXRhZGF0YUtleXMgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldEtleSl7XG4gIHZhciBtZXRhZGF0YU1hcCA9IGdldE9yQ3JlYXRlTWV0YWRhdGFNYXAodGFyZ2V0LCB0YXJnZXRLZXksIGZhbHNlKVxuICAgICwga2V5cyAgICAgICAgPSBbXTtcbiAgaWYobWV0YWRhdGFNYXApbWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbihfLCBrZXkpeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufTtcbnZhciB0b01ldGFLZXkgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG52YXIgZXhwID0gZnVuY3Rpb24oTyl7XG4gICRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIE8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0b3JlOiBzdG9yZSxcbiAgbWFwOiBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwLFxuICBoYXM6IG9yZGluYXJ5SGFzT3duTWV0YWRhdGEsXG4gIGdldDogb3JkaW5hcnlHZXRPd25NZXRhZGF0YSxcbiAgc2V0OiBvcmRpbmFyeURlZmluZU93bk1ldGFkYXRhLFxuICBrZXlzOiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAga2V5OiB0b01ldGFLZXksXG4gIGV4cDogZXhwXG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXRcbiAgLCBPYnNlcnZlciAgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlclxuICAsIHByb2Nlc3MgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgUHJvbWlzZSAgID0gZ2xvYmFsLlByb21pc2VcbiAgLCBpc05vZGUgICAgPSByZXF1aXJlKCcuL19jb2YnKShwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXtcbiAgdmFyIGhlYWQsIGxhc3QsIG5vdGlmeTtcblxuICB2YXIgZmx1c2ggPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmKGlzTm9kZSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKXBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUoaGVhZCl7XG4gICAgICBmbiAgID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgaWYoaGVhZClub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZihwYXJlbnQpcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZihpc05vZGUpe1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXJcbiAgfSBlbHNlIGlmKE9ic2VydmVyKXtcbiAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgLCBub2RlICAgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKXtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgICBwcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ1xuICAvLyAtIG9ucmVhZHlzdGF0ZWNoYW5nZVxuICAvLyAtIHNldFRpbWVvdXRcbiAgfSBlbHNlIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmbil7XG4gICAgdmFyIHRhc2sgPSB7Zm46IGZuLCBuZXh0OiB1bmRlZmluZWR9O1xuICAgIGlmKGxhc3QpbGFzdC5uZXh0ID0gdGFzaztcbiAgICBpZighaGVhZCl7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGRQICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgZ09QRCAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsIG93bktleXMgICA9IHJlcXVpcmUoJy4vX293bi1rZXlzJylcbiAgLCB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lKHRhcmdldCwgbWl4aW4pe1xuICB2YXIga2V5cyAgID0gb3duS2V5cyh0b0lPYmplY3QobWl4aW4pKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgPSAwLCBrZXk7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZih0YXJnZXQsIGtleSA9IGtleXNbaSsrXSwgZ09QRC5mKG1peGluLCBrZXkpKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59OyIsIi8vIEZvcmNlZCByZXBsYWNlbWVudCBwcm90b3R5cGUgYWNjZXNzb3JzIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fbGlicmFyeScpfHwgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEsgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwgSywgZnVuY3Rpb24oKXsgLyogZW1wdHkgKi99KTtcbiAgZGVsZXRlIHJlcXVpcmUoJy4vX2dsb2JhbCcpW0tdO1xufSk7IiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBnT1BOICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCB0b1N0cmluZyAgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uKGl0KXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7IiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9PYmplY3QgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihPKXtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZihoYXMoTywgSUVfUFJPVE8pKXJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcil7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTsiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07IiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJ2YXIgZ2V0S2V5cyAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIGlzRW51bSAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc0VudHJpZXMpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoaXQpXG4gICAgICAsIGtleXMgICA9IGdldEtleXMoTylcbiAgICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICwgaSAgICAgID0gMFxuICAgICAgLCByZXN1bHQgPSBbXVxuICAgICAgLCBrZXk7XG4gICAgd2hpbGUobGVuZ3RoID4gaSlpZihpc0VudW0uY2FsbChPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07IiwiLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBSZWZsZWN0ICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3QgJiYgUmVmbGVjdC5vd25LZXlzIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpe1xuICB2YXIga2V5cyAgICAgICA9IGdPUE4uZihhbk9iamVjdChpdCkpXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59OyIsInZhciAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlRmxvYXRcbiAgLCAkdHJpbSAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbTtcblxubW9kdWxlLmV4cG9ydHMgPSAxIC8gJHBhcnNlRmxvYXQocmVxdWlyZSgnLi9fc3RyaW5nLXdzJykgKyAnLTAnKSAhPT0gLUluZmluaXR5ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHIpe1xuICB2YXIgc3RyaW5nID0gJHRyaW0oU3RyaW5nKHN0ciksIDMpXG4gICAgLCByZXN1bHQgPSAkcGFyc2VGbG9hdChzdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHN0cmluZy5jaGFyQXQoMCkgPT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQ7IiwidmFyICRwYXJzZUludCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLnBhcnNlSW50XG4gICwgJHRyaW0gICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgd3MgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBoZXggICAgICAgPSAvXltcXC0rXT8wW3hYXS87XG5cbm1vZHVsZS5leHBvcnRzID0gJHBhcnNlSW50KHdzICsgJzA4JykgIT09IDggfHwgJHBhcnNlSW50KHdzICsgJzB4MTYnKSAhPT0gMjIgPyBmdW5jdGlvbiBwYXJzZUludChzdHIsIHJhZGl4KXtcbiAgdmFyIHN0cmluZyA9ICR0cmltKFN0cmluZyhzdHIpLCAzKTtcbiAgcmV0dXJuICRwYXJzZUludChzdHJpbmcsIChyYWRpeCA+Pj4gMCkgfHwgKGhleC50ZXN0KHN0cmluZykgPyAxNiA6IDEwKSk7XG59IDogJHBhcnNlSW50OyIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXRoICAgICAgPSByZXF1aXJlKCcuL19wYXRoJylcbiAgLCBpbnZva2UgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oLyogLi4ucGFyZ3MgKi8pe1xuICB2YXIgZm4gICAgID0gYUZ1bmN0aW9uKHRoaXMpXG4gICAgLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBwYXJncyAgPSBBcnJheShsZW5ndGgpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBfICAgICAgPSBwYXRoLl9cbiAgICAsIGhvbGRlciA9IGZhbHNlO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKChwYXJnc1tpXSA9IGFyZ3VtZW50c1tpKytdKSA9PT0gXylob2xkZXIgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIHRoYXQgPSB0aGlzXG4gICAgICAsIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIGogPSAwLCBrID0gMCwgYXJncztcbiAgICBpZighaG9sZGVyICYmICFhTGVuKXJldHVybiBpbnZva2UoZm4sIHBhcmdzLCB0aGF0KTtcbiAgICBhcmdzID0gcGFyZ3Muc2xpY2UoKTtcbiAgICBpZihob2xkZXIpZm9yKDtsZW5ndGggPiBqOyBqKyspaWYoYXJnc1tqXSA9PT0gXylhcmdzW2pdID0gYXJndW1lbnRzW2srK107XG4gICAgd2hpbGUoYUxlbiA+IGspYXJncy5wdXNoKGFyZ3VtZW50c1trKytdKTtcbiAgICByZXR1cm4gaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19nbG9iYWwnKTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGFyZ2V0LCBzcmMsIHNhZmUpe1xuICBmb3IodmFyIGtleSBpbiBzcmMpcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNyY1trZXldLCBzYWZlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihyZWdFeHAsIHJlcGxhY2Upe1xuICB2YXIgcmVwbGFjZXIgPSByZXBsYWNlID09PSBPYmplY3QocmVwbGFjZSkgPyBmdW5jdGlvbihwYXJ0KXtcbiAgICByZXR1cm4gcmVwbGFjZVtwYXJ0XTtcbiAgfSA6IHJlcGxhY2U7XG4gIHJldHVybiBmdW5jdGlvbihpdCl7XG4gICAgcmV0dXJuIFN0cmluZyhpdCkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2VyKTtcbiAgfTtcbn07IiwiLy8gNy4yLjkgU2FtZVZhbHVlKHgsIHkpXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KXtcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59OyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGRQICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJylcbiAgLCBTUEVDSUVTICAgICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZKXtcbiAgdmFyIEMgPSBnbG9iYWxbS0VZXTtcbiAgaWYoREVTQ1JJUFRPUlMgJiYgQyAmJiAhQ1tTUEVDSUVTXSlkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfVxuICB9KTtcbn07IiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBoYXMgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCB0YWcsIHN0YXQpe1xuICBpZihpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKWRlZihpdCwgVEFHLCB7Y29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnfSk7XG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBTUEVDSUVTICAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBEKXtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvciwgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTsiLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1ldGhvZCwgYXJnKXtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgYXJnID8gbWV0aG9kLmNhbGwobnVsbCwgZnVuY3Rpb24oKXt9LCAxKSA6IG1ldGhvZC5jYWxsKG51bGwpO1xuICB9KTtcbn07IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIGRlZmluZWQgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07IiwiLy8gaGVscGVyIGZvciBTdHJpbmcje3N0YXJ0c1dpdGgsIGVuZHNXaXRoLCBpbmNsdWRlc31cbnZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZGVmaW5lZCAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgc2VhcmNoU3RyaW5nLCBOQU1FKXtcbiAgaWYoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSl0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZyMnICsgTkFNRSArIFwiIGRvZXNuJ3QgYWNjZXB0IHJlZ2V4IVwiKTtcbiAgcmV0dXJuIFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbn07IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHF1b3QgICAgPSAvXCIvZztcbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxudmFyIGNyZWF0ZUhUTUwgPSBmdW5jdGlvbihzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyAgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKVxuICAgICwgcDEgPSAnPCcgKyB0YWc7XG4gIGlmKGF0dHJpYnV0ZSAhPT0gJycpcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOQU1FLCBleGVjKXtcbiAgdmFyIE8gPSB7fTtcbiAgT1tOQU1FXSA9IGV4ZWMoY3JlYXRlSFRNTCk7XG4gICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXtcbiAgICB2YXIgdGVzdCA9ICcnW05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KSwgJ1N0cmluZycsIE8pO1xufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1zdHJpbmctcGFkLXN0YXJ0LWVuZFxudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCByZXBlYXQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsIGRlZmluZWQgID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIG1heExlbmd0aCwgZmlsbFN0cmluZywgbGVmdCl7XG4gIHZhciBTICAgICAgICAgICAgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSlcbiAgICAsIHN0cmluZ0xlbmd0aCA9IFMubGVuZ3RoXG4gICAgLCBmaWxsU3RyICAgICAgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZylcbiAgICAsIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gIGlmKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PSAnJylyZXR1cm4gUztcbiAgdmFyIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGhcbiAgICAsIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIE1hdGguY2VpbChmaWxsTGVuIC8gZmlsbFN0ci5sZW5ndGgpKTtcbiAgaWYoc3RyaW5nRmlsbGVyLmxlbmd0aCA+IGZpbGxMZW4pc3RyaW5nRmlsbGVyID0gc3RyaW5nRmlsbGVyLnNsaWNlKDAsIGZpbGxMZW4pO1xuICByZXR1cm4gbGVmdCA/IHN0cmluZ0ZpbGxlciArIFMgOiBTICsgc3RyaW5nRmlsbGVyO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBkZWZpbmVkICAgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGNvdW50KXtcbiAgdmFyIHN0ciA9IFN0cmluZyhkZWZpbmVkKHRoaXMpKVxuICAgICwgcmVzID0gJydcbiAgICAsIG4gICA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpdGhyb3cgUmFuZ2VFcnJvcihcIkNvdW50IGNhbid0IGJlIG5lZ2F0aXZlXCIpO1xuICBmb3IoO24gPiAwOyAobiA+Pj49IDEpICYmIChzdHIgKz0gc3RyKSlpZihuICYgMSlyZXMgKz0gc3RyO1xuICByZXR1cm4gcmVzO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc3BhY2VzICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgc3BhY2UgICA9ICdbJyArIHNwYWNlcyArICddJ1xuICAsIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnXG4gICwgbHRyaW0gICA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKVxuICAsIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYoVFlQRSAmIDEpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYoVFlQRSAmIDIpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7IiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnOyIsInZhciBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGludm9rZSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgaHRtbCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faHRtbCcpXG4gICwgY2VsICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsIHNldFRhc2sgICAgICAgICAgICA9IGdsb2JhbC5zZXRJbW1lZGlhdGVcbiAgLCBjbGVhclRhc2sgICAgICAgICAgPSBnbG9iYWwuY2xlYXJJbW1lZGlhdGVcbiAgLCBNZXNzYWdlQ2hhbm5lbCAgICAgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWxcbiAgLCBjb3VudGVyICAgICAgICAgICAgPSAwXG4gICwgcXVldWUgICAgICAgICAgICAgID0ge31cbiAgLCBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJ1xuICAsIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpZCA9ICt0aGlzO1xuICBpZihxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpe1xuICAgIHZhciBmbiA9IHF1ZXVlW2lkXTtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICAgIGZuKCk7XG4gIH1cbn07XG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCl7XG4gIHJ1bi5jYWxsKGV2ZW50LmRhdGEpO1xufTtcbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmKCFzZXRUYXNrIHx8ICFjbGVhclRhc2spe1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKXtcbiAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICB3aGlsZShhcmd1bWVudHMubGVuZ3RoID4gaSlhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbigpe1xuICAgICAgaW52b2tlKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbiksIGFyZ3MpO1xuICAgIH07XG4gICAgZGVmZXIoY291bnRlcik7XG4gICAgcmV0dXJuIGNvdW50ZXI7XG4gIH07XG4gIGNsZWFyVGFzayA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKXtcbiAgICBkZWxldGUgcXVldWVbaWRdO1xuICB9O1xuICAvLyBOb2RlLmpzIDAuOC1cbiAgaWYocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKXtcbiAgICBkZWZlciA9IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBCcm93c2VycyB3aXRoIE1lc3NhZ2VDaGFubmVsLCBpbmNsdWRlcyBXZWJXb3JrZXJzXG4gIH0gZWxzZSBpZihNZXNzYWdlQ2hhbm5lbCl7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbDtcbiAgICBwb3J0ICAgID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gY3R4KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cyl7XG4gICAgZGVmZXIgPSBmdW5jdGlvbihpZCl7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNlbCgnc2NyaXB0Jykpe1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgaHRtbC5hcHBlbmRDaGlsZChjZWwoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24oaWQpe1xuICAgICAgc2V0VGltZW91dChjdHgocnVuLCBpZCwgMSksIDApO1xuICAgIH07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6ICAgc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTsiLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWF4ICAgICAgID0gTWF0aC5tYXhcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5kZXgsIGxlbmd0aCl7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59OyIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgID0gTWF0aC5jZWlsXG4gICwgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTsiLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59OyIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBTKXtcbiAgaWYoIWlzT2JqZWN0KGl0KSlyZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZihTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYoIVMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpKXtcbiAgdmFyIExJQlJBUlkgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19saWJyYXJ5JylcbiAgICAsIGdsb2JhbCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAgICwgZmFpbHMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgICAsICRleHBvcnQgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAgICwgJHR5cGVkICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgICAsICRidWZmZXIgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAgICwgY3R4ICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICAgLCBhbkluc3RhbmNlICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAgICwgcHJvcGVydHlEZXNjICAgICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAgICwgaGlkZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAgICwgcmVkZWZpbmVBbGwgICAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICAgLCB0b0ludGVnZXIgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICAgLCB0b0xlbmd0aCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgICAsIHRvSW5kZXggICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICAgLCB0b1ByaW1pdGl2ZSAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgICAsIGhhcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAgICwgc2FtZSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3NhbWUtdmFsdWUnKVxuICAgICwgY2xhc3NvZiAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAgICwgaXNPYmplY3QgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICAgLCB0b09iamVjdCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgICAsIGlzQXJyYXlJdGVyICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgICAsIGNyZWF0ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgICAsIGdldFByb3RvdHlwZU9mICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgICAsIGdPUE4gICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgICAsIGdldEl0ZXJGbiAgICAgICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpXG4gICAgLCB1aWQgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgICAsIHdrcyAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL193a3MnKVxuICAgICwgY3JlYXRlQXJyYXlNZXRob2QgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKVxuICAgICwgY3JlYXRlQXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJylcbiAgICAsIHNwZWNpZXNDb25zdHJ1Y3RvciAgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgICAsIEFycmF5SXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpXG4gICAgLCBJdGVyYXRvcnMgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgICAsICRpdGVyRGV0ZWN0ICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpXG4gICAgLCBzZXRTcGVjaWVzICAgICAgICAgID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKVxuICAgICwgYXJyYXlGaWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAgICwgYXJyYXlDb3B5V2l0aGluICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWNvcHktd2l0aGluJylcbiAgICAsICREUCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAgICwgJEdPUEQgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgICAsIGRQICAgICAgICAgICAgICAgICAgPSAkRFAuZlxuICAgICwgZ09QRCAgICAgICAgICAgICAgICA9ICRHT1BELmZcbiAgICAsIFJhbmdlRXJyb3IgICAgICAgICAgPSBnbG9iYWwuUmFuZ2VFcnJvclxuICAgICwgVHlwZUVycm9yICAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgICAsIFVpbnQ4QXJyYXkgICAgICAgICAgPSBnbG9iYWwuVWludDhBcnJheVxuICAgICwgQVJSQVlfQlVGRkVSICAgICAgICA9ICdBcnJheUJ1ZmZlcidcbiAgICAsIFNIQVJFRF9CVUZGRVIgICAgICAgPSAnU2hhcmVkJyArIEFSUkFZX0JVRkZFUlxuICAgICwgQllURVNfUEVSX0VMRU1FTlQgICA9ICdCWVRFU19QRVJfRUxFTUVOVCdcbiAgICAsIFBST1RPVFlQRSAgICAgICAgICAgPSAncHJvdG90eXBlJ1xuICAgICwgQXJyYXlQcm90byAgICAgICAgICA9IEFycmF5W1BST1RPVFlQRV1cbiAgICAsICRBcnJheUJ1ZmZlciAgICAgICAgPSAkYnVmZmVyLkFycmF5QnVmZmVyXG4gICAgLCAkRGF0YVZpZXcgICAgICAgICAgID0gJGJ1ZmZlci5EYXRhVmlld1xuICAgICwgYXJyYXlGb3JFYWNoICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDApXG4gICAgLCBhcnJheUZpbHRlciAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoMilcbiAgICAsIGFycmF5U29tZSAgICAgICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCgzKVxuICAgICwgYXJyYXlFdmVyeSAgICAgICAgICA9IGNyZWF0ZUFycmF5TWV0aG9kKDQpXG4gICAgLCBhcnJheUZpbmQgICAgICAgICAgID0gY3JlYXRlQXJyYXlNZXRob2QoNSlcbiAgICAsIGFycmF5RmluZEluZGV4ICAgICAgPSBjcmVhdGVBcnJheU1ldGhvZCg2KVxuICAgICwgYXJyYXlJbmNsdWRlcyAgICAgICA9IGNyZWF0ZUFycmF5SW5jbHVkZXModHJ1ZSlcbiAgICAsIGFycmF5SW5kZXhPZiAgICAgICAgPSBjcmVhdGVBcnJheUluY2x1ZGVzKGZhbHNlKVxuICAgICwgYXJyYXlWYWx1ZXMgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLnZhbHVlc1xuICAgICwgYXJyYXlLZXlzICAgICAgICAgICA9IEFycmF5SXRlcmF0b3JzLmtleXNcbiAgICAsIGFycmF5RW50cmllcyAgICAgICAgPSBBcnJheUl0ZXJhdG9ycy5lbnRyaWVzXG4gICAgLCBhcnJheUxhc3RJbmRleE9mICAgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZlxuICAgICwgYXJyYXlSZWR1Y2UgICAgICAgICA9IEFycmF5UHJvdG8ucmVkdWNlXG4gICAgLCBhcnJheVJlZHVjZVJpZ2h0ICAgID0gQXJyYXlQcm90by5yZWR1Y2VSaWdodFxuICAgICwgYXJyYXlKb2luICAgICAgICAgICA9IEFycmF5UHJvdG8uam9pblxuICAgICwgYXJyYXlTb3J0ICAgICAgICAgICA9IEFycmF5UHJvdG8uc29ydFxuICAgICwgYXJyYXlTbGljZSAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2VcbiAgICAsIGFycmF5VG9TdHJpbmcgICAgICAgPSBBcnJheVByb3RvLnRvU3RyaW5nXG4gICAgLCBhcnJheVRvTG9jYWxlU3RyaW5nID0gQXJyYXlQcm90by50b0xvY2FsZVN0cmluZ1xuICAgICwgSVRFUkFUT1IgICAgICAgICAgICA9IHdrcygnaXRlcmF0b3InKVxuICAgICwgVEFHICAgICAgICAgICAgICAgICA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAgICwgVFlQRURfQ09OU1RSVUNUT1IgICA9IHVpZCgndHlwZWRfY29uc3RydWN0b3InKVxuICAgICwgREVGX0NPTlNUUlVDVE9SICAgICA9IHVpZCgnZGVmX2NvbnN0cnVjdG9yJylcbiAgICAsIEFMTF9DT05TVFJVQ1RPUlMgICAgPSAkdHlwZWQuQ09OU1RSXG4gICAgLCBUWVBFRF9BUlJBWSAgICAgICAgID0gJHR5cGVkLlRZUEVEXG4gICAgLCBWSUVXICAgICAgICAgICAgICAgID0gJHR5cGVkLlZJRVdcbiAgICAsIFdST05HX0xFTkdUSCAgICAgICAgPSAnV3JvbmcgbGVuZ3RoISc7XG5cbiAgdmFyICRtYXAgPSBjcmVhdGVBcnJheU1ldGhvZCgxLCBmdW5jdGlvbihPLCBsZW5ndGgpe1xuICAgIHJldHVybiBhbGxvY2F0ZShzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSwgbGVuZ3RoKTtcbiAgfSk7XG5cbiAgdmFyIExJVFRMRV9FTkRJQU4gPSBmYWlscyhmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVWludDE2QXJyYXkoWzFdKS5idWZmZXIpWzBdID09PSAxO1xuICB9KTtcblxuICB2YXIgRk9SQ0VEX1NFVCA9ICEhVWludDhBcnJheSAmJiAhIVVpbnQ4QXJyYXlbUFJPVE9UWVBFXS5zZXQgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgVWludDhBcnJheSgxKS5zZXQoe30pO1xuICB9KTtcblxuICB2YXIgc3RyaWN0VG9MZW5ndGggPSBmdW5jdGlvbihpdCwgU0FNRSl7XG4gICAgaWYoaXQgPT09IHVuZGVmaW5lZCl0aHJvdyBUeXBlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICB2YXIgbnVtYmVyID0gK2l0XG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0KTtcbiAgICBpZihTQU1FICYmICFzYW1lKG51bWJlciwgbGVuZ3RoKSl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcblxuICB2YXIgdG9PZmZzZXQgPSBmdW5jdGlvbihpdCwgQllURVMpe1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoaXQpO1xuICAgIGlmKG9mZnNldCA8IDAgfHwgb2Zmc2V0ICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0IScpO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oaXQpe1xuICAgIGlmKGlzT2JqZWN0KGl0KSAmJiBUWVBFRF9BUlJBWSBpbiBpdClyZXR1cm4gaXQ7XG4gICAgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSEnKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbihDLCBsZW5ndGgpe1xuICAgIGlmKCEoaXNPYmplY3QoQykgJiYgVFlQRURfQ09OU1RSVUNUT1IgaW4gQykpe1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJdCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvciEnKTtcbiAgICB9IHJldHVybiBuZXcgQyhsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBzcGVjaWVzRnJvbUxpc3QgPSBmdW5jdGlvbihPLCBsaXN0KXtcbiAgICByZXR1cm4gZnJvbUxpc3Qoc3BlY2llc0NvbnN0cnVjdG9yKE8sIE9bREVGX0NPTlNUUlVDVE9SXSksIGxpc3QpO1xuICB9O1xuXG4gIHZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uKEMsIGxpc3Qpe1xuICAgIHZhciBpbmRleCAgPSAwXG4gICAgICAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICAsIHJlc3VsdCA9IGFsbG9jYXRlKEMsIGxlbmd0aCk7XG4gICAgd2hpbGUobGVuZ3RoID4gaW5kZXgpcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24oaXQsIGtleSwgaW50ZXJuYWwpe1xuICAgIGRQKGl0LCBrZXksIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9kW2ludGVybmFsXTsgfX0pO1xuICB9O1xuXG4gIHZhciAkZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qLCBtYXBmbiwgdGhpc0FyZyAqLyl7XG4gICAgdmFyIE8gICAgICAgPSB0b09iamVjdChzb3VyY2UpXG4gICAgICAsIGFMZW4gICAgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAsIG1hcGZuICAgPSBhTGVuID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZFxuICAgICAgLCBpdGVyRm4gID0gZ2V0SXRlckZuKE8pXG4gICAgICAsIGksIGxlbmd0aCwgdmFsdWVzLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKGl0ZXJGbiAhPSB1bmRlZmluZWQgJiYgIWlzQXJyYXlJdGVyKGl0ZXJGbikpe1xuICAgICAgZm9yKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoTyksIHZhbHVlcyA9IFtdLCBpID0gMDsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpKyspe1xuICAgICAgICB2YWx1ZXMucHVzaChzdGVwLnZhbHVlKTtcbiAgICAgIH0gTyA9IHZhbHVlcztcbiAgICB9XG4gICAgaWYobWFwcGluZyAmJiBhTGVuID4gMiltYXBmbiA9IGN0eChtYXBmbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICBmb3IoaSA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKSwgcmVzdWx0ID0gYWxsb2NhdGUodGhpcywgbGVuZ3RoKTsgbGVuZ3RoID4gaTsgaSsrKXtcbiAgICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyICRvZiA9IGZ1bmN0aW9uIG9mKC8qLi4uaXRlbXMqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBhbGxvY2F0ZSh0aGlzLCBsZW5ndGgpO1xuICAgIHdoaWxlKGxlbmd0aCA+IGluZGV4KXJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG4gIHZhciBUT19MT0NBTEVfQlVHID0gISFVaW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uKCl7IGFycmF5VG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgVWludDhBcnJheSgxKSk7IH0pO1xuXG4gIHZhciAkdG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpe1xuICAgIHJldHVybiBhcnJheVRvTG9jYWxlU3RyaW5nLmFwcGx5KFRPX0xPQ0FMRV9CVUcgPyBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcykpIDogdmFsaWRhdGUodGhpcyksIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgdmFyIHByb3RvID0ge1xuICAgIGNvcHlXaXRoaW46IGZ1bmN0aW9uIGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCAvKiwgZW5kICovKXtcbiAgICAgIHJldHVybiBhcnJheUNvcHlXaXRoaW4uY2FsbCh2YWxpZGF0ZSh0aGlzKSwgdGFyZ2V0LCBzdGFydCwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgZXZlcnk6IGZ1bmN0aW9uIGV2ZXJ5KGNhbGxiYWNrZm4gLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RXZlcnkodmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyosIHN0YXJ0LCBlbmQgKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlGaWxsLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gc3BlY2llc0Zyb21MaXN0KHRoaXMsIGFycmF5RmlsdGVyKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZmluZDogZnVuY3Rpb24gZmluZChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZCh2YWxpZGF0ZSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBmaW5kSW5kZXg6IGZ1bmN0aW9uIGZpbmRJbmRleChwcmVkaWNhdGUgLyosIHRoaXNBcmcgKi8pe1xuICAgICAgcmV0dXJuIGFycmF5RmluZEluZGV4KHZhbGlkYXRlKHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICBhcnJheUZvckVhY2godmFsaWRhdGUodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiwgZnJvbUluZGV4ICovKXtcbiAgICAgIHJldHVybiBhcnJheUluZGV4T2YodmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8pe1xuICAgICAgcmV0dXJuIGFycmF5SW5jbHVkZXModmFsaWRhdGUodGhpcyksIHNlYXJjaEVsZW1lbnQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIGpvaW46IGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIGxhc3RJbmRleE9mOiBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggKi8peyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4gYXJyYXlMYXN0SW5kZXhPZi5hcHBseSh2YWxpZGF0ZSh0aGlzKSwgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gbWFwKG1hcGZuIC8qLCB0aGlzQXJnICovKXtcbiAgICAgIHJldHVybiAkbWFwKHZhbGlkYXRlKHRoaXMpLCBtYXBmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiwgaW5pdGlhbFZhbHVlICovKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlLmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNhbGxiYWNrZm4gLyosIGluaXRpYWxWYWx1ZSAqLyl7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIHJldHVybiBhcnJheVJlZHVjZVJpZ2h0LmFwcGx5KHZhbGlkYXRlKHRoaXMpLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpe1xuICAgICAgdmFyIHRoYXQgICA9IHRoaXNcbiAgICAgICAgLCBsZW5ndGggPSB2YWxpZGF0ZSh0aGF0KS5sZW5ndGhcbiAgICAgICAgLCBtaWRkbGUgPSBNYXRoLmZsb29yKGxlbmd0aCAvIDIpXG4gICAgICAgICwgaW5kZXggID0gMFxuICAgICAgICAsIHZhbHVlO1xuICAgICAgd2hpbGUoaW5kZXggPCBtaWRkbGUpe1xuICAgICAgICB2YWx1ZSAgICAgICAgID0gdGhhdFtpbmRleF07XG4gICAgICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICAgICAgdGhhdFtsZW5ndGhdICA9IHZhbHVlO1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9LFxuICAgIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiwgdGhpc0FyZyAqLyl7XG4gICAgICByZXR1cm4gYXJyYXlTb21lKHZhbGlkYXRlKHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbil7XG4gICAgICByZXR1cm4gYXJyYXlTb3J0LmNhbGwodmFsaWRhdGUodGhpcyksIGNvbXBhcmVmbik7XG4gICAgfSxcbiAgICBzdWJhcnJheTogZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCl7XG4gICAgICB2YXIgTyAgICAgID0gdmFsaWRhdGUodGhpcylcbiAgICAgICAgLCBsZW5ndGggPSBPLmxlbmd0aFxuICAgICAgICAsICRiZWdpbiA9IHRvSW5kZXgoYmVnaW4sIGxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgT1tERUZfQ09OU1RSVUNUT1JdKSkoXG4gICAgICAgIE8uYnVmZmVyLFxuICAgICAgICBPLmJ5dGVPZmZzZXQgKyAkYmVnaW4gKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgICAgICB0b0xlbmd0aCgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiB0b0luZGV4KGVuZCwgbGVuZ3RoKSkgLSAkYmVnaW4pXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICB2YXIgJHNsaWNlID0gZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCl7XG4gICAgcmV0dXJuIHNwZWNpZXNGcm9tTGlzdCh0aGlzLCBhcnJheVNsaWNlLmNhbGwodmFsaWRhdGUodGhpcyksIHN0YXJ0LCBlbmQpKTtcbiAgfTtcblxuICB2YXIgJHNldCA9IGZ1bmN0aW9uIHNldChhcnJheUxpa2UgLyosIG9mZnNldCAqLyl7XG4gICAgdmFsaWRhdGUodGhpcyk7XG4gICAgdmFyIG9mZnNldCA9IHRvT2Zmc2V0KGFyZ3VtZW50c1sxXSwgMSlcbiAgICAgICwgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICwgc3JjICAgID0gdG9PYmplY3QoYXJyYXlMaWtlKVxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aChzcmMubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIGlmKGxlbiArIG9mZnNldCA+IGxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgd2hpbGUoaW5kZXggPCBsZW4pdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG4gIH07XG5cbiAgdmFyICRpdGVyYXRvcnMgPSB7XG4gICAgZW50cmllczogZnVuY3Rpb24gZW50cmllcygpe1xuICAgICAgcmV0dXJuIGFycmF5RW50cmllcy5jYWxsKHZhbGlkYXRlKHRoaXMpKTtcbiAgICB9LFxuICAgIGtleXM6IGZ1bmN0aW9uIGtleXMoKXtcbiAgICAgIHJldHVybiBhcnJheUtleXMuY2FsbCh2YWxpZGF0ZSh0aGlzKSk7XG4gICAgfSxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcygpe1xuICAgICAgcmV0dXJuIGFycmF5VmFsdWVzLmNhbGwodmFsaWRhdGUodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNUQUluZGV4ID0gZnVuY3Rpb24odGFyZ2V0LCBrZXkpe1xuICAgIHJldHVybiBpc09iamVjdCh0YXJnZXQpXG4gICAgICAmJiB0YXJnZXRbVFlQRURfQVJSQVldXG4gICAgICAmJiB0eXBlb2Yga2V5ICE9ICdzeW1ib2wnXG4gICAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG4gIH07XG4gIHZhciAkZ2V0RGVzYyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSl7XG4gICAgcmV0dXJuIGlzVEFJbmRleCh0YXJnZXQsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpXG4gICAgICA/IHByb3BlcnR5RGVzYygyLCB0YXJnZXRba2V5XSlcbiAgICAgIDogZ09QRCh0YXJnZXQsIGtleSk7XG4gIH07XG4gIHZhciAkc2V0RGVzYyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjKXtcbiAgICBpZihpc1RBSW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICAgJiYgaXNPYmplY3QoZGVzYylcbiAgICAgICYmIGhhcyhkZXNjLCAndmFsdWUnKVxuICAgICAgJiYgIWhhcyhkZXNjLCAnZ2V0JylcbiAgICAgICYmICFoYXMoZGVzYywgJ3NldCcpXG4gICAgICAvLyBUT0RPOiBhZGQgdmFsaWRhdGlvbiBkZXNjcmlwdG9yIHcvbyBjYWxsaW5nIGFjY2Vzc29yc1xuICAgICAgJiYgIWRlc2MuY29uZmlndXJhYmxlXG4gICAgICAmJiAoIWhhcyhkZXNjLCAnd3JpdGFibGUnKSB8fCBkZXNjLndyaXRhYmxlKVxuICAgICAgJiYgKCFoYXMoZGVzYywgJ2VudW1lcmFibGUnKSB8fCBkZXNjLmVudW1lcmFibGUpXG4gICAgKXtcbiAgICAgIHRhcmdldFtrZXldID0gZGVzYy52YWx1ZTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHJldHVybiBkUCh0YXJnZXQsIGtleSwgZGVzYyk7XG4gIH07XG5cbiAgaWYoIUFMTF9DT05TVFJVQ1RPUlMpe1xuICAgICRHT1BELmYgPSAkZ2V0RGVzYztcbiAgICAkRFAuZiAgID0gJHNldERlc2M7XG4gIH1cblxuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFBTExfQ09OU1RSVUNUT1JTLCAnT2JqZWN0Jywge1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldERlc2MsXG4gICAgZGVmaW5lUHJvcGVydHk6ICAgICAgICAgICAkc2V0RGVzY1xuICB9KTtcblxuICBpZihmYWlscyhmdW5jdGlvbigpeyBhcnJheVRvU3RyaW5nLmNhbGwoe30pOyB9KSl7XG4gICAgYXJyYXlUb1N0cmluZyA9IGFycmF5VG9Mb2NhbGVTdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpe1xuICAgICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciAkVHlwZWRBcnJheVByb3RvdHlwZSQgPSByZWRlZmluZUFsbCh7fSwgcHJvdG8pO1xuICByZWRlZmluZUFsbCgkVHlwZWRBcnJheVByb3RvdHlwZSQsICRpdGVyYXRvcnMpO1xuICBoaWRlKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgSVRFUkFUT1IsICRpdGVyYXRvcnMudmFsdWVzKTtcbiAgcmVkZWZpbmVBbGwoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCB7XG4gICAgc2xpY2U6ICAgICAgICAgICRzbGljZSxcbiAgICBzZXQ6ICAgICAgICAgICAgJHNldCxcbiAgICBjb25zdHJ1Y3RvcjogICAgZnVuY3Rpb24oKXsgLyogbm9vcCAqLyB9LFxuICAgIHRvU3RyaW5nOiAgICAgICBhcnJheVRvU3RyaW5nLFxuICAgIHRvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmdcbiAgfSk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdidWZmZXInLCAnYicpO1xuICBhZGRHZXR0ZXIoJFR5cGVkQXJyYXlQcm90b3R5cGUkLCAnYnl0ZU9mZnNldCcsICdvJyk7XG4gIGFkZEdldHRlcigkVHlwZWRBcnJheVByb3RvdHlwZSQsICdieXRlTGVuZ3RoJywgJ2wnKTtcbiAgYWRkR2V0dGVyKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgJ2xlbmd0aCcsICdlJyk7XG4gIGRQKCRUeXBlZEFycmF5UHJvdG90eXBlJCwgVEFHLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpc1tUWVBFRF9BUlJBWV07IH1cbiAgfSk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKXtcbiAgICBDTEFNUEVEID0gISFDTEFNUEVEO1xuICAgIHZhciBOQU1FICAgICAgID0gS0VZICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknXG4gICAgICAsIElTTlRfVUlOVDggPSBOQU1FICE9ICdVaW50OEFycmF5J1xuICAgICAgLCBHRVRURVIgICAgID0gJ2dldCcgKyBLRVlcbiAgICAgICwgU0VUVEVSICAgICA9ICdzZXQnICsgS0VZXG4gICAgICAsIFR5cGVkQXJyYXkgPSBnbG9iYWxbTkFNRV1cbiAgICAgICwgQmFzZSAgICAgICA9IFR5cGVkQXJyYXkgfHwge31cbiAgICAgICwgVEFDICAgICAgICA9IFR5cGVkQXJyYXkgJiYgZ2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheSlcbiAgICAgICwgRk9SQ0VEICAgICA9ICFUeXBlZEFycmF5IHx8ICEkdHlwZWQuQUJWXG4gICAgICAsIE8gICAgICAgICAgPSB7fVxuICAgICAgLCBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheSAmJiBUeXBlZEFycmF5W1BST1RPVFlQRV07XG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uKHRoYXQsIGluZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhhdC5fZDtcbiAgICAgIHJldHVybiBkYXRhLnZbR0VUVEVSXShpbmRleCAqIEJZVEVTICsgZGF0YS5vLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih0aGF0LCBpbmRleCwgdmFsdWUpe1xuICAgICAgdmFyIGRhdGEgPSB0aGF0Ll9kO1xuICAgICAgaWYoQ0xBTVBFRCl2YWx1ZSA9ICh2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweGZmID8gMHhmZiA6IHZhbHVlICYgMHhmZjtcbiAgICAgIGRhdGEudltTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLm8sIHZhbHVlLCBMSVRUTEVfRU5ESUFOKTtcbiAgICB9O1xuICAgIHZhciBhZGRFbGVtZW50ID0gZnVuY3Rpb24odGhhdCwgaW5kZXgpe1xuICAgICAgZFAodGhhdCwgaW5kZXgsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICByZXR1cm4gc2V0dGVyKHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYoRk9SQ0VEKXtcbiAgICAgIFR5cGVkQXJyYXkgPSB3cmFwcGVyKGZ1bmN0aW9uKHRoYXQsIGRhdGEsICRvZmZzZXQsICRsZW5ndGgpe1xuICAgICAgICBhbkluc3RhbmNlKHRoYXQsIFR5cGVkQXJyYXksIE5BTUUsICdfZCcpO1xuICAgICAgICB2YXIgaW5kZXggID0gMFxuICAgICAgICAgICwgb2Zmc2V0ID0gMFxuICAgICAgICAgICwgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGgsIGtsYXNzO1xuICAgICAgICBpZighaXNPYmplY3QoZGF0YSkpe1xuICAgICAgICAgIGxlbmd0aCAgICAgPSBzdHJpY3RUb0xlbmd0aChkYXRhLCB0cnVlKVxuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgICAgID0gbmV3ICRBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgb2Zmc2V0ID0gdG9PZmZzZXQoJG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmKCRsZW5ndGggPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBpZigkbGVuICUgQllURVMpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgICAgYnl0ZUxlbmd0aCA9ICRsZW4gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZihieXRlTGVuZ3RoIDwgMCl0aHJvdyBSYW5nZUVycm9yKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCgkbGVuZ3RoKSAqIEJZVEVTO1xuICAgICAgICAgICAgaWYoYnl0ZUxlbmd0aCArIG9mZnNldCA+ICRsZW4pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggPSBieXRlTGVuZ3RoIC8gQllURVM7XG4gICAgICAgIH0gZWxzZSBpZihUWVBFRF9BUlJBWSBpbiBkYXRhKXtcbiAgICAgICAgICByZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICRmcm9tLmNhbGwoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSh0aGF0LCAnX2QnLCB7XG4gICAgICAgICAgYjogYnVmZmVyLFxuICAgICAgICAgIG86IG9mZnNldCxcbiAgICAgICAgICBsOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGU6IGxlbmd0aCxcbiAgICAgICAgICB2OiBuZXcgJERhdGFWaWV3KGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlKGluZGV4IDwgbGVuZ3RoKWFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5W1BST1RPVFlQRV0gPSBjcmVhdGUoJFR5cGVkQXJyYXlQcm90b3R5cGUkKTtcbiAgICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheSk7XG4gICAgfSBlbHNlIGlmKCEkaXRlckRldGVjdChmdW5jdGlvbihpdGVyKXtcbiAgICAgIC8vIFY4IHdvcmtzIHdpdGggaXRlcmF0b3JzLCBidXQgZmFpbHMgaW4gbWFueSBvdGhlciBjYXNlc1xuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQ1NTJcbiAgICAgIG5ldyBUeXBlZEFycmF5KG51bGwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgbmV3IFR5cGVkQXJyYXkoaXRlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfSwgdHJ1ZSkpe1xuICAgICAgVHlwZWRBcnJheSA9IHdyYXBwZXIoZnVuY3Rpb24odGhhdCwgZGF0YSwgJG9mZnNldCwgJGxlbmd0aCl7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheSwgTkFNRSk7XG4gICAgICAgIHZhciBrbGFzcztcbiAgICAgICAgLy8gYHdzYCBtb2R1bGUgYnVnLCB0ZW1wb3JhcmlseSByZW1vdmUgdmFsaWRhdGlvbiBsZW5ndGggZm9yIFVpbnQ4QXJyYXlcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvcHVsbC82NDVcbiAgICAgICAgaWYoIWlzT2JqZWN0KGRhdGEpKXJldHVybiBuZXcgQmFzZShzdHJpY3RUb0xlbmd0aChkYXRhLCBJU05UX1VJTlQ4KSk7XG4gICAgICAgIGlmKGRhdGEgaW5zdGFuY2VvZiAkQXJyYXlCdWZmZXIgfHwgKGtsYXNzID0gY2xhc3NvZihkYXRhKSkgPT0gQVJSQVlfQlVGRkVSIHx8IGtsYXNzID09IFNIQVJFRF9CVUZGRVIpe1xuICAgICAgICAgIHJldHVybiAkbGVuZ3RoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IEJhc2UoZGF0YSwgdG9PZmZzZXQoJG9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiAkb2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgQmFzZShkYXRhLCB0b09mZnNldCgkb2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICAgIDogbmV3IEJhc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoVFlQRURfQVJSQVkgaW4gZGF0YSlyZXR1cm4gZnJvbUxpc3QoVHlwZWRBcnJheSwgZGF0YSk7XG4gICAgICAgIHJldHVybiAkZnJvbS5jYWxsKFR5cGVkQXJyYXksIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhcnJheUZvckVhY2goVEFDICE9PSBGdW5jdGlvbi5wcm90b3R5cGUgPyBnT1BOKEJhc2UpLmNvbmNhdChnT1BOKFRBQykpIDogZ09QTihCYXNlKSwgZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgaWYoIShrZXkgaW4gVHlwZWRBcnJheSkpaGlkZShUeXBlZEFycmF5LCBrZXksIEJhc2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlbUFJPVE9UWVBFXSA9IFR5cGVkQXJyYXlQcm90b3R5cGU7XG4gICAgICBpZighTElCUkFSWSlUeXBlZEFycmF5UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHlwZWRBcnJheTtcbiAgICB9XG4gICAgdmFyICRuYXRpdmVJdGVyYXRvciAgID0gVHlwZWRBcnJheVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICAgICwgQ09SUkVDVF9JVEVSX05BTUUgPSAhISRuYXRpdmVJdGVyYXRvciAmJiAoJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgJG5hdGl2ZUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgLCAkaXRlcmF0b3IgICAgICAgICA9ICRpdGVyYXRvcnMudmFsdWVzO1xuICAgIGhpZGUoVHlwZWRBcnJheSwgVFlQRURfQ09OU1RSVUNUT1IsIHRydWUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVFlQRURfQVJSQVksIE5BTUUpO1xuICAgIGhpZGUoVHlwZWRBcnJheVByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gICAgaGlkZShUeXBlZEFycmF5UHJvdG90eXBlLCBERUZfQ09OU1RSVUNUT1IsIFR5cGVkQXJyYXkpO1xuXG4gICAgaWYoQ0xBTVBFRCA/IG5ldyBUeXBlZEFycmF5KDEpW1RBR10gIT0gTkFNRSA6ICEoVEFHIGluIFR5cGVkQXJyYXlQcm90b3R5cGUpKXtcbiAgICAgIGRQKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRBRywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBOQU1FOyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPW05BTUVdID0gVHlwZWRBcnJheTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogKFR5cGVkQXJyYXkgIT0gQmFzZSksIE8pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlMsIE5BTUUsIHtcbiAgICAgIEJZVEVTX1BFUl9FTEVNRU5UOiBCWVRFUyxcbiAgICAgIGZyb206ICRmcm9tLFxuICAgICAgb2Y6ICRvZlxuICAgIH0pO1xuXG4gICAgaWYoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5UHJvdG90eXBlKSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCwgTkFNRSwgcHJvdG8pO1xuXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcblxuICAgICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogRk9SQ0VEX1NFVCwgTkFNRSwge3NldDogJHNldH0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhQ09SUkVDVF9JVEVSX05BTUUsIE5BTUUsICRpdGVyYXRvcnMpO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoVHlwZWRBcnJheVByb3RvdHlwZS50b1N0cmluZyAhPSBhcnJheVRvU3RyaW5nKSwgTkFNRSwge3RvU3RyaW5nOiBhcnJheVRvU3RyaW5nfSk7XG5cbiAgICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgICBuZXcgVHlwZWRBcnJheSgxKS5zbGljZSgpO1xuICAgIH0pLCBOQU1FLCB7c2xpY2U6ICRzbGljZX0pO1xuXG4gICAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBbMSwgMl0udG9Mb2NhbGVTdHJpbmcoKSAhPSBuZXcgVHlwZWRBcnJheShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKClcbiAgICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICAgIFR5cGVkQXJyYXlQcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcuY2FsbChbMSwgMl0pO1xuICAgIH0pKSwgTkFNRSwge3RvTG9jYWxlU3RyaW5nOiAkdG9Mb2NhbGVTdHJpbmd9KTtcblxuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IENPUlJFQ1RfSVRFUl9OQU1FID8gJG5hdGl2ZUl0ZXJhdG9yIDogJGl0ZXJhdG9yO1xuICAgIGlmKCFMSUJSQVJZICYmICFDT1JSRUNUX0lURVJfTkFNRSloaWRlKFR5cGVkQXJyYXlQcm90b3R5cGUsIElURVJBVE9SLCAkaXRlcmF0b3IpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgJHR5cGVkICAgICAgICAgPSByZXF1aXJlKCcuL190eXBlZCcpXG4gICwgaGlkZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZUFsbCAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpXG4gICwgZmFpbHMgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgYW5JbnN0YW5jZSAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgdG9JbnRlZ2VyICAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgZ09QTiAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBhcnJheUZpbGwgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKVxuICAsIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIEFSUkFZX0JVRkZFUiAgID0gJ0FycmF5QnVmZmVyJ1xuICAsIERBVEFfVklFVyAgICAgID0gJ0RhdGFWaWV3J1xuICAsIFBST1RPVFlQRSAgICAgID0gJ3Byb3RvdHlwZSdcbiAgLCBXUk9OR19MRU5HVEggICA9ICdXcm9uZyBsZW5ndGghJ1xuICAsIFdST05HX0lOREVYICAgID0gJ1dyb25nIGluZGV4ISdcbiAgLCAkQXJyYXlCdWZmZXIgICA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdXG4gICwgJERhdGFWaWV3ICAgICAgPSBnbG9iYWxbREFUQV9WSUVXXVxuICAsIE1hdGggICAgICAgICAgID0gZ2xvYmFsLk1hdGhcbiAgLCBSYW5nZUVycm9yICAgICA9IGdsb2JhbC5SYW5nZUVycm9yXG4gICwgSW5maW5pdHkgICAgICAgPSBnbG9iYWwuSW5maW5pdHlcbiAgLCBCYXNlQnVmZmVyICAgICA9ICRBcnJheUJ1ZmZlclxuICAsIGFicyAgICAgICAgICAgID0gTWF0aC5hYnNcbiAgLCBwb3cgICAgICAgICAgICA9IE1hdGgucG93XG4gICwgZmxvb3IgICAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgbG9nICAgICAgICAgICAgPSBNYXRoLmxvZ1xuICAsIExOMiAgICAgICAgICAgID0gTWF0aC5MTjJcbiAgLCBCVUZGRVIgICAgICAgICA9ICdidWZmZXInXG4gICwgQllURV9MRU5HVEggICAgPSAnYnl0ZUxlbmd0aCdcbiAgLCBCWVRFX09GRlNFVCAgICA9ICdieXRlT2Zmc2V0J1xuICAsICRCVUZGRVIgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX2InIDogQlVGRkVSXG4gICwgJExFTkdUSCAgICAgICAgPSBERVNDUklQVE9SUyA/ICdfbCcgOiBCWVRFX0xFTkdUSFxuICAsICRPRkZTRVQgICAgICAgID0gREVTQ1JJUFRPUlMgPyAnX28nIDogQllURV9PRkZTRVQ7XG5cbi8vIElFRUU3NTQgY29udmVyc2lvbnMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9pZWVlNzU0XG52YXIgcGFja0lFRUU3NTQgPSBmdW5jdGlvbih2YWx1ZSwgbUxlbiwgbkJ5dGVzKXtcbiAgdmFyIGJ1ZmZlciA9IEFycmF5KG5CeXRlcylcbiAgICAsIGVMZW4gICA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICAgICwgZU1heCAgID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyAgPSBlTWF4ID4+IDFcbiAgICAsIHJ0ICAgICA9IG1MZW4gPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDBcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIHMgICAgICA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gMSA6IDBcbiAgICAsIGUsIG0sIGM7XG4gIHZhbHVlID0gYWJzKHZhbHVlKVxuICBpZih2YWx1ZSAhPSB2YWx1ZSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpe1xuICAgIG0gPSB2YWx1ZSAhPSB2YWx1ZSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBmbG9vcihsb2codmFsdWUpIC8gTE4yKTtcbiAgICBpZih2YWx1ZSAqIChjID0gcG93KDIsIC1lKSkgPCAxKXtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYoZSArIGVCaWFzID49IDEpe1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIHBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZih2YWx1ZSAqIGMgPj0gMil7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmKGUgKyBlQmlhcyA+PSBlTWF4KXtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmKGUgKyBlQmlhcyA+PSAxKXtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBwb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuICBmb3IoOyBtTGVuID49IDg7IGJ1ZmZlcltpKytdID0gbSAmIDI1NSwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG4gIGUgPSBlIDw8IG1MZW4gfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvcig7IGVMZW4gPiAwOyBidWZmZXJbaSsrXSA9IGUgJiAyNTUsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuICBidWZmZXJbLS1pXSB8PSBzICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcbnZhciB1bnBhY2tJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBtTGVuLCBuQnl0ZXMpe1xuICB2YXIgZUxlbiAgPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgICAsIGVNYXggID0gKDEgPDwgZUxlbikgLSAxXG4gICAgLCBlQmlhcyA9IGVNYXggPj4gMVxuICAgICwgbkJpdHMgPSBlTGVuIC0gN1xuICAgICwgaSAgICAgPSBuQnl0ZXMgLSAxXG4gICAgLCBzICAgICA9IGJ1ZmZlcltpLS1dXG4gICAgLCBlICAgICA9IHMgJiAxMjdcbiAgICAsIG07XG4gIHMgPj49IDc7XG4gIGZvcig7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbaV0sIGktLSwgbkJpdHMgLT0gOCk7XG4gIG0gPSBlICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGUgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltpXSwgaS0tLCBuQml0cyAtPSA4KTtcbiAgaWYoZSA9PT0gMCl7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmKGUgPT09IGVNYXgpe1xuICAgIHJldHVybiBtID8gTmFOIDogcyA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgcG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH0gcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBwb3coMiwgZSAtIG1MZW4pO1xufTtcblxudmFyIHVucGFja0kzMiA9IGZ1bmN0aW9uKGJ5dGVzKXtcbiAgcmV0dXJuIGJ5dGVzWzNdIDw8IDI0IHwgYnl0ZXNbMl0gPDwgMTYgfCBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG59O1xudmFyIHBhY2tJOCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIFtpdCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTE2ID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmZdO1xufTtcbnZhciBwYWNrSTMyID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gW2l0ICYgMHhmZiwgaXQgPj4gOCAmIDB4ZmYsIGl0ID4+IDE2ICYgMHhmZiwgaXQgPj4gMjQgJiAweGZmXTtcbn07XG52YXIgcGFja0Y2NCA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KGl0LCA1MiwgOCk7XG59O1xudmFyIHBhY2tGMzIgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBwYWNrSUVFRTc1NChpdCwgMjMsIDQpO1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uKEMsIGtleSwgaW50ZXJuYWwpe1xuICBkUChDW1BST1RPVFlQRV0sIGtleSwge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXNbaW50ZXJuYWxdOyB9fSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24odmlldywgYnl0ZXMsIGluZGV4LCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IHN0b3JlLnNsaWNlKHN0YXJ0LCBzdGFydCArIGJ5dGVzKTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcbnZhciBzZXQgPSBmdW5jdGlvbih2aWV3LCBieXRlcywgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbil7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleFxuICAgICwgaW50SW5kZXggPSB0b0ludGVnZXIobnVtSW5kZXgpO1xuICBpZihudW1JbmRleCAhPSBpbnRJbmRleCB8fCBpbnRJbmRleCA8IDAgfHwgaW50SW5kZXggKyBieXRlcyA+IHZpZXdbJExFTkdUSF0pdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBzdG9yZSA9IHZpZXdbJEJVRkZFUl0uX2JcbiAgICAsIHN0YXJ0ID0gaW50SW5kZXggKyB2aWV3WyRPRkZTRVRdXG4gICAgLCBwYWNrICA9IGNvbnZlcnNpb24oK3ZhbHVlKTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJ5dGVzOyBpKyspc3RvcmVbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogYnl0ZXMgLSBpIC0gMV07XG59O1xuXG52YXIgdmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyA9IGZ1bmN0aW9uKHRoYXQsIGxlbmd0aCl7XG4gIGFuSW5zdGFuY2UodGhhdCwgJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuICB2YXIgbnVtYmVyTGVuZ3RoID0gK2xlbmd0aFxuICAgICwgYnl0ZUxlbmd0aCAgID0gdG9MZW5ndGgobnVtYmVyTGVuZ3RoKTtcbiAgaWYobnVtYmVyTGVuZ3RoICE9IGJ5dGVMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICByZXR1cm4gYnl0ZUxlbmd0aDtcbn07XG5cbmlmKCEkdHlwZWQuQUJWKXtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKXtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHZhbGlkYXRlQXJyYXlCdWZmZXJBcmd1bWVudHModGhpcywgbGVuZ3RoKTtcbiAgICB0aGlzLl9iICAgICAgID0gYXJyYXlGaWxsLmNhbGwoQXJyYXkoYnl0ZUxlbmd0aCksIDApO1xuICAgIHRoaXNbJExFTkdUSF0gPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCl7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkRGF0YVZpZXcsIERBVEFfVklFVyk7XG4gICAgYW5JbnN0YW5jZShidWZmZXIsICRBcnJheUJ1ZmZlciwgREFUQV9WSUVXKTtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYnVmZmVyWyRMRU5HVEhdXG4gICAgICAsIG9mZnNldCAgICAgICA9IHRvSW50ZWdlcihieXRlT2Zmc2V0KTtcbiAgICBpZihvZmZzZXQgPCAwIHx8IG9mZnNldCA+IGJ1ZmZlckxlbmd0aCl0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQhJyk7XG4gICAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPT09IHVuZGVmaW5lZCA/IGJ1ZmZlckxlbmd0aCAtIG9mZnNldCA6IHRvTGVuZ3RoKGJ5dGVMZW5ndGgpO1xuICAgIGlmKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgIHRoaXNbJEJVRkZFUl0gPSBidWZmZXI7XG4gICAgdGhpc1skT0ZGU0VUXSA9IG9mZnNldDtcbiAgICB0aGlzWyRMRU5HVEhdID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBpZihERVNDUklQVE9SUyl7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJVRkZFUiwgJ19iJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgQllURV9MRU5HVEgsICdfbCcpO1xuICAgIGFkZEdldHRlcigkRGF0YVZpZXcsIEJZVEVfT0ZGU0VULCAnX28nKTtcbiAgfVxuXG4gIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KXtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCl7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MTY6IGZ1bmN0aW9uIGdldEludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzWzFdKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJMzIoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50c1sxXSksIDIzLCA0KTtcbiAgICB9LFxuICAgIGdldEZsb2F0NjQ6IGZ1bmN0aW9uIGdldEZsb2F0NjQoYnl0ZU9mZnNldCAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHNbMV0pLCA1MiwgOCk7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKXtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSTgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0k4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0kxNiwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSTE2LCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSTMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qLCBsaXR0bGVFbmRpYW4gKi8pe1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJMzIsIHZhbHVlLCBhcmd1bWVudHNbMl0pO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiwgbGl0dGxlRW5kaWFuICovKXtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrRjMyLCB2YWx1ZSwgYXJndW1lbnRzWzJdKTtcbiAgICB9LFxuICAgIHNldEZsb2F0NjQ6IGZ1bmN0aW9uIHNldEZsb2F0NjQoYnl0ZU9mZnNldCwgdmFsdWUgLyosIGxpdHRsZUVuZGlhbiAqLyl7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Y2NCwgdmFsdWUsIGFyZ3VtZW50c1syXSk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmKCFmYWlscyhmdW5jdGlvbigpe1xuICAgIG5ldyAkQXJyYXlCdWZmZXI7ICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBuZXcgJEFycmF5QnVmZmVyKC41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgfSkpe1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCl7XG4gICAgICByZXR1cm4gbmV3IEJhc2VCdWZmZXIodmFsaWRhdGVBcnJheUJ1ZmZlckFyZ3VtZW50cyh0aGlzLCBsZW5ndGgpKTtcbiAgICB9O1xuICAgIHZhciBBcnJheUJ1ZmZlclByb3RvID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV0gPSBCYXNlQnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yKHZhciBrZXlzID0gZ09QTihCYXNlQnVmZmVyKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyApe1xuICAgICAgaWYoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKWhpZGUoJEFycmF5QnVmZmVyLCBrZXksIEJhc2VCdWZmZXJba2V5XSk7XG4gICAgfTtcbiAgICBpZighTElCUkFSWSlBcnJheUJ1ZmZlclByb3RvLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9XG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSlcbiAgICAsICRzZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdmlldy5zZXRJbnQ4KDAsIDIxNDc0ODM2NDgpO1xuICB2aWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmKHZpZXcuZ2V0SW50OCgwKSB8fCAhdmlldy5nZXRJbnQ4KDEpKXJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSl7XG4gICAgICAkc2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHRydWUpO1xufVxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuaGlkZSgkRGF0YVZpZXdbUFJPVE9UWVBFXSwgJHR5cGVkLlZJRVcsIHRydWUpO1xuZXhwb3J0c1tBUlJBWV9CVUZGRVJdID0gJEFycmF5QnVmZmVyO1xuZXhwb3J0c1tEQVRBX1ZJRVddID0gJERhdGFWaWV3OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgVFlQRUQgID0gdWlkKCd0eXBlZF9hcnJheScpXG4gICwgVklFVyAgID0gdWlkKCd2aWV3JylcbiAgLCBBQlYgICAgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZ2xvYmFsLkRhdGFWaWV3KVxuICAsIENPTlNUUiA9IEFCVlxuICAsIGkgPSAwLCBsID0gOSwgVHlwZWQ7XG5cbnZhciBUeXBlZEFycmF5Q29uc3RydWN0b3JzID0gKFxuICAnSW50OEFycmF5LFVpbnQ4QXJyYXksVWludDhDbGFtcGVkQXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXknXG4pLnNwbGl0KCcsJyk7XG5cbndoaWxlKGkgPCBsKXtcbiAgaWYoVHlwZWQgPSBnbG9iYWxbVHlwZWRBcnJheUNvbnN0cnVjdG9yc1tpKytdXSl7XG4gICAgaGlkZShUeXBlZC5wcm90b3R5cGUsIFRZUEVELCB0cnVlKTtcbiAgICBoaWRlKFR5cGVkLnByb3RvdHlwZSwgVklFVywgdHJ1ZSk7XG4gIH0gZWxzZSBDT05TVFIgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFCVjogICAgQUJWLFxuICBDT05TVFI6IENPTlNUUixcbiAgVFlQRUQ6ICBUWVBFRCxcbiAgVklFVzogICBWSUVXXG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBMSUJSQVJZICAgICAgICA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKVxuICAsIHdrc0V4dCAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpXG4gICwgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSlkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7dmFsdWU6IHdrc0V4dC5mKG5hbWUpfSk7XG59OyIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpOyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlOyIsInZhciBnbG9iYWwgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgcGFydGlhbCA9IHJlcXVpcmUoJy4vX3BhcnRpYWwnKTtcbi8vIGh0dHBzOi8vZXNkaXNjdXNzLm9yZy90b3BpYy9wcm9taXNlLXJldHVybmluZy1kZWxheS1mdW5jdGlvblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYsIHtcbiAgZGVsYXk6IGZ1bmN0aW9uIGRlbGF5KHRpbWUpe1xuICAgIHJldHVybiBuZXcgKGNvcmUuUHJvbWlzZSB8fCBnbG9iYWwuUHJvbWlzZSkoZnVuY3Rpb24ocmVzb2x2ZSl7XG4gICAgICBzZXRUaW1lb3V0KHBhcnRpYWwuY2FsbChyZXNvbHZlLCB0cnVlKSwgdGltZSk7XG4gICAgfSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgYXNzaWduICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJylcbiAgLCBjcmVhdGUgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKVxuICAsIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0S2V5cyAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpXG4gICwgZFAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGtleU9mICAgICAgICAgID0gcmVxdWlyZSgnLi9fa2V5b2YnKVxuICAsIGFGdW5jdGlvbiAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgZm9yT2YgICAgICAgICAgPSByZXF1aXJlKCcuL19mb3Itb2YnKVxuICAsIGlzSXRlcmFibGUgICAgID0gcmVxdWlyZSgnLi9jb3JlLmlzLWl0ZXJhYmxlJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJylcbiAgLCBzdGVwICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgREVTQ1JJUFRPUlMgICAgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKTtcblxuLy8gMCAtPiBEaWN0LmZvckVhY2hcbi8vIDEgLT4gRGljdC5tYXBcbi8vIDIgLT4gRGljdC5maWx0ZXJcbi8vIDMgLT4gRGljdC5zb21lXG4vLyA0IC0+IERpY3QuZXZlcnlcbi8vIDUgLT4gRGljdC5maW5kXG4vLyA2IC0+IERpY3QuZmluZEtleVxuLy8gNyAtPiBEaWN0Lm1hcFBhaXJzXG52YXIgY3JlYXRlRGljdE1ldGhvZCA9IGZ1bmN0aW9uKFRZUEUpe1xuICB2YXIgSVNfTUFQICAgPSBUWVBFID09IDFcbiAgICAsIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBjYWxsYmFja2ZuLCB0aGF0IC8qID0gdW5kZWZpbmVkICovKXtcbiAgICB2YXIgZiAgICAgID0gY3R4KGNhbGxiYWNrZm4sIHRoYXQsIDMpXG4gICAgICAsIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgICAsIHJlc3VsdCA9IElTX01BUCB8fCBUWVBFID09IDcgfHwgVFlQRSA9PSAyXG4gICAgICAgICAgPyBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogRGljdCkgOiB1bmRlZmluZWRcbiAgICAgICwga2V5LCB2YWwsIHJlcztcbiAgICBmb3Ioa2V5IGluIE8paWYoaGFzKE8sIGtleSkpe1xuICAgICAgdmFsID0gT1trZXldO1xuICAgICAgcmVzID0gZih2YWwsIGtleSwgb2JqZWN0KTtcbiAgICAgIGlmKFRZUEUpe1xuICAgICAgICBpZihJU19NQVApcmVzdWx0W2tleV0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdFtrZXldID0gdmFsOyBicmVhazsgICAgIC8vIGZpbHRlclxuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGtleTsgICAgICAgICAgICAgICAgICAgLy8gZmluZEtleVxuICAgICAgICAgIGNhc2UgNzogcmVzdWx0W3Jlc1swXV0gPSByZXNbMV07ICAgICAgLy8gbWFwUGFpcnNcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBUWVBFID09IDMgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07XG52YXIgZmluZEtleSA9IGNyZWF0ZURpY3RNZXRob2QoNik7XG5cbnZhciBjcmVhdGVEaWN0SXRlciA9IGZ1bmN0aW9uKGtpbmQpe1xuICByZXR1cm4gZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBuZXcgRGljdEl0ZXJhdG9yKGl0LCBraW5kKTtcbiAgfTtcbn07XG52YXIgRGljdEl0ZXJhdG9yID0gZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2EgPSBnZXRLZXlzKGl0ZXJhdGVkKTsgICAvLyBrZXlzXG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG59O1xuJGl0ZXJDcmVhdGUoRGljdEl0ZXJhdG9yLCAnRGljdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwgTyAgICA9IHRoYXQuX3RcbiAgICAsIGtleXMgPSB0aGF0Ll9hXG4gICAgLCBraW5kID0gdGhhdC5fa1xuICAgICwga2V5O1xuICBkbyB7XG4gICAgaWYodGhhdC5faSA+PSBrZXlzLmxlbmd0aCl7XG4gICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgfVxuICB9IHdoaWxlKCFoYXMoTywga2V5ID0ga2V5c1t0aGF0Ll9pKytdKSk7XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwga2V5KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2tleV0pO1xuICByZXR1cm4gc3RlcCgwLCBba2V5LCBPW2tleV1dKTtcbn0pO1xuXG5mdW5jdGlvbiBEaWN0KGl0ZXJhYmxlKXtcbiAgdmFyIGRpY3QgPSBjcmVhdGUobnVsbCk7XG4gIGlmKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCl7XG4gICAgaWYoaXNJdGVyYWJsZShpdGVyYWJsZSkpe1xuICAgICAgZm9yT2YoaXRlcmFibGUsIHRydWUsIGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgICBkaWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBhc3NpZ24oZGljdCwgaXRlcmFibGUpO1xuICB9XG4gIHJldHVybiBkaWN0O1xufVxuRGljdC5wcm90b3R5cGUgPSBudWxsO1xuXG5mdW5jdGlvbiByZWR1Y2Uob2JqZWN0LCBtYXBmbiwgaW5pdCl7XG4gIGFGdW5jdGlvbihtYXBmbik7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwga2V5cyAgID0gZ2V0S2V5cyhPKVxuICAgICwgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAsIGkgICAgICA9IDBcbiAgICAsIG1lbW8sIGtleTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA8IDMpe1xuICAgIGlmKCFsZW5ndGgpdGhyb3cgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgb2JqZWN0IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIG1lbW8gPSBPW2tleXNbaSsrXV07XG4gIH0gZWxzZSBtZW1vID0gT2JqZWN0KGluaXQpO1xuICB3aGlsZShsZW5ndGggPiBpKWlmKGhhcyhPLCBrZXkgPSBrZXlzW2krK10pKXtcbiAgICBtZW1vID0gbWFwZm4obWVtbywgT1trZXldLCBrZXksIG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzKG9iamVjdCwgZWwpe1xuICByZXR1cm4gKGVsID09IGVsID8ga2V5T2Yob2JqZWN0LCBlbCkgOiBmaW5kS2V5KG9iamVjdCwgZnVuY3Rpb24oaXQpe1xuICAgIHJldHVybiBpdCAhPSBpdDtcbiAgfSkpICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldChvYmplY3QsIGtleSl7XG4gIGlmKGhhcyhvYmplY3QsIGtleSkpcmV0dXJuIG9iamVjdFtrZXldO1xufVxuZnVuY3Rpb24gc2V0KG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIGlmKERFU0NSSVBUT1JTICYmIGtleSBpbiBPYmplY3QpZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGlzRGljdChpdCl7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgZ2V0UHJvdG90eXBlT2YoaXQpID09PSBEaWN0LnByb3RvdHlwZTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYsIHtEaWN0OiBEaWN0fSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRGljdCcsIHtcbiAga2V5czogICAgIGNyZWF0ZURpY3RJdGVyKCdrZXlzJyksXG4gIHZhbHVlczogICBjcmVhdGVEaWN0SXRlcigndmFsdWVzJyksXG4gIGVudHJpZXM6ICBjcmVhdGVEaWN0SXRlcignZW50cmllcycpLFxuICBmb3JFYWNoOiAgY3JlYXRlRGljdE1ldGhvZCgwKSxcbiAgbWFwOiAgICAgIGNyZWF0ZURpY3RNZXRob2QoMSksXG4gIGZpbHRlcjogICBjcmVhdGVEaWN0TWV0aG9kKDIpLFxuICBzb21lOiAgICAgY3JlYXRlRGljdE1ldGhvZCgzKSxcbiAgZXZlcnk6ICAgIGNyZWF0ZURpY3RNZXRob2QoNCksXG4gIGZpbmQ6ICAgICBjcmVhdGVEaWN0TWV0aG9kKDUpLFxuICBmaW5kS2V5OiAgZmluZEtleSxcbiAgbWFwUGFpcnM6IGNyZWF0ZURpY3RNZXRob2QoNyksXG4gIHJlZHVjZTogICByZWR1Y2UsXG4gIGtleU9mOiAgICBrZXlPZixcbiAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICBoYXM6ICAgICAgaGFzLFxuICBnZXQ6ICAgICAgZ2V0LFxuICBzZXQ6ICAgICAgc2V0LFxuICBpc0RpY3Q6ICAgaXNEaWN0XG59KTsiLCJ2YXIgcGF0aCAgICA9IHJlcXVpcmUoJy4vX3BhdGgnKVxuICAsICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuLy8gUGxhY2Vob2xkZXJcbnJlcXVpcmUoJy4vX2NvcmUnKS5fID0gcGF0aC5fID0gcGF0aC5fIHx8IHt9O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiwgJ0Z1bmN0aW9uJywge3BhcnQ6IHJlcXVpcmUoJy4vX3BhcnRpYWwnKX0pOyIsInZhciBjbGFzc29mICAgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbihpdCl7XG4gIGlmKGl0ICE9IHVuZGVmaW5lZClyZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59OyIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0ICAgICAgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZih0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTsiLCJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpXG4gICwgSVRFUkFUT1IgID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmlzSXRlcmFibGUgPSBmdW5jdGlvbihpdCl7XG4gIHZhciBPID0gT2JqZWN0KGl0KTtcbiAgcmV0dXJuIE9bSVRFUkFUT1JdICE9PSB1bmRlZmluZWRcbiAgICB8fCAnQEBpdGVyYXRvcicgaW4gT1xuICAgIHx8IEl0ZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShjbGFzc29mKE8pKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShOdW1iZXIsICdOdW1iZXInLCBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX2wgPSAraXRlcmF0ZWQ7XG4gIHRoaXMuX2kgPSAwO1xufSwgZnVuY3Rpb24oKXtcbiAgdmFyIGkgICAgPSB0aGlzLl9pKytcbiAgICAsIGRvbmUgPSAhKGkgPCB0aGlzLl9sKTtcbiAgcmV0dXJuIHtkb25lOiBkb25lLCB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IGl9O1xufSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7Y2xhc3NvZjogcmVxdWlyZSgnLi9fY2xhc3NvZicpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZSAgPSByZXF1aXJlKCcuL19vYmplY3QtZGVmaW5lJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0Jywge2RlZmluZTogZGVmaW5lfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7aXNPYmplY3Q6IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGRlZmluZSAgPSByZXF1aXJlKCcuL19vYmplY3QtZGVmaW5lJylcbiAgLCBjcmVhdGUgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHtcbiAgbWFrZTogZnVuY3Rpb24ocHJvdG8sIG1peGluKXtcbiAgICByZXR1cm4gZGVmaW5lKGNyZWF0ZShwcm90byksIG1peGluKTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2JlbmphbWluZ3IvUmV4RXhwLmVzY2FwZVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZSAgICAgPSByZXF1aXJlKCcuL19yZXBsYWNlcicpKC9bXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZ0V4cCcsIHtlc2NhcGU6IGZ1bmN0aW9uIGVzY2FwZShpdCl7IHJldHVybiAkcmUoaXQpOyB9fSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoL1smPD5cIiddL2csIHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyZhcG9zOydcbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiwgJ1N0cmluZycsIHtlc2NhcGVIVE1MOiBmdW5jdGlvbiBlc2NhcGVIVE1MKCl7IHJldHVybiAkcmUodGhpcyk7IH19KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyICRyZSA9IHJlcXVpcmUoJy4vX3JlcGxhY2VyJykoLyYoPzphbXB8bHR8Z3R8cXVvdHxhcG9zKTsvZywge1xuICAnJmFtcDsnOiAgJyYnLFxuICAnJmx0Oyc6ICAgJzwnLFxuICAnJmd0Oyc6ICAgJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhcG9zOyc6IFwiJ1wiXG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYsICdTdHJpbmcnLCB7dW5lc2NhcGVIVE1MOiAgZnVuY3Rpb24gdW5lc2NhcGVIVE1MKCl7IHJldHVybiAkcmUodGhpcyk7IH19KTsiLCIvLyAyMi4xLjMuMyBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbih0YXJnZXQsIHN0YXJ0LCBlbmQgPSB0aGlzLmxlbmd0aClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnQXJyYXknLCB7Y29weVdpdGhpbjogcmVxdWlyZSgnLi9fYXJyYXktY29weS13aXRoaW4nKX0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnY29weVdpdGhpbicpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZXZlcnkgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDQpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZXZlcnksIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy41IC8gMTUuNC40LjE2IEFycmF5LnByb3RvdHlwZS5ldmVyeShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pe1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiLy8gMjIuMS4zLjYgQXJyYXkucHJvdG90eXBlLmZpbGwodmFsdWUsIHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge2ZpbGw6IHJlcXVpcmUoJy4vX2FycmF5LWZpbGwnKX0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnZmlsbCcpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZmlsdGVyLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuNyAvIDE1LjQuNC4yMCBBcnJheS5wcm90b3R5cGUuZmlsdGVyKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuOSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkZmluZCAgID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDYpXG4gICwgS0VZICAgICA9ICdmaW5kSW5kZXgnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbi8qLCB0aGF0ID0gdW5kZWZpbmVkICovKXtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbnJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpKEtFWSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSlcbiAgLCBLRVkgICAgID0gJ2ZpbmQnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgU1RSSUNUICAgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBjdHggICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBjYWxsICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpXG4gICwgaXNBcnJheUl0ZXIgICAgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJylcbiAgLCB0b0xlbmd0aCAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKVxuICAsIGdldEl0ZXJGbiAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZS8qLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCovKXtcbiAgICB2YXIgTyAgICAgICA9IHRvT2JqZWN0KGFycmF5TGlrZSlcbiAgICAgICwgQyAgICAgICA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXlcbiAgICAgICwgYUxlbiAgICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbWFwZm4gICA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkXG4gICAgICAsIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkXG4gICAgICAsIGluZGV4ICAgPSAwXG4gICAgICAsIGl0ZXJGbiAgPSBnZXRJdGVyRm4oTylcbiAgICAgICwgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmKG1hcHBpbmcpbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZihpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSl7XG4gICAgICBmb3IoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEM7ICEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZTsgaW5kZXgrKyl7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKXtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkaW5kZXhPZiAgICAgID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCAkbmF0aXZlICAgICAgID0gW10uaW5kZXhPZlxuICAsIE5FR0FUSVZFX1pFUk8gPSAhISRuYXRpdmUgJiYgMSAvIFsxXS5pbmRleE9mKDEsIC0wKSA8IDA7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKE5FR0FUSVZFX1pFUk8gfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKSgkbmF0aXZlKSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjExIC8gMTUuNC40LjE0IEFycmF5LnByb3RvdHlwZS5pbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyAkbmF0aXZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIvLyAyMi4xLjIuMiAvIDE1LjQuMy4yIEFycmF5LmlzQXJyYXkoYXJnKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdBcnJheScsIHtpc0FycmF5OiByZXF1aXJlKCcuL19pcy1hcnJheScpfSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKVxuICAsIEl0ZXJhdG9ycyAgICAgICAgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKVxuICAsIHRvSU9iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24oaXRlcmF0ZWQsIGtpbmQpe1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uKCl7XG4gIHZhciBPICAgICA9IHRoaXMuX3RcbiAgICAsIGtpbmQgID0gdGhpcy5fa1xuICAgICwgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKXtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmKGtpbmQgPT0gJ2tleXMnICApcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZihraW5kID09ICd2YWx1ZXMnKXJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMi4xLjMuMTMgQXJyYXkucHJvdG90eXBlLmpvaW4oc2VwYXJhdG9yKVxudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlKb2luID0gW10uam9pbjtcblxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIHN0cmluZ3NcbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKHJlcXVpcmUoJy4vX2lvYmplY3QnKSAhPSBPYmplY3QgfHwgIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShhcnJheUpvaW4pKSwgJ0FycmF5Jywge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcil7XG4gICAgcmV0dXJuIGFycmF5Sm9pbi5jYWxsKHRvSU9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvSW50ZWdlciAgICAgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCB0b0xlbmd0aCAgICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCAkbmF0aXZlICAgICAgID0gW10ubGFzdEluZGV4T2ZcbiAgLCBORUdBVElWRV9aRVJPID0gISEkbmF0aXZlICYmIDEgLyBbMV0ubGFzdEluZGV4T2YoMSwgLTApIDwgMDtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoTkVHQVRJVkVfWkVSTyB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRuYXRpdmUpKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTQgLyAxNS40LjQuMTUgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgWywgZnJvbUluZGV4XSlcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyosIGZyb21JbmRleCA9IEBbKi0xXSAqLyl7XG4gICAgLy8gY29udmVydCAtMCB0byArMFxuICAgIGlmKE5FR0FUSVZFX1pFUk8pcmV0dXJuICRuYXRpdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCAwO1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QodGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IGxlbmd0aCAtIDE7XG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpaW5kZXggPSBNYXRoLm1pbihpbmRleCwgdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpO1xuICAgIGlmKGluZGV4IDwgMClpbmRleCA9IGxlbmd0aCArIGluZGV4O1xuICAgIGZvcig7aW5kZXggPj0gMDsgaW5kZXgtLSlpZihpbmRleCBpbiBPKWlmKE9baW5kZXhdID09PSBzZWFyY2hFbGVtZW50KXJldHVybiBpbmRleCB8fCAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRtYXAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5tYXAsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xNSAvIDE1LjQuNC4xOSBBcnJheS5wcm90b3R5cGUubWFwKGNhbGxiYWNrZm4gWywgdGhpc0FyZ10pXG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHNbMV0pO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIFdlYktpdCBBcnJheS5vZiBpc24ndCBnZW5lcmljXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjMgQXJyYXkub2YoIC4uLml0ZW1zKVxuICBvZjogZnVuY3Rpb24gb2YoLyogLi4uYXJncyAqLyl7XG4gICAgdmFyIGluZGV4ICA9IDBcbiAgICAgICwgYUxlbiAgID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgLCByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFMZW4pO1xuICAgIHdoaWxlKGFMZW4gPiBpbmRleCljcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhTGVuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2VSaWdodCwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE5IC8gMTUuNC40LjIyIEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodChjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbiByZWR1Y2VSaWdodChjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIHRydWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5LXJlZHVjZScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10ucmVkdWNlLCB0cnVlKSwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTggLyAxNS40LjQuMjEgQXJyYXkucHJvdG90eXBlLnJlZHVjZShjYWxsYmFja2ZuIFssIGluaXRpYWxWYWx1ZV0pXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pe1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50c1sxXSwgZmFsc2UpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaHRtbCAgICAgICA9IHJlcXVpcmUoJy4vX2h0bWwnKVxuICAsIGNvZiAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIHRvSW5kZXggICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpXG4gICwgdG9MZW5ndGggICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXJyYXlTbGljZSA9IFtdLnNsaWNlO1xuXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgaWYoaHRtbClhcnJheVNsaWNlLmNhbGwoaHRtbCk7XG59KSwgJ0FycmF5Jywge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2UoYmVnaW4sIGVuZCl7XG4gICAgdmFyIGxlbiAgID0gdG9MZW5ndGgodGhpcy5sZW5ndGgpXG4gICAgICAsIGtsYXNzID0gY29mKHRoaXMpO1xuICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kO1xuICAgIGlmKGtsYXNzID09ICdBcnJheScpcmV0dXJuIGFycmF5U2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB2YXIgc3RhcnQgID0gdG9JbmRleChiZWdpbiwgbGVuKVxuICAgICAgLCB1cFRvICAgPSB0b0luZGV4KGVuZCwgbGVuKVxuICAgICAgLCBzaXplICAgPSB0b0xlbmd0aCh1cFRvIC0gc3RhcnQpXG4gICAgICAsIGNsb25lZCA9IEFycmF5KHNpemUpXG4gICAgICAsIGkgICAgICA9IDA7XG4gICAgZm9yKDsgaSA8IHNpemU7IGkrKyljbG9uZWRbaV0gPSBrbGFzcyA9PSAnU3RyaW5nJ1xuICAgICAgPyB0aGlzLmNoYXJBdChzdGFydCArIGkpXG4gICAgICA6IHRoaXNbc3RhcnQgKyBpXTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHNvbWUgICA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgzKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnNvbWUsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4yMyAvIDE1LjQuNC4xNyBBcnJheS5wcm90b3R5cGUuc29tZShjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBzb21lOiBmdW5jdGlvbiBzb21lKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9PYmplY3QgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBmYWlscyAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgJHNvcnQgICAgID0gW10uc29ydFxuICAsIHRlc3QgICAgICA9IFsxLCAyLCAzXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gSUU4LVxuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbigpe1xuICAvLyBWOCBidWdcbiAgdGVzdC5zb3J0KG51bGwpO1xuICAvLyBPbGQgV2ViS2l0XG59KSB8fCAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKCRzb3J0KSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjI1IEFycmF5LnByb3RvdHlwZS5zb3J0KGNvbXBhcmVmbilcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pe1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpKVxuICAgICAgOiAkc29ydC5jYWxsKHRvT2JqZWN0KHRoaXMpLCBhRnVuY3Rpb24oY29tcGFyZWZuKSk7XG4gIH1cbn0pOyIsInJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoJ0FycmF5Jyk7IiwiLy8gMjAuMy4zLjEgLyAxNS45LjQuNCBEYXRlLm5vdygpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ0RhdGUnLCB7bm93OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH19KTsiLCIndXNlIHN0cmljdCc7XG4vLyAyMC4zLjQuMzYgLyAxNS45LjUuNDMgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcoKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ2V0VGltZSA9IERhdGUucHJvdG90eXBlLmdldFRpbWU7XG5cbnZhciBseiA9IGZ1bmN0aW9uKG51bSl7XG4gIHJldHVybiBudW0gPiA5ID8gbnVtIDogJzAnICsgbnVtO1xufTtcblxuLy8gUGhhbnRvbUpTIC8gb2xkIFdlYktpdCBoYXMgYSBicm9rZW4gaW1wbGVtZW50YXRpb25zXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChmYWlscyhmdW5jdGlvbigpe1xuICByZXR1cm4gbmV3IERhdGUoLTVlMTMgLSAxKS50b0lTT1N0cmluZygpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uKCl7XG4gIG5ldyBEYXRlKE5hTikudG9JU09TdHJpbmcoKTtcbn0pKSwgJ0RhdGUnLCB7XG4gIHRvSVNPU3RyaW5nOiBmdW5jdGlvbiB0b0lTT1N0cmluZygpe1xuICAgIGlmKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKXRocm93IFJhbmdlRXJyb3IoJ0ludmFsaWQgdGltZSB2YWx1ZScpO1xuICAgIHZhciBkID0gdGhpc1xuICAgICAgLCB5ID0gZC5nZXRVVENGdWxsWWVhcigpXG4gICAgICAsIG0gPSBkLmdldFVUQ01pbGxpc2Vjb25kcygpXG4gICAgICAsIHMgPSB5IDwgMCA/ICctJyA6IHkgPiA5OTk5ID8gJysnIDogJyc7XG4gICAgcmV0dXJuIHMgKyAoJzAwMDAwJyArIE1hdGguYWJzKHkpKS5zbGljZShzID8gLTYgOiAtNCkgK1xuICAgICAgJy0nICsgbHooZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBseihkLmdldFVUQ0RhdGUoKSkgK1xuICAgICAgJ1QnICsgbHooZC5nZXRVVENIb3VycygpKSArICc6JyArIGx6KGQuZ2V0VVRDTWludXRlcygpKSArXG4gICAgICAnOicgKyBseihkLmdldFVUQ1NlY29uZHMoKSkgKyAnLicgKyAobSA+IDk5ID8gbSA6ICcwJyArIGx6KG0pKSArICdaJztcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgRGF0ZShOYU4pLnRvSlNPTigpICE9PSBudWxsIHx8IERhdGUucHJvdG90eXBlLnRvSlNPTi5jYWxsKHt0b0lTT1N0cmluZzogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH19KSAhPT0gMTtcbn0pLCAnRGF0ZScsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oa2V5KXtcbiAgICB2YXIgTyAgPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pOyIsInZhciBUT19QUklNSVRJVkUgPSByZXF1aXJlKCcuL193a3MnKSgndG9QcmltaXRpdmUnKVxuICAsIHByb3RvICAgICAgICA9IERhdGUucHJvdG90eXBlO1xuXG5pZighKFRPX1BSSU1JVElWRSBpbiBwcm90bykpcmVxdWlyZSgnLi9faGlkZScpKHByb3RvLCBUT19QUklNSVRJVkUsIHJlcXVpcmUoJy4vX2RhdGUtdG8tcHJpbWl0aXZlJykpOyIsInZhciBEYXRlUHJvdG8gICAgPSBEYXRlLnByb3RvdHlwZVxuICAsIElOVkFMSURfREFURSA9ICdJbnZhbGlkIERhdGUnXG4gICwgVE9fU1RSSU5HICAgID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyAgICA9IERhdGVQcm90b1tUT19TVFJJTkddXG4gICwgZ2V0VGltZSAgICAgID0gRGF0ZVByb3RvLmdldFRpbWU7XG5pZihuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShEYXRlUHJvdG8sIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgdmFsdWUgPSBnZXRUaW1lLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICR0b1N0cmluZy5jYWxsKHRoaXMpIDogSU5WQUxJRF9EQVRFO1xuICB9KTtcbn0iLCIvLyAxOS4yLjMuMiAvIDE1LjMuNC41IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKHRoaXNBcmcsIGFyZ3MuLi4pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0Z1bmN0aW9uJywge2JpbmQ6IHJlcXVpcmUoJy4vX2JpbmQnKX0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBIQVNfSU5TVEFOQ0UgICA9IHJlcXVpcmUoJy4vX3drcycpKCdoYXNJbnN0YW5jZScpXG4gICwgRnVuY3Rpb25Qcm90byAgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyAxOS4yLjMuNiBGdW5jdGlvbi5wcm90b3R5cGVbQEBoYXNJbnN0YW5jZV0oVilcbmlmKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG8pKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoRnVuY3Rpb25Qcm90bywgSEFTX0lOU1RBTkNFLCB7dmFsdWU6IGZ1bmN0aW9uKE8pe1xuICBpZih0eXBlb2YgdGhpcyAhPSAnZnVuY3Rpb24nIHx8ICFpc09iamVjdChPKSlyZXR1cm4gZmFsc2U7XG4gIGlmKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpcmV0dXJuIE8gaW5zdGFuY2VvZiB0aGlzO1xuICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpaWYodGhpcy5wcm90b3R5cGUgPT09IE8pcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn19KTsiLCJ2YXIgZFAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgaGFzICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgRlByb3RvICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZVxuICAsIG5hbWVSRSAgICAgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS9cbiAgLCBOQU1FICAgICAgID0gJ25hbWUnO1xuXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbigpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgZFAoRlByb3RvLCBOQU1FLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpe1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICAgLCBuYW1lID0gKCcnICsgdGhhdCkubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIGhhcyh0aGF0LCBOQU1FKSB8fCAhaXNFeHRlbnNpYmxlKHRoYXQpIHx8IGRQKHRoYXQsIE5BTUUsIGNyZWF0ZURlc2MoNSwgbmFtZSkpO1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnTWFwJywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMS4zLjYgTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpe1xuICAgIHZhciBlbnRyeSA9IHN0cm9uZy5nZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52O1xuICB9LFxuICAvLyAyMy4xLjMuOSBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7IiwiLy8gMjAuMi4yLjMgTWF0aC5hY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGxvZzFwICAgPSByZXF1aXJlKCcuL19tYXRoLWxvZzFwJylcbiAgLCBzcXJ0ICAgID0gTWF0aC5zcXJ0XG4gICwgJGFjb3NoICA9IE1hdGguYWNvc2g7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYWNvc2hcbiAgLy8gVjggYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzUwOVxuICAmJiBNYXRoLmZsb29yKCRhY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgPT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOIFxuICAmJiAkYWNvc2goSW5maW5pdHkpID09IEluZmluaXR5XG4pLCAnTWF0aCcsIHtcbiAgYWNvc2g6IGZ1bmN0aW9uIGFjb3NoKHgpe1xuICAgIHJldHVybiAoeCA9ICt4KSA8IDEgPyBOYU4gOiB4ID4gOTQ5MDYyNjUuNjI0MjUxNTZcbiAgICAgID8gTWF0aC5sb2coeCkgKyBNYXRoLkxOMlxuICAgICAgOiBsb2cxcCh4IC0gMSArIHNxcnQoeCAtIDEpICogc3FydCh4ICsgMSkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuNSBNYXRoLmFzaW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGFzaW5oICA9IE1hdGguYXNpbmg7XG5cbmZ1bmN0aW9uIGFzaW5oKHgpe1xuICByZXR1cm4gIWlzRmluaXRlKHggPSAreCkgfHwgeCA9PSAwID8geCA6IHggPCAwID8gLWFzaW5oKC14KSA6IE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSk7XG59XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hc2luaCgwKSAtPiAtMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXNpbmggJiYgMSAvICRhc2luaCgwKSA+IDApLCAnTWF0aCcsIHthc2luaDogYXNpbmh9KTsiLCIvLyAyMC4yLjIuNyBNYXRoLmF0YW5oKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0YW5oICA9IE1hdGguYXRhbmg7XG5cbi8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hdGFuaCgtMCkgLT4gMCBcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISgkYXRhbmggJiYgMSAvICRhdGFuaCgtMCkgPCAwKSwgJ01hdGgnLCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KXtcbiAgICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSkgLyAyO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuOSBNYXRoLmNicnQoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgID0gcmVxdWlyZSgnLi9fbWF0aC1zaWduJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KXtcbiAgICByZXR1cm4gc2lnbih4ID0gK3gpICogTWF0aC5wb3coTWF0aC5hYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjExIE1hdGguY2x6MzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgY2x6MzI6IGZ1bmN0aW9uIGNsejMyKHgpe1xuICAgIHJldHVybiAoeCA+Pj49IDApID8gMzEgLSBNYXRoLmZsb29yKE1hdGgubG9nKHggKyAwLjUpICogTWF0aC5MT0cyRSkgOiAzMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjEyIE1hdGguY29zaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cCAgICAgPSBNYXRoLmV4cDtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBjb3NoOiBmdW5jdGlvbiBjb3NoKHgpe1xuICAgIHJldHVybiAoZXhwKHggPSAreCkgKyBleHAoLXgpKSAvIDI7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4xNCBNYXRoLmV4cG0xKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGV4cG0xICA9IHJlcXVpcmUoJy4vX21hdGgtZXhwbTEnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoJGV4cG0xICE9IE1hdGguZXhwbTEpLCAnTWF0aCcsIHtleHBtMTogJGV4cG0xfSk7IiwiLy8gMjAuMi4yLjE2IE1hdGguZnJvdW5kKHgpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBzaWduICAgICAgPSByZXF1aXJlKCcuL19tYXRoLXNpZ24nKVxuICAsIHBvdyAgICAgICA9IE1hdGgucG93XG4gICwgRVBTSUxPTiAgID0gcG93KDIsIC01MilcbiAgLCBFUFNJTE9OMzIgPSBwb3coMiwgLTIzKVxuICAsIE1BWDMyICAgICA9IHBvdygyLCAxMjcpICogKDIgLSBFUFNJTE9OMzIpXG4gICwgTUlOMzIgICAgID0gcG93KDIsIC0xMjYpO1xuXG52YXIgcm91bmRUaWVzVG9FdmVuID0gZnVuY3Rpb24obil7XG4gIHJldHVybiBuICsgMSAvIEVQU0lMT04gLSAxIC8gRVBTSUxPTjtcbn07XG5cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBmcm91bmQ6IGZ1bmN0aW9uIGZyb3VuZCh4KXtcbiAgICB2YXIgJGFicyAgPSBNYXRoLmFicyh4KVxuICAgICAgLCAkc2lnbiA9IHNpZ24oeClcbiAgICAgICwgYSwgcmVzdWx0O1xuICAgIGlmKCRhYnMgPCBNSU4zMilyZXR1cm4gJHNpZ24gKiByb3VuZFRpZXNUb0V2ZW4oJGFicyAvIE1JTjMyIC8gRVBTSUxPTjMyKSAqIE1JTjMyICogRVBTSUxPTjMyO1xuICAgIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgICByZXN1bHQgPSBhIC0gKGEgLSAkYWJzKTtcbiAgICBpZihyZXN1bHQgPiBNQVgzMiB8fCByZXN1bHQgIT0gcmVzdWx0KXJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICAgIHJldHVybiAkc2lnbiAqIHJlc3VsdDtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjE3IE1hdGguaHlwb3QoW3ZhbHVlMVssIHZhbHVlMlssIOKApiBdXV0pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYWJzICAgICA9IE1hdGguYWJzO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGh5cG90OiBmdW5jdGlvbiBoeXBvdCh2YWx1ZTEsIHZhbHVlMil7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3VtICA9IDBcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgbGFyZyA9IDBcbiAgICAgICwgYXJnLCBkaXY7XG4gICAgd2hpbGUoaSA8IGFMZW4pe1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmKGxhcmcgPCBhcmcpe1xuICAgICAgICBkaXYgID0gbGFyZyAvIGFyZztcbiAgICAgICAgc3VtICA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYoYXJnID4gMCl7XG4gICAgICAgIGRpdiAgPSBhcmcgLyBsYXJnO1xuICAgICAgICBzdW0gKz0gZGl2ICogZGl2O1xuICAgICAgfSBlbHNlIHN1bSArPSBhcmc7XG4gICAgfVxuICAgIHJldHVybiBsYXJnID09PSBJbmZpbml0eSA/IEluZmluaXR5IDogbGFyZyAqIE1hdGguc3FydChzdW0pO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMTggTWF0aC5pbXVsKHgsIHkpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGltdWwgICA9IE1hdGguaW11bDtcblxuLy8gc29tZSBXZWJLaXQgdmVyc2lvbnMgZmFpbHMgd2l0aCBiaWcgbnVtYmVycywgc29tZSBoYXMgd3JvbmcgYXJpdHlcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICByZXR1cm4gJGltdWwoMHhmZmZmZmZmZiwgNSkgIT0gLTUgfHwgJGltdWwubGVuZ3RoICE9IDI7XG59KSwgJ01hdGgnLCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSl7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCB4biA9ICt4XG4gICAgICAsIHluID0gK3lcbiAgICAgICwgeGwgPSBVSU5UMTYgJiB4blxuICAgICAgLCB5bCA9IFVJTlQxNiAmIHluO1xuICAgIHJldHVybiAwIHwgeGwgKiB5bCArICgoVUlOVDE2ICYgeG4gPj4+IDE2KSAqIHlsICsgeGwgKiAoVUlOVDE2ICYgeW4gPj4+IDE2KSA8PCAxNiA+Pj4gMCk7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMSBNYXRoLmxvZzEwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7XG4gIGxvZzEwOiBmdW5jdGlvbiBsb2cxMCh4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG4gIH1cbn0pOyIsIi8vIDIwLjIuMi4yMCBNYXRoLmxvZzFwKHgpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ01hdGgnLCB7bG9nMXA6IHJlcXVpcmUoJy4vX21hdGgtbG9nMXAnKX0pOyIsIi8vIDIwLjIuMi4yMiBNYXRoLmxvZzIoeClcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KXtcbiAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjI4IE1hdGguc2lnbih4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge3NpZ246IHJlcXVpcmUoJy4vX21hdGgtc2lnbicpfSk7IiwiLy8gMjAuMi4yLjMwIE1hdGguc2luaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhTWF0aC5zaW5oKC0yZS0xNykgIT0gLTJlLTE3O1xufSksICdNYXRoJywge1xuICBzaW5oOiBmdW5jdGlvbiBzaW5oKHgpe1xuICAgIHJldHVybiBNYXRoLmFicyh4ID0gK3gpIDwgMVxuICAgICAgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMlxuICAgICAgOiAoZXhwKHggLSAxKSAtIGV4cCgteCAtIDEpKSAqIChNYXRoLkUgLyAyKTtcbiAgfVxufSk7IiwiLy8gMjAuMi4yLjMzIE1hdGgudGFuaCh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGV4cG0xICAgPSByZXF1aXJlKCcuL19tYXRoLWV4cG0xJylcbiAgLCBleHAgICAgID0gTWF0aC5leHA7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgdGFuaDogZnVuY3Rpb24gdGFuaCh4KXtcbiAgICB2YXIgYSA9IGV4cG0xKHggPSAreClcbiAgICAgICwgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTsiLCIvLyAyMC4yLjIuMzQgTWF0aC50cnVuYyh4KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpe1xuICAgIHJldHVybiAoaXQgPiAwID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbCkoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufSIsIi8vIDIwLjEuMi4xIE51bWJlci5FUFNJTE9OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtFUFNJTE9OOiBNYXRoLnBvdygyLCAtNTIpfSk7IiwiLy8gMjAuMS4yLjIgTnVtYmVyLmlzRmluaXRlKG51bWJlcilcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIF9pc0Zpbml0ZSA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KXtcbiAgICByZXR1cm4gdHlwZW9mIGl0ID09ICdudW1iZXInICYmIF9pc0Zpbml0ZShpdCk7XG4gIH1cbn0pOyIsIi8vIDIwLjEuMi4zIE51bWJlci5pc0ludGVnZXIobnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7aXNJbnRlZ2VyOiByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJyl9KTsiLCIvLyAyMC4xLjIuNCBOdW1iZXIuaXNOYU4obnVtYmVyKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpe1xuICAgIHJldHVybiBudW1iZXIgIT0gbnVtYmVyO1xuICB9XG59KTsiLCIvLyAyMC4xLjIuNSBOdW1iZXIuaXNTYWZlSW50ZWdlcihudW1iZXIpXG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBpc0ludGVnZXIgPSByZXF1aXJlKCcuL19pcy1pbnRlZ2VyJylcbiAgLCBhYnMgICAgICAgPSBNYXRoLmFicztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdOdW1iZXInLCB7XG4gIGlzU2FmZUludGVnZXI6IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIobnVtYmVyKXtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxZmZmZmZmZmZmZmZmZjtcbiAgfVxufSk7IiwiLy8gMjAuMS4yLjYgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01BWF9TQUZFX0lOVEVHRVI6IDB4MWZmZmZmZmZmZmZmZmZ9KTsiLCIvLyAyMC4xLjIuMTAgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTnVtYmVyJywge01JTl9TQUZFX0lOVEVHRVI6IC0weDFmZmZmZmZmZmZmZmZmfSk7IiwidmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4vX3BhcnNlLWZsb2F0Jyk7XG4vLyAyMC4xLjIuMTIgTnVtYmVyLnBhcnNlRmxvYXQoc3RyaW5nKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTnVtYmVyLnBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCAnTnVtYmVyJywge3BhcnNlRmxvYXQ6ICRwYXJzZUZsb2F0fSk7IiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhcnNlSW50ID0gcmVxdWlyZSgnLi9fcGFyc2UtaW50Jyk7XG4vLyAyMC4xLjIuMTMgTnVtYmVyLnBhcnNlSW50KHN0cmluZywgcmFkaXgpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChOdW1iZXIucGFyc2VJbnQgIT0gJHBhcnNlSW50KSwgJ051bWJlcicsIHtwYXJzZUludDogJHBhcnNlSW50fSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JbnRlZ2VyICAgID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgYU51bWJlclZhbHVlID0gcmVxdWlyZSgnLi9fYS1udW1iZXItdmFsdWUnKVxuICAsIHJlcGVhdCAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxuICAsICR0b0ZpeGVkICAgICA9IDEuLnRvRml4ZWRcbiAgLCBmbG9vciAgICAgICAgPSBNYXRoLmZsb29yXG4gICwgZGF0YSAgICAgICAgID0gWzAsIDAsIDAsIDAsIDAsIDBdXG4gICwgRVJST1IgICAgICAgID0gJ051bWJlci50b0ZpeGVkOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnXG4gICwgWkVSTyAgICAgICAgID0gJzAnO1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbihuLCBjKXtcbiAgdmFyIGkgID0gLTFcbiAgICAsIGMyID0gYztcbiAgd2hpbGUoKytpIDwgNil7XG4gICAgYzIgKz0gbiAqIGRhdGFbaV07XG4gICAgZGF0YVtpXSA9IGMyICUgMWU3O1xuICAgIGMyID0gZmxvb3IoYzIgLyAxZTcpO1xuICB9XG59O1xudmFyIGRpdmlkZSA9IGZ1bmN0aW9uKG4pe1xuICB2YXIgaSA9IDZcbiAgICAsIGMgPSAwO1xuICB3aGlsZSgtLWkgPj0gMCl7XG4gICAgYyArPSBkYXRhW2ldO1xuICAgIGRhdGFbaV0gPSBmbG9vcihjIC8gbik7XG4gICAgYyA9IChjICUgbikgKiAxZTc7XG4gIH1cbn07XG52YXIgbnVtVG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgaSA9IDZcbiAgICAsIHMgPSAnJztcbiAgd2hpbGUoLS1pID49IDApe1xuICAgIGlmKHMgIT09ICcnIHx8IGkgPT09IDAgfHwgZGF0YVtpXSAhPT0gMCl7XG4gICAgICB2YXIgdCA9IFN0cmluZyhkYXRhW2ldKTtcbiAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoWkVSTywgNyAtIHQubGVuZ3RoKSArIHQ7XG4gICAgfVxuICB9IHJldHVybiBzO1xufTtcbnZhciBwb3cgPSBmdW5jdGlvbih4LCBuLCBhY2Mpe1xuICByZXR1cm4gbiA9PT0gMCA/IGFjYyA6IG4gJSAyID09PSAxID8gcG93KHgsIG4gLSAxLCBhY2MgKiB4KSA6IHBvdyh4ICogeCwgbiAvIDIsIGFjYyk7XG59O1xudmFyIGxvZyA9IGZ1bmN0aW9uKHgpe1xuICB2YXIgbiAgPSAwXG4gICAgLCB4MiA9IHg7XG4gIHdoaWxlKHgyID49IDQwOTYpe1xuICAgIG4gKz0gMTI7XG4gICAgeDIgLz0gNDA5NjtcbiAgfVxuICB3aGlsZSh4MiA+PSAyKXtcbiAgICBuICArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqICghISR0b0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguLnRvRml4ZWQoMCkgIT09ICcxMDAwMDAwMDAwMDAwMDAwMTI4J1xuKSB8fCAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICAvLyBWOCB+IEFuZHJvaWQgNC4zLVxuICAkdG9GaXhlZC5jYWxsKHt9KTtcbn0pKSwgJ051bWJlcicsIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cyl7XG4gICAgdmFyIHggPSBhTnVtYmVyVmFsdWUodGhpcywgRVJST1IpXG4gICAgICAsIGYgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpXG4gICAgICAsIHMgPSAnJ1xuICAgICAgLCBtID0gWkVST1xuICAgICAgLCBlLCB6LCBqLCBrO1xuICAgIGlmKGYgPCAwIHx8IGYgPiAyMCl0aHJvdyBSYW5nZUVycm9yKEVSUk9SKTtcbiAgICBpZih4ICE9IHgpcmV0dXJuICdOYU4nO1xuICAgIGlmKHggPD0gLTFlMjEgfHwgeCA+PSAxZTIxKXJldHVybiBTdHJpbmcoeCk7XG4gICAgaWYoeCA8IDApe1xuICAgICAgcyA9ICctJztcbiAgICAgIHggPSAteDtcbiAgICB9XG4gICAgaWYoeCA+IDFlLTIxKXtcbiAgICAgIGUgPSBsb2coeCAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyB4ICogcG93KDIsIC1lLCAxKSA6IHggLyBwb3coMiwgZSwgMSk7XG4gICAgICB6ICo9IDB4MTAwMDAwMDAwMDAwMDA7XG4gICAgICBlID0gNTIgLSBlO1xuICAgICAgaWYoZSA+IDApe1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGY7XG4gICAgICAgIHdoaWxlKGogPj0gNyl7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUoaiA+PSAyMyl7XG4gICAgICAgICAgZGl2aWRlKDEgPDwgMjMpO1xuICAgICAgICAgIGogLT0gMjM7XG4gICAgICAgIH1cbiAgICAgICAgZGl2aWRlKDEgPDwgaik7XG4gICAgICAgIG11bHRpcGx5KDEsIDEpO1xuICAgICAgICBkaXZpZGUoMik7XG4gICAgICAgIG0gPSBudW1Ub1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoMCwgeik7XG4gICAgICAgIG11bHRpcGx5KDEgPDwgLWUsIDApO1xuICAgICAgICBtID0gbnVtVG9TdHJpbmcoKSArIHJlcGVhdC5jYWxsKFpFUk8sIGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZihmID4gMCl7XG4gICAgICBrID0gbS5sZW5ndGg7XG4gICAgICBtID0gcyArIChrIDw9IGYgPyAnMC4nICsgcmVwZWF0LmNhbGwoWkVSTywgZiAtIGspICsgbSA6IG0uc2xpY2UoMCwgayAtIGYpICsgJy4nICsgbS5zbGljZShrIC0gZikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcyArIG07XG4gICAgfSByZXR1cm4gbTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZhaWxzICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGFOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4vX2EtbnVtYmVyLXZhbHVlJylcbiAgLCAkdG9QcmVjaXNpb24gPSAxLi50b1ByZWNpc2lvbjtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIC8vIElFNy1cbiAgcmV0dXJuICR0b1ByZWNpc2lvbi5jYWxsKDEsIHVuZGVmaW5lZCkgIT09ICcxJztcbn0pIHx8ICEkZmFpbHMoZnVuY3Rpb24oKXtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgJHRvUHJlY2lzaW9uLmNhbGwoe30pO1xufSkpLCAnTnVtYmVyJywge1xuICB0b1ByZWNpc2lvbjogZnVuY3Rpb24gdG9QcmVjaXNpb24ocHJlY2lzaW9uKXtcbiAgICB2YXIgdGhhdCA9IGFOdW1iZXJWYWx1ZSh0aGlzLCAnTnVtYmVyI3RvUHJlY2lzaW9uOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWQgPyAkdG9QcmVjaXNpb24uY2FsbCh0aGF0KSA6ICR0b1ByZWNpc2lvbi5jYWxsKHRoYXQsIHByZWNpc2lvbik7IFxuICB9XG59KTsiLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4vLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge2NyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpfSk7IiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0Jywge2RlZmluZVByb3BlcnR5OiByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mfSk7IiwiLy8gMTkuMS4yLjUgT2JqZWN0LmZyZWV6ZShPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdmcmVlemUnLCBmdW5jdGlvbigkZnJlZXplKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZyZWV6ZShpdCl7XG4gICAgcmV0dXJuICRmcmVlemUgJiYgaXNPYmplY3QoaXQpID8gJGZyZWV6ZShtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eU5hbWVzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpLmY7XG59KTsiLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihpdCl7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjExIE9iamVjdC5pc0V4dGVuc2libGUoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2lzRXh0ZW5zaWJsZScsIGZ1bmN0aW9uKCRpc0V4dGVuc2libGUpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNFeHRlbnNpYmxlKGl0KXtcbiAgICByZXR1cm4gaXNPYmplY3QoaXQpID8gJGlzRXh0ZW5zaWJsZSA/ICRpc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjEyIE9iamVjdC5pc0Zyb3plbihPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNGcm96ZW4nLCBmdW5jdGlvbigkaXNGcm96ZW4pe1xuICByZXR1cm4gZnVuY3Rpb24gaXNGcm96ZW4oaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNGcm96ZW4gPyAkaXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjEzIE9iamVjdC5pc1NlYWxlZChPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnaXNTZWFsZWQnLCBmdW5jdGlvbigkaXNTZWFsZWQpe1xuICByZXR1cm4gZnVuY3Rpb24gaXNTZWFsZWQoaXQpe1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyAkaXNTZWFsZWQgPyAkaXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9O1xufSk7IiwiLy8gMTkuMS4zLjEwIE9iamVjdC5pcyh2YWx1ZTEsIHZhbHVlMilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtpczogcmVxdWlyZSgnLi9fc2FtZS12YWx1ZScpfSk7IiwiLy8gMTkuMS4yLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsICRrZXlzICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdrZXlzJywgZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoaXQpe1xuICAgIHJldHVybiAka2V5cyh0b09iamVjdChpdCkpO1xuICB9O1xufSk7IiwiLy8gMTkuMS4yLjE1IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyhPKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBtZXRhICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5vbkZyZWV6ZTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdwcmV2ZW50RXh0ZW5zaW9ucycsIGZ1bmN0aW9uKCRwcmV2ZW50RXh0ZW5zaW9ucyl7XG4gIHJldHVybiBmdW5jdGlvbiBwcmV2ZW50RXh0ZW5zaW9ucyhpdCl7XG4gICAgcmV0dXJuICRwcmV2ZW50RXh0ZW5zaW9ucyAmJiBpc09iamVjdChpdCkgPyAkcHJldmVudEV4dGVuc2lvbnMobWV0YShpdCkpIDogaXQ7XG4gIH07XG59KTsiLCIvLyAxOS4xLjIuMTcgT2JqZWN0LnNlYWwoTylcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgbWV0YSAgICAgPSByZXF1aXJlKCcuL19tZXRhJykub25GcmVlemU7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnc2VhbCcsIGZ1bmN0aW9uKCRzZWFsKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYWwoaXQpe1xuICAgIHJldHVybiAkc2VhbCAmJiBpc09iamVjdChpdCkgPyAkc2VhbChtZXRhKGl0KSkgOiBpdDtcbiAgfTtcbn0pOyIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7c2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldH0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJylcbiAgLCB0ZXN0ICAgID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpe1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn0iLCJ2YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRwYXJzZUZsb2F0ID0gcmVxdWlyZSgnLi9fcGFyc2UtZmxvYXQnKTtcbi8vIDE4LjIuNCBwYXJzZUZsb2F0KHN0cmluZylcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5GICogKHBhcnNlRmxvYXQgIT0gJHBhcnNlRmxvYXQpLCB7cGFyc2VGbG9hdDogJHBhcnNlRmxvYXR9KTsiLCJ2YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFyc2VJbnQgPSByZXF1aXJlKCcuL19wYXJzZS1pbnQnKTtcbi8vIDE4LjIuNSBwYXJzZUludChzdHJpbmcsIHJhZGl4KVxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkYgKiAocGFyc2VJbnQgIT0gJHBhcnNlSW50KSwge3BhcnNlSW50OiAkcGFyc2VJbnR9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgTElCUkFSWSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbGlicmFyeScpXG4gICwgZ2xvYmFsICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjdHggICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIGNsYXNzb2YgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKVxuICAsICRleHBvcnQgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBhbkluc3RhbmNlICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpXG4gICwgZm9yT2YgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJylcbiAgLCB0YXNrICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190YXNrJykuc2V0XG4gICwgbWljcm90YXNrICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIFBST01JU0UgICAgICAgICAgICA9ICdQcm9taXNlJ1xuICAsIFR5cGVFcnJvciAgICAgICAgICA9IGdsb2JhbC5UeXBlRXJyb3JcbiAgLCBwcm9jZXNzICAgICAgICAgICAgPSBnbG9iYWwucHJvY2Vzc1xuICAsICRQcm9taXNlICAgICAgICAgICA9IGdsb2JhbFtQUk9NSVNFXVxuICAsIHByb2Nlc3MgICAgICAgICAgICA9IGdsb2JhbC5wcm9jZXNzXG4gICwgaXNOb2RlICAgICAgICAgICAgID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2VzcydcbiAgLCBlbXB0eSAgICAgICAgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgSW50ZXJuYWwsIEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcblxudmFyIFVTRV9OQVRJVkUgPSAhIWZ1bmN0aW9uKCl7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgICAgID0gJFByb21pc2UucmVzb2x2ZSgxKVxuICAgICAgLCBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24oZXhlYyl7IGV4ZWMoZW1wdHksIGVtcHR5KTsgfTtcbiAgICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gICAgcmV0dXJuIChpc05vZGUgfHwgdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PSAnZnVuY3Rpb24nKSAmJiBwcm9taXNlLnRoZW4oZW1wdHkpIGluc3RhbmNlb2YgRmFrZVByb21pc2U7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbn0oKTtcblxuLy8gaGVscGVyc1xudmFyIHNhbWVDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGEsIGIpe1xuICAvLyB3aXRoIGxpYnJhcnkgd3JhcHBlciBzcGVjaWFsIGNhc2VcbiAgcmV0dXJuIGEgPT09IGIgfHwgYSA9PT0gJFByb21pc2UgJiYgYiA9PT0gV3JhcHBlcjtcbn07XG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIHRoZW47XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgdHlwZW9mICh0aGVuID0gaXQudGhlbikgPT0gJ2Z1bmN0aW9uJyA/IHRoZW4gOiBmYWxzZTtcbn07XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgcmV0dXJuIHNhbWVDb25zdHJ1Y3RvcigkUHJvbWlzZSwgQylcbiAgICA/IG5ldyBQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgIDogbmV3IEdlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbn07XG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbihDKXtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24oJCRyZXNvbHZlLCAkJHJlamVjdCl7XG4gICAgaWYocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCAgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgID0gYUZ1bmN0aW9uKHJlamVjdCk7XG59O1xudmFyIHBlcmZvcm0gPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICBleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHtlcnJvcjogZX07XG4gIH1cbn07XG52YXIgbm90aWZ5ID0gZnVuY3Rpb24ocHJvbWlzZSwgaXNSZWplY3Qpe1xuICBpZihwcm9taXNlLl9uKXJldHVybjtcbiAgcHJvbWlzZS5fbiA9IHRydWU7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2M7XG4gIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgIHZhciB2YWx1ZSA9IHByb21pc2UuX3ZcbiAgICAgICwgb2sgICAgPSBwcm9taXNlLl9zID09IDFcbiAgICAgICwgaSAgICAgPSAwO1xuICAgIHZhciBydW4gPSBmdW5jdGlvbihyZWFjdGlvbil7XG4gICAgICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsXG4gICAgICAgICwgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmVcbiAgICAgICAgLCByZWplY3QgID0gcmVhY3Rpb24ucmVqZWN0XG4gICAgICAgICwgZG9tYWluICA9IHJlYWN0aW9uLmRvbWFpblxuICAgICAgICAsIHJlc3VsdCwgdGhlbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGhhbmRsZXIpe1xuICAgICAgICAgIGlmKCFvayl7XG4gICAgICAgICAgICBpZihwcm9taXNlLl9oID09IDIpb25IYW5kbGVVbmhhbmRsZWQocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlLl9oID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGFuZGxlciA9PT0gdHJ1ZSlyZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmKGRvbWFpbilkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYoZG9tYWluKWRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSl7XG4gICAgICAgICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgIH0gZWxzZSBpZih0aGVuID0gaXNUaGVuYWJsZShyZXN1bHQpKXtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aGlsZShjaGFpbi5sZW5ndGggPiBpKXJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmKGlzUmVqZWN0ICYmICFwcm9taXNlLl9oKW9uVW5oYW5kbGVkKHByb21pc2UpO1xuICB9KTtcbn07XG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92XG4gICAgICAsIGFicnVwdCwgaGFuZGxlciwgY29uc29sZTtcbiAgICBpZihpc1VuaGFuZGxlZChwcm9taXNlKSl7XG4gICAgICBhYnJ1cHQgPSBwZXJmb3JtKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGlzTm9kZSl7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZihoYW5kbGVyID0gZ2xvYmFsLm9udW5oYW5kbGVkcmVqZWN0aW9uKXtcbiAgICAgICAgICBoYW5kbGVyKHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlfSk7XG4gICAgICAgIH0gZWxzZSBpZigoY29uc29sZSA9IGdsb2JhbC5jb25zb2xlKSAmJiBjb25zb2xlLmVycm9yKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYoYWJydXB0KXRocm93IGFicnVwdC5lcnJvcjtcbiAgfSk7XG59O1xudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24ocHJvbWlzZSl7XG4gIGlmKHByb21pc2UuX2ggPT0gMSlyZXR1cm4gZmFsc2U7XG4gIHZhciBjaGFpbiA9IHByb21pc2UuX2EgfHwgcHJvbWlzZS5fY1xuICAgICwgaSAgICAgPSAwXG4gICAgLCByZWFjdGlvbjtcbiAgd2hpbGUoY2hhaW4ubGVuZ3RoID4gaSl7XG4gICAgcmVhY3Rpb24gPSBjaGFpbltpKytdO1xuICAgIGlmKHJlYWN0aW9uLmZhaWwgfHwgIWlzVW5oYW5kbGVkKHJlYWN0aW9uLnByb21pc2UpKXJldHVybiBmYWxzZTtcbiAgfSByZXR1cm4gdHJ1ZTtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbihwcm9taXNlKXtcbiAgdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24oKXtcbiAgICB2YXIgaGFuZGxlcjtcbiAgICBpZihpc05vZGUpe1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmKGhhbmRsZXIgPSBnbG9iYWwub25yZWplY3Rpb25oYW5kbGVkKXtcbiAgICAgIGhhbmRsZXIoe3Byb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdn0pO1xuICAgIH1cbiAgfSk7XG59O1xudmFyICRyZWplY3QgPSBmdW5jdGlvbih2YWx1ZSl7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYocHJvbWlzZS5fZClyZXR1cm47XG4gIHByb21pc2UuX2QgPSB0cnVlO1xuICBwcm9taXNlID0gcHJvbWlzZS5fdyB8fCBwcm9taXNlOyAvLyB1bndyYXBcbiAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICBwcm9taXNlLl9zID0gMjtcbiAgaWYoIXByb21pc2UuX2EpcHJvbWlzZS5fYSA9IHByb21pc2UuX2Muc2xpY2UoKTtcbiAgbm90aWZ5KHByb21pc2UsIHRydWUpO1xufTtcbnZhciAkcmVzb2x2ZSA9IGZ1bmN0aW9uKHZhbHVlKXtcbiAgdmFyIHByb21pc2UgPSB0aGlzXG4gICAgLCB0aGVuO1xuICBpZihwcm9taXNlLl9kKXJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmKHByb21pc2UgPT09IHZhbHVlKXRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIGlmKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSl7XG4gICAgICBtaWNyb3Rhc2soZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7X3c6IHByb21pc2UsIF9kOiBmYWxzZX07IC8vIHdyYXBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIGN0eCgkcmVzb2x2ZSwgd3JhcHBlciwgMSksIGN0eCgkcmVqZWN0LCB3cmFwcGVyLCAxKSk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgJHJlamVjdC5jYWxsKHdyYXBwZXIsIGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbWlzZS5fdiA9IHZhbHVlO1xuICAgICAgcHJvbWlzZS5fcyA9IDE7XG4gICAgICBub3RpZnkocHJvbWlzZSwgZmFsc2UpO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICAkcmVqZWN0LmNhbGwoe193OiBwcm9taXNlLCBfZDogZmFsc2V9LCBlKTsgLy8gd3JhcFxuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYoIVVTRV9OQVRJVkUpe1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICAkUHJvbWlzZSA9IGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3Ipe1xuICAgIGFuSW5zdGFuY2UodGhpcywgJFByb21pc2UsIFBST01JU0UsICdfaCcpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoY3R4KCRyZXNvbHZlLCB0aGlzLCAxKSwgY3R4KCRyZWplY3QsIHRoaXMsIDEpKTtcbiAgICB9IGNhdGNoKGVycil7XG4gICAgICAkcmVqZWN0LmNhbGwodGhpcywgZXJyKTtcbiAgICB9XG4gIH07XG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcil7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKXtcbiAgICAgIHZhciByZWFjdGlvbiAgICA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCAkUHJvbWlzZSkpO1xuICAgICAgcmVhY3Rpb24ub2sgICAgID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsICAgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBpc05vZGUgPyBwcm9jZXNzLmRvbWFpbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2MucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9hKXRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZih0aGlzLl9zKW5vdGlmeSh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gcmVhY3Rpb24ucHJvbWlzZTtcbiAgICB9LFxuICAgIC8vIDI1LjQuNS4xIFByb21pc2UucHJvdG90eXBlLmNhdGNoKG9uUmVqZWN0ZWQpXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3RlZCl7XG4gICAgICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICB9KTtcbiAgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwcm9taXNlICA9IG5ldyBJbnRlcm5hbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICAgIHRoaXMucmVzb2x2ZSA9IGN0eCgkcmVzb2x2ZSwgcHJvbWlzZSwgMSk7XG4gICAgdGhpcy5yZWplY3QgID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7UHJvbWlzZTogJFByb21pc2V9KTtcbnJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJykoJFByb21pc2UsIFBST01JU0UpO1xucmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKShQUk9NSVNFKTtcbldyYXBwZXIgPSByZXF1aXJlKCcuL19jb3JlJylbUFJPTUlTRV07XG5cbi8vIHN0YXRpY3NcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjUgUHJvbWlzZS5yZWplY3QocilcbiAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3Qocil7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKVxuICAgICAgLCAkJHJlamVjdCAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgJCRyZWplY3Qocik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIChMSUJSQVJZIHx8ICFVU0VfTkFUSVZFKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuNiBQcm9taXNlLnJlc29sdmUoeClcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KXtcbiAgICAvLyBpbnN0YW5jZW9mIGluc3RlYWQgb2YgaW50ZXJuYWwgc2xvdCBjaGVjayBiZWNhdXNlIHdlIHNob3VsZCBmaXggaXQgd2l0aG91dCByZXBsYWNlbWVudCBuYXRpdmUgUHJvbWlzZSBjb3JlXG4gICAgaWYoeCBpbnN0YW5jZW9mICRQcm9taXNlICYmIHNhbWVDb25zdHJ1Y3Rvcih4LmNvbnN0cnVjdG9yLCB0aGlzKSlyZXR1cm4geDtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpXG4gICAgICAsICQkcmVzb2x2ZSAgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgJCRyZXNvbHZlKHgpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhKFVTRV9OQVRJVkUgJiYgcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKShmdW5jdGlvbihpdGVyKXtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpe1xuICAgIHZhciBDICAgICAgICAgID0gdGhpc1xuICAgICAgLCBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgICwgcmVzb2x2ZSAgICA9IGNhcGFiaWxpdHkucmVzb2x2ZVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIHZhciB2YWx1ZXMgICAgPSBbXVxuICAgICAgICAsIGluZGV4ICAgICA9IDBcbiAgICAgICAgLCByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbihwcm9taXNlKXtcbiAgICAgICAgdmFyICRpbmRleCAgICAgICAgPSBpbmRleCsrXG4gICAgICAgICAgLCBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHZhbHVlcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlbWFpbmluZysrO1xuICAgICAgICBDLnJlc29sdmUocHJvbWlzZSkudGhlbihmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgaWYoYWxyZWFkeUNhbGxlZClyZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCAgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1skaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYoYWJydXB0KXJlamVjdChhYnJ1cHQuZXJyb3IpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH0sXG4gIC8vIDI1LjQuNC40IFByb21pc2UucmFjZShpdGVyYWJsZSlcbiAgcmFjZTogZnVuY3Rpb24gcmFjZShpdGVyYWJsZSl7XG4gICAgdmFyIEMgICAgICAgICAgPSB0aGlzXG4gICAgICAsIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgLCByZWplY3QgICAgID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIGFicnVwdCA9IHBlcmZvcm0oZnVuY3Rpb24oKXtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24ocHJvbWlzZSl7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGNhcGFiaWxpdHkucmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmKGFicnVwdClyZWplY3QoYWJydXB0LmVycm9yKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTsiLCIvLyAyNi4xLjEgUmVmbGVjdC5hcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGFuT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgckFwcGx5ICAgID0gKHJlcXVpcmUoJy4vX2dsb2JhbCcpLlJlZmxlY3QgfHwge30pLmFwcGx5XG4gICwgZkFwcGx5ICAgID0gRnVuY3Rpb24uYXBwbHk7XG4vLyBNUyBFZGdlIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgckFwcGx5KGZ1bmN0aW9uKCl7fSk7XG59KSwgJ1JlZmxlY3QnLCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCl7XG4gICAgdmFyIFQgPSBhRnVuY3Rpb24odGFyZ2V0KVxuICAgICAgLCBMID0gYW5PYmplY3QoYXJndW1lbnRzTGlzdCk7XG4gICAgcmV0dXJuIHJBcHBseSA/IHJBcHBseShULCB0aGlzQXJndW1lbnQsIEwpIDogZkFwcGx5LmNhbGwoVCwgdGhpc0FyZ3VtZW50LCBMKTtcbiAgfVxufSk7IiwiLy8gMjYuMS4yIFJlZmxlY3QuY29uc3RydWN0KHRhcmdldCwgYXJndW1lbnRzTGlzdCBbLCBuZXdUYXJnZXRdKVxudmFyICRleHBvcnQgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZSAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJylcbiAgLCBhRnVuY3Rpb24gID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgaXNPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZmFpbHMgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBiaW5kICAgICAgID0gcmVxdWlyZSgnLi9fYmluZCcpXG4gICwgckNvbnN0cnVjdCA9IChyZXF1aXJlKCcuL19nbG9iYWwnKS5SZWZsZWN0IHx8IHt9KS5jb25zdHJ1Y3Q7XG5cbi8vIE1TIEVkZ2Ugc3VwcG9ydHMgb25seSAyIGFyZ3VtZW50cyBhbmQgYXJndW1lbnRzTGlzdCBhcmd1bWVudCBpcyBvcHRpb25hbFxuLy8gRkYgTmlnaHRseSBzZXRzIHRoaXJkIGFyZ3VtZW50IGFzIGBuZXcudGFyZ2V0YCwgYnV0IGRvZXMgbm90IGNyZWF0ZSBgdGhpc2AgZnJvbSBpdFxudmFyIE5FV19UQVJHRVRfQlVHID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gRigpe31cbiAgcmV0dXJuICEockNvbnN0cnVjdChmdW5jdGlvbigpe30sIFtdLCBGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG52YXIgQVJHU19CVUcgPSAhZmFpbHMoZnVuY3Rpb24oKXtcbiAgckNvbnN0cnVjdChmdW5jdGlvbigpe30pO1xufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogKE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHKSwgJ1JlZmxlY3QnLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gY29uc3RydWN0KFRhcmdldCwgYXJncyAvKiwgbmV3VGFyZ2V0Ki8pe1xuICAgIGFGdW5jdGlvbihUYXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFGdW5jdGlvbihhcmd1bWVudHNbMl0pO1xuICAgIGlmKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRylyZXR1cm4gckNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYoVGFyZ2V0ID09IG5ld1RhcmdldCl7XG4gICAgICAvLyB3L28gYWx0ZXJlZCBuZXdUYXJnZXQsIG9wdGltaXphdGlvbiBmb3IgMC00IGFyZ3VtZW50c1xuICAgICAgc3dpdGNoKGFyZ3MubGVuZ3RoKXtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldDtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpO1xuICAgIH1cbiAgICAvLyB3aXRoIGFsdGVyZWQgbmV3VGFyZ2V0LCBub3Qgc3VwcG9ydCBidWlsdC1pbiBjb25zdHJ1Y3RvcnNcbiAgICB2YXIgcHJvdG8gICAgPSBuZXdUYXJnZXQucHJvdG90eXBlXG4gICAgICAsIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSlcbiAgICAgICwgcmVzdWx0ICAgPSBGdW5jdGlvbi5hcHBseS5jYWxsKFRhcmdldCwgaW5zdGFuY2UsIGFyZ3MpO1xuICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogaW5zdGFuY2U7XG4gIH1cbn0pOyIsIi8vIDI2LjEuMyBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpXG52YXIgZFAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcblxuLy8gTVMgRWRnZSBoYXMgYnJva2VuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkgLSB0aHJvd2luZyBpbnN0ZWFkIG9mIHJldHVybmluZyBmYWxzZVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZFAuZih7fSwgMSwge3ZhbHVlOiAxfSksIDEsIHt2YWx1ZTogMn0pO1xufSksICdSZWZsZWN0Jywge1xuICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyl7XG4gICAgYW5PYmplY3QodGFyZ2V0KTtcbiAgICBwcm9wZXJ0eUtleSA9IHRvUHJpbWl0aXZlKHByb3BlcnR5S2V5LCB0cnVlKTtcbiAgICBhbk9iamVjdChhdHRyaWJ1dGVzKTtcbiAgICB0cnkge1xuICAgICAgZFAuZih0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59KTsiLCIvLyAyNi4xLjQgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBnT1BEICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgZGVsZXRlUHJvcGVydHk6IGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHZhciBkZXNjID0gZ09QRChhbk9iamVjdCh0YXJnZXQpLCBwcm9wZXJ0eUtleSk7XG4gICAgcmV0dXJuIGRlc2MgJiYgIWRlc2MuY29uZmlndXJhYmxlID8gZmFsc2UgOiBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjYuMS41IFJlZmxlY3QuZW51bWVyYXRlKHRhcmdldClcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBFbnVtZXJhdGUgPSBmdW5jdGlvbihpdGVyYXRlZCl7XG4gIHRoaXMuX3QgPSBhbk9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHZhciBrZXlzID0gdGhpcy5fayA9IFtdICAgICAgIC8vIGtleXNcbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBpdGVyYXRlZClrZXlzLnB1c2goa2V5KTtcbn07XG5yZXF1aXJlKCcuL19pdGVyLWNyZWF0ZScpKEVudW1lcmF0ZSwgJ09iamVjdCcsIGZ1bmN0aW9uKCl7XG4gIHZhciB0aGF0ID0gdGhpc1xuICAgICwga2V5cyA9IHRoYXQuX2tcbiAgICAsIGtleTtcbiAgZG8ge1xuICAgIGlmKHRoYXQuX2kgPj0ga2V5cy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgfSB3aGlsZSghKChrZXkgPSBrZXlzW3RoYXQuX2krK10pIGluIHRoYXQuX3QpKTtcbiAgcmV0dXJuIHt2YWx1ZToga2V5LCBkb25lOiBmYWxzZX07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBlbnVtZXJhdGU6IGZ1bmN0aW9uIGVudW1lcmF0ZSh0YXJnZXQpe1xuICAgIHJldHVybiBuZXcgRW51bWVyYXRlKHRhcmdldCk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNyBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyIGdPUEQgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpe1xuICAgIHJldHVybiBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTsiLCIvLyAyNi4xLjggUmVmbGVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdldFByb3RvID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KXtcbiAgICByZXR1cm4gZ2V0UHJvdG8oYW5PYmplY3QodGFyZ2V0KSk7XG4gIH1cbn0pOyIsIi8vIDI2LjEuNiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5S2V5IFssIHJlY2VpdmVyXSlcbnZhciBnT1BEICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJylcbiAgLCBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCAkZXhwb3J0ICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaXNPYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIGdldCh0YXJnZXQsIHByb3BlcnR5S2V5LyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXVxuICAgICwgZGVzYywgcHJvdG87XG4gIGlmKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKXJldHVybiB0YXJnZXRbcHJvcGVydHlLZXldO1xuICBpZihkZXNjID0gZ09QRC5mKHRhcmdldCwgcHJvcGVydHlLZXkpKXJldHVybiBoYXMoZGVzYywgJ3ZhbHVlJylcbiAgICA/IGRlc2MudmFsdWVcbiAgICA6IGRlc2MuZ2V0ICE9PSB1bmRlZmluZWRcbiAgICAgID8gZGVzYy5nZXQuY2FsbChyZWNlaXZlcilcbiAgICAgIDogdW5kZWZpbmVkO1xuICBpZihpc09iamVjdChwcm90byA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKXJldHVybiBnZXQocHJvdG8sIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtnZXQ6IGdldH0pOyIsIi8vIDI2LjEuOSBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBoYXM6IGZ1bmN0aW9uIGhhcyh0YXJnZXQsIHByb3BlcnR5S2V5KXtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTsiLCIvLyAyNi4xLjEwIFJlZmxlY3QuaXNFeHRlbnNpYmxlKHRhcmdldClcbnZhciAkZXhwb3J0ICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCAkaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpe1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKHRhcmdldCkgOiB0cnVlO1xuICB9XG59KTsiLCIvLyAyNi4xLjExIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1JlZmxlY3QnLCB7b3duS2V5czogcmVxdWlyZSgnLi9fb3duLWtleXMnKX0pOyIsIi8vIDI2LjEuMTIgUmVmbGVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpXG52YXIgJGV4cG9ydCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsICRwcmV2ZW50RXh0ZW5zaW9ucyA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucztcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge1xuICBwcmV2ZW50RXh0ZW5zaW9uczogZnVuY3Rpb24gcHJldmVudEV4dGVuc2lvbnModGFyZ2V0KXtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHRyeSB7XG4gICAgICBpZigkcHJldmVudEV4dGVuc2lvbnMpJHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xNCBSZWZsZWN0LnNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHNldFByb3RvID0gcmVxdWlyZSgnLi9fc2V0LXByb3RvJyk7XG5cbmlmKHNldFByb3RvKSRleHBvcnQoJGV4cG9ydC5TLCAnUmVmbGVjdCcsIHtcbiAgc2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKHRhcmdldCwgcHJvdG8pe1xuICAgIHNldFByb3RvLmNoZWNrKHRhcmdldCwgcHJvdG8pO1xuICAgIHRyeSB7XG4gICAgICBzZXRQcm90by5zZXQodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7IiwiLy8gMjYuMS4xMyBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWIFssIHJlY2VpdmVyXSlcbnZhciBkUCAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIHByb3BlcnR5S2V5LCBWLyosIHJlY2VpdmVyKi8pe1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgNCA/IHRhcmdldCA6IGFyZ3VtZW50c1szXVxuICAgICwgb3duRGVzYyAgPSBnT1BELmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpXG4gICAgLCBleGlzdGluZ0Rlc2NyaXB0b3IsIHByb3RvO1xuICBpZighb3duRGVzYyl7XG4gICAgaWYoaXNPYmplY3QocHJvdG8gPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSl7XG4gICAgICByZXR1cm4gc2V0KHByb3RvLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjID0gY3JlYXRlRGVzYygwKTtcbiAgfVxuICBpZihoYXMob3duRGVzYywgJ3ZhbHVlJykpe1xuICAgIGlmKG93bkRlc2Mud3JpdGFibGUgPT09IGZhbHNlIHx8ICFpc09iamVjdChyZWNlaXZlcikpcmV0dXJuIGZhbHNlO1xuICAgIGV4aXN0aW5nRGVzY3JpcHRvciA9IGdPUEQuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpIHx8IGNyZWF0ZURlc2MoMCk7XG4gICAgZXhpc3RpbmdEZXNjcmlwdG9yLnZhbHVlID0gVjtcbiAgICBkUC5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3duRGVzYy5zZXQgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogKG93bkRlc2Muc2V0LmNhbGwocmVjZWl2ZXIsIFYpLCB0cnVlKTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LlMsICdSZWZsZWN0Jywge3NldDogc2V0fSk7IiwidmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4vX2luaGVyaXQtaWYtcmVxdWlyZWQnKVxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgaXNSZWdFeHAgICAgICAgICAgPSByZXF1aXJlKCcuL19pcy1yZWdleHAnKVxuICAsICRmbGFncyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmxhZ3MnKVxuICAsICRSZWdFeHAgICAgICAgICAgID0gZ2xvYmFsLlJlZ0V4cFxuICAsIEJhc2UgICAgICAgICAgICAgID0gJFJlZ0V4cFxuICAsIHByb3RvICAgICAgICAgICAgID0gJFJlZ0V4cC5wcm90b3R5cGVcbiAgLCByZTEgICAgICAgICAgICAgICA9IC9hL2dcbiAgLCByZTIgICAgICAgICAgICAgICA9IC9hL2dcbiAgLy8gXCJuZXdcIiBjcmVhdGVzIGEgbmV3IG9iamVjdCwgb2xkIHdlYmtpdCBidWdneSBoZXJlXG4gICwgQ09SUkVDVF9ORVcgICAgICAgPSBuZXcgJFJlZ0V4cChyZTEpICE9PSByZTE7XG5cbmlmKHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgKCFDT1JSRUNUX05FVyB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJlMltyZXF1aXJlKCcuL193a3MnKSgnbWF0Y2gnKV0gPSBmYWxzZTtcbiAgLy8gUmVnRXhwIGNvbnN0cnVjdG9yIGNhbiBhbHRlciBmbGFncyBhbmQgSXNSZWdFeHAgd29ya3MgY29ycmVjdCB3aXRoIEBAbWF0Y2hcbiAgcmV0dXJuICRSZWdFeHAocmUxKSAhPSByZTEgfHwgJFJlZ0V4cChyZTIpID09IHJlMiB8fCAkUmVnRXhwKHJlMSwgJ2knKSAhPSAnL2EvaSc7XG59KSkpe1xuICAkUmVnRXhwID0gZnVuY3Rpb24gUmVnRXhwKHAsIGYpe1xuICAgIHZhciB0aVJFID0gdGhpcyBpbnN0YW5jZW9mICRSZWdFeHBcbiAgICAgICwgcGlSRSA9IGlzUmVnRXhwKHApXG4gICAgICAsIGZpVSAgPSBmID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aVJFICYmIHBpUkUgJiYgcC5jb25zdHJ1Y3RvciA9PT0gJFJlZ0V4cCAmJiBmaVUgPyBwXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IEJhc2UocGlSRSAmJiAhZmlVID8gcC5zb3VyY2UgOiBwLCBmKVxuICAgICAgICA6IEJhc2UoKHBpUkUgPSBwIGluc3RhbmNlb2YgJFJlZ0V4cCkgPyBwLnNvdXJjZSA6IHAsIHBpUkUgJiYgZmlVID8gJGZsYWdzLmNhbGwocCkgOiBmKVxuICAgICAgLCB0aVJFID8gdGhpcyA6IHByb3RvLCAkUmVnRXhwKTtcbiAgfTtcbiAgdmFyIHByb3h5ID0gZnVuY3Rpb24oa2V5KXtcbiAgICBrZXkgaW4gJFJlZ0V4cCB8fCBkUCgkUmVnRXhwLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIEJhc2Vba2V5XTsgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaXQpeyBCYXNlW2tleV0gPSBpdDsgfVxuICAgIH0pO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSBnT1BOKEJhc2UpLCBpID0gMDsga2V5cy5sZW5ndGggPiBpOyApcHJveHkoa2V5c1tpKytdKTtcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkUmVnRXhwO1xuICAkUmVnRXhwLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgJ1JlZ0V4cCcsICRSZWdFeHApO1xufVxuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdSZWdFeHAnKTsiLCIvLyAyMS4yLjUuMyBnZXQgUmVnRXhwLnByb3RvdHlwZS5mbGFncygpXG5pZihyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmIC8uL2cuZmxhZ3MgIT0gJ2cnKXJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYoUmVnRXhwLnByb3RvdHlwZSwgJ2ZsYWdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogcmVxdWlyZSgnLi9fZmxhZ3MnKVxufSk7IiwiLy8gQEBtYXRjaCBsb2dpY1xucmVxdWlyZSgnLi9fZml4LXJlLXdrcycpKCdtYXRjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIE1BVENILCAkbWF0Y2gpe1xuICAvLyAyMS4xLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5tYXRjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gbWF0Y2gocmVnZXhwKXtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICB9LCAkbWF0Y2hdO1xufSk7IiwiLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBSRVBMQUNFLCAkcmVwbGFjZSl7XG4gIC8vIDIxLjEuMy4xNCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSlcbiAgcmV0dXJuIFtmdW5jdGlvbiByZXBsYWNlKHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpe1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgTyAgPSBkZWZpbmVkKHRoaXMpXG4gICAgICAsIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWRcbiAgICAgID8gZm4uY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gIH0sICRyZXBsYWNlXTtcbn0pOyIsIi8vIEBAc2VhcmNoIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uKGRlZmluZWQsIFNFQVJDSCwgJHNlYXJjaCl7XG4gIC8vIDIxLjEuMy4xNSBTdHJpbmcucHJvdG90eXBlLnNlYXJjaChyZWdleHApXG4gIHJldHVybiBbZnVuY3Rpb24gc2VhcmNoKHJlZ2V4cCl7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBPICA9IGRlZmluZWQodGhpcylcbiAgICAgICwgZm4gPSByZWdleHAgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcmVnZXhwW1NFQVJDSF07XG4gICAgcmV0dXJuIGZuICE9PSB1bmRlZmluZWQgPyBmbi5jYWxsKHJlZ2V4cCwgTykgOiBuZXcgUmVnRXhwKHJlZ2V4cClbU0VBUkNIXShTdHJpbmcoTykpO1xuICB9LCAkc2VhcmNoXTtcbn0pOyIsIi8vIEBAc3BsaXQgbG9naWNcbnJlcXVpcmUoJy4vX2ZpeC1yZS13a3MnKSgnc3BsaXQnLCAyLCBmdW5jdGlvbihkZWZpbmVkLCBTUExJVCwgJHNwbGl0KXtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgaXNSZWdFeHAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICAgLCBfc3BsaXQgICAgID0gJHNwbGl0XG4gICAgLCAkcHVzaCAgICAgID0gW10ucHVzaFxuICAgICwgJFNQTElUICAgICA9ICdzcGxpdCdcbiAgICAsIExFTkdUSCAgICAgPSAnbGVuZ3RoJ1xuICAgICwgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuICBpZihcbiAgICAnYWJiYydbJFNQTElUXSgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0J1skU1BMSVRdKC8oPzopLywgLTEpW0xFTkdUSF0gIT0gNCB8fFxuICAgICdhYidbJFNQTElUXSgvKD86YWIpKi8pW0xFTkdUSF0gIT0gMiB8fFxuICAgICcuJ1skU1BMSVRdKC8oLj8pKC4/KS8pW0xFTkdUSF0gIT0gNCB8fFxuICAgICcuJ1skU1BMSVRdKC8oKSgpLylbTEVOR1RIXSA+IDEgfHxcbiAgICAnJ1skU1BMSVRdKC8uPy8pW0xFTkdUSF1cbiAgKXtcbiAgICB2YXIgTlBDRyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdW5kZWZpbmVkOyAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwKXJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZighaXNSZWdFeHAoc2VwYXJhdG9yKSlyZXR1cm4gX3NwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHZhciBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgPyAneScgOiAnJyk7XG4gICAgICB2YXIgbGFzdExhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgc3BsaXRMaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyA0Mjk0OTY3Mjk1IDogbGltaXQgPj4+IDA7XG4gICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgdmFyIHNlcGFyYXRvckNvcHkgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgIHZhciBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoLCBpO1xuICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICBpZighTlBDRylzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3JDb3B5LnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgd2hpbGUobWF0Y2ggPSBzZXBhcmF0b3JDb3B5LmV4ZWMoc3RyaW5nKSl7XG4gICAgICAgIC8vIGBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICBpZihsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KXtcbiAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3IgTlBDR1xuICAgICAgICAgIGlmKCFOUENHICYmIG1hdGNoW0xFTkdUSF0gPiAxKW1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvcihpID0gMTsgaSA8IGFyZ3VtZW50c1tMRU5HVEhdIC0gMjsgaSsrKWlmKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKW1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pJHB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdW0xFTkdUSF07XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZihvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KWJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0gPT09IG1hdGNoLmluZGV4KXNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pe1xuICAgICAgICBpZihsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKW91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZignMCdbJFNQTElUXSh1bmRlZmluZWQsIDApW0xFTkdUSF0pe1xuICAgICRzcGxpdCA9IGZ1bmN0aW9uKHNlcGFyYXRvciwgbGltaXQpe1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9XG4gIC8vIDIxLjEuMy4xNyBTdHJpbmcucHJvdG90eXBlLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpXG4gIHJldHVybiBbZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCl7XG4gICAgdmFyIE8gID0gZGVmaW5lZCh0aGlzKVxuICAgICAgLCBmbiA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgIHJldHVybiBmbiAhPT0gdW5kZWZpbmVkID8gZm4uY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KSA6ICRzcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gIH0sICRzcGxpdF07XG59KTsiLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgJGZsYWdzICAgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpXG4gICwgVE9fU1RSSU5HICAgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nICAgPSAvLi9bVE9fU1RSSU5HXTtcblxudmFyIGRlZmluZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmVxdWlyZSgnLi9fcmVkZWZpbmUnKShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZuLCB0cnVlKTtcbn07XG5cbi8vIDIxLjIuNS4xNCBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nKClcbmlmKHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXsgcmV0dXJuICR0b1N0cmluZy5jYWxsKHtzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJ30pICE9ICcvYS9iJzsgfSkpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICB2YXIgUiA9IGFuT2JqZWN0KHRoaXMpO1xuICAgIHJldHVybiAnLycuY29uY2F0KFIuc291cmNlLCAnLycsXG4gICAgICAnZmxhZ3MnIGluIFIgPyBSLmZsYWdzIDogIURFU0NSSVBUT1JTICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgPyAkZmxhZ3MuY2FsbChSKSA6IHVuZGVmaW5lZCk7XG4gIH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbn0gZWxzZSBpZigkdG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkcpe1xuICBkZWZpbmUoZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gJHRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xuXG4vLyAyMy4yIFNldCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKSgnU2V0JywgZnVuY3Rpb24oZ2V0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKXtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMiBTdHJpbmcucHJvdG90eXBlLmFuY2hvcihuYW1lKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnYW5jaG9yJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBhbmNob3IobmFtZSl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2EnLCAnbmFtZScsIG5hbWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy4zIFN0cmluZy5wcm90b3R5cGUuYmlnKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2JpZycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmlnKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JpZycsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjQgU3RyaW5nLnByb3RvdHlwZS5ibGluaygpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdibGluaycsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gYmxpbmsoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYmxpbmsnLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBCLjIuMy41IFN0cmluZy5wcm90b3R5cGUuYm9sZCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdib2xkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBib2xkKCl7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2InLCAnJywgJycpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGF0ICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKGZhbHNlKTtcbiRleHBvcnQoJGV4cG9ydC5QLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjMuMyBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KHBvcylcbiAgY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcyl7XG4gICAgcmV0dXJuICRhdCh0aGlzLCBwb3MpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuNiBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKHNlYXJjaFN0cmluZyBbLCBlbmRQb3NpdGlvbl0pXG4ndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgPSByZXF1aXJlKCcuL190by1sZW5ndGgnKVxuICAsIGNvbnRleHQgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1jb250ZXh0JylcbiAgLCBFTkRTX1dJVEggPSAnZW5kc1dpdGgnXG4gICwgJGVuZHNXaXRoID0gJydbRU5EU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShFTkRTX1dJVEgpLCAnU3RyaW5nJywge1xuICBlbmRzV2l0aDogZnVuY3Rpb24gZW5kc1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBlbmRQb3NpdGlvbiA9IEBsZW5ndGggKi8pe1xuICAgIHZhciB0aGF0ID0gY29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIEVORFNfV0lUSClcbiAgICAgICwgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZFxuICAgICAgLCBsZW4gICAgPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aClcbiAgICAgICwgZW5kICAgID0gZW5kUG9zaXRpb24gPT09IHVuZGVmaW5lZCA/IGxlbiA6IE1hdGgubWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKVxuICAgICAgLCBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoU3RyaW5nKTtcbiAgICByZXR1cm4gJGVuZHNXaXRoXG4gICAgICA/ICRlbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKVxuICAgICAgOiB0aGF0LnNsaWNlKGVuZCAtIHNlYXJjaC5sZW5ndGgsIGVuZCkgPT09IHNlYXJjaDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuNiBTdHJpbmcucHJvdG90eXBlLmZpeGVkKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2ZpeGVkJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBmaXhlZCgpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICd0dCcsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjcgU3RyaW5nLnByb3RvdHlwZS5mb250Y29sb3IoY29sb3IpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdmb250Y29sb3InLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRjb2xvcihjb2xvcil7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2ZvbnQnLCAnY29sb3InLCBjb2xvcik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjggU3RyaW5nLnByb3RvdHlwZS5mb250c2l6ZShzaXplKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnZm9udHNpemUnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpe1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdmb250JywgJ3NpemUnLCBzaXplKTtcbiAgfVxufSk7IiwidmFyICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0luZGV4ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLWluZGV4JylcbiAgLCBmcm9tQ2hhckNvZGUgICA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgLCAkZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50O1xuXG4vLyBsZW5ndGggc2hvdWxkIGJlIDEsIG9sZCBGRiBwcm9ibGVtXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghISRmcm9tQ29kZVBvaW50ICYmICRmcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxKSwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4yLjIgU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uY29kZVBvaW50cylcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciByZXMgID0gW11cbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgaSAgICA9IDBcbiAgICAgICwgY29kZTtcbiAgICB3aGlsZShhTGVuID4gaSl7XG4gICAgICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgICAgaWYodG9JbmRleChjb2RlLCAweDEwZmZmZikgIT09IGNvZGUpdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICByZXMucHVzaChjb2RlIDwgMHgxMDAwMFxuICAgICAgICA/IGZyb21DaGFyQ29kZShjb2RlKVxuICAgICAgICA6IGZyb21DaGFyQ29kZSgoKGNvZGUgLT0gMHgxMDAwMCkgPj4gMTApICsgMHhkODAwLCBjb2RlICUgMHg0MDAgKyAweGRjMDApXG4gICAgICApO1xuICAgIH0gcmV0dXJuIHJlcy5qb2luKCcnKTtcbiAgfVxufSk7IiwiLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29udGV4dCAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgSU5DTFVERVMgPSAnaW5jbHVkZXMnO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzLWlzLXJlZ2V4cCcpKElOQ0xVREVTKSwgJ1N0cmluZycsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiwgcG9zaXRpb24gPSAwICovKXtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEIuMi4zLjkgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzKClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2l0YWxpY3MnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGl0YWxpY3MoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnaScsICcnLCAnJyk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkYXQgID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24oaXRlcmF0ZWQpe1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBpbmRleCA9IHRoaXMuX2lcbiAgICAsIHBvaW50O1xuICBpZihpbmRleCA+PSBPLmxlbmd0aClyZXR1cm4ge3ZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWV9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4ge3ZhbHVlOiBwb2ludCwgZG9uZTogZmFsc2V9O1xufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTAgU3RyaW5nLnByb3RvdHlwZS5saW5rKHVybClcbnJlcXVpcmUoJy4vX3N0cmluZy1odG1sJykoJ2xpbmsnLCBmdW5jdGlvbihjcmVhdGVIVE1MKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsodXJsKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7IiwidmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3RyaW5nJywge1xuICAvLyAyMS4xLjIuNCBTdHJpbmcucmF3KGNhbGxTaXRlLCAuLi5zdWJzdGl0dXRpb25zKVxuICByYXc6IGZ1bmN0aW9uIHJhdyhjYWxsU2l0ZSl7XG4gICAgdmFyIHRwbCAgPSB0b0lPYmplY3QoY2FsbFNpdGUucmF3KVxuICAgICAgLCBsZW4gID0gdG9MZW5ndGgodHBsLmxlbmd0aClcbiAgICAgICwgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICwgcmVzICA9IFtdXG4gICAgICAsIGkgICAgPSAwO1xuICAgIHdoaWxlKGxlbiA+IGkpe1xuICAgICAgcmVzLnB1c2goU3RyaW5nKHRwbFtpKytdKSk7XG4gICAgICBpZihpIDwgYUxlbilyZXMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gcmVzLmpvaW4oJycpO1xuICB9XG59KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgLy8gMjEuMS4zLjEzIFN0cmluZy5wcm90b3R5cGUucmVwZWF0KGNvdW50KVxuICByZXBlYXQ6IHJlcXVpcmUoJy4vX3N0cmluZy1yZXBlYXQnKVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTEgU3RyaW5nLnByb3RvdHlwZS5zbWFsbCgpXG5yZXF1aXJlKCcuL19zdHJpbmctaHRtbCcpKCdzbWFsbCcsIGZ1bmN0aW9uKGNyZWF0ZUhUTUwpe1xuICByZXR1cm4gZnVuY3Rpb24gc21hbGwoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc21hbGwnLCAnJywgJycpO1xuICB9XG59KTsiLCIvLyAyMS4xLjMuMTggU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyBbLCBwb3NpdGlvbiBdKVxuJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b0xlbmd0aCAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgY29udGV4dCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctY29udGV4dCcpXG4gICwgU1RBUlRTX1dJVEggPSAnc3RhcnRzV2l0aCdcbiAgLCAkc3RhcnRzV2l0aCA9ICcnW1NUQVJUU19XSVRIXTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiByZXF1aXJlKCcuL19mYWlscy1pcy1yZWdleHAnKShTVEFSVFNfV0lUSCksICdTdHJpbmcnLCB7XG4gIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nIC8qLCBwb3NpdGlvbiA9IDAgKi8pe1xuICAgIHZhciB0aGF0ICAgPSBjb250ZXh0KHRoaXMsIHNlYXJjaFN0cmluZywgU1RBUlRTX1dJVEgpXG4gICAgICAsIGluZGV4ICA9IHRvTGVuZ3RoKE1hdGgubWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpXG4gICAgICAsIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiAkc3RhcnRzV2l0aFxuICAgICAgPyAkc3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpXG4gICAgICA6IHRoYXQuc2xpY2UoaW5kZXgsIGluZGV4ICsgc2VhcmNoLmxlbmd0aCkgPT09IHNlYXJjaDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTIgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2UoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3RyaWtlJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdHJpa2UoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3RyaWtlJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTMgU3RyaW5nLnByb3RvdHlwZS5zdWIoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3ViJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdWIoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gQi4yLjMuMTQgU3RyaW5nLnByb3RvdHlwZS5zdXAoKVxucmVxdWlyZSgnLi9fc3RyaW5nLWh0bWwnKSgnc3VwJywgZnVuY3Rpb24oY3JlYXRlSFRNTCl7XG4gIHJldHVybiBmdW5jdGlvbiBzdXAoKXtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3VwJywgJycsICcnKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjEuMS4zLjI1IFN0cmluZy5wcm90b3R5cGUudHJpbSgpXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltJywgZnVuY3Rpb24oJHRyaW0pe1xuICByZXR1cm4gZnVuY3Rpb24gdHJpbSgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAzKTtcbiAgfTtcbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgICAgICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIERFU0NSSVBUT1JTICAgID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCByZWRlZmluZSAgICAgICA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJylcbiAgLCBNRVRBICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVlcbiAgLCAkZmFpbHMgICAgICAgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzaGFyZWQgICAgICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgdWlkICAgICAgICAgICAgPSByZXF1aXJlKCcuL191aWQnKVxuICAsIHdrcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCB3a3NFeHQgICAgICAgICA9IHJlcXVpcmUoJy4vX3drcy1leHQnKVxuICAsIHdrc0RlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpXG4gICwga2V5T2YgICAgICAgICAgPSByZXF1aXJlKCcuL19rZXlvZicpXG4gICwgZW51bUtleXMgICAgICAgPSByZXF1aXJlKCcuL19lbnVtLWtleXMnKVxuICAsIGlzQXJyYXkgICAgICAgID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKVxuICAsIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBjcmVhdGVEZXNjICAgICA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKVxuICAsIF9jcmVhdGUgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpXG4gICwgZ09QTkV4dCAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbi1leHQnKVxuICAsICRHT1BEICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKVxuICAsICREUCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCAka2V5cyAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BEICAgICAgICAgICA9ICRHT1BELmZcbiAgLCBkUCAgICAgICAgICAgICA9ICREUC5mXG4gICwgZ09QTiAgICAgICAgICAgPSBnT1BORXh0LmZcbiAgLCAkU3ltYm9sICAgICAgICA9IGdsb2JhbC5TeW1ib2xcbiAgLCAkSlNPTiAgICAgICAgICA9IGdsb2JhbC5KU09OXG4gICwgX3N0cmluZ2lmeSAgICAgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnlcbiAgLCBQUk9UT1RZUEUgICAgICA9ICdwcm90b3R5cGUnXG4gICwgSElEREVOICAgICAgICAgPSB3a3MoJ19oaWRkZW4nKVxuICAsIFRPX1BSSU1JVElWRSAgID0gd2tzKCd0b1ByaW1pdGl2ZScpXG4gICwgaXNFbnVtICAgICAgICAgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZVxuICAsIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKVxuICAsIEFsbFN5bWJvbHMgICAgID0gc2hhcmVkKCdzeW1ib2xzJylcbiAgLCBPUFN5bWJvbHMgICAgICA9IHNoYXJlZCgnb3Atc3ltYm9scycpXG4gICwgT2JqZWN0UHJvdG8gICAgPSBPYmplY3RbUFJPVE9UWVBFXVxuICAsIFVTRV9OQVRJVkUgICAgID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJ1xuICAsIFFPYmplY3QgICAgICAgID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBzZXR0ZXIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xuXG4vLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODdcbnZhciBzZXRTeW1ib2xEZXNjID0gREVTQ1JJUFRPUlMgJiYgJGZhaWxzKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiBkUCh0aGlzLCAnYScsIHt2YWx1ZTogN30pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24oaXQsIGtleSwgRCl7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZihwcm90b0Rlc2MpZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZihwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKWRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7XG59IDogZFA7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24odGFnKXtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCl7XG4gIGlmKGl0ID09PSBPYmplY3RQcm90bykkZGVmaW5lUHJvcGVydHkoT1BTeW1ib2xzLCBrZXksIEQpO1xuICBhbk9iamVjdChpdCk7XG4gIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEQpO1xuICBpZihoYXMoQWxsU3ltYm9scywga2V5KSl7XG4gICAgaWYoIUQuZW51bWVyYWJsZSl7XG4gICAgICBpZighaGFzKGl0LCBISURERU4pKWRQKGl0LCBISURERU4sIGNyZWF0ZURlc2MoMSwge30pKTtcbiAgICAgIGl0W0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0paXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7ZW51bWVyYWJsZTogY3JlYXRlRGVzYygwLCBmYWxzZSl9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKXtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpXG4gICAgLCBpICAgID0gMFxuICAgICwgbCA9IGtleXMubGVuZ3RoXG4gICAgLCBrZXk7XG4gIHdoaWxlKGwgPiBpKSRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApe1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSl7XG4gIHZhciBFID0gaXNFbnVtLmNhbGwodGhpcywga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKSk7XG4gIGlmKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKXJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpe1xuICBpdCAgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZihpdCA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSlELmVudW1lcmFibGUgPSB0cnVlO1xuICByZXR1cm4gRDtcbn07XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KXtcbiAgdmFyIG5hbWVzICA9IGdPUE4odG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSlyZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpe1xuICB2YXIgSVNfT1AgID0gaXQgPT09IE9iamVjdFByb3RvXG4gICAgLCBuYW1lcyAgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSlcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCBrZXk7XG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpe1xuICAgIGlmKGhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiAoSVNfT1AgPyBoYXMoT2JqZWN0UHJvdG8sIGtleSkgOiB0cnVlKSlyZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmKCFVU0VfTkFUSVZFKXtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpe1xuICAgIGlmKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKXRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpO1xuICAgIHZhciB0YWcgPSB1aWQoYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICAgIHZhciAkc2V0ID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgaWYodGhpcyA9PT0gT2JqZWN0UHJvdG8pJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSl0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgICAgc2V0U3ltYm9sRGVzYyh0aGlzLCB0YWcsIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmKERFU0NSSVBUT1JTICYmIHNldHRlcilzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHtjb25maWd1cmFibGU6IHRydWUsIHNldDogJHNldH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mICAgPSAkZGVmaW5lUHJvcGVydHk7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICByZXF1aXJlKCcuL19vYmplY3QtcGllJykuZiAgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYoREVTQ1JJUFRPUlMgJiYgIXJlcXVpcmUoJy4vX2xpYnJhcnknKSl7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH1cbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwge1N5bWJvbDogJFN5bWJvbH0pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaSA9IDA7IHN5bWJvbHMubGVuZ3RoID4gaTsgKXdrcyhzeW1ib2xzW2krK10pO1xuXG5mb3IodmFyIHN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBpID0gMDsgc3ltYm9scy5sZW5ndGggPiBpOyApd2tzRGVmaW5lKHN5bWJvbHNbaSsrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24oa2V5KXtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKGtleSl7XG4gICAgaWYoaXNTeW1ib2woa2V5KSlyZXR1cm4ga2V5T2YoU3ltYm9sUmVnaXN0cnksIGtleSk7XG4gICAgdGhyb3cgVHlwZUVycm9yKGtleSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uKCl7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24oKXsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24oKXtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoe2E6IFN9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nO1xufSkpLCAnSlNPTicsIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpe1xuICAgIGlmKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKXJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIHZhciBhcmdzID0gW2l0XVxuICAgICAgLCBpICAgID0gMVxuICAgICAgLCByZXBsYWNlciwgJHJlcGxhY2VyO1xuICAgIHdoaWxlKGFyZ3VtZW50cy5sZW5ndGggPiBpKWFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmKHR5cGVvZiByZXBsYWNlciA9PSAnZnVuY3Rpb24nKSRyZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIGlmKCRyZXBsYWNlciB8fCAhaXNBcnJheShyZXBsYWNlcikpcmVwbGFjZXIgPSBmdW5jdGlvbihrZXksIHZhbHVlKXtcbiAgICAgIGlmKCRyZXBsYWNlcil2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYoIWlzU3ltYm9sKHZhbHVlKSlyZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR0eXBlZCAgICAgICA9IHJlcXVpcmUoJy4vX3R5cGVkJylcbiAgLCBidWZmZXIgICAgICAgPSByZXF1aXJlKCcuL190eXBlZC1idWZmZXInKVxuICAsIGFuT2JqZWN0ICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9JbmRleCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKVxuICAsIHRvTGVuZ3RoICAgICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgaXNPYmplY3QgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBBcnJheUJ1ZmZlciAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5BcnJheUJ1ZmZlclxuICAsIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX3NwZWNpZXMtY29uc3RydWN0b3InKVxuICAsICRBcnJheUJ1ZmZlciA9IGJ1ZmZlci5BcnJheUJ1ZmZlclxuICAsICREYXRhVmlldyAgICA9IGJ1ZmZlci5EYXRhVmlld1xuICAsICRpc1ZpZXcgICAgICA9ICR0eXBlZC5BQlYgJiYgQXJyYXlCdWZmZXIuaXNWaWV3XG4gICwgJHNsaWNlICAgICAgID0gJEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZVxuICAsIFZJRVcgICAgICAgICA9ICR0eXBlZC5WSUVXXG4gICwgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQXJyYXlCdWZmZXIgIT09ICRBcnJheUJ1ZmZlciksIHtBcnJheUJ1ZmZlcjogJEFycmF5QnVmZmVyfSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogISR0eXBlZC5DT05TVFIsIEFSUkFZX0JVRkZFUiwge1xuICAvLyAyNC4xLjMuMSBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKVxuICBpc1ZpZXc6IGZ1bmN0aW9uIGlzVmlldyhpdCl7XG4gICAgcmV0dXJuICRpc1ZpZXcgJiYgJGlzVmlldyhpdCkgfHwgaXNPYmplY3QoaXQpICYmIFZJRVcgaW4gaXQ7XG4gIH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuVSArICRleHBvcnQuRiAqIHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuICFuZXcgJEFycmF5QnVmZmVyKDIpLnNsaWNlKDEsIHVuZGVmaW5lZCkuYnl0ZUxlbmd0aDtcbn0pLCBBUlJBWV9CVUZGRVIsIHtcbiAgLy8gMjQuMS40LjMgQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKXtcbiAgICBpZigkc2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZClyZXR1cm4gJHNsaWNlLmNhbGwoYW5PYmplY3QodGhpcyksIHN0YXJ0KTsgLy8gRkYgZml4XG4gICAgdmFyIGxlbiAgICA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGhcbiAgICAgICwgZmlyc3QgID0gdG9JbmRleChzdGFydCwgbGVuKVxuICAgICAgLCBmaW5hbCAgPSB0b0luZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogZW5kLCBsZW4pXG4gICAgICAsIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsICRBcnJheUJ1ZmZlcikpKHRvTGVuZ3RoKGZpbmFsIC0gZmlyc3QpKVxuICAgICAgLCB2aWV3UyAgPSBuZXcgJERhdGFWaWV3KHRoaXMpXG4gICAgICAsIHZpZXdUICA9IG5ldyAkRGF0YVZpZXcocmVzdWx0KVxuICAgICAgLCBpbmRleCAgPSAwO1xuICAgIHdoaWxlKGZpcnN0IDwgZmluYWwpe1xuICAgICAgdmlld1Quc2V0VWludDgoaW5kZXgrKywgdmlld1MuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoQVJSQVlfQlVGRkVSKTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fdHlwZWQnKS5BQlYsIHtcbiAgRGF0YVZpZXc6IHJlcXVpcmUoJy4vX3R5cGVkLWJ1ZmZlcicpLkRhdGFWaWV3XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdGbG9hdDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBGbG9hdDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnRmxvYXQ2NCcsIDgsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQ2NEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDE2JywgMiwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDMyJywgNCwgZnVuY3Rpb24oaW5pdCl7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ0ludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpe1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTsiLCJyZXF1aXJlKCcuL190eXBlZC1hcnJheScpKCdVaW50MTYnLCAyLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQxNkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pOyIsInJlcXVpcmUoJy4vX3R5cGVkLWFycmF5JykoJ1VpbnQzMicsIDQsIGZ1bmN0aW9uKGluaXQpe1xuICByZXR1cm4gZnVuY3Rpb24gVWludDMyQXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKXtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7IiwicmVxdWlyZSgnLi9fdHlwZWQtYXJyYXknKSgnVWludDgnLCAxLCBmdW5jdGlvbihpbml0KXtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCl7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0sIHRydWUpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBlYWNoICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCByZWRlZmluZSAgICAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgbWV0YSAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YScpXG4gICwgYXNzaWduICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpXG4gICwgd2VhayAgICAgICAgID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJylcbiAgLCBpc09iamVjdCAgICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGdldFdlYWsgICAgICA9IG1ldGEuZ2V0V2Vha1xuICAsIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGVcbiAgLCB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlXG4gICwgdG1wICAgICAgICAgID0ge31cbiAgLCBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpe1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSl7XG4gICAgaWYoaXNPYmplY3Qoa2V5KSl7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmKGRhdGEgPT09IHRydWUpcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhpcykuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1dlYWtNYXAnLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYobmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNyl7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24oa2V5KXtcbiAgICB2YXIgcHJvdG8gID0gJFdlYWtNYXAucHJvdG90eXBlXG4gICAgICAsIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24oYSwgYil7XG4gICAgICAvLyBzdG9yZSBmcm96ZW4gb2JqZWN0cyBvbiBpbnRlcm5hbCB3ZWFrbWFwIHNoaW1cbiAgICAgIGlmKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpe1xuICAgICAgICBpZighdGhpcy5fZil0aGlzLl9mID0gbmV3IEludGVybmFsTWFwO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fZltrZXldKGEsIGIpO1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzZXQnID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIC8vIHN0b3JlIGFsbCB0aGUgcmVzdCBvbiBuYXRpdmUgd2Vha21hcFxuICAgICAgfSByZXR1cm4gbWV0aG9kLmNhbGwodGhpcywgYSwgYik7XG4gICAgfSk7XG4gIH0pO1xufSIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWFrID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi13ZWFrJyk7XG5cbi8vIDIzLjQgV2Vha1NldCBPYmplY3RzXG5yZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoJ1dlYWtTZXQnLCBmdW5jdGlvbihnZXQpe1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha1NldCgpeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuNC4zLjEgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSl7XG4gICAgcmV0dXJuIHdlYWsuZGVmKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgfVxufSwgd2VhaywgZmFsc2UsIHRydWUpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L0FycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xudmFyICRleHBvcnQgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdBcnJheScsIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKGVsIC8qLCBmcm9tSW5kZXggPSAwICovKXtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5yZXF1aXJlKCcuL19hZGQtdG8tdW5zY29wYWJsZXMnKSgnaW5jbHVkZXMnKTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vcndhbGRyb24vdGMzOS1ub3Rlcy9ibG9iL21hc3Rlci9lczYvMjAxNC0wOS9zZXB0LTI1Lm1kIzUxMC1nbG9iYWxhc2FwLWZvci1lbnF1ZXVpbmctYS1taWNyb3Rhc2tcbnZhciAkZXhwb3J0ICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4vX21pY3JvdGFzaycpKClcbiAgLCBwcm9jZXNzICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5wcm9jZXNzXG4gICwgaXNOb2RlICAgID0gcmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xuXG4kZXhwb3J0KCRleHBvcnQuRywge1xuICBhc2FwOiBmdW5jdGlvbiBhc2FwKGZuKXtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvcHJvcG9zYWwtaXMtZXJyb3JcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBjb2YgICAgID0gcmVxdWlyZSgnLi9fY29mJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnRXJyb3InLCB7XG4gIGlzRXJyb3I6IGZ1bmN0aW9uIGlzRXJyb3IoaXQpe1xuICAgIHJldHVybiBjb2YoaXQpID09PSAnRXJyb3InO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdNYXAnLCB7dG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJyl9KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpYWRkaDogZnVuY3Rpb24gaWFkZGgoeDAsIHgxLCB5MCwgeTEpe1xuICAgIHZhciAkeDAgPSB4MCA+Pj4gMFxuICAgICAgLCAkeDEgPSB4MSA+Pj4gMFxuICAgICAgLCAkeTAgPSB5MCA+Pj4gMDtcbiAgICByZXR1cm4gJHgxICsgKHkxID4+PiAwKSArICgoJHgwICYgJHkwIHwgKCR4MCB8ICR5MCkgJiB+KCR4MCArICR5MCA+Pj4gMCkpID4+PiAzMSkgfCAwO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICBpbXVsaDogZnVuY3Rpb24gaW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4gMTZcbiAgICAgICwgdjEgPSAkdiA+PiAxNlxuICAgICAgLCB0ICA9ICh1MSAqIHYwID4+PiAwKSArICh1MCAqIHYwID4+PiAxNik7XG4gICAgcmV0dXJuIHUxICogdjEgKyAodCA+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+IDE2KTtcbiAgfVxufSk7IiwiLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vQnJlbmRhbkVpY2gvNDI5NGQ1YzIxMmE2ZDIyNTQ3MDNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnTWF0aCcsIHtcbiAgaXN1Ymg6IGZ1bmN0aW9uIGlzdWJoKHgwLCB4MSwgeTAsIHkxKXtcbiAgICB2YXIgJHgwID0geDAgPj4+IDBcbiAgICAgICwgJHgxID0geDEgPj4+IDBcbiAgICAgICwgJHkwID0geTAgPj4+IDA7XG4gICAgcmV0dXJuICR4MSAtICh5MSA+Pj4gMCkgLSAoKH4keDAgJiAkeTAgfCB+KCR4MCBeICR5MCkgJiAkeDAgLSAkeTAgPj4+IDApID4+PiAzMSkgfCAwO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9CcmVuZGFuRWljaC80Mjk0ZDVjMjEyYTZkMjI1NDcwM1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdNYXRoJywge1xuICB1bXVsaDogZnVuY3Rpb24gdW11bGgodSwgdil7XG4gICAgdmFyIFVJTlQxNiA9IDB4ZmZmZlxuICAgICAgLCAkdSA9ICt1XG4gICAgICAsICR2ID0gK3ZcbiAgICAgICwgdTAgPSAkdSAmIFVJTlQxNlxuICAgICAgLCB2MCA9ICR2ICYgVUlOVDE2XG4gICAgICAsIHUxID0gJHUgPj4+IDE2XG4gICAgICAsIHYxID0gJHYgPj4+IDE2XG4gICAgICAsIHQgID0gKHUxICogdjAgPj4+IDApICsgKHUwICogdjAgPj4+IDE2KTtcbiAgICByZXR1cm4gdTEgKiB2MSArICh0ID4+PiAxNikgKyAoKHUwICogdjEgPj4+IDApICsgKHQgJiBVSU5UMTYpID4+PiAxNik7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIHRvT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgYUZ1bmN0aW9uICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG5cbi8vIEIuMi4yLjIgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcilcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2RlZmluZUdldHRlcl9fOiBmdW5jdGlvbiBfX2RlZmluZUdldHRlcl9fKFAsIGdldHRlcil7XG4gICAgJGRlZmluZVByb3BlcnR5LmYodG9PYmplY3QodGhpcyksIFAsIHtnZXQ6IGFGdW5jdGlvbihnZXR0ZXIpLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCAkZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcblxuLy8gQi4yLjIuMyBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKXtcbiAgICAkZGVmaW5lUHJvcGVydHkuZih0b09iamVjdCh0aGlzKSwgUCwge3NldDogYUZ1bmN0aW9uKHNldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICB9XG59KTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtdmFsdWVzLWVudHJpZXNcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGVudHJpZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoaXQpe1xuICAgIHJldHVybiAkZW50cmllcyhpdCk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG52YXIgJGV4cG9ydCAgICAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIG93bktleXMgICAgICAgID0gcmVxdWlyZSgnLi9fb3duLWtleXMnKVxuICAsIHRvSU9iamVjdCAgICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgZ09QRCAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpXG4gICwgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqZWN0KXtcbiAgICB2YXIgTyAgICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgICAsIGdldERlc2MgPSBnT1BELmZcbiAgICAgICwga2V5cyAgICA9IG93bktleXMoTylcbiAgICAgICwgcmVzdWx0ICA9IHt9XG4gICAgICAsIGkgICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShrZXlzLmxlbmd0aCA+IGkpY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXkgPSBrZXlzW2krK10sIGdldERlc2MoTywga2V5KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgdG9PYmplY3QgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKVxuICAsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxuLy8gQi4yLjIuNCBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX18oUClcbnJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgJGV4cG9ydCgkZXhwb3J0LlAgKyByZXF1aXJlKCcuL19vYmplY3QtZm9yY2VkLXBhbScpLCAnT2JqZWN0Jywge1xuICBfX2xvb2t1cEdldHRlcl9fOiBmdW5jdGlvbiBfX2xvb2t1cEdldHRlcl9fKFApe1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcylcbiAgICAgICwgSyA9IHRvUHJpbWl0aXZlKFAsIHRydWUpXG4gICAgICAsIEQ7XG4gICAgZG8ge1xuICAgICAgaWYoRCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBLKSlyZXR1cm4gRC5nZXQ7XG4gICAgfSB3aGlsZShPID0gZ2V0UHJvdG90eXBlT2YoTykpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCB0b09iamVjdCAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpXG4gICwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG4vLyBCLjIuMi41IE9iamVjdC5wcm90b3R5cGUuX19sb29rdXBTZXR0ZXJfXyhQKVxucmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAkZXhwb3J0KCRleHBvcnQuUCArIHJlcXVpcmUoJy4vX29iamVjdC1mb3JjZWQtcGFtJyksICdPYmplY3QnLCB7XG4gIF9fbG9va3VwU2V0dGVyX186IGZ1bmN0aW9uIF9fbG9va3VwU2V0dGVyX18oUCl7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKVxuICAgICAgLCBLID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSlcbiAgICAgICwgRDtcbiAgICBkbyB7XG4gICAgICBpZihEID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIEspKXJldHVybiBELnNldDtcbiAgICB9IHdoaWxlKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gIH1cbn0pOyIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICR2YWx1ZXMgPSByZXF1aXJlKCcuL19vYmplY3QtdG8tYXJyYXknKShmYWxzZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0Jywge1xuICB2YWx1ZXM6IGZ1bmN0aW9uIHZhbHVlcyhpdCl7XG4gICAgcmV0dXJuICR2YWx1ZXMoaXQpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG52YXIgJGV4cG9ydCAgICAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGdsb2JhbCAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIG1pY3JvdGFzayAgID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKVxuICAsIE9CU0VSVkFCTEUgID0gcmVxdWlyZSgnLi9fd2tzJykoJ29ic2VydmFibGUnKVxuICAsIGFGdW5jdGlvbiAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGFuSW5zdGFuY2UgID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKVxuICAsIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJylcbiAgLCBoaWRlICAgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGZvck9mICAgICAgID0gcmVxdWlyZSgnLi9fZm9yLW9mJylcbiAgLCBSRVRVUk4gICAgICA9IGZvck9mLlJFVFVSTjtcblxudmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uKGZuKXtcbiAgcmV0dXJuIGZuID09IG51bGwgPyB1bmRlZmluZWQgOiBhRnVuY3Rpb24oZm4pO1xufTtcblxudmFyIGNsZWFudXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbihzdWJzY3JpcHRpb24pe1xuICB2YXIgY2xlYW51cCA9IHN1YnNjcmlwdGlvbi5fYztcbiAgaWYoY2xlYW51cCl7XG4gICAgc3Vic2NyaXB0aW9uLl9jID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXAoKTtcbiAgfVxufTtcblxudmFyIHN1YnNjcmlwdGlvbkNsb3NlZCA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIHJldHVybiBzdWJzY3JpcHRpb24uX28gPT09IHVuZGVmaW5lZDtcbn07XG5cbnZhciBjbG9zZVN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKHN1YnNjcmlwdGlvbil7XG4gIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgfVxufTtcblxudmFyIFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKG9ic2VydmVyLCBzdWJzY3JpYmVyKXtcbiAgYW5PYmplY3Qob2JzZXJ2ZXIpO1xuICB0aGlzLl9jID0gdW5kZWZpbmVkO1xuICB0aGlzLl9vID0gb2JzZXJ2ZXI7XG4gIG9ic2VydmVyID0gbmV3IFN1YnNjcmlwdGlvbk9ic2VydmVyKHRoaXMpO1xuICB0cnkge1xuICAgIHZhciBjbGVhbnVwICAgICAgPSBzdWJzY3JpYmVyKG9ic2VydmVyKVxuICAgICAgLCBzdWJzY3JpcHRpb24gPSBjbGVhbnVwO1xuICAgIGlmKGNsZWFudXAgIT0gbnVsbCl7XG4gICAgICBpZih0eXBlb2YgY2xlYW51cC51bnN1YnNjcmliZSA9PT0gJ2Z1bmN0aW9uJyljbGVhbnVwID0gZnVuY3Rpb24oKXsgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICBlbHNlIGFGdW5jdGlvbihjbGVhbnVwKTtcbiAgICAgIHRoaXMuX2MgPSBjbGVhbnVwO1xuICAgIH1cbiAgfSBjYXRjaChlKXtcbiAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICByZXR1cm47XG4gIH0gaWYoc3Vic2NyaXB0aW9uQ2xvc2VkKHRoaXMpKWNsZWFudXBTdWJzY3JpcHRpb24odGhpcyk7XG59O1xuXG5TdWJzY3JpcHRpb24ucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoe30sIHtcbiAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCl7IGNsb3NlU3Vic2NyaXB0aW9uKHRoaXMpOyB9XG59KTtcblxudmFyIFN1YnNjcmlwdGlvbk9ic2VydmVyID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uKXtcbiAgdGhpcy5fcyA9IHN1YnNjcmlwdGlvbjtcbn07XG5cblN1YnNjcmlwdGlvbk9ic2VydmVyLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKHt9LCB7XG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5uZXh0KTtcbiAgICAgICAgaWYobSlyZXR1cm4gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNsb3NlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKHZhbHVlKXtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGhpcy5fcztcbiAgICBpZihzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl0aHJvdyB2YWx1ZTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgc3Vic2NyaXB0aW9uLl9vID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5lcnJvcik7XG4gICAgICBpZighbSl0aHJvdyB2YWx1ZTtcbiAgICAgIHZhbHVlID0gbS5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNsZWFudXBTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUodmFsdWUpe1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLl9zO1xuICAgIGlmKCFzdWJzY3JpcHRpb25DbG9zZWQoc3Vic2NyaXB0aW9uKSl7XG4gICAgICB2YXIgb2JzZXJ2ZXIgPSBzdWJzY3JpcHRpb24uX287XG4gICAgICBzdWJzY3JpcHRpb24uX28gPSB1bmRlZmluZWQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbSA9IGdldE1ldGhvZChvYnNlcnZlci5jb21wbGV0ZSk7XG4gICAgICAgIHZhbHVlID0gbSA/IG0uY2FsbChvYnNlcnZlciwgdmFsdWUpIDogdW5kZWZpbmVkO1xuICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfSBjbGVhbnVwU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59KTtcblxudmFyICRPYnNlcnZhYmxlID0gZnVuY3Rpb24gT2JzZXJ2YWJsZShzdWJzY3JpYmVyKXtcbiAgYW5JbnN0YW5jZSh0aGlzLCAkT2JzZXJ2YWJsZSwgJ09ic2VydmFibGUnLCAnX2YnKS5fZiA9IGFGdW5jdGlvbihzdWJzY3JpYmVyKTtcbn07XG5cbnJlZGVmaW5lQWxsKCRPYnNlcnZhYmxlLnByb3RvdHlwZSwge1xuICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShvYnNlcnZlcil7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24ob2JzZXJ2ZXIsIHRoaXMuX2YpO1xuICB9LFxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZuKXtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyAoY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgYUZ1bmN0aW9uKGZuKTtcbiAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGF0LnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQgOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IHJlamVjdCxcbiAgICAgICAgY29tcGxldGU6IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcblxucmVkZWZpbmVBbGwoJE9ic2VydmFibGUsIHtcbiAgZnJvbTogZnVuY3Rpb24gZnJvbSh4KXtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlO1xuICAgIHZhciBtZXRob2QgPSBnZXRNZXRob2QoYW5PYmplY3QoeClbT0JTRVJWQUJMRV0pO1xuICAgIGlmKG1ldGhvZCl7XG4gICAgICB2YXIgb2JzZXJ2YWJsZSA9IGFuT2JqZWN0KG1ldGhvZC5jYWxsKHgpKTtcbiAgICAgIHJldHVybiBvYnNlcnZhYmxlLmNvbnN0cnVjdG9yID09PSBDID8gb2JzZXJ2YWJsZSA6IG5ldyBDKGZ1bmN0aW9uKG9ic2VydmVyKXtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEMoZnVuY3Rpb24ob2JzZXJ2ZXIpe1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbigpe1xuICAgICAgICBpZighZG9uZSl7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKGZvck9mKHgsIGZhbHNlLCBmdW5jdGlvbihpdCl7XG4gICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoaXQpO1xuICAgICAgICAgICAgICBpZihkb25lKXJldHVybiBSRVRVUk47XG4gICAgICAgICAgICB9KSA9PT0gUkVUVVJOKXJldHVybjtcbiAgICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgaWYoZG9uZSl0aHJvdyBlO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpeyBkb25lID0gdHJ1ZTsgfTtcbiAgICB9KTtcbiAgfSxcbiAgb2Y6IGZ1bmN0aW9uIG9mKCl7XG4gICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gQXJyYXkobCk7IGkgPCBsOylpdGVtc1tpXSA9IGFyZ3VtZW50c1tpKytdO1xuICAgIHJldHVybiBuZXcgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nID8gdGhpcyA6ICRPYnNlcnZhYmxlKShmdW5jdGlvbihvYnNlcnZlcil7XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFkb25lKXtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChpdGVtc1tpXSk7XG4gICAgICAgICAgICBpZihkb25lKXJldHVybjtcbiAgICAgICAgICB9IG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7IGRvbmUgPSB0cnVlOyB9O1xuICAgIH0pO1xuICB9XG59KTtcblxuaGlkZSgkT2JzZXJ2YWJsZS5wcm90b3R5cGUsIE9CU0VSVkFCTEUsIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzOyB9KTtcblxuJGV4cG9ydCgkZXhwb3J0LkcsIHtPYnNlcnZhYmxlOiAkT2JzZXJ2YWJsZX0pO1xuXG5yZXF1aXJlKCcuL19zZXQtc3BlY2llcycpKCdPYnNlcnZhYmxlJyk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7ZGVmaW5lTWV0YWRhdGE6IGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHRhcmdldEtleSl7XG4gIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIGFuT2JqZWN0KHRhcmdldCksIHRvTWV0YUtleSh0YXJnZXRLZXkpKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgID0gbWV0YWRhdGEua2V5XG4gICwgZ2V0T3JDcmVhdGVNZXRhZGF0YU1hcCA9IG1ldGFkYXRhLm1hcFxuICAsIHN0b3JlICAgICAgICAgICAgICAgICAgPSBtZXRhZGF0YS5zdG9yZTtcblxubWV0YWRhdGEuZXhwKHtkZWxldGVNZXRhZGF0YTogZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgdmFyIHRhcmdldEtleSAgID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKVxuICAgICwgbWV0YWRhdGFNYXAgPSBnZXRPckNyZWF0ZU1ldGFkYXRhTWFwKGFuT2JqZWN0KHRhcmdldCksIHRhcmdldEtleSwgZmFsc2UpO1xuICBpZihtZXRhZGF0YU1hcCA9PT0gdW5kZWZpbmVkIHx8ICFtZXRhZGF0YU1hcFsnZGVsZXRlJ10obWV0YWRhdGFLZXkpKXJldHVybiBmYWxzZTtcbiAgaWYobWV0YWRhdGFNYXAuc2l6ZSlyZXR1cm4gdHJ1ZTtcbiAgdmFyIHRhcmdldE1ldGFkYXRhID0gc3RvcmUuZ2V0KHRhcmdldCk7XG4gIHRhcmdldE1ldGFkYXRhWydkZWxldGUnXSh0YXJnZXRLZXkpO1xuICByZXR1cm4gISF0YXJnZXRNZXRhZGF0YS5zaXplIHx8IHN0b3JlWydkZWxldGUnXSh0YXJnZXQpO1xufX0pOyIsInZhciBTZXQgICAgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vZXM2LnNldCcpXG4gICwgZnJvbSAgICAgICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJylcbiAgLCBtZXRhZGF0YSAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZ2V0UHJvdG90eXBlT2YgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5TWV0YWRhdGFLZXlzID0gZnVuY3Rpb24oTywgUCl7XG4gIHZhciBvS2V5cyAgPSBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICwgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIGlmKHBhcmVudCA9PT0gbnVsbClyZXR1cm4gb0tleXM7XG4gIHZhciBwS2V5cyAgPSBvcmRpbmFyeU1ldGFkYXRhS2V5cyhwYXJlbnQsIFApO1xuICByZXR1cm4gcEtleXMubGVuZ3RoID8gb0tleXMubGVuZ3RoID8gZnJvbShuZXcgU2V0KG9LZXlzLmNvbmNhdChwS2V5cykpKSA6IHBLZXlzIDogb0tleXM7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhS2V5czogZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5TWV0YWRhdGFLZXlzKGFuT2JqZWN0KHRhcmdldCksIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1sxXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgb3JkaW5hcnlHZXRPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmdldFxuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbnZhciBvcmRpbmFyeUdldE1ldGFkYXRhID0gZnVuY3Rpb24oTWV0YWRhdGFLZXksIE8sIFApe1xuICB2YXIgaGFzT3duID0gb3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIGlmKGhhc093bilyZXR1cm4gb3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCk7XG4gIHZhciBwYXJlbnQgPSBnZXRQcm90b3R5cGVPZihPKTtcbiAgcmV0dXJuIHBhcmVudCAhPT0gbnVsbCA/IG9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIHBhcmVudCwgUCkgOiB1bmRlZmluZWQ7XG59O1xuXG5tZXRhZGF0YS5leHAoe2dldE1ldGFkYXRhOiBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyA9IG1ldGFkYXRhLmtleXNcbiAgLCB0b01ldGFLZXkgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YUtleXM6IGZ1bmN0aW9uIGdldE93bk1ldGFkYXRhS2V5cyh0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhhbk9iamVjdCh0YXJnZXQpLCBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMV0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBvcmRpbmFyeUdldE93bk1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0XG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxubWV0YWRhdGEuZXhwKHtnZXRPd25NZXRhZGF0YTogZnVuY3Rpb24gZ2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCAvKiwgdGFyZ2V0S2V5ICovKXtcbiAgcmV0dXJuIG9yZGluYXJ5R2V0T3duTWV0YWRhdGEobWV0YWRhdGFLZXksIGFuT2JqZWN0KHRhcmdldClcbiAgICAsIGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdW5kZWZpbmVkIDogdG9NZXRhS2V5KGFyZ3VtZW50c1syXSkpO1xufX0pOyIsInZhciBtZXRhZGF0YSAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fbWV0YWRhdGEnKVxuICAsIGFuT2JqZWN0ICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldFByb3RvdHlwZU9mICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJylcbiAgLCBvcmRpbmFyeUhhc093bk1ldGFkYXRhID0gbWV0YWRhdGEuaGFzXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleTtcblxudmFyIG9yZGluYXJ5SGFzTWV0YWRhdGEgPSBmdW5jdGlvbihNZXRhZGF0YUtleSwgTywgUCl7XG4gIHZhciBoYXNPd24gPSBvcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgaWYoaGFzT3duKXJldHVybiB0cnVlO1xuICB2YXIgcGFyZW50ID0gZ2V0UHJvdG90eXBlT2YoTyk7XG4gIHJldHVybiBwYXJlbnQgIT09IG51bGwgPyBvcmRpbmFyeUhhc01ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApIDogZmFsc2U7XG59O1xuXG5tZXRhZGF0YS5leHAoe2hhc01ldGFkYXRhOiBmdW5jdGlvbiBoYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0IC8qLCB0YXJnZXRLZXkgKi8pe1xuICByZXR1cm4gb3JkaW5hcnlIYXNNZXRhZGF0YShtZXRhZGF0YUtleSwgYW5PYmplY3QodGFyZ2V0KSwgYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiB0b01ldGFLZXkoYXJndW1lbnRzWzJdKSk7XG59fSk7IiwidmFyIG1ldGFkYXRhICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19tZXRhZGF0YScpXG4gICwgYW5PYmplY3QgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgb3JkaW5hcnlIYXNPd25NZXRhZGF0YSA9IG1ldGFkYXRhLmhhc1xuICAsIHRvTWV0YUtleSAgICAgICAgICAgICAgPSBtZXRhZGF0YS5rZXk7XG5cbm1ldGFkYXRhLmV4cCh7aGFzT3duTWV0YWRhdGE6IGZ1bmN0aW9uIGhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQgLyosIHRhcmdldEtleSAqLyl7XG4gIHJldHVybiBvcmRpbmFyeUhhc093bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBhbk9iamVjdCh0YXJnZXQpXG4gICAgLCBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IHRvTWV0YUtleShhcmd1bWVudHNbMl0pKTtcbn19KTsiLCJ2YXIgbWV0YWRhdGEgICAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX21ldGFkYXRhJylcbiAgLCBhbk9iamVjdCAgICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBhRnVuY3Rpb24gICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpXG4gICwgdG9NZXRhS2V5ICAgICAgICAgICAgICAgICA9IG1ldGFkYXRhLmtleVxuICAsIG9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEgPSBtZXRhZGF0YS5zZXQ7XG5cbm1ldGFkYXRhLmV4cCh7bWV0YWRhdGE6IGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRvcih0YXJnZXQsIHRhcmdldEtleSl7XG4gICAgb3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShcbiAgICAgIG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLFxuICAgICAgKHRhcmdldEtleSAhPT0gdW5kZWZpbmVkID8gYW5PYmplY3QgOiBhRnVuY3Rpb24pKHRhcmdldCksXG4gICAgICB0b01ldGFLZXkodGFyZ2V0S2V5KVxuICAgICk7XG4gIH07XG59fSk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0Jywge3RvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpfSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRhdCAgICAgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIGF0OiBmdW5jdGlvbiBhdChwb3Mpe1xuICAgIHJldHVybiAkYXQodGhpcywgcG9zKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9TdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsL1xudmFyICRleHBvcnQgICAgID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkICAgICA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIHRvTGVuZ3RoICAgID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBpc1JlZ0V4cCAgICA9IHJlcXVpcmUoJy4vX2lzLXJlZ2V4cCcpXG4gICwgZ2V0RmxhZ3MgICAgPSByZXF1aXJlKCcuL19mbGFncycpXG4gICwgUmVnRXhwUHJvdG8gPSBSZWdFeHAucHJvdG90eXBlO1xuXG52YXIgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yID0gZnVuY3Rpb24ocmVnZXhwLCBzdHJpbmcpe1xuICB0aGlzLl9yID0gcmVnZXhwO1xuICB0aGlzLl9zID0gc3RyaW5nO1xufTtcblxucmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKSgkUmVnRXhwU3RyaW5nSXRlcmF0b3IsICdSZWdFeHAgU3RyaW5nJywgZnVuY3Rpb24gbmV4dCgpe1xuICB2YXIgbWF0Y2ggPSB0aGlzLl9yLmV4ZWModGhpcy5fcyk7XG4gIHJldHVybiB7dmFsdWU6IG1hdGNoLCBkb25lOiBtYXRjaCA9PT0gbnVsbH07XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIG1hdGNoQWxsOiBmdW5jdGlvbiBtYXRjaEFsbChyZWdleHApe1xuICAgIGRlZmluZWQodGhpcyk7XG4gICAgaWYoIWlzUmVnRXhwKHJlZ2V4cCkpdGhyb3cgVHlwZUVycm9yKHJlZ2V4cCArICcgaXMgbm90IGEgcmVnZXhwIScpO1xuICAgIHZhciBTICAgICA9IFN0cmluZyh0aGlzKVxuICAgICAgLCBmbGFncyA9ICdmbGFncycgaW4gUmVnRXhwUHJvdG8gPyBTdHJpbmcocmVnZXhwLmZsYWdzKSA6IGdldEZsYWdzLmNhbGwocmVnZXhwKVxuICAgICAgLCByeCAgICA9IG5ldyBSZWdFeHAocmVnZXhwLnNvdXJjZSwgfmZsYWdzLmluZGV4T2YoJ2cnKSA/IGZsYWdzIDogJ2cnICsgZmxhZ3MpO1xuICAgIHJ4Lmxhc3RJbmRleCA9IHRvTGVuZ3RoKHJlZ2V4cC5sYXN0SW5kZXgpO1xuICAgIHJldHVybiBuZXcgJFJlZ0V4cFN0cmluZ0l0ZXJhdG9yKHJ4LCBTKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtc3RyaW5nLXBhZC1zdGFydC1lbmRcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcGFkICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXBhZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ1N0cmluZycsIHtcbiAgcGFkRW5kOiBmdW5jdGlvbiBwYWRFbmQobWF4TGVuZ3RoIC8qLCBmaWxsU3RyaW5nID0gJyAnICovKXtcbiAgICByZXR1cm4gJHBhZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmYWxzZSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJHBhZCAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy1wYWQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdTdHJpbmcnLCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyosIGZpbGxTdHJpbmcgPSAnICcgKi8pe1xuICAgIHJldHVybiAkcGFkKHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRydWUpO1xuICB9XG59KTsiLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2VibWFya2JhZ2UvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG5yZXF1aXJlKCcuL19zdHJpbmctdHJpbScpKCd0cmltTGVmdCcsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1MZWZ0KCl7XG4gICAgcmV0dXJuICR0cmltKHRoaXMsIDEpO1xuICB9O1xufSwgJ3RyaW1TdGFydCcpOyIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWJtYXJrYmFnZS9lY21hc2NyaXB0LXN0cmluZy1sZWZ0LXJpZ2h0LXRyaW1cbnJlcXVpcmUoJy4vX3N0cmluZy10cmltJykoJ3RyaW1SaWdodCcsIGZ1bmN0aW9uKCR0cmltKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRyaW1SaWdodCgpe1xuICAgIHJldHVybiAkdHJpbSh0aGlzLCAyKTtcbiAgfTtcbn0sICd0cmltRW5kJyk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdhc3luY0l0ZXJhdG9yJyk7IiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9wcm9wb3NhbC1nbG9iYWxcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TLCAnU3lzdGVtJywge2dsb2JhbDogcmVxdWlyZSgnLi9fZ2xvYmFsJyl9KTsiLCJ2YXIgJGl0ZXJhdG9ycyAgICA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJylcbiAgLCByZWRlZmluZSAgICAgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGdsb2JhbCAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCBJdGVyYXRvcnMgICAgID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJylcbiAgLCB3a3MgICAgICAgICAgID0gcmVxdWlyZSgnLi9fd2tzJylcbiAgLCBJVEVSQVRPUiAgICAgID0gd2tzKCdpdGVyYXRvcicpXG4gICwgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKVxuICAsIEFycmF5VmFsdWVzICAgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmZvcih2YXIgY29sbGVjdGlvbnMgPSBbJ05vZGVMaXN0JywgJ0RPTVRva2VuTGlzdCcsICdNZWRpYUxpc3QnLCAnU3R5bGVTaGVldExpc3QnLCAnQ1NTUnVsZUxpc3QnXSwgaSA9IDA7IGkgPCA1OyBpKyspe1xuICB2YXIgTkFNRSAgICAgICA9IGNvbGxlY3Rpb25zW2ldXG4gICAgLCBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdXG4gICAgLCBwcm90byAgICAgID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZVxuICAgICwga2V5O1xuICBpZihwcm90byl7XG4gICAgaWYoIXByb3RvW0lURVJBVE9SXSloaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmKCFwcm90b1tUT19TVFJJTkdfVEFHXSloaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgICBJdGVyYXRvcnNbTkFNRV0gPSBBcnJheVZhbHVlcztcbiAgICBmb3Ioa2V5IGluICRpdGVyYXRvcnMpaWYoIXByb3RvW2tleV0pcmVkZWZpbmUocHJvdG8sIGtleSwgJGl0ZXJhdG9yc1trZXldLCB0cnVlKTtcbiAgfVxufSIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkdGFzayAgID0gcmVxdWlyZSgnLi9fdGFzaycpO1xuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LkIsIHtcbiAgc2V0SW1tZWRpYXRlOiAgICR0YXNrLnNldCxcbiAgY2xlYXJJbW1lZGlhdGU6ICR0YXNrLmNsZWFyXG59KTsiLCIvLyBpZTktIHNldFRpbWVvdXQgJiBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG52YXIgZ2xvYmFsICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgJGV4cG9ydCAgICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgaW52b2tlICAgICA9IHJlcXVpcmUoJy4vX2ludm9rZScpXG4gICwgcGFydGlhbCAgICA9IHJlcXVpcmUoJy4vX3BhcnRpYWwnKVxuICAsIG5hdmlnYXRvciAgPSBnbG9iYWwubmF2aWdhdG9yXG4gICwgTVNJRSAgICAgICA9ICEhbmF2aWdhdG9yICYmIC9NU0lFIC5cXC4vLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcbnZhciB3cmFwID0gZnVuY3Rpb24oc2V0KXtcbiAgcmV0dXJuIE1TSUUgPyBmdW5jdGlvbihmbiwgdGltZSAvKiwgLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIHNldChpbnZva2UoXG4gICAgICBwYXJ0aWFsLFxuICAgICAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgdHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKVxuICAgICksIHRpbWUpO1xuICB9IDogc2V0O1xufTtcbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5CICsgJGV4cG9ydC5GICogTVNJRSwge1xuICBzZXRUaW1lb3V0OiAgd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pOyIsInJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZWFsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5pcy1leHRlbnNpYmxlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYub2JqZWN0LmlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5mdW5jdGlvbi5uYW1lJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucGFyc2UtZmxvYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci50by1maXhlZCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIudG8tcHJlY2lzaW9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5lcHNpbG9uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLWludGVnZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubnVtYmVyLmlzLW5hbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5taW4tc2FmZS1pbnRlZ2VyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm51bWJlci5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5udW1iZXIucGFyc2UtaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguYWNvc2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5hc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmF0YW5oJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY2JydCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmNsejMyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguY29zaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmV4cG0xJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguZnJvdW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguaHlwb3QnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5pbXVsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGgubG9nMTAnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5sb2cxcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLmxvZzInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC5zaWduJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2Lm1hdGguc2luaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5tYXRoLnRhbmgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuZnJvbS1jb2RlLXBvaW50Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yYXcnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5yZXBlYXQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN0YXJ0cy13aXRoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5hbmNob3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJpZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuYmxpbmsnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmJvbGQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZpeGVkJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5mb250Y29sb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLmZvbnRzaXplJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5pdGFsaWNzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5saW5rJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zbWFsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5zdHJpbmcuc3RyaWtlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnN0cmluZy5zdWInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuc3RyaW5nLnN1cCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmlzLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZyb20nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkub2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zbGljZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5ldmVyeScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmluZGV4LW9mJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LmFycmF5LmZpbmQtaW5kZXgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYuYXJyYXkuc3BlY2llcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWdleHAuZmxhZ3MnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLm1hdGNoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZ2V4cC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi53ZWFrLXNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5hcnJheS1idWZmZXInKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi50eXBlZC51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnR5cGVkLmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYudHlwZWQuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmFwcGx5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuY29uc3RydWN0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZW51bWVyYXRlJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM2LnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmhhcycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczYucmVmbGVjdC5vd24ta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNi5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLmF0Jyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnBhZC1lbmQnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuc3RyaW5nLnRyaW0tbGVmdCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcudHJpbS1yaWdodCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5vYmplY3QudmFsdWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5lbnRyaWVzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hcC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnN5c3RlbS5nbG9iYWwnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcuZXJyb3IuaXMtZXJyb3InKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC5pYWRkaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5tYXRoLmlzdWJoJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm1hdGguaW11bGgnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcubWF0aC51bXVsaCcpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlZmluZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmRlbGV0ZS1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1tZXRhZGF0YS1rZXlzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3LnJlZmxlY3QuZ2V0LW93bi1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0LmdldC1vd24tbWV0YWRhdGEta2V5cycpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5yZWZsZWN0Lmhhcy1vd24tbWV0YWRhdGEnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy9lczcucmVmbGVjdC5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL2VzNy5hc2FwJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvZXM3Lm9ic2VydmFibGUnKTtcbnJlcXVpcmUoJy4vbW9kdWxlcy93ZWIudGltZXJzJyk7XG5yZXF1aXJlKCcuL21vZHVsZXMvd2ViLmltbWVkaWF0ZScpO1xucmVxdWlyZSgnLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tb2R1bGVzL19jb3JlJyk7IiwiIWZ1bmN0aW9uKCkge1xuICB2YXIgZDMgPSB7XG4gICAgdmVyc2lvbjogXCIzLjUuMTdcIlxuICB9O1xuICB2YXIgZDNfYXJyYXlTbGljZSA9IFtdLnNsaWNlLCBkM19hcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICByZXR1cm4gZDNfYXJyYXlTbGljZS5jYWxsKGxpc3QpO1xuICB9O1xuICB2YXIgZDNfZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuICBmdW5jdGlvbiBkM19kb2N1bWVudEVsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlICYmIChub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZS5kb2N1bWVudCB8fCBub2RlKS5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfd2luZG93KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBub2RlLmRvY3VtZW50ICYmIG5vZGUgfHwgbm9kZS5kZWZhdWx0Vmlldyk7XG4gIH1cbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGQzX2FycmF5KGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jaGlsZE5vZGVzKVswXS5ub2RlVHlwZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkM19hcnJheSA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCwgYXJyYXkgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgIHdoaWxlIChpLS0pIGFycmF5W2ldID0gbGlzdFtpXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKCFEYXRlLm5vdykgRGF0ZS5ub3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlKCk7XG4gIH07XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBkM19kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiRElWXCIpLnN0eWxlLnNldFByb3BlcnR5KFwib3BhY2l0eVwiLCAwLCBcIlwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmFyIGQzX2VsZW1lbnRfcHJvdG90eXBlID0gdGhpcy5FbGVtZW50LnByb3RvdHlwZSwgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGUgPSBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGUsIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlTlMgPSBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUywgZDNfc3R5bGVfcHJvdG90eXBlID0gdGhpcy5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZSwgZDNfc3R5bGVfc2V0UHJvcGVydHkgPSBkM19zdHlsZV9wcm90b3R5cGUuc2V0UHJvcGVydHk7XG4gICAgICBkM19lbGVtZW50X3Byb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBkM19lbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlICsgXCJcIik7XG4gICAgICB9O1xuICAgICAgZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMgPSBmdW5jdGlvbihzcGFjZSwgbG9jYWwsIHZhbHVlKSB7XG4gICAgICAgIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBzcGFjZSwgbG9jYWwsIHZhbHVlICsgXCJcIik7XG4gICAgICB9O1xuICAgICAgZDNfc3R5bGVfcHJvdG90eXBlLnNldFByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHByaW9yaXR5KSB7XG4gICAgICAgIGQzX3N0eWxlX3NldFByb3BlcnR5LmNhbGwodGhpcywgbmFtZSwgdmFsdWUgKyBcIlwiLCBwcmlvcml0eSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBkMy5hc2NlbmRpbmcgPSBkM19hc2NlbmRpbmc7XG4gIGZ1bmN0aW9uIGQzX2FzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xuICB9XG4gIGQzLmRlc2NlbmRpbmcgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xuICB9O1xuICBkMy5taW4gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGI7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYSA+IGIpIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgZDMubWF4ID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID4gYSkgYSA9IGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGIgPiBhKSBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIGQzLmV4dGVudCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYiwgYztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYyA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhID4gYikgYSA9IGI7XG4gICAgICAgIGlmIChjIDwgYikgYyA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGMgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIGEgPSBiO1xuICAgICAgICBpZiAoYyA8IGIpIGMgPSBiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWyBhLCBjIF07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX251bWJlcih4KSB7XG4gICAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbiAgfVxuICBmdW5jdGlvbiBkM19udW1lcmljKHgpIHtcbiAgICByZXR1cm4gIWlzTmFOKHgpO1xuICB9XG4gIGQzLnN1bSA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIHMgPSAwLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gK2FycmF5W2ldKSkgcyArPSBhO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9ICtmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpIHMgKz0gYTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH07XG4gIGQzLm1lYW4gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBzID0gMCwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xLCBqID0gbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkgcyArPSBhOyBlbHNlIC0tajtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkgcyArPSBhOyBlbHNlIC0tajtcbiAgICB9XG4gICAgaWYgKGopIHJldHVybiBzIC8gajtcbiAgfTtcbiAgZDMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIHApIHtcbiAgICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSwgaCA9IE1hdGguZmxvb3IoSCksIHYgPSArdmFsdWVzW2ggLSAxXSwgZSA9IEggLSBoO1xuICAgIHJldHVybiBlID8gdiArIGUgKiAodmFsdWVzW2hdIC0gdikgOiB2O1xuICB9O1xuICBkMy5tZWRpYW4gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBudW1iZXJzID0gW10sIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoYXJyYXlbaV0pKSkgbnVtYmVycy5wdXNoKGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSBudW1iZXJzLnB1c2goYSk7XG4gICAgfVxuICAgIGlmIChudW1iZXJzLmxlbmd0aCkgcmV0dXJuIGQzLnF1YW50aWxlKG51bWJlcnMuc29ydChkM19hc2NlbmRpbmcpLCAuNSk7XG4gIH07XG4gIGQzLnZhcmlhbmNlID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCwgbSA9IDAsIGEsIGQsIHMgPSAwLCBpID0gLTEsIGogPSAwO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIHtcbiAgICAgICAgICBkID0gYSAtIG07XG4gICAgICAgICAgbSArPSBkIC8gKytqO1xuICAgICAgICAgIHMgKz0gZCAqIChhIC0gbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChqID4gMSkgcmV0dXJuIHMgLyAoaiAtIDEpO1xuICB9O1xuICBkMy5kZXZpYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGQzLnZhcmlhbmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHYgPyBNYXRoLnNxcnQodikgOiB2O1xuICB9O1xuICBmdW5jdGlvbiBkM19iaXNlY3Rvcihjb21wYXJlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGxvID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSBoaSA9IGEubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7IGVsc2UgaGkgPSBtaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgfSxcbiAgICAgIHJpZ2h0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBsbyA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpID4gMCkgaGkgPSBtaWQ7IGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHZhciBkM19iaXNlY3QgPSBkM19iaXNlY3RvcihkM19hc2NlbmRpbmcpO1xuICBkMy5iaXNlY3RMZWZ0ID0gZDNfYmlzZWN0LmxlZnQ7XG4gIGQzLmJpc2VjdCA9IGQzLmJpc2VjdFJpZ2h0ID0gZDNfYmlzZWN0LnJpZ2h0O1xuICBkMy5iaXNlY3RvciA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZDNfYmlzZWN0b3IoZi5sZW5ndGggPT09IDEgPyBmdW5jdGlvbihkLCB4KSB7XG4gICAgICByZXR1cm4gZDNfYXNjZW5kaW5nKGYoZCksIHgpO1xuICAgIH0gOiBmKTtcbiAgfTtcbiAgZDMuc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5LCBpMCwgaTEpIHtcbiAgICBpZiAoKG0gPSBhcmd1bWVudHMubGVuZ3RoKSA8IDMpIHtcbiAgICAgIGkxID0gYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKG0gPCAyKSBpMCA9IDA7XG4gICAgfVxuICAgIHZhciBtID0gaTEgLSBpMCwgdCwgaTtcbiAgICB3aGlsZSAobSkge1xuICAgICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgICAgdCA9IGFycmF5W20gKyBpMF0sIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdLCBhcnJheVtpICsgaTBdID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuICBkMy5wZXJtdXRlID0gZnVuY3Rpb24oYXJyYXksIGluZGV4ZXMpIHtcbiAgICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSBwZXJtdXRlc1tpXSA9IGFycmF5W2luZGV4ZXNbaV1dO1xuICAgIHJldHVybiBwZXJtdXRlcztcbiAgfTtcbiAgZDMucGFpcnMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBpID0gMCwgbiA9IGFycmF5Lmxlbmd0aCAtIDEsIHAwLCBwMSA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgICB3aGlsZSAoaSA8IG4pIHBhaXJzW2ldID0gWyBwMCA9IHAxLCBwMSA9IGFycmF5WysraV0gXTtcbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG4gIGQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICAgIGZvciAodmFyIGkgPSAtMSwgbSA9IGQzLm1pbihtYXRyaXgsIGQzX3RyYW5zcG9zZUxlbmd0aCksIHRyYW5zcG9zZSA9IG5ldyBBcnJheShtKTsgKytpIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBqID0gLTEsIG4sIHJvdyA9IHRyYW5zcG9zZVtpXSA9IG5ldyBBcnJheShuKTsgKytqIDwgbjsgKSB7XG4gICAgICAgIHJvd1tqXSA9IG1hdHJpeFtqXVtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zcG9zZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNwb3NlTGVuZ3RoKGQpIHtcbiAgICByZXR1cm4gZC5sZW5ndGg7XG4gIH1cbiAgZDMuemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnRyYW5zcG9zZShhcmd1bWVudHMpO1xuICB9O1xuICBkMy5rZXlzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcbiAgZDMudmFsdWVzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIHZhbHVlcy5wdXNoKG1hcFtrZXldKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuICBkMy5lbnRyaWVzID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogbWFwW2tleV1cbiAgICB9KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfTtcbiAgZDMubWVyZ2UgPSBmdW5jdGlvbihhcnJheXMpIHtcbiAgICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsIG0sIGkgPSAtMSwgaiA9IDAsIG1lcmdlZCwgYXJyYXk7XG4gICAgd2hpbGUgKCsraSA8IG4pIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG4gICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICBhcnJheSA9IGFycmF5c1tuXTtcbiAgICAgIG0gPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgICAgbWVyZ2VkWy0tal0gPSBhcnJheVttXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfTtcbiAgdmFyIGFicyA9IE1hdGguYWJzO1xuICBkMy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBzdGVwID0gMTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcihcImluZmluaXRlIHJhbmdlXCIpO1xuICAgIHZhciByYW5nZSA9IFtdLCBrID0gZDNfcmFuZ2VfaW50ZWdlclNjYWxlKGFicyhzdGVwKSksIGkgPSAtMSwgajtcbiAgICBzdGFydCAqPSBrLCBzdG9wICo9IGssIHN0ZXAgKj0gaztcbiAgICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGogLyBrKTsgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqIC8gayk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuICBmdW5jdGlvbiBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoeCkge1xuICAgIHZhciBrID0gMTtcbiAgICB3aGlsZSAoeCAqIGsgJSAxKSBrICo9IDEwO1xuICAgIHJldHVybiBrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2NsYXNzKGN0b3IsIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBrZXksIHtcbiAgICAgICAgdmFsdWU6IHByb3BlcnRpZXNba2V5XSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkMy5tYXAgPSBmdW5jdGlvbihvYmplY3QsIGYpIHtcbiAgICB2YXIgbWFwID0gbmV3IGQzX01hcCgpO1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBkM19NYXApIHtcbiAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gb2JqZWN0Lmxlbmd0aCwgbztcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB3aGlsZSAoKytpIDwgbikgbWFwLnNldChpLCBvYmplY3RbaV0pOyBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYuY2FsbChvYmplY3QsIG8gPSBvYmplY3RbaV0sIGkpLCBvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfTWFwKCkge1xuICAgIHRoaXMuXyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdmFyIGQzX21hcF9wcm90byA9IFwiX19wcm90b19fXCIsIGQzX21hcF96ZXJvID0gXCJcXHgwMFwiO1xuICBkM19jbGFzcyhkM19NYXAsIHtcbiAgICBoYXM6IGQzX21hcF9oYXMsXG4gICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9bZDNfbWFwX2VzY2FwZShrZXkpXTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldID0gdmFsdWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGQzX21hcF9yZW1vdmUsXG4gICAga2V5czogZDNfbWFwX2tleXMsXG4gICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHZhbHVlcy5wdXNoKHRoaXMuX1trZXldKTtcbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSxcbiAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBlbnRyaWVzLnB1c2goe1xuICAgICAgICBrZXk6IGQzX21hcF91bmVzY2FwZShrZXkpLFxuICAgICAgICB2YWx1ZTogdGhpcy5fW2tleV1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSxcbiAgICBzaXplOiBkM19tYXBfc2l6ZSxcbiAgICBlbXB0eTogZDNfbWFwX2VtcHR5LFxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGYuY2FsbCh0aGlzLCBkM19tYXBfdW5lc2NhcGUoa2V5KSwgdGhpcy5fW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX21hcF9lc2NhcGUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgKz0gXCJcIikgPT09IGQzX21hcF9wcm90byB8fCBrZXlbMF0gPT09IGQzX21hcF96ZXJvID8gZDNfbWFwX3plcm8gKyBrZXkgOiBrZXk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3VuZXNjYXBlKGtleSkge1xuICAgIHJldHVybiAoa2V5ICs9IFwiXCIpWzBdID09PSBkM19tYXBfemVybyA/IGtleS5zbGljZSgxKSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfaGFzKGtleSkge1xuICAgIHJldHVybiBkM19tYXBfZXNjYXBlKGtleSkgaW4gdGhpcy5fO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9yZW1vdmUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgPSBkM19tYXBfZXNjYXBlKGtleSkpIGluIHRoaXMuXyAmJiBkZWxldGUgdGhpcy5fW2tleV07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2tleXMoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBrZXlzLnB1c2goZDNfbWFwX3VuZXNjYXBlKGtleSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9zaXplKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSArK3NpemU7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX2VtcHR5KCkge1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkMy5uZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5lc3QgPSB7fSwga2V5cyA9IFtdLCBzb3J0S2V5cyA9IFtdLCBzb3J0VmFsdWVzLCByb2xsdXA7XG4gICAgZnVuY3Rpb24gbWFwKG1hcFR5cGUsIGFycmF5LCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gcm9sbHVwID8gcm9sbHVwLmNhbGwobmVzdCwgYXJyYXkpIDogc29ydFZhbHVlcyA/IGFycmF5LnNvcnQoc29ydFZhbHVlcykgOiBhcnJheTtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGtleSA9IGtleXNbZGVwdGgrK10sIGtleVZhbHVlLCBvYmplY3QsIHNldHRlciwgdmFsdWVzQnlLZXkgPSBuZXcgZDNfTWFwKCksIHZhbHVlcztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkob2JqZWN0ID0gYXJyYXlbaV0pKSkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKG9iamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzQnlLZXkuc2V0KGtleVZhbHVlLCBbIG9iamVjdCBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hcFR5cGUpIHtcbiAgICAgICAgb2JqZWN0ID0gbWFwVHlwZSgpO1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihrZXlWYWx1ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgb2JqZWN0LnNldChrZXlWYWx1ZSwgbWFwKG1hcFR5cGUsIHZhbHVlcywgZGVwdGgpKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdCA9IHt9O1xuICAgICAgICBzZXR0ZXIgPSBmdW5jdGlvbihrZXlWYWx1ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgb2JqZWN0W2tleVZhbHVlXSA9IG1hcChtYXBUeXBlLCB2YWx1ZXMsIGRlcHRoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhbHVlc0J5S2V5LmZvckVhY2goc2V0dGVyKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xuICAgICAgaWYgKGRlcHRoID49IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwO1xuICAgICAgdmFyIGFycmF5ID0gW10sIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCsrXTtcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKGtleSwga2V5TWFwKSB7XG4gICAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlczogZW50cmllcyhrZXlNYXAsIGRlcHRoKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvcnRLZXkgPyBhcnJheS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRLZXkoYS5rZXksIGIua2V5KTtcbiAgICAgIH0pIDogYXJyYXk7XG4gICAgfVxuICAgIG5lc3QubWFwID0gZnVuY3Rpb24oYXJyYXksIG1hcFR5cGUpIHtcbiAgICAgIHJldHVybiBtYXAobWFwVHlwZSwgYXJyYXksIDApO1xuICAgIH07XG4gICAgbmVzdC5lbnRyaWVzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIHJldHVybiBlbnRyaWVzKG1hcChkMy5tYXAsIGFycmF5LCAwKSwgMCk7XG4gICAgfTtcbiAgICBuZXN0LmtleSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGtleXMucHVzaChkKTtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5zb3J0S2V5cyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Quc29ydFZhbHVlcyA9IGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICBzb3J0VmFsdWVzID0gb3JkZXI7XG4gICAgICByZXR1cm4gbmVzdDtcbiAgICB9O1xuICAgIG5lc3Qucm9sbHVwID0gZnVuY3Rpb24oZikge1xuICAgICAgcm9sbHVwID0gZjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgcmV0dXJuIG5lc3Q7XG4gIH07XG4gIGQzLnNldCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHNldCA9IG5ldyBkM19TZXQoKTtcbiAgICBpZiAoYXJyYXkpIGZvciAodmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoOyBpIDwgbjsgKytpKSBzZXQuYWRkKGFycmF5W2ldKTtcbiAgICByZXR1cm4gc2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19TZXQoKSB7XG4gICAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBkM19jbGFzcyhkM19TZXQsIHtcbiAgICBoYXM6IGQzX21hcF9oYXMsXG4gICAgYWRkOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSArPSBcIlwiKV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9LFxuICAgIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAgICB2YWx1ZXM6IGQzX21hcF9rZXlzLFxuICAgIHNpemU6IGQzX21hcF9zaXplLFxuICAgIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpKTtcbiAgICB9XG4gIH0pO1xuICBkMy5iZWhhdmlvciA9IHt9O1xuICBmdW5jdGlvbiBkM19pZGVudGl0eShkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgZDMucmViaW5kID0gZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB2YXIgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBtZXRob2Q7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRhcmdldFttZXRob2QgPSBhcmd1bWVudHNbaV1dID0gZDNfcmViaW5kKHRhcmdldCwgc291cmNlLCBzb3VyY2VbbWV0aG9kXSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfcmViaW5kKHRhcmdldCwgc291cmNlLCBtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSBtZXRob2QuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBzb3VyY2UgPyB0YXJnZXQgOiB2YWx1ZTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3ZlbmRvclN5bWJvbChvYmplY3QsIG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiBvYmplY3QpIHJldHVybiBuYW1lO1xuICAgIG5hbWUgPSBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGQzX3ZlbmRvclByZWZpeGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHByZWZpeE5hbWUgPSBkM192ZW5kb3JQcmVmaXhlc1tpXSArIG5hbWU7XG4gICAgICBpZiAocHJlZml4TmFtZSBpbiBvYmplY3QpIHJldHVybiBwcmVmaXhOYW1lO1xuICAgIH1cbiAgfVxuICB2YXIgZDNfdmVuZG9yUHJlZml4ZXMgPSBbIFwid2Via2l0XCIsIFwibXNcIiwgXCJtb3pcIiwgXCJNb3pcIiwgXCJvXCIsIFwiT1wiIF07XG4gIGZ1bmN0aW9uIGQzX25vb3AoKSB7fVxuICBkMy5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXNwYXRjaCA9IG5ldyBkM19kaXNwYXRjaCgpLCBpID0gLTEsIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkaXNwYXRjaFthcmd1bWVudHNbaV1dID0gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpO1xuICAgIHJldHVybiBkaXNwYXRjaDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZGlzcGF0Y2goKSB7fVxuICBkM19kaXNwYXRjaC5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBpID0gdHlwZS5pbmRleE9mKFwiLlwiKSwgbmFtZSA9IFwiXCI7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgbmFtZSA9IHR5cGUuc2xpY2UoaSArIDEpO1xuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSk7XG4gICAgfVxuICAgIGlmICh0eXBlKSByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB0aGlzW3R5cGVdLm9uKG5hbWUpIDogdGhpc1t0eXBlXS5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSBmb3IgKHR5cGUgaW4gdGhpcykge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhpc1t0eXBlXS5vbihuYW1lLCBudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gW10sIGxpc3RlbmVyQnlOYW1lID0gbmV3IGQzX01hcCgpO1xuICAgIGZ1bmN0aW9uIGV2ZW50KCkge1xuICAgICAgdmFyIHogPSBsaXN0ZW5lcnMsIGkgPSAtMSwgbiA9IHoubGVuZ3RoLCBsO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChsID0geltpXS5vbikgbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGRpc3BhdGNoO1xuICAgIH1cbiAgICBldmVudC5vbiA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbCA9IGxpc3RlbmVyQnlOYW1lLmdldChuYW1lKSwgaTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGwgJiYgbC5vbjtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGwub24gPSBudWxsO1xuICAgICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCwgaSA9IGxpc3RlbmVycy5pbmRleE9mKGwpKS5jb25jYXQobGlzdGVuZXJzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIGxpc3RlbmVyQnlOYW1lLnJlbW92ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaXN0ZW5lcikgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXJCeU5hbWUuc2V0KG5hbWUsIHtcbiAgICAgICAgb246IGxpc3RlbmVyXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2g7XG4gICAgfTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgZDMuZXZlbnQgPSBudWxsO1xuICBmdW5jdGlvbiBkM19ldmVudFByZXZlbnREZWZhdWx0KCkge1xuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZXZlbnRTb3VyY2UoKSB7XG4gICAgdmFyIGUgPSBkMy5ldmVudCwgcztcbiAgICB3aGlsZSAocyA9IGUuc291cmNlRXZlbnQpIGUgPSBzO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2V2ZW50RGlzcGF0Y2godGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoKCksIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgZGlzcGF0Y2hbYXJndW1lbnRzW2ldXSA9IGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKTtcbiAgICBkaXNwYXRjaC5vZiA9IGZ1bmN0aW9uKHRoaXosIGFyZ3VtZW50eikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUxKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGUwID0gZTEuc291cmNlRXZlbnQgPSBkMy5ldmVudDtcbiAgICAgICAgICBlMS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgZDMuZXZlbnQgPSBlMTtcbiAgICAgICAgICBkaXNwYXRjaFtlMS50eXBlXS5hcHBseSh0aGl6LCBhcmd1bWVudHopO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGQzLmV2ZW50ID0gZTA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gZGlzcGF0Y2g7XG4gIH1cbiAgZDMucmVxdW90ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKGQzX3JlcXVvdGVfcmUsIFwiXFxcXCQmXCIpO1xuICB9O1xuICB2YXIgZDNfcmVxdW90ZV9yZSA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcbiAgdmFyIGQzX3N1YmNsYXNzID0ge30uX19wcm90b19fID8gZnVuY3Rpb24ob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICB9IDogZnVuY3Rpb24ob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBwcm90b3R5cGUpIG9iamVjdFtwcm9wZXJ0eV0gPSBwcm90b3R5cGVbcHJvcGVydHldO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb24oZ3JvdXBzKSB7XG4gICAgZDNfc3ViY2xhc3MoZ3JvdXBzLCBkM19zZWxlY3Rpb25Qcm90b3R5cGUpO1xuICAgIHJldHVybiBncm91cHM7XG4gIH1cbiAgdmFyIGQzX3NlbGVjdCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICByZXR1cm4gbi5xdWVyeVNlbGVjdG9yKHMpO1xuICB9LCBkM19zZWxlY3RBbGwgPSBmdW5jdGlvbihzLCBuKSB7XG4gICAgcmV0dXJuIG4ucXVlcnlTZWxlY3RvckFsbChzKTtcbiAgfSwgZDNfc2VsZWN0TWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICB2YXIgZDNfc2VsZWN0TWF0Y2hlciA9IG4ubWF0Y2hlcyB8fCBuW2QzX3ZlbmRvclN5bWJvbChuLCBcIm1hdGNoZXNTZWxlY3RvclwiKV07XG4gICAgZDNfc2VsZWN0TWF0Y2hlcyA9IGZ1bmN0aW9uKG4sIHMpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVyLmNhbGwobiwgcyk7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlcyhuLCBzKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBTaXp6bGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGQzX3NlbGVjdCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICAgIHJldHVybiBTaXp6bGUocywgbilbMF0gfHwgbnVsbDtcbiAgICB9O1xuICAgIGQzX3NlbGVjdEFsbCA9IFNpenpsZTtcbiAgICBkM19zZWxlY3RNYXRjaGVzID0gU2l6emxlLm1hdGNoZXNTZWxlY3RvcjtcbiAgfVxuICBkMy5zZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2VsZWN0KGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gIH07XG4gIHZhciBkM19zZWxlY3Rpb25Qcm90b3R5cGUgPSBkMy5zZWxlY3Rpb24ucHJvdG90eXBlID0gW107XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIGdyb3VwLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSAoZ3JvdXAgPSB0aGlzW2pdKS5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICAgIGlmIChzdWJub2RlICYmIFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiID8gc2VsZWN0b3IgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3Qoc2VsZWN0b3IsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgbm9kZTtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBkM19hcnJheShzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSk7XG4gICAgICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdEFsbChzZWxlY3RvciwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfbnNYaHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuICB2YXIgZDNfbnNQcmVmaXggPSB7XG4gICAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgeGh0bWw6IGQzX25zWGh0bWwsXG4gICAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH07XG4gIGQzLm5zID0ge1xuICAgIHByZWZpeDogZDNfbnNQcmVmaXgsXG4gICAgcXVhbGlmeTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCI6XCIpLCBwcmVmaXggPSBuYW1lO1xuICAgICAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICAgICAgcmV0dXJuIGQzX25zUHJlZml4Lmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7XG4gICAgICAgIHNwYWNlOiBkM19uc1ByZWZpeFtwcmVmaXhdLFxuICAgICAgICBsb2NhbDogbmFtZVxuICAgICAgfSA6IG5hbWU7XG4gICAgfVxuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgICAgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lLmxvY2FsID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSA6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2F0dHIodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpO1xuICAgIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpOyBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyRnVuY3Rpb25OUygpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7IGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBuYW1lLmxvY2FsID8gYXR0ck51bGxOUyA6IGF0dHJOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24gOiBuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY29sbGFwc2Uocykge1xuICAgIHJldHVybiBzLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2xhc3NlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKSwgbiA9IChuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkpLmxlbmd0aCwgaSA9IC0xO1xuICAgICAgICBpZiAodmFsdWUgPSBub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIXZhbHVlLmNvbnRhaW5zKG5hbWVbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZVtpXSkudGVzdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9jbGFzc2VkKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKylcIiArIGQzLnJlcXVvdGUobmFtZSkgKyBcIig/OlxcXFxzK3wkKVwiLCBcImdcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkge1xuICAgIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkubWFwKGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZSk7XG4gICAgdmFyIG4gPSBuYW1lLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBjbGFzc2VkQ29uc3RhbnQoKSB7XG4gICAgICB2YXIgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG5hbWVbaV0odGhpcywgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IC0xLCB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBuYW1lW2ldKHRoaXMsIHgpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjbGFzc2VkRnVuY3Rpb24gOiBjbGFzc2VkQ29uc3RhbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWROYW1lKG5hbWUpIHtcbiAgICB2YXIgcmUgPSBkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWUpO1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKGMgPSBub2RlLmNsYXNzTGlzdCkgcmV0dXJuIHZhbHVlID8gYy5hZGQobmFtZSkgOiBjLnJlbW92ZShuYW1lKTtcbiAgICAgIHZhciBjID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmICghcmUudGVzdChjKSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjICsgXCIgXCIgKyBuYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGQzX2NvbGxhcHNlKGMucmVwbGFjZShyZSwgXCIgXCIpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAocHJpb3JpdHkgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShwcmlvcml0eSwgbmFtZVtwcmlvcml0eV0sIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCAyKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIHJldHVybiBkM193aW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgfVxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIGZ1bmN0aW9uIHN0eWxlTnVsbCgpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpOyBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgeCwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVGdW5jdGlvbiA6IHN0eWxlQ29uc3RhbnQ7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMubm9kZSgpW25hbWVdO1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5TnVsbCgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KCkge1xuICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07IGVsc2UgdGhpc1tuYW1lXSA9IHg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gcHJvcGVydHlOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wZXJ0eUZ1bmN0aW9uIDogcHJvcGVydHlDb25zdGFudDtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH0pIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfSkgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgICAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gZDNfbnNYaHRtbCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBkM19uc1hodG1sID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVOUygpIHtcbiAgICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiAobmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSkpLmxvY2FsID8gY3JlYXRlTlMgOiBjcmVhdGU7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICAgIG5hbWUgPSBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKTtcbiAgICBiZWZvcmUgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3IoYmVmb3JlKTtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBiZWZvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgICB9KTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uUmVtb3ZlKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uUmVtb3ZlKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHZhciBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCwgZ3JvdXAsIG5vZGU7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBBcnJheShuID0gKGdyb3VwID0gdGhpc1swXSkubGVuZ3RoKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB2YWx1ZVtpXSA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluZChncm91cCwgZ3JvdXBEYXRhKSB7XG4gICAgICB2YXIgaSwgbiA9IGdyb3VwLmxlbmd0aCwgbSA9IGdyb3VwRGF0YS5sZW5ndGgsIG4wID0gTWF0aC5taW4obiwgbSksIHVwZGF0ZU5vZGVzID0gbmV3IEFycmF5KG0pLCBlbnRlck5vZGVzID0gbmV3IEFycmF5KG0pLCBleGl0Tm9kZXMgPSBuZXcgQXJyYXkobiksIG5vZGUsIG5vZGVEYXRhO1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgZDNfTWFwKCksIGtleVZhbHVlcyA9IG5ldyBBcnJheShuKSwga2V5VmFsdWU7XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuOyApIHtcbiAgICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgICBpZiAobm9kZUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSkpKSB7XG4gICAgICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5VmFsdWVzW2ldID0ga2V5VmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBtOyApIHtcbiAgICAgICAgICBpZiAoIShub2RlID0gbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlID0ga2V5LmNhbGwoZ3JvdXBEYXRhLCBub2RlRGF0YSA9IGdyb3VwRGF0YVtpXSwgaSkpKSkge1xuICAgICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShub2RlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB1cGRhdGVOb2Rlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlLl9fZGF0YV9fID0gbm9kZURhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47ICkge1xuICAgICAgICAgIGlmIChpIGluIGtleVZhbHVlcyAmJiBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWVzW2ldKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZXhpdE5vZGVzW2ldID0gZ3JvdXBbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjA7ICkge1xuICAgICAgICAgIG5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgICBub2RlRGF0YSA9IGdyb3VwRGF0YVtpXTtcbiAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5fX2RhdGFfXyA9IG5vZGVEYXRhO1xuICAgICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKG5vZGVEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7aSA8IG07ICsraSkge1xuICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUoZ3JvdXBEYXRhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDtpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZXhpdE5vZGVzW2ldID0gZ3JvdXBbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVudGVyTm9kZXMudXBkYXRlID0gdXBkYXRlTm9kZXM7XG4gICAgICBlbnRlck5vZGVzLnBhcmVudE5vZGUgPSB1cGRhdGVOb2Rlcy5wYXJlbnROb2RlID0gZXhpdE5vZGVzLnBhcmVudE5vZGUgPSBncm91cC5wYXJlbnROb2RlO1xuICAgICAgZW50ZXIucHVzaChlbnRlck5vZGVzKTtcbiAgICAgIHVwZGF0ZS5wdXNoKHVwZGF0ZU5vZGVzKTtcbiAgICAgIGV4aXQucHVzaChleGl0Tm9kZXMpO1xuICAgIH1cbiAgICB2YXIgZW50ZXIgPSBkM19zZWxlY3Rpb25fZW50ZXIoW10pLCB1cGRhdGUgPSBkM19zZWxlY3Rpb24oW10pLCBleGl0ID0gZDNfc2VsZWN0aW9uKFtdKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGJpbmQoZ3JvdXAgPSB0aGlzW2ldLCB2YWx1ZS5jYWxsKGdyb3VwLCBncm91cC5wYXJlbnROb2RlLl9fZGF0YV9fLCBpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGJpbmQoZ3JvdXAgPSB0aGlzW2ldLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZS5lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGVudGVyO1xuICAgIH07XG4gICAgdXBkYXRlLmV4aXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGl0O1xuICAgIH07XG4gICAgcmV0dXJuIHVwZGF0ZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19kYXRhX186IGRhdGFcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5kYXR1bSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpIDogdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZDNfc2VsZWN0aW9uX2ZpbHRlcihmaWx0ZXIpO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IChncm91cCA9IHRoaXNbal0pLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgZmlsdGVyLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ZpbHRlcihzZWxlY3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVzKHRoaXMsIHNlbGVjdG9yKTtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5vcmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gbm9kZS5uZXh0U2libGluZykgbmV4dC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBuZXh0KTtcbiAgICAgICAgICBuZXh0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihjb21wYXJhdG9yKSB7XG4gICAgY29tcGFyYXRvciA9IGQzX3NlbGVjdGlvbl9zb3J0Q29tcGFyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHRoaXNbal0uc29ydChjb21wYXJhdG9yKTtcbiAgICByZXR1cm4gdGhpcy5vcmRlcigpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc29ydENvbXBhcmF0b3IoY29tcGFyYXRvcikge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgY29tcGFyYXRvciA9IGQzX2FzY2VuZGluZztcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmF0b3IoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICAgIH07XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgIH0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZWFjaChncm91cHMsIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2sobm9kZSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBncm91cHM7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gZDNfYXJyYXkoYXJndW1lbnRzKTtcbiAgICBjYWxsYmFjay5hcHBseShhcmdzWzBdID0gdGhpcywgYXJncyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5ub2RlKCk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICBpZiAobm9kZSkgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gMDtcbiAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICsrbjtcbiAgICB9KTtcbiAgICByZXR1cm4gbjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VudGVyKHNlbGVjdGlvbikge1xuICAgIGQzX3N1YmNsYXNzKHNlbGVjdGlvbiwgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlKTtcbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIHZhciBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUgPSBbXTtcbiAgZDMuc2VsZWN0aW9uLmVudGVyID0gZDNfc2VsZWN0aW9uX2VudGVyO1xuICBkMy5zZWxlY3Rpb24uZW50ZXIucHJvdG90eXBlID0gZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuYXBwZW5kID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmFwcGVuZDtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmVtcHR5ID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5O1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUubm9kZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5ub2RlO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuY2FsbCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuc2l6ZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplO1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCB1cGdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICB1cGdyb3VwID0gKGdyb3VwID0gdGhpc1tqXSkudXBkYXRlO1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gZ3JvdXAucGFyZW50Tm9kZTtcbiAgICAgIGZvciAodmFyIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHVwZ3JvdXBbaV0gPSBzdWJub2RlID0gc2VsZWN0b3IuY2FsbChncm91cC5wYXJlbnROb2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgICAgICAgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIGJlZm9yZSA9IGQzX3NlbGVjdGlvbl9lbnRlckluc2VydEJlZm9yZSh0aGlzKTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmluc2VydC5jYWxsKHRoaXMsIG5hbWUsIGJlZm9yZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lbnRlckluc2VydEJlZm9yZShlbnRlcikge1xuICAgIHZhciBpMCwgajA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGopIHtcbiAgICAgIHZhciBncm91cCA9IGVudGVyW2pdLnVwZGF0ZSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTtcbiAgICAgIGlmIChqICE9IGowKSBqMCA9IGosIGkwID0gMDtcbiAgICAgIGlmIChpID49IGkwKSBpMCA9IGkgKyAxO1xuICAgICAgd2hpbGUgKCEobm9kZSA9IGdyb3VwW2kwXSkgJiYgKytpMCA8IG4pIDtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gIH1cbiAgZDMuc2VsZWN0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBncm91cDtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGdyb3VwID0gWyBkM19zZWxlY3Qobm9kZSwgZDNfZG9jdW1lbnQpIF07XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9IFsgbm9kZSBdO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50RWxlbWVudChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihbIGdyb3VwIF0pO1xuICB9O1xuICBkMy5zZWxlY3RBbGwgPSBmdW5jdGlvbihub2Rlcykge1xuICAgIHZhciBncm91cDtcbiAgICBpZiAodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cCA9IGQzX2FycmF5KGQzX3NlbGVjdEFsbChub2RlcywgZDNfZG9jdW1lbnQpKTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gZDNfYXJyYXkobm9kZXMpO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oWyBncm91cCBdKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSBsaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNhcHR1cmUgaW4gdHlwZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9vbihjYXB0dXJlLCB0eXBlW2NhcHR1cmVdLCBsaXN0ZW5lcikpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgMikgcmV0dXJuIChuID0gdGhpcy5ub2RlKClbXCJfX29uXCIgKyB0eXBlXSkgJiYgbi5fO1xuICAgICAgY2FwdHVyZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9vbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICB2YXIgbmFtZSA9IFwiX19vblwiICsgdHlwZSwgaSA9IHR5cGUuaW5kZXhPZihcIi5cIiksIHdyYXAgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcjtcbiAgICBpZiAoaSA+IDApIHR5cGUgPSB0eXBlLnNsaWNlKDAsIGkpO1xuICAgIHZhciBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLmdldCh0eXBlKTtcbiAgICBpZiAoZmlsdGVyKSB0eXBlID0gZmlsdGVyLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uRmlsdGVyO1xuICAgIGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuICAgICAgdmFyIGwgPSB0aGlzW25hbWVdO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGwsIGwuJCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkFkZCgpIHtcbiAgICAgIHZhciBsID0gd3JhcChsaXN0ZW5lciwgZDNfYXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICBvblJlbW92ZS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXNbbmFtZV0gPSBsLCBsLiQgPSBjYXB0dXJlKTtcbiAgICAgIGwuXyA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXl9fb24oW14uXSspXCIgKyBkMy5yZXF1b3RlKHR5cGUpICsgXCIkXCIpLCBtYXRjaDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICBpZiAobWF0Y2ggPSBuYW1lLm1hdGNoKHJlKSkge1xuICAgICAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIobWF0Y2hbMV0sIGwsIGwuJCk7XG4gICAgICAgICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkgPyBsaXN0ZW5lciA/IG9uQWRkIDogb25SZW1vdmUgOiBsaXN0ZW5lciA/IGQzX25vb3AgOiByZW1vdmVBbGw7XG4gIH1cbiAgdmFyIGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMgPSBkMy5tYXAoe1xuICAgIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gIH0pO1xuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKFwib25cIiArIGsgaW4gZDNfZG9jdW1lbnQpIGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMucmVtb3ZlKGspO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbkxpc3RlbmVyKGxpc3RlbmVyLCBhcmd1bWVudHopIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIG8gPSBkMy5ldmVudDtcbiAgICAgIGQzLmV2ZW50ID0gZTtcbiAgICAgIGFyZ3VtZW50elswXSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0cnkge1xuICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHopO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDMuZXZlbnQgPSBvO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uRmlsdGVyKGxpc3RlbmVyLCBhcmd1bWVudHopIHtcbiAgICB2YXIgbCA9IGQzX3NlbGVjdGlvbl9vbkxpc3RlbmVyKGxpc3RlbmVyLCBhcmd1bWVudHopO1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICAgIGlmICghcmVsYXRlZCB8fCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIShyZWxhdGVkLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRhcmdldCkgJiA4KSkge1xuICAgICAgICBsLmNhbGwodGFyZ2V0LCBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHZhciBkM19ldmVudF9kcmFnU2VsZWN0LCBkM19ldmVudF9kcmFnSWQgPSAwO1xuICBmdW5jdGlvbiBkM19ldmVudF9kcmFnU3VwcHJlc3Mobm9kZSkge1xuICAgIHZhciBuYW1lID0gXCIuZHJhZ3N1cHByZXNzLVwiICsgKytkM19ldmVudF9kcmFnSWQsIGNsaWNrID0gXCJjbGlja1wiICsgbmFtZSwgdyA9IGQzLnNlbGVjdChkM193aW5kb3cobm9kZSkpLm9uKFwidG91Y2htb3ZlXCIgKyBuYW1lLCBkM19ldmVudFByZXZlbnREZWZhdWx0KS5vbihcImRyYWdzdGFydFwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCkub24oXCJzZWxlY3RzdGFydFwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCk7XG4gICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QgPT0gbnVsbCkge1xuICAgICAgZDNfZXZlbnRfZHJhZ1NlbGVjdCA9IFwib25zZWxlY3RzdGFydFwiIGluIG5vZGUgPyBmYWxzZSA6IGQzX3ZlbmRvclN5bWJvbChub2RlLnN0eWxlLCBcInVzZXJTZWxlY3RcIik7XG4gICAgfVxuICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0KSB7XG4gICAgICB2YXIgc3R5bGUgPSBkM19kb2N1bWVudEVsZW1lbnQobm9kZSkuc3R5bGUsIHNlbGVjdCA9IHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdO1xuICAgICAgc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF0gPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN1cHByZXNzQ2xpY2spIHtcbiAgICAgIHcub24obmFtZSwgbnVsbCk7XG4gICAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCkgc3R5bGVbZDNfZXZlbnRfZHJhZ1NlbGVjdF0gPSBzZWxlY3Q7XG4gICAgICBpZiAoc3VwcHJlc3NDbGljaykge1xuICAgICAgICB2YXIgb2ZmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdy5vbihjbGljaywgbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHcub24oY2xpY2ssIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBvZmYoKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHNldFRpbWVvdXQob2ZmLCAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzLm1vdXNlID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGQzX21vdXNlUG9pbnQoY29udGFpbmVyLCBkM19ldmVudFNvdXJjZSgpKTtcbiAgfTtcbiAgdmFyIGQzX21vdXNlX2J1ZzQ0MDgzID0gdGhpcy5uYXZpZ2F0b3IgJiYgL1dlYktpdC8udGVzdCh0aGlzLm5hdmlnYXRvci51c2VyQWdlbnQpID8gLTEgOiAwO1xuICBmdW5jdGlvbiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgZSkge1xuICAgIGlmIChlLmNoYW5nZWRUb3VjaGVzKSBlID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB2YXIgc3ZnID0gY29udGFpbmVyLm93bmVyU1ZHRWxlbWVudCB8fCBjb250YWluZXI7XG4gICAgaWYgKHN2Zy5jcmVhdGVTVkdQb2ludCkge1xuICAgICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICBpZiAoZDNfbW91c2VfYnVnNDQwODMgPCAwKSB7XG4gICAgICAgIHZhciB3aW5kb3cgPSBkM193aW5kb3coY29udGFpbmVyKTtcbiAgICAgICAgaWYgKHdpbmRvdy5zY3JvbGxYIHx8IHdpbmRvdy5zY3JvbGxZKSB7XG4gICAgICAgICAgc3ZnID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzdmdcIikuc3R5bGUoe1xuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgYm9yZGVyOiBcIm5vbmVcIlxuICAgICAgICAgIH0sIFwiaW1wb3J0YW50XCIpO1xuICAgICAgICAgIHZhciBjdG0gPSBzdmdbMF1bMF0uZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgZDNfbW91c2VfYnVnNDQwODMgPSAhKGN0bS5mIHx8IGN0bS5lKTtcbiAgICAgICAgICBzdmcucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkM19tb3VzZV9idWc0NDA4MykgcG9pbnQueCA9IGUucGFnZVgsIHBvaW50LnkgPSBlLnBhZ2VZOyBlbHNlIHBvaW50LnggPSBlLmNsaWVudFgsIFxuICAgICAgcG9pbnQueSA9IGUuY2xpZW50WTtcbiAgICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKGNvbnRhaW5lci5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkpO1xuICAgICAgcmV0dXJuIFsgcG9pbnQueCwgcG9pbnQueSBdO1xuICAgIH1cbiAgICB2YXIgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gWyBlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjb250YWluZXIuY2xpZW50TGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wIF07XG4gIH1cbiAgZDMudG91Y2ggPSBmdW5jdGlvbihjb250YWluZXIsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIGlkZW50aWZpZXIgPSB0b3VjaGVzLCB0b3VjaGVzID0gZDNfZXZlbnRTb3VyY2UoKS5jaGFuZ2VkVG91Y2hlcztcbiAgICBpZiAodG91Y2hlcykgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzLmxlbmd0aCwgdG91Y2g7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgdG91Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZDMuYmVoYXZpb3IuZHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goZHJhZywgXCJkcmFnXCIsIFwiZHJhZ3N0YXJ0XCIsIFwiZHJhZ2VuZFwiKSwgb3JpZ2luID0gbnVsbCwgbW91c2Vkb3duID0gZHJhZ3N0YXJ0KGQzX25vb3AsIGQzLm1vdXNlLCBkM193aW5kb3csIFwibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiKSwgdG91Y2hzdGFydCA9IGRyYWdzdGFydChkM19iZWhhdmlvcl9kcmFnVG91Y2hJZCwgZDMudG91Y2gsIGQzX2lkZW50aXR5LCBcInRvdWNobW92ZVwiLCBcInRvdWNoZW5kXCIpO1xuICAgIGZ1bmN0aW9uIGRyYWcoKSB7XG4gICAgICB0aGlzLm9uKFwibW91c2Vkb3duLmRyYWdcIiwgbW91c2Vkb3duKS5vbihcInRvdWNoc3RhcnQuZHJhZ1wiLCB0b3VjaHN0YXJ0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhZ3N0YXJ0KGlkLCBwb3NpdGlvbiwgc3ViamVjdCwgbW92ZSwgZW5kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcywgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0LmNvcnJlc3BvbmRpbmdFbGVtZW50IHx8IGQzLmV2ZW50LnRhcmdldCwgcGFyZW50ID0gdGhhdC5wYXJlbnROb2RlLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGRyYWdnZWQgPSAwLCBkcmFnSWQgPSBpZCgpLCBkcmFnTmFtZSA9IFwiLmRyYWdcIiArIChkcmFnSWQgPT0gbnVsbCA/IFwiXCIgOiBcIi1cIiArIGRyYWdJZCksIGRyYWdPZmZzZXQsIGRyYWdTdWJqZWN0ID0gZDMuc2VsZWN0KHN1YmplY3QodGFyZ2V0KSkub24obW92ZSArIGRyYWdOYW1lLCBtb3ZlZCkub24oZW5kICsgZHJhZ05hbWUsIGVuZGVkKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGFyZ2V0KSwgcG9zaXRpb24wID0gcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IG9yaWdpbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBbIGRyYWdPZmZzZXQueCAtIHBvc2l0aW9uMFswXSwgZHJhZ09mZnNldC55IC0gcG9zaXRpb24wWzFdIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IFsgMCwgMCBdO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBcImRyYWdzdGFydFwiXG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24xID0gcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpLCBkeCwgZHk7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbjEpIHJldHVybjtcbiAgICAgICAgICBkeCA9IHBvc2l0aW9uMVswXSAtIHBvc2l0aW9uMFswXTtcbiAgICAgICAgICBkeSA9IHBvc2l0aW9uMVsxXSAtIHBvc2l0aW9uMFsxXTtcbiAgICAgICAgICBkcmFnZ2VkIHw9IGR4IHwgZHk7XG4gICAgICAgICAgcG9zaXRpb24wID0gcG9zaXRpb24xO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ1wiLFxuICAgICAgICAgICAgeDogcG9zaXRpb24xWzBdICsgZHJhZ09mZnNldFswXSxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uMVsxXSArIGRyYWdPZmZzZXRbMV0sXG4gICAgICAgICAgICBkeDogZHgsXG4gICAgICAgICAgICBkeTogZHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKSkgcmV0dXJuO1xuICAgICAgICAgIGRyYWdTdWJqZWN0Lm9uKG1vdmUgKyBkcmFnTmFtZSwgbnVsbCkub24oZW5kICsgZHJhZ05hbWUsIG51bGwpO1xuICAgICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ2VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGRyYWcub3JpZ2luID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luO1xuICAgICAgb3JpZ2luID0geDtcbiAgICAgIHJldHVybiBkcmFnO1xuICAgIH07XG4gICAgcmV0dXJuIGQzLnJlYmluZChkcmFnLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQoKSB7XG4gICAgcmV0dXJuIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gIH1cbiAgZDMudG91Y2hlcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgdG91Y2hlcykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgdG91Y2hlcyA9IGQzX2V2ZW50U291cmNlKCkudG91Y2hlcztcbiAgICByZXR1cm4gdG91Y2hlcyA/IGQzX2FycmF5KHRvdWNoZXMpLm1hcChmdW5jdGlvbih0b3VjaCkge1xuICAgICAgdmFyIHBvaW50ID0gZDNfbW91c2VQb2ludChjb250YWluZXIsIHRvdWNoKTtcbiAgICAgIHBvaW50LmlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0pIDogW107XG4gIH07XG4gIHZhciDOtSA9IDFlLTYsIM61MiA9IM61ICogzrUsIM+AID0gTWF0aC5QSSwgz4QgPSAyICogz4AsIM+EzrUgPSDPhCAtIM61LCBoYWxmz4AgPSDPgCAvIDIsIGQzX3JhZGlhbnMgPSDPgCAvIDE4MCwgZDNfZGVncmVlcyA9IDE4MCAvIM+AO1xuICBmdW5jdGlvbiBkM19zZ24oeCkge1xuICAgIHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDtcbiAgfVxuICBmdW5jdGlvbiBkM19jcm9zczJkKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgLSAoYlsxXSAtIGFbMV0pICogKGNbMF0gLSBhWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19hY29zKHgpIHtcbiAgICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gz4AgOiBNYXRoLmFjb3MoeCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYXNpbih4KSB7XG4gICAgcmV0dXJuIHggPiAxID8gaGFsZs+AIDogeCA8IC0xID8gLWhhbGbPgCA6IE1hdGguYXNpbih4KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zaW5oKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19jb3NoKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM190YW5oKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbiAgfVxuICBmdW5jdGlvbiBkM19oYXZlcnNpbih4KSB7XG4gICAgcmV0dXJuICh4ID0gTWF0aC5zaW4oeCAvIDIpKSAqIHg7XG4gIH1cbiAgdmFyIM+BID0gTWF0aC5TUVJUMiwgz4EyID0gMiwgz4E0ID0gNDtcbiAgZDMuaW50ZXJwb2xhdGVab29tID0gZnVuY3Rpb24ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSwgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLCBkeCA9IHV4MSAtIHV4MCwgZHkgPSB1eTEgLSB1eTAsIGQyID0gZHggKiBkeCArIGR5ICogZHksIGksIFM7XG4gICAgaWYgKGQyIDwgzrUyKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyDPgTtcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbIHV4MCArIHQgKiBkeCwgdXkwICsgdCAqIGR5LCB3MCAqIE1hdGguZXhwKM+BICogdCAqIFMpIF07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLCBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIM+BNCAqIGQyKSAvICgyICogdzAgKiDPgTIgKiBkMSksIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gz4E0ICogZDIpIC8gKDIgKiB3MSAqIM+BMiAqIGQxKSwgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLCByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gz4E7XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLCBjb3NocjAgPSBkM19jb3NoKHIwKSwgdSA9IHcwIC8gKM+BMiAqIGQxKSAqIChjb3NocjAgKiBkM190YW5oKM+BICogcyArIHIwKSAtIGQzX3NpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFsgdXgwICsgdSAqIGR4LCB1eTAgKyB1ICogZHksIHcwICogY29zaHIwIC8gZDNfY29zaCjPgSAqIHMgKyByMCkgXTtcbiAgICAgIH07XG4gICAgfVxuICAgIGkuZHVyYXRpb24gPSBTICogMWUzO1xuICAgIHJldHVybiBpO1xuICB9O1xuICBkMy5iZWhhdmlvci56b29tID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZpZXcgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGs6IDFcbiAgICB9LCB0cmFuc2xhdGUwLCBjZW50ZXIwLCBjZW50ZXIsIHNpemUgPSBbIDk2MCwgNTAwIF0sIHNjYWxlRXh0ZW50ID0gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5LCBkdXJhdGlvbiA9IDI1MCwgem9vbWluZyA9IDAsIG1vdXNlZG93biA9IFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vtb3ZlID0gXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZXVwID0gXCJtb3VzZXVwLnpvb21cIiwgbW91c2V3aGVlbFRpbWVyLCB0b3VjaHN0YXJ0ID0gXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2h0aW1lLCBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goem9vbSwgXCJ6b29tc3RhcnRcIiwgXCJ6b29tXCIsIFwiem9vbWVuZFwiKSwgeDAsIHgxLCB5MCwgeTE7XG4gICAgaWYgKCFkM19iZWhhdmlvcl96b29tV2hlZWwpIHtcbiAgICAgIGQzX2JlaGF2aW9yX3pvb21XaGVlbCA9IFwib253aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLWQzLmV2ZW50LmRlbHRhWSAqIChkMy5ldmVudC5kZWx0YU1vZGUgPyAxMjAgOiAxKTtcbiAgICAgIH0sIFwid2hlZWxcIikgOiBcIm9ubW91c2V3aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZDMuZXZlbnQud2hlZWxEZWx0YTtcbiAgICAgIH0sIFwibW91c2V3aGVlbFwiKSA6IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC1kMy5ldmVudC5kZXRhaWw7XG4gICAgICB9LCBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb20oZykge1xuICAgICAgZy5vbihtb3VzZWRvd24sIG1vdXNlZG93bmVkKS5vbihkM19iZWhhdmlvcl96b29tV2hlZWwgKyBcIi56b29tXCIsIG1vdXNld2hlZWxlZCkub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpLm9uKHRvdWNoc3RhcnQsIHRvdWNoc3RhcnRlZCk7XG4gICAgfVxuICAgIHpvb20uZXZlbnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyksIHZpZXcxID0gdmlldztcbiAgICAgICAgaWYgKGQzX3RyYW5zaXRpb25Jbmhlcml0SWQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmVhY2goXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmlldyA9IHRoaXMuX19jaGFydF9fIHx8IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgazogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KS50d2VlbihcInpvb206em9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHNpemVbMF0sIGR5ID0gc2l6ZVsxXSwgY3ggPSBjZW50ZXIwID8gY2VudGVyMFswXSA6IGR4IC8gMiwgY3kgPSBjZW50ZXIwID8gY2VudGVyMFsxXSA6IGR5IC8gMiwgaSA9IGQzLmludGVycG9sYXRlWm9vbShbIChjeCAtIHZpZXcueCkgLyB2aWV3LmssIChjeSAtIHZpZXcueSkgLyB2aWV3LmssIGR4IC8gdmlldy5rIF0sIFsgKGN4IC0gdmlldzEueCkgLyB2aWV3MS5rLCAoY3kgLSB2aWV3MS55KSAvIHZpZXcxLmssIGR4IC8gdmlldzEuayBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHZhciBsID0gaSh0KSwgayA9IGR4IC8gbFsyXTtcbiAgICAgICAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSB2aWV3ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN4IC0gbFswXSAqIGssXG4gICAgICAgICAgICAgICAgeTogY3kgLSBsWzFdICogayxcbiAgICAgICAgICAgICAgICBrOiBrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmVhY2goXCJpbnRlcnJ1cHQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSkuZWFjaChcImVuZC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHZpZXc7XG4gICAgICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB6b29tLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgdmlldy54LCB2aWV3LnkgXTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6ICtfWzBdLFxuICAgICAgICB5OiArX1sxXSxcbiAgICAgICAgazogdmlldy5rXG4gICAgICB9O1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmlldy5rO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogdmlldy54LFxuICAgICAgICB5OiB2aWV3LnksXG4gICAgICAgIGs6IG51bGxcbiAgICAgIH07XG4gICAgICBzY2FsZVRvKCtfKTtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlRXh0ZW50O1xuICAgICAgc2NhbGVFeHRlbnQgPSBfID09IG51bGwgPyBkM19iZWhhdmlvcl96b29tSW5maW5pdHkgOiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbnRlcjtcbiAgICAgIGNlbnRlciA9IF8gJiYgWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBfICYmIFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIGR1cmF0aW9uID0gK187XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20ueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSB6O1xuICAgICAgeDAgPSB6LmNvcHkoKTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGs6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20ueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTEgPSB6O1xuICAgICAgeTAgPSB6LmNvcHkoKTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGs6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxvY2F0aW9uKHApIHtcbiAgICAgIHJldHVybiBbIChwWzBdIC0gdmlldy54KSAvIHZpZXcuaywgKHBbMV0gLSB2aWV3LnkpIC8gdmlldy5rIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50KGwpIHtcbiAgICAgIHJldHVybiBbIGxbMF0gKiB2aWV3LmsgKyB2aWV3LngsIGxbMV0gKiB2aWV3LmsgKyB2aWV3LnkgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyhzKSB7XG4gICAgICB2aWV3LmsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlVG8ocCwgbCkge1xuICAgICAgbCA9IHBvaW50KGwpO1xuICAgICAgdmlldy54ICs9IHBbMF0gLSBsWzBdO1xuICAgICAgdmlldy55ICs9IHBbMV0gLSBsWzFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tVG8odGhhdCwgcCwgbCwgaykge1xuICAgICAgdGhhdC5fX2NoYXJ0X18gPSB7XG4gICAgICAgIHg6IHZpZXcueCxcbiAgICAgICAgeTogdmlldy55LFxuICAgICAgICBrOiB2aWV3LmtcbiAgICAgIH07XG4gICAgICBzY2FsZVRvKE1hdGgucG93KDIsIGspKTtcbiAgICAgIHRyYW5zbGF0ZVRvKGNlbnRlcjAgPSBwLCBsKTtcbiAgICAgIHRoYXQgPSBkMy5zZWxlY3QodGhhdCk7XG4gICAgICBpZiAoZHVyYXRpb24gPiAwKSB0aGF0ID0gdGhhdC50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgdGhhdC5jYWxsKHpvb20uZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgaWYgKHgxKSB4MS5kb21haW4oeDAucmFuZ2UoKS5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKHggLSB2aWV3LngpIC8gdmlldy5rO1xuICAgICAgfSkubWFwKHgwLmludmVydCkpO1xuICAgICAgaWYgKHkxKSB5MS5kb21haW4oeTAucmFuZ2UoKS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gKHkgLSB2aWV3LnkpIC8gdmlldy5rO1xuICAgICAgfSkubWFwKHkwLmludmVydCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tc3RhcnRlZChkaXNwYXRjaCkge1xuICAgICAgaWYgKCF6b29taW5nKyspIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tc3RhcnRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21lZChkaXNwYXRjaCkge1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21cIixcbiAgICAgICAgc2NhbGU6IHZpZXcuayxcbiAgICAgICAgdHJhbnNsYXRlOiBbIHZpZXcueCwgdmlldy55IF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tZW5kZWQoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICghLS16b29taW5nKSBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbWVuZFwiXG4gICAgICB9KSwgY2VudGVyMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGRyYWdnZWQgPSAwLCBzdWJqZWN0ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyh0aGF0KSkub24obW91c2Vtb3ZlLCBtb3ZlZCkub24obW91c2V1cCwgZW5kZWQpLCBsb2NhdGlvbjAgPSBsb2NhdGlvbihkMy5tb3VzZSh0aGF0KSksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRoYXQpO1xuICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoYXQpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIGRyYWdnZWQgPSAxO1xuICAgICAgICB0cmFuc2xhdGVUbyhkMy5tb3VzZSh0aGF0KSwgbG9jYXRpb24wKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlbW92ZSwgbnVsbCkub24obW91c2V1cCwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgbG9jYXRpb25zMCA9IHt9LCBkaXN0YW5jZTAgPSAwLCBzY2FsZTAsIHpvb21OYW1lID0gXCIuem9vbS1cIiArIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIsIHRvdWNobW92ZSA9IFwidG91Y2htb3ZlXCIgKyB6b29tTmFtZSwgdG91Y2hlbmQgPSBcInRvdWNoZW5kXCIgKyB6b29tTmFtZSwgdGFyZ2V0cyA9IFtdLCBzdWJqZWN0ID0gZDMuc2VsZWN0KHRoYXQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0aGF0KTtcbiAgICAgIHN0YXJ0ZWQoKTtcbiAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIHN1YmplY3Qub24obW91c2Vkb3duLCBudWxsKS5vbih0b3VjaHN0YXJ0LCBzdGFydGVkKTtcbiAgICAgIGZ1bmN0aW9uIHJlbG9jYXRlKCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGQzLnRvdWNoZXModGhhdCk7XG4gICAgICAgIHNjYWxlMCA9IHZpZXcuaztcbiAgICAgICAgdG91Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBpZiAodC5pZGVudGlmaWVyIGluIGxvY2F0aW9uczApIGxvY2F0aW9uczBbdC5pZGVudGlmaWVyXSA9IGxvY2F0aW9uKHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGFydGVkKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0O1xuICAgICAgICBkMy5zZWxlY3QodGFyZ2V0KS5vbih0b3VjaG1vdmUsIG1vdmVkKS5vbih0b3VjaGVuZCwgZW5kZWQpO1xuICAgICAgICB0YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGFuZ2VkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGxvY2F0aW9uczBbY2hhbmdlZFtpXS5pZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoZXMgPSByZWxvY2F0ZSgpLCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpZiAobm93IC0gdG91Y2h0aW1lIDwgNTAwKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRvdWNoZXNbMF07XG4gICAgICAgICAgICB6b29tVG8odGhhdCwgcCwgbG9jYXRpb25zMFtwLmlkZW50aWZpZXJdLCBNYXRoLmZsb29yKE1hdGgubG9nKHZpZXcuaykgLyBNYXRoLkxOMikgKyAxKTtcbiAgICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG91Y2h0aW1lID0gbm93O1xuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBwID0gdG91Y2hlc1swXSwgcSA9IHRvdWNoZXNbMV0sIGR4ID0gcFswXSAtIHFbMF0sIGR5ID0gcFsxXSAtIHFbMV07XG4gICAgICAgICAgZGlzdGFuY2UwID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGQzLnRvdWNoZXModGhhdCksIHAwLCBsMCwgcDEsIGwxO1xuICAgICAgICBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhhdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBuOyArK2ksIGwxID0gbnVsbCkge1xuICAgICAgICAgIHAxID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICBpZiAobDEgPSBsb2NhdGlvbnMwW3AxLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBpZiAobDApIGJyZWFrO1xuICAgICAgICAgICAgcDAgPSBwMSwgbDAgPSBsMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwxKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlMSA9IChkaXN0YW5jZTEgPSBwMVswXSAtIHAwWzBdKSAqIGRpc3RhbmNlMSArIChkaXN0YW5jZTEgPSBwMVsxXSAtIHAwWzFdKSAqIGRpc3RhbmNlMSwgc2NhbGUxID0gZGlzdGFuY2UwICYmIE1hdGguc3FydChkaXN0YW5jZTEgLyBkaXN0YW5jZTApO1xuICAgICAgICAgIHAwID0gWyAocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyIF07XG4gICAgICAgICAgbDAgPSBbIChsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDIgXTtcbiAgICAgICAgICBzY2FsZVRvKHNjYWxlMSAqIHNjYWxlMCk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2h0aW1lID0gbnVsbDtcbiAgICAgICAgdHJhbnNsYXRlVG8ocDAsIGwwKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hhbmdlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhdGlvbnMwW2NoYW5nZWRbaV0uaWRlbnRpZmllcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlkZW50aWZpZXIgaW4gbG9jYXRpb25zMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgcmVsb2NhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZDMuc2VsZWN0QWxsKHRhcmdldHMpLm9uKHpvb21OYW1lLCBudWxsKTtcbiAgICAgICAgc3ViamVjdC5vbihtb3VzZWRvd24sIG1vdXNlZG93bmVkKS5vbih0b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0ZWQpO1xuICAgICAgICBkcmFnUmVzdG9yZSgpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsZWQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKG1vdXNld2hlZWxUaW1lcikgY2xlYXJUaW1lb3V0KG1vdXNld2hlZWxUaW1lcik7IGVsc2UgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoaXMpLCBcbiAgICAgIHRyYW5zbGF0ZTAgPSBsb2NhdGlvbihjZW50ZXIwID0gY2VudGVyIHx8IGQzLm1vdXNlKHRoaXMpKSwgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgbW91c2V3aGVlbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgbW91c2V3aGVlbFRpbWVyID0gbnVsbDtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH0sIDUwKTtcbiAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNjYWxlVG8oTWF0aC5wb3coMiwgZDNfYmVoYXZpb3Jfem9vbURlbHRhKCkgKiAuMDAyKSAqIHZpZXcuayk7XG4gICAgICB0cmFuc2xhdGVUbyhjZW50ZXIwLCB0cmFuc2xhdGUwKTtcbiAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRibGNsaWNrZWQoKSB7XG4gICAgICB2YXIgcCA9IGQzLm1vdXNlKHRoaXMpLCBrID0gTWF0aC5sb2codmlldy5rKSAvIE1hdGguTE4yO1xuICAgICAgem9vbVRvKHRoaXMsIHAsIGxvY2F0aW9uKHApLCBkMy5ldmVudC5zaGlmdEtleSA/IE1hdGguY2VpbChrKSAtIDEgOiBNYXRoLmZsb29yKGspICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoem9vbSwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIHZhciBkM19iZWhhdmlvcl96b29tSW5maW5pdHkgPSBbIDAsIEluZmluaXR5IF0sIGQzX2JlaGF2aW9yX3pvb21EZWx0YSwgZDNfYmVoYXZpb3Jfem9vbVdoZWVsO1xuICBkMy5jb2xvciA9IGQzX2NvbG9yO1xuICBmdW5jdGlvbiBkM19jb2xvcigpIHt9XG4gIGQzX2NvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpICsgXCJcIjtcbiAgfTtcbiAgZDMuaHNsID0gZDNfaHNsO1xuICBmdW5jdGlvbiBkM19oc2woaCwgcywgbCkge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaHNsID8gdm9pZCAodGhpcy5oID0gK2gsIHRoaXMucyA9ICtzLCB0aGlzLmwgPSArbCkgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGggaW5zdGFuY2VvZiBkM19oc2wgPyBuZXcgZDNfaHNsKGguaCwgaC5zLCBoLmwpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyBoLCBkM19yZ2JfaHNsLCBkM19oc2wpIDogbmV3IGQzX2hzbChoLCBzLCBsKTtcbiAgfVxuICB2YXIgZDNfaHNsUHJvdG90eXBlID0gZDNfaHNsLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19oc2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfaHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgLyBrKTtcbiAgfTtcbiAgZDNfaHNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19oc2wodGhpcy5oLCB0aGlzLnMsIGsgKiB0aGlzLmwpO1xuICB9O1xuICBkM19oc2xQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2hzbF9yZ2IodGhpcy5oLCB0aGlzLnMsIHRoaXMubCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2hzbF9yZ2IoaCwgcywgbCkge1xuICAgIHZhciBtMSwgbTI7XG4gICAgaCA9IGlzTmFOKGgpID8gMCA6IChoICU9IDM2MCkgPCAwID8gaCArIDM2MCA6IGg7XG4gICAgcyA9IGlzTmFOKHMpID8gMCA6IHMgPCAwID8gMCA6IHMgPiAxID8gMSA6IHM7XG4gICAgbCA9IGwgPCAwID8gMCA6IGwgPiAxID8gMSA6IGw7XG4gICAgbTIgPSBsIDw9IC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICBmdW5jdGlvbiB2KGgpIHtcbiAgICAgIGlmIChoID4gMzYwKSBoIC09IDM2MDsgZWxzZSBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgICAgaWYgKGggPCA2MCkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAvIDYwO1xuICAgICAgaWYgKGggPCAxODApIHJldHVybiBtMjtcbiAgICAgIGlmIChoIDwgMjQwKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MDtcbiAgICAgIHJldHVybiBtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdnYoaCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodihoKSAqIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZDNfcmdiKHZ2KGggKyAxMjApLCB2dihoKSwgdnYoaCAtIDEyMCkpO1xuICB9XG4gIGQzLmhjbCA9IGQzX2hjbDtcbiAgZnVuY3Rpb24gZDNfaGNsKGgsIGMsIGwpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2hjbCA/IHZvaWQgKHRoaXMuaCA9ICtoLCB0aGlzLmMgPSArYywgdGhpcy5sID0gK2wpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBoIGluc3RhbmNlb2YgZDNfaGNsID8gbmV3IGQzX2hjbChoLmgsIGguYywgaC5sKSA6IGggaW5zdGFuY2VvZiBkM19sYWIgPyBkM19sYWJfaGNsKGgubCwgaC5hLCBoLmIpIDogZDNfbGFiX2hjbCgoaCA9IGQzX3JnYl9sYWIoKGggPSBkMy5yZ2IoaCkpLnIsIGguZywgaC5iKSkubCwgaC5hLCBoLmIpIDogbmV3IGQzX2hjbChoLCBjLCBsKTtcbiAgfVxuICB2YXIgZDNfaGNsUHJvdG90eXBlID0gZDNfaGNsLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19oY2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19oY2wodGhpcy5oLCB0aGlzLmMsIE1hdGgubWluKDEwMCwgdGhpcy5sICsgZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xuICB9O1xuICBkM19oY2xQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1heCgwLCB0aGlzLmwgLSBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSk7XG4gIH07XG4gIGQzX2hjbFByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaGNsX2xhYih0aGlzLmgsIHRoaXMuYywgdGhpcy5sKS5yZ2IoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaGNsX2xhYihoLCBjLCBsKSB7XG4gICAgaWYgKGlzTmFOKGgpKSBoID0gMDtcbiAgICBpZiAoaXNOYU4oYykpIGMgPSAwO1xuICAgIHJldHVybiBuZXcgZDNfbGFiKGwsIE1hdGguY29zKGggKj0gZDNfcmFkaWFucykgKiBjLCBNYXRoLnNpbihoKSAqIGMpO1xuICB9XG4gIGQzLmxhYiA9IGQzX2xhYjtcbiAgZnVuY3Rpb24gZDNfbGFiKGwsIGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2xhYiA/IHZvaWQgKHRoaXMubCA9ICtsLCB0aGlzLmEgPSArYSwgdGhpcy5iID0gK2IpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBsIGluc3RhbmNlb2YgZDNfbGFiID8gbmV3IGQzX2xhYihsLmwsIGwuYSwgbC5iKSA6IGwgaW5zdGFuY2VvZiBkM19oY2wgPyBkM19oY2xfbGFiKGwuaCwgbC5jLCBsLmwpIDogZDNfcmdiX2xhYigobCA9IGQzX3JnYihsKSkuciwgbC5nLCBsLmIpIDogbmV3IGQzX2xhYihsLCBhLCBiKTtcbiAgfVxuICB2YXIgZDNfbGFiX0sgPSAxODtcbiAgdmFyIGQzX2xhYl9YID0gLjk1MDQ3LCBkM19sYWJfWSA9IDEsIGQzX2xhYl9aID0gMS4wODg4MztcbiAgdmFyIGQzX2xhYlByb3RvdHlwZSA9IGQzX2xhYi5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfbGFiUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfbGFiKE1hdGgubWluKDEwMCwgdGhpcy5sICsgZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZDNfbGFiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1heCgwLCB0aGlzLmwgLSBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBkM19sYWJQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2xhYl9yZ2IodGhpcy5sLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xhYl9yZ2IobCwgYSwgYikge1xuICAgIHZhciB5ID0gKGwgKyAxNikgLyAxMTYsIHggPSB5ICsgYSAvIDUwMCwgeiA9IHkgLSBiIC8gMjAwO1xuICAgIHggPSBkM19sYWJfeHl6KHgpICogZDNfbGFiX1g7XG4gICAgeSA9IGQzX2xhYl94eXooeSkgKiBkM19sYWJfWTtcbiAgICB6ID0gZDNfbGFiX3h5eih6KSAqIGQzX2xhYl9aO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKGQzX3h5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAuNDk4NTMxNCAqIHopLCBkM194eXpfcmdiKC0uOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAuMDQxNTU2ICogeiksIGQzX3h5el9yZ2IoLjA1NTY0MzQgKiB4IC0gLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xhYl9oY2wobCwgYSwgYikge1xuICAgIHJldHVybiBsID4gMCA/IG5ldyBkM19oY2woTWF0aC5hdGFuMihiLCBhKSAqIGQzX2RlZ3JlZXMsIE1hdGguc3FydChhICogYSArIGIgKiBiKSwgbCkgOiBuZXcgZDNfaGNsKE5hTiwgTmFOLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYWJfeHl6KHgpIHtcbiAgICByZXR1cm4geCA+IC4yMDY4OTMwMzQgPyB4ICogeCAqIHggOiAoeCAtIDQgLyAyOSkgLyA3Ljc4NzAzNztcbiAgfVxuICBmdW5jdGlvbiBkM194eXpfbGFiKHgpIHtcbiAgICByZXR1cm4geCA+IC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NzAzNyAqIHggKyA0IC8gMjk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeHl6X3JnYihyKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoMjU1ICogKHIgPD0gLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBNYXRoLnBvdyhyLCAxIC8gMi40KSAtIC4wNTUpKTtcbiAgfVxuICBkMy5yZ2IgPSBkM19yZ2I7XG4gIGZ1bmN0aW9uIGQzX3JnYihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19yZ2IgPyB2b2lkICh0aGlzLnIgPSB+fnIsIHRoaXMuZyA9IH5+ZywgdGhpcy5iID0gfn5iKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gciBpbnN0YW5jZW9mIGQzX3JnYiA/IG5ldyBkM19yZ2Ioci5yLCByLmcsIHIuYikgOiBkM19yZ2JfcGFyc2UoXCJcIiArIHIsIGQzX3JnYiwgZDNfaHNsX3JnYikgOiBuZXcgZDNfcmdiKHIsIGcsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYk51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgZDNfcmdiKHZhbHVlID4+IDE2LCB2YWx1ZSA+PiA4ICYgMjU1LCB2YWx1ZSAmIDI1NSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGQzX3JnYk51bWJlcih2YWx1ZSkgKyBcIlwiO1xuICB9XG4gIHZhciBkM19yZ2JQcm90b3R5cGUgPSBkM19yZ2IucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX3JnYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgdmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmIsIGkgPSAzMDtcbiAgICBpZiAoIXIgJiYgIWcgJiYgIWIpIHJldHVybiBuZXcgZDNfcmdiKGksIGksIGkpO1xuICAgIGlmIChyICYmIHIgPCBpKSByID0gaTtcbiAgICBpZiAoZyAmJiBnIDwgaSkgZyA9IGk7XG4gICAgaWYgKGIgJiYgYiA8IGkpIGIgPSBpO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKE1hdGgubWluKDI1NSwgciAvIGspLCBNYXRoLm1pbigyNTUsIGcgLyBrKSwgTWF0aC5taW4oMjU1LCBiIC8gaykpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihrICogdGhpcy5yLCBrICogdGhpcy5nLCBrICogdGhpcy5iKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLmhzbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19yZ2JfaHNsKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCIjXCIgKyBkM19yZ2JfaGV4KHRoaXMucikgKyBkM19yZ2JfaGV4KHRoaXMuZykgKyBkM19yZ2JfaGV4KHRoaXMuYik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JnYl9oZXgodikge1xuICAgIHJldHVybiB2IDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIHYpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgdikudG9TdHJpbmcoMTYpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9wYXJzZShmb3JtYXQsIHJnYiwgaHNsKSB7XG4gICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIG0xLCBtMiwgY29sb3I7XG4gICAgbTEgPSAvKFthLXpdKylcXCgoLiopXFwpLy5leGVjKGZvcm1hdCA9IGZvcm1hdC50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAobTEpIHtcbiAgICAgIG0yID0gbTFbMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgc3dpdGNoIChtMVsxXSkge1xuICAgICAgIGNhc2UgXCJoc2xcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBoc2wocGFyc2VGbG9hdChtMlswXSksIHBhcnNlRmxvYXQobTJbMV0pIC8gMTAwLCBwYXJzZUZsb2F0KG0yWzJdKSAvIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiByZ2IoZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzBdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzFdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzJdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbG9yID0gZDNfcmdiX25hbWVzLmdldChmb3JtYXQpKSB7XG4gICAgICByZXR1cm4gcmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0LmNoYXJBdCgwKSA9PT0gXCIjXCIgJiYgIWlzTmFOKGNvbG9yID0gcGFyc2VJbnQoZm9ybWF0LnNsaWNlKDEpLCAxNikpKSB7XG4gICAgICBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByID0gKGNvbG9yICYgMzg0MCkgPj4gNDtcbiAgICAgICAgciA9IHIgPj4gNCB8IHI7XG4gICAgICAgIGcgPSBjb2xvciAmIDI0MDtcbiAgICAgICAgZyA9IGcgPj4gNCB8IGc7XG4gICAgICAgIGIgPSBjb2xvciAmIDE1O1xuICAgICAgICBiID0gYiA8PCA0IHwgYjtcbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNykge1xuICAgICAgICByID0gKGNvbG9yICYgMTY3MTE2ODApID4+IDE2O1xuICAgICAgICBnID0gKGNvbG9yICYgNjUyODApID4+IDg7XG4gICAgICAgIGIgPSBjb2xvciAmIDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYihyLCBnLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfaHNsKHIsIGcsIGIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NSksIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBkID0gbWF4IC0gbWluLCBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIGlmIChkKSB7XG4gICAgICBzID0gbCA8IC41ID8gZCAvIChtYXggKyBtaW4pIDogZCAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgIGlmIChyID09IG1heCkgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBlbHNlIGlmIChnID09IG1heCkgaCA9IChiIC0gcikgLyBkICsgMjsgZWxzZSBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgaCAqPSA2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IE5hTjtcbiAgICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGQzX2hzbChoLCBzLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfbGFiKHIsIGcsIGIpIHtcbiAgICByID0gZDNfcmdiX3h5eihyKTtcbiAgICBnID0gZDNfcmdiX3h5eihnKTtcbiAgICBiID0gZDNfcmdiX3h5eihiKTtcbiAgICB2YXIgeCA9IGQzX3h5el9sYWIoKC40MTI0NTY0ICogciArIC4zNTc1NzYxICogZyArIC4xODA0Mzc1ICogYikgLyBkM19sYWJfWCksIHkgPSBkM194eXpfbGFiKCguMjEyNjcyOSAqIHIgKyAuNzE1MTUyMiAqIGcgKyAuMDcyMTc1ICogYikgLyBkM19sYWJfWSksIHogPSBkM194eXpfbGFiKCguMDE5MzMzOSAqIHIgKyAuMTE5MTkyICogZyArIC45NTAzMDQxICogYikgLyBkM19sYWJfWik7XG4gICAgcmV0dXJuIGQzX2xhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl94eXoocikge1xuICAgIHJldHVybiAociAvPSAyNTUpIDw9IC4wNDA0NSA/IHIgLyAxMi45MiA6IE1hdGgucG93KChyICsgLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfcGFyc2VOdW1iZXIoYykge1xuICAgIHZhciBmID0gcGFyc2VGbG9hdChjKTtcbiAgICByZXR1cm4gYy5jaGFyQXQoYy5sZW5ndGggLSAxKSA9PT0gXCIlXCIgPyBNYXRoLnJvdW5kKGYgKiAyLjU1KSA6IGY7XG4gIH1cbiAgdmFyIGQzX3JnYl9uYW1lcyA9IGQzLm1hcCh7XG4gICAgYWxpY2VibHVlOiAxNTc5MjM4MyxcbiAgICBhbnRpcXVld2hpdGU6IDE2NDQ0Mzc1LFxuICAgIGFxdWE6IDY1NTM1LFxuICAgIGFxdWFtYXJpbmU6IDgzODg1NjQsXG4gICAgYXp1cmU6IDE1Nzk0MTc1LFxuICAgIGJlaWdlOiAxNjExOTI2MCxcbiAgICBiaXNxdWU6IDE2NzcwMjQ0LFxuICAgIGJsYWNrOiAwLFxuICAgIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSxcbiAgICBibHVlOiAyNTUsXG4gICAgYmx1ZXZpb2xldDogOTA1NTIwMixcbiAgICBicm93bjogMTA4MjQyMzQsXG4gICAgYnVybHl3b29kOiAxNDU5NjIzMSxcbiAgICBjYWRldGJsdWU6IDYyNjY1MjgsXG4gICAgY2hhcnRyZXVzZTogODM4ODM1MixcbiAgICBjaG9jb2xhdGU6IDEzNzg5NDcwLFxuICAgIGNvcmFsOiAxNjc0NDI3MixcbiAgICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSxcbiAgICBjb3Juc2lsazogMTY3NzUzODgsXG4gICAgY3JpbXNvbjogMTQ0MjMxMDAsXG4gICAgY3lhbjogNjU1MzUsXG4gICAgZGFya2JsdWU6IDEzOSxcbiAgICBkYXJrY3lhbjogMzU3MjMsXG4gICAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksXG4gICAgZGFya2dyYXk6IDExMTE5MDE3LFxuICAgIGRhcmtncmVlbjogMjU2MDAsXG4gICAgZGFya2dyZXk6IDExMTE5MDE3LFxuICAgIGRhcmtraGFraTogMTI0MzMyNTksXG4gICAgZGFya21hZ2VudGE6IDkxMDk2NDMsXG4gICAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksXG4gICAgZGFya29yYW5nZTogMTY3NDc1MjAsXG4gICAgZGFya29yY2hpZDogMTAwNDAwMTIsXG4gICAgZGFya3JlZDogOTEwOTUwNCxcbiAgICBkYXJrc2FsbW9uOiAxNTMwODQxMCxcbiAgICBkYXJrc2VhZ3JlZW46IDk0MTk5MTksXG4gICAgZGFya3NsYXRlYmx1ZTogNDczNDM0NyxcbiAgICBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LFxuICAgIGRhcmtzbGF0ZWdyZXk6IDMxMDA0OTUsXG4gICAgZGFya3R1cnF1b2lzZTogNTI5NDUsXG4gICAgZGFya3Zpb2xldDogOTY5OTUzOSxcbiAgICBkZWVwcGluazogMTY3MTY5NDcsXG4gICAgZGVlcHNreWJsdWU6IDQ5MTUxLFxuICAgIGRpbWdyYXk6IDY5MDgyNjUsXG4gICAgZGltZ3JleTogNjkwODI2NSxcbiAgICBkb2RnZXJibHVlOiAyMDAzMTk5LFxuICAgIGZpcmVicmljazogMTE2NzQxNDYsXG4gICAgZmxvcmFsd2hpdGU6IDE2Nzc1OTIwLFxuICAgIGZvcmVzdGdyZWVuOiAyMjYzODQyLFxuICAgIGZ1Y2hzaWE6IDE2NzExOTM1LFxuICAgIGdhaW5zYm9ybzogMTQ0NzQ0NjAsXG4gICAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsXG4gICAgZ29sZDogMTY3NjY3MjAsXG4gICAgZ29sZGVucm9kOiAxNDMyOTEyMCxcbiAgICBncmF5OiA4NDIxNTA0LFxuICAgIGdyZWVuOiAzMjc2OCxcbiAgICBncmVlbnllbGxvdzogMTE0MDMwNTUsXG4gICAgZ3JleTogODQyMTUwNCxcbiAgICBob25leWRldzogMTU3OTQxNjAsXG4gICAgaG90cGluazogMTY3Mzg3NDAsXG4gICAgaW5kaWFucmVkOiAxMzQ1ODUyNCxcbiAgICBpbmRpZ286IDQ5MTUzMzAsXG4gICAgaXZvcnk6IDE2Nzc3MjAwLFxuICAgIGtoYWtpOiAxNTc4NzY2MCxcbiAgICBsYXZlbmRlcjogMTUxMzI0MTAsXG4gICAgbGF2ZW5kZXJibHVzaDogMTY3NzMzNjUsXG4gICAgbGF3bmdyZWVuOiA4MTkwOTc2LFxuICAgIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsXG4gICAgbGlnaHRibHVlOiAxMTM5MzI1NCxcbiAgICBsaWdodGNvcmFsOiAxNTc2MTUzNixcbiAgICBsaWdodGN5YW46IDE0NzQ1NTk5LFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAxNjQ0ODIxMCxcbiAgICBsaWdodGdyYXk6IDEzODgyMzIzLFxuICAgIGxpZ2h0Z3JlZW46IDk0OTgyNTYsXG4gICAgbGlnaHRncmV5OiAxMzg4MjMyMyxcbiAgICBsaWdodHBpbms6IDE2NzU4NDY1LFxuICAgIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MixcbiAgICBsaWdodHNlYWdyZWVuOiAyMTQyODkwLFxuICAgIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NixcbiAgICBsaWdodHNsYXRlZ3JheTogNzgzMzc1MyxcbiAgICBsaWdodHNsYXRlZ3JleTogNzgzMzc1MyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsXG4gICAgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LFxuICAgIGxpbWU6IDY1MjgwLFxuICAgIGxpbWVncmVlbjogMzMyOTMzMCxcbiAgICBsaW5lbjogMTY0NDU2NzAsXG4gICAgbWFnZW50YTogMTY3MTE5MzUsXG4gICAgbWFyb29uOiA4Mzg4NjA4LFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsXG4gICAgbWVkaXVtYmx1ZTogMjA1LFxuICAgIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsXG4gICAgbWVkaXVtcHVycGxlOiA5NjYyNjgzLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAzOTc4MDk3LFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsXG4gICAgbWVkaXVtdHVycXVvaXNlOiA0NzcyMzAwLFxuICAgIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsXG4gICAgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLFxuICAgIG1pbnRjcmVhbTogMTYxMjE4NTAsXG4gICAgbWlzdHlyb3NlOiAxNjc3MDI3MyxcbiAgICBtb2NjYXNpbjogMTY3NzAyMjksXG4gICAgbmF2YWpvd2hpdGU6IDE2NzY4Njg1LFxuICAgIG5hdnk6IDEyOCxcbiAgICBvbGRsYWNlOiAxNjY0MzU1OCxcbiAgICBvbGl2ZTogODQyMTM3NixcbiAgICBvbGl2ZWRyYWI6IDcwNDg3MzksXG4gICAgb3JhbmdlOiAxNjc1MzkyMCxcbiAgICBvcmFuZ2VyZWQ6IDE2NzI5MzQ0LFxuICAgIG9yY2hpZDogMTQzMTU3MzQsXG4gICAgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsXG4gICAgcGFsZWdyZWVuOiAxMDAyNTg4MCxcbiAgICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NixcbiAgICBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMyxcbiAgICBwYXBheWF3aGlwOiAxNjc3MzA3NyxcbiAgICBwZWFjaHB1ZmY6IDE2NzY3NjczLFxuICAgIHBlcnU6IDEzNDY4OTkxLFxuICAgIHBpbms6IDE2NzYxMDM1LFxuICAgIHBsdW06IDE0NTI0NjM3LFxuICAgIHBvd2RlcmJsdWU6IDExNTkxOTEwLFxuICAgIHB1cnBsZTogODM4ODczNixcbiAgICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLFxuICAgIHJlZDogMTY3MTE2ODAsXG4gICAgcm9zeWJyb3duOiAxMjM1NzUxOSxcbiAgICByb3lhbGJsdWU6IDQyODY5NDUsXG4gICAgc2FkZGxlYnJvd246IDkxMjcxODcsXG4gICAgc2FsbW9uOiAxNjQxNjg4MixcbiAgICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgICBzZWFncmVlbjogMzA1MDMyNyxcbiAgICBzZWFzaGVsbDogMTY3NzQ2MzgsXG4gICAgc2llbm5hOiAxMDUwNjc5NyxcbiAgICBzaWx2ZXI6IDEyNjMyMjU2LFxuICAgIHNreWJsdWU6IDg5MDAzMzEsXG4gICAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICAgIHNsYXRlZ3JheTogNzM3Mjk0NCxcbiAgICBzbGF0ZWdyZXk6IDczNzI5NDQsXG4gICAgc25vdzogMTY3NzU5MzAsXG4gICAgc3ByaW5nZ3JlZW46IDY1NDA3LFxuICAgIHN0ZWVsYmx1ZTogNDYyMDk4MCxcbiAgICB0YW46IDEzODA4NzgwLFxuICAgIHRlYWw6IDMyODk2LFxuICAgIHRoaXN0bGU6IDE0MjA0ODg4LFxuICAgIHRvbWF0bzogMTY3MzcwOTUsXG4gICAgdHVycXVvaXNlOiA0MjUxODU2LFxuICAgIHZpb2xldDogMTU2MzEwODYsXG4gICAgd2hlYXQ6IDE2MTEzMzMxLFxuICAgIHdoaXRlOiAxNjc3NzIxNSxcbiAgICB3aGl0ZXNtb2tlOiAxNjExOTI4NSxcbiAgICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICAgIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxuICB9KTtcbiAgZDNfcmdiX25hbWVzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGQzX3JnYl9uYW1lcy5zZXQoa2V5LCBkM19yZ2JOdW1iZXIodmFsdWUpKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2Z1bmN0b3Iodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdiA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgfVxuICBkMy5mdW5jdG9yID0gZDNfZnVuY3RvcjtcbiAgZDMueGhyID0gZDNfeGhyVHlwZShkM19pZGVudGl0eSk7XG4gIGZ1bmN0aW9uIGQzX3hoclR5cGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBtaW1lVHlwZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBtaW1lVHlwZSA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayA9IG1pbWVUeXBlLCBcbiAgICAgIG1pbWVUeXBlID0gbnVsbDtcbiAgICAgIHJldHVybiBkM194aHIodXJsLCBtaW1lVHlwZSwgcmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hocih1cmwsIG1pbWVUeXBlLCByZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0ge30sIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goXCJiZWZvcmVzZW5kXCIsIFwicHJvZ3Jlc3NcIiwgXCJsb2FkXCIsIFwiZXJyb3JcIiksIGhlYWRlcnMgPSB7fSwgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCByZXNwb25zZVR5cGUgPSBudWxsO1xuICAgIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0KSAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgXCJvbmxvYWRcIiBpbiByZXF1ZXN0ID8gcmVxdWVzdC5vbmxvYWQgPSByZXF1ZXN0Lm9uZXJyb3IgPSByZXNwb25kIDogcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMgJiYgcmVzcG9uZCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICAgIHZhciBzdGF0dXMgPSByZXF1ZXN0LnN0YXR1cywgcmVzdWx0O1xuICAgICAgaWYgKCFzdGF0dXMgJiYgZDNfeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoLmxvYWQuY2FsbCh4aHIsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbyA9IGQzLmV2ZW50O1xuICAgICAgZDMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc3BhdGNoLnByb2dyZXNzLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5oZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgbmFtZSA9IChuYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGhlYWRlcnNbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgZGVsZXRlIGhlYWRlcnNbbmFtZV07IGVsc2UgaGVhZGVyc1tuYW1lXSA9IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIubWltZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWltZVR5cGU7XG4gICAgICBtaW1lVHlwZSA9IHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWUgKyBcIlwiO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmVzcG9uc2VUeXBlO1xuICAgICAgcmVzcG9uc2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLnJlc3BvbnNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3BvbnNlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgWyBcImdldFwiLCBcInBvc3RcIiBdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB4aHJbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geGhyLnNlbmQuYXBwbHkoeGhyLCBbIG1ldGhvZCBdLmNvbmNhdChkM19hcnJheShhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHhoci5zZW5kID0gZnVuY3Rpb24obWV0aG9kLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiAhKFwiYWNjZXB0XCIgaW4gaGVhZGVycykpIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBtaW1lVHlwZSArIFwiLCovKlwiO1xuICAgICAgaWYgKHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcikgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XG4gICAgICBpZiAocmVzcG9uc2VUeXBlICE9IG51bGwpIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHhoci5vbihcImVycm9yXCIsIGNhbGxiYWNrKS5vbihcImxvYWRcIiwgZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2guYmVmb3Jlc2VuZC5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICByZXF1ZXN0LnNlbmQoZGF0YSA9PSBudWxsID8gbnVsbCA6IGRhdGEpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIGQzLnJlYmluZCh4aHIsIGRpc3BhdGNoLCBcIm9uXCIpO1xuICAgIHJldHVybiBjYWxsYmFjayA9PSBudWxsID8geGhyIDogeGhyLmdldChkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spKTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY2FsbGJhY2subGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yID09IG51bGwgPyByZXF1ZXN0IDogbnVsbCk7XG4gICAgfSA6IGNhbGxiYWNrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUgIT09IFwidGV4dFwiID8gcmVxdWVzdC5yZXNwb25zZSA6IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG4gIGQzLmRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKCdbXCInICsgZGVsaW1pdGVyICsgXCJcXG5dXCIpLCBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgZnVuY3Rpb24gZHN2KHVybCwgcm93LCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBjYWxsYmFjayA9IHJvdywgcm93ID0gbnVsbDtcbiAgICAgIHZhciB4aHIgPSBkM194aHIodXJsLCBtaW1lVHlwZSwgcm93ID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2Uocm93KSwgY2FsbGJhY2spO1xuICAgICAgeGhyLnJvdyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB4aHIucmVzcG9uc2UoKHJvdyA9IF8pID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2UoXykpIDogcm93O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZFJlc3BvbnNlKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQsIGYpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZHN2LnBhcnNlID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIG87XG4gICAgICByZXR1cm4gZHN2LnBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgaWYgKG8pIHJldHVybiBvKHJvdywgaSAtIDEpO1xuICAgICAgICB2YXIgYSA9IG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgcm93Lm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgICAgICBvID0gZiA/IGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgICAgIHJldHVybiBmKGEocm93KSwgaSk7XG4gICAgICAgIH0gOiBhO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBkc3YucGFyc2VSb3dzID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCBFT0YgPSB7fSwgcm93cyA9IFtdLCBOID0gdGV4dC5sZW5ndGgsIEkgPSAwLCBuID0gMCwgdCwgZW9sO1xuICAgICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICAgIGlmIChJID49IE4pIHJldHVybiBFT0Y7XG4gICAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuICAgICAgICB2YXIgaiA9IEk7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IDM0KSB7XG4gICAgICAgICAgdmFyIGkgPSBqO1xuICAgICAgICAgIHdoaWxlIChpKysgPCBOKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSAzNCkge1xuICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMzQpIGJyZWFrO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIEkgPSBpICsgMjtcbiAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMikgPT09IDEwKSArK0k7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAxMCkge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkpLnJlcGxhY2UoL1wiXCIvZywgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSwgayA9IDE7XG4gICAgICAgICAgaWYgKGMgPT09IDEwKSBlb2wgPSB0cnVlOyBlbHNlIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IDEwKSArK0ksICsraztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09IGRlbGltaXRlckNvZGUpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIEkgLSBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHtcbiAgICAgICAgICBhLnB1c2godCk7XG4gICAgICAgICAgdCA9IHRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgJiYgKGEgPSBmKGEsIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICByb3dzLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIGRzdi5mb3JtYXQgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzWzBdKSkgcmV0dXJuIGRzdi5mb3JtYXRSb3dzKHJvd3MpO1xuICAgICAgdmFyIGZpZWxkU2V0ID0gbmV3IGQzX1NldCgpLCBmaWVsZHMgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gcm93KSB7XG4gICAgICAgICAgaWYgKCFmaWVsZFNldC5oYXMoZmllbGQpKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZFNldC5hZGQoZmllbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFsgZmllbGRzLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpIF0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbZmllbGRdKTtcbiAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBkc3YuZm9ybWF0Um93cyA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh0ZXh0KSB7XG4gICAgICByZXR1cm4gcmVGb3JtYXQudGVzdCh0ZXh0KSA/ICdcIicgKyB0ZXh0LnJlcGxhY2UoL1xcXCIvZywgJ1wiXCInKSArICdcIicgOiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZHN2O1xuICB9O1xuICBkMy5jc3YgPSBkMy5kc3YoXCIsXCIsIFwidGV4dC9jc3ZcIik7XG4gIGQzLnRzdiA9IGQzLmRzdihcIlx0XCIsIFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiKTtcbiAgdmFyIGQzX3RpbWVyX3F1ZXVlSGVhZCwgZDNfdGltZXJfcXVldWVUYWlsLCBkM190aW1lcl9pbnRlcnZhbCwgZDNfdGltZXJfdGltZW91dCwgZDNfdGltZXJfZnJhbWUgPSB0aGlzW2QzX3ZlbmRvclN5bWJvbCh0aGlzLCBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV0gfHwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxNyk7XG4gIH07XG4gIGQzLnRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgZDNfdGltZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aGVuKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMikgZGVsYXkgPSAwO1xuICAgIGlmIChuIDwgMykgdGhlbiA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWUgPSB0aGVuICsgZGVsYXksIHRpbWVyID0ge1xuICAgICAgYzogY2FsbGJhY2ssXG4gICAgICB0OiB0aW1lLFxuICAgICAgbjogbnVsbFxuICAgIH07XG4gICAgaWYgKGQzX3RpbWVyX3F1ZXVlVGFpbCkgZDNfdGltZXJfcXVldWVUYWlsLm4gPSB0aW1lcjsgZWxzZSBkM190aW1lcl9xdWV1ZUhlYWQgPSB0aW1lcjtcbiAgICBkM190aW1lcl9xdWV1ZVRhaWwgPSB0aW1lcjtcbiAgICBpZiAoIWQzX3RpbWVyX2ludGVydmFsKSB7XG4gICAgICBkM190aW1lcl90aW1lb3V0ID0gY2xlYXJUaW1lb3V0KGQzX3RpbWVyX3RpbWVvdXQpO1xuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAxO1xuICAgICAgZDNfdGltZXJfZnJhbWUoZDNfdGltZXJfc3RlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lcjtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lcl9zdGVwKCkge1xuICAgIHZhciBub3cgPSBkM190aW1lcl9tYXJrKCksIGRlbGF5ID0gZDNfdGltZXJfc3dlZXAoKSAtIG5vdztcbiAgICBpZiAoZGVsYXkgPiAyNCkge1xuICAgICAgaWYgKGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZDNfdGltZXJfdGltZW91dCk7XG4gICAgICAgIGQzX3RpbWVyX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGQzX3RpbWVyX3N0ZXAsIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAxO1xuICAgICAgZDNfdGltZXJfZnJhbWUoZDNfdGltZXJfc3RlcCk7XG4gICAgfVxuICB9XG4gIGQzLnRpbWVyLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgZDNfdGltZXJfbWFyaygpO1xuICAgIGQzX3RpbWVyX3N3ZWVwKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX21hcmsoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCksIHRpbWVyID0gZDNfdGltZXJfcXVldWVIZWFkO1xuICAgIHdoaWxlICh0aW1lcikge1xuICAgICAgaWYgKG5vdyA+PSB0aW1lci50ICYmIHRpbWVyLmMobm93IC0gdGltZXIudCkpIHRpbWVyLmMgPSBudWxsO1xuICAgICAgdGltZXIgPSB0aW1lci5uO1xuICAgIH1cbiAgICByZXR1cm4gbm93O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX3N3ZWVwKCkge1xuICAgIHZhciB0MCwgdDEgPSBkM190aW1lcl9xdWV1ZUhlYWQsIHRpbWUgPSBJbmZpbml0eTtcbiAgICB3aGlsZSAodDEpIHtcbiAgICAgIGlmICh0MS5jKSB7XG4gICAgICAgIGlmICh0MS50IDwgdGltZSkgdGltZSA9IHQxLnQ7XG4gICAgICAgIHQxID0gKHQwID0gdDEpLm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MSA9IHQwID8gdDAubiA9IHQxLm4gOiBkM190aW1lcl9xdWV1ZUhlYWQgPSB0MS5uO1xuICAgICAgfVxuICAgIH1cbiAgICBkM190aW1lcl9xdWV1ZVRhaWwgPSB0MDtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuICBmdW5jdGlvbiBkM19mb3JtYXRfcHJlY2lzaW9uKHgsIHApIHtcbiAgICByZXR1cm4gcCAtICh4ID8gTWF0aC5jZWlsKE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwKSA6IDEpO1xuICB9XG4gIGQzLnJvdW5kID0gZnVuY3Rpb24oeCwgbikge1xuICAgIHJldHVybiBuID8gTWF0aC5yb3VuZCh4ICogKG4gPSBNYXRoLnBvdygxMCwgbikpKSAvIG4gOiBNYXRoLnJvdW5kKHgpO1xuICB9O1xuICB2YXIgZDNfZm9ybWF0UHJlZml4ZXMgPSBbIFwieVwiLCBcInpcIiwgXCJhXCIsIFwiZlwiLCBcInBcIiwgXCJuXCIsIFwiwrVcIiwgXCJtXCIsIFwiXCIsIFwia1wiLCBcIk1cIiwgXCJHXCIsIFwiVFwiLCBcIlBcIiwgXCJFXCIsIFwiWlwiLCBcIllcIiBdLm1hcChkM19mb3JtYXRQcmVmaXgpO1xuICBkMy5mb3JtYXRQcmVmaXggPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgKj0gLTE7XG4gICAgICBpZiAocHJlY2lzaW9uKSB2YWx1ZSA9IGQzLnJvdW5kKHZhbHVlLCBkM19mb3JtYXRfcHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pKTtcbiAgICAgIGkgPSAxICsgTWF0aC5mbG9vcigxZS0xMiArIE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCk7XG4gICAgICBpID0gTWF0aC5tYXgoLTI0LCBNYXRoLm1pbigyNCwgTWF0aC5mbG9vcigoaSAtIDEpIC8gMykgKiAzKSk7XG4gICAgfVxuICAgIHJldHVybiBkM19mb3JtYXRQcmVmaXhlc1s4ICsgaSAvIDNdO1xuICB9O1xuICBmdW5jdGlvbiBkM19mb3JtYXRQcmVmaXgoZCwgaSkge1xuICAgIHZhciBrID0gTWF0aC5wb3coMTAsIGFicyg4IC0gaSkgKiAzKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IGkgPiA4ID8gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIGs7XG4gICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAqIGs7XG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBkXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsLCBsb2NhbGVfdGhvdXNhbmRzID0gbG9jYWxlLnRob3VzYW5kcywgbG9jYWxlX2dyb3VwaW5nID0gbG9jYWxlLmdyb3VwaW5nLCBsb2NhbGVfY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksIGZvcm1hdEdyb3VwID0gbG9jYWxlX2dyb3VwaW5nICYmIGxvY2FsZV90aG91c2FuZHMgPyBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLCB0ID0gW10sIGogPSAwLCBnID0gbG9jYWxlX2dyb3VwaW5nWzBdLCBsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gbG9jYWxlX2dyb3VwaW5nW2ogPSAoaiArIDEpICUgbG9jYWxlX2dyb3VwaW5nLmxlbmd0aF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbihsb2NhbGVfdGhvdXNhbmRzKTtcbiAgICB9IDogZDNfaWRlbnRpdHk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIG1hdGNoID0gZDNfZm9ybWF0X3JlLmV4ZWMoc3BlY2lmaWVyKSwgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLCBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLCBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsIHpmaWxsID0gbWF0Y2hbNV0sIHdpZHRoID0gK21hdGNoWzZdLCBjb21tYSA9IG1hdGNoWzddLCBwcmVjaXNpb24gPSBtYXRjaFs4XSwgdHlwZSA9IG1hdGNoWzldLCBzY2FsZSA9IDEsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIGludGVnZXIgPSBmYWxzZSwgZXhwb25lbnQgPSB0cnVlO1xuICAgICAgaWYgKHByZWNpc2lvbikgcHJlY2lzaW9uID0gK3ByZWNpc2lvbi5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoemZpbGwgfHwgZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSB7XG4gICAgICAgIHpmaWxsID0gZmlsbCA9IFwiMFwiO1xuICAgICAgICBhbGlnbiA9IFwiPVwiO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgY29tbWEgPSB0cnVlO1xuICAgICAgICB0eXBlID0gXCJnXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xuICAgICAgICB0eXBlID0gXCJmXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xuICAgICAgICB0eXBlID0gXCJyXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcImJcIjpcbiAgICAgICBjYXNlIFwib1wiOlxuICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gXCIjXCIpIHByZWZpeCA9IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgZXhwb25lbnQgPSBmYWxzZTtcblxuICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIGludGVnZXIgPSB0cnVlO1xuICAgICAgICBwcmVjaXNpb24gPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHNjYWxlID0gLTE7XG4gICAgICAgIHR5cGUgPSBcInJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3ltYm9sID09PSBcIiRcIikgcHJlZml4ID0gbG9jYWxlX2N1cnJlbmN5WzBdLCBzdWZmaXggPSBsb2NhbGVfY3VycmVuY3lbMV07XG4gICAgICBpZiAodHlwZSA9PSBcInJcIiAmJiAhcHJlY2lzaW9uKSB0eXBlID0gXCJnXCI7XG4gICAgICBpZiAocHJlY2lzaW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJnXCIpIHByZWNpc2lvbiA9IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKTsgZWxzZSBpZiAodHlwZSA9PSBcImVcIiB8fCB0eXBlID09IFwiZlwiKSBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG4gICAgICB9XG4gICAgICB0eXBlID0gZDNfZm9ybWF0X3R5cGVzLmdldCh0eXBlKSB8fCBkM19mb3JtYXRfdHlwZURlZmF1bHQ7XG4gICAgICB2YXIgemNvbW1hID0gemZpbGwgJiYgY29tbWE7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGZ1bGxTdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIGlmIChpbnRlZ2VyICYmIHZhbHVlICUgMSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciBuZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gKHZhbHVlID0gLXZhbHVlLCBcIi1cIikgOiBzaWduID09PSBcIi1cIiA/IFwiXCIgOiBzaWduO1xuICAgICAgICBpZiAoc2NhbGUgPCAwKSB7XG4gICAgICAgICAgdmFyIHVuaXQgPSBkMy5mb3JtYXRQcmVmaXgodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgICAgdmFsdWUgPSB1bml0LnNjYWxlKHZhbHVlKTtcbiAgICAgICAgICBmdWxsU3VmZml4ID0gdW5pdC5zeW1ib2wgKyBzdWZmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgKj0gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0eXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICB2YXIgaSA9IHZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKSwgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgdmFyIGogPSBleHBvbmVudCA/IHZhbHVlLmxhc3RJbmRleE9mKFwiZVwiKSA6IC0xO1xuICAgICAgICAgIGlmIChqIDwgMCkgYmVmb3JlID0gdmFsdWUsIGFmdGVyID0gXCJcIjsgZWxzZSBiZWZvcmUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgaiksIGFmdGVyID0gdmFsdWUuc3Vic3RyaW5nKGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IHZhbHVlLnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgICBhZnRlciA9IGxvY2FsZV9kZWNpbWFsICsgdmFsdWUuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpmaWxsICYmIGNvbW1hKSBiZWZvcmUgPSBmb3JtYXRHcm91cChiZWZvcmUsIEluZmluaXR5KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByZWZpeC5sZW5ndGggKyBiZWZvcmUubGVuZ3RoICsgYWZ0ZXIubGVuZ3RoICsgKHpjb21tYSA/IDAgOiBuZWdhdGl2ZS5sZW5ndGgpLCBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkobGVuZ3RoID0gd2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcbiAgICAgICAgaWYgKHpjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAocGFkZGluZyArIGJlZm9yZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIGFmdGVyLmxlbmd0aCA6IEluZmluaXR5KTtcbiAgICAgICAgbmVnYXRpdmUgKz0gcHJlZml4O1xuICAgICAgICB2YWx1ZSA9IGJlZm9yZSArIGFmdGVyO1xuICAgICAgICByZXR1cm4gKGFsaWduID09PSBcIjxcIiA/IG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nIDogYWxpZ24gPT09IFwiPlwiID8gcGFkZGluZyArIG5lZ2F0aXZlICsgdmFsdWUgOiBhbGlnbiA9PT0gXCJeXCIgPyBwYWRkaW5nLnN1YnN0cmluZygwLCBsZW5ndGggPj49IDEpICsgbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmcuc3Vic3RyaW5nKGxlbmd0aCkgOiBuZWdhdGl2ZSArICh6Y29tbWEgPyB2YWx1ZSA6IHBhZGRpbmcgKyB2YWx1ZSkpICsgZnVsbFN1ZmZpeDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZm9ybWF0X3JlID0gLyg/OihbXntdKT8oWzw+PV5dKSk/KFsrXFwtIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuLT9cXGQrKT8oW2EteiVdKT8vaTtcbiAgdmFyIGQzX2Zvcm1hdF90eXBlcyA9IGQzLm1hcCh7XG4gICAgYjogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMik7XG4gICAgfSxcbiAgICBjOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDgpO1xuICAgIH0sXG4gICAgeDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpO1xuICAgIH0sXG4gICAgWDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBnOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b1ByZWNpc2lvbihwKTtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKHApO1xuICAgIH0sXG4gICAgcjogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuICh4ID0gZDMucm91bmQoeCwgZDNfZm9ybWF0X3ByZWNpc2lvbih4LCBwKSkpLnRvRml4ZWQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCAqICgxICsgMWUtMTUpLCBwKSkpKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBkM19mb3JtYXRfdHlwZURlZmF1bHQoeCkge1xuICAgIHJldHVybiB4ICsgXCJcIjtcbiAgfVxuICB2YXIgZDNfdGltZSA9IGQzLnRpbWUgPSB7fSwgZDNfZGF0ZSA9IERhdGU7XG4gIGZ1bmN0aW9uIGQzX2RhdGVfdXRjKCkge1xuICAgIHRoaXMuXyA9IG5ldyBEYXRlKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gRGF0ZS5VVEMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXSk7XG4gIH1cbiAgZDNfZGF0ZV91dGMucHJvdG90eXBlID0ge1xuICAgIGdldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENEYXRlKCk7XG4gICAgfSxcbiAgICBnZXREYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENEYXkoKTtcbiAgICB9LFxuICAgIGdldEZ1bGxZZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9LFxuICAgIGdldEhvdXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDSG91cnMoKTtcbiAgICB9LFxuICAgIGdldE1pbGxpc2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIH0sXG4gICAgZ2V0TWludXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01pbnV0ZXMoKTtcbiAgICB9LFxuICAgIGdldE1vbnRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTW9udGgoKTtcbiAgICB9LFxuICAgIGdldFNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENTZWNvbmRzKCk7XG4gICAgfSxcbiAgICBnZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgZ2V0VGltZXpvbmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8udmFsdWVPZigpO1xuICAgIH0sXG4gICAgc2V0RGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENEYXRlLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldERheTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENEYXkuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0RnVsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRnVsbFllYXIuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0SG91cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDSG91cnMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TWlsbGlzZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01pbGxpc2Vjb25kcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNaW51dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01pbnV0ZXMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTW9udGguYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0U2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENTZWNvbmRzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VGltZS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfdGltZV9wcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbiAgZnVuY3Rpb24gZDNfdGltZV9pbnRlcnZhbChsb2NhbCwgc3RlcCwgbnVtYmVyKSB7XG4gICAgZnVuY3Rpb24gcm91bmQoZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbG9jYWwoZGF0ZSksIGQxID0gb2Zmc2V0KGQwLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZWlsKGRhdGUpIHtcbiAgICAgIHN0ZXAoZGF0ZSA9IGxvY2FsKG5ldyBkM19kYXRlKGRhdGUgLSAxKSksIDEpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9mZnNldChkYXRlLCBrKSB7XG4gICAgICBzdGVwKGRhdGUgPSBuZXcgZDNfZGF0ZSgrZGF0ZSksIGspO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlKHQwLCB0MSwgZHQpIHtcbiAgICAgIHZhciB0aW1lID0gY2VpbCh0MCksIHRpbWVzID0gW107XG4gICAgICBpZiAoZHQgPiAxKSB7XG4gICAgICAgIHdoaWxlICh0aW1lIDwgdDEpIHtcbiAgICAgICAgICBpZiAoIShudW1iZXIodGltZSkgJSBkdCkpIHRpbWVzLnB1c2gobmV3IERhdGUoK3RpbWUpKTtcbiAgICAgICAgICBzdGVwKHRpbWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAodGltZSA8IHQxKSB0aW1lcy5wdXNoKG5ldyBEYXRlKCt0aW1lKSksIHN0ZXAodGltZSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlX3V0Yyh0MCwgdDEsIGR0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZV91dGMoKTtcbiAgICAgICAgdXRjLl8gPSB0MDtcbiAgICAgICAgcmV0dXJuIHJhbmdlKHV0YywgdDEsIGR0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2NhbC5mbG9vciA9IGxvY2FsO1xuICAgIGxvY2FsLnJvdW5kID0gcm91bmQ7XG4gICAgbG9jYWwuY2VpbCA9IGNlaWw7XG4gICAgbG9jYWwub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxvY2FsLnJhbmdlID0gcmFuZ2U7XG4gICAgdmFyIHV0YyA9IGxvY2FsLnV0YyA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKGxvY2FsKTtcbiAgICB1dGMuZmxvb3IgPSB1dGM7XG4gICAgdXRjLnJvdW5kID0gZDNfdGltZV9pbnRlcnZhbF91dGMocm91bmQpO1xuICAgIHV0Yy5jZWlsID0gZDNfdGltZV9pbnRlcnZhbF91dGMoY2VpbCk7XG4gICAgdXRjLm9mZnNldCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKG9mZnNldCk7XG4gICAgdXRjLnJhbmdlID0gcmFuZ2VfdXRjO1xuICAgIHJldHVybiBsb2NhbDtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2ludGVydmFsX3V0YyhtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGVfdXRjKCk7XG4gICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgcmV0dXJuIG1ldGhvZCh1dGMsIGspLl87XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzX3RpbWUueWVhciA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUgPSBkM190aW1lLmRheShkYXRlKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIHJldHVybiBkYXRlO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9KTtcbiAgZDNfdGltZS55ZWFycyA9IGQzX3RpbWUueWVhci5yYW5nZTtcbiAgZDNfdGltZS55ZWFycy51dGMgPSBkM190aW1lLnllYXIudXRjLnJhbmdlO1xuICBkM190aW1lLmRheSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkYXkgPSBuZXcgZDNfZGF0ZSgyZTMsIDApO1xuICAgIGRheS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgIHJldHVybiBkYXk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCkgLSAxO1xuICB9KTtcbiAgZDNfdGltZS5kYXlzID0gZDNfdGltZS5kYXkucmFuZ2U7XG4gIGQzX3RpbWUuZGF5cy51dGMgPSBkM190aW1lLmRheS51dGMucmFuZ2U7XG4gIGQzX3RpbWUuZGF5T2ZZZWFyID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciB5ZWFyID0gZDNfdGltZS55ZWFyKGRhdGUpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlIC0geWVhciAtIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLSB5ZWFyLmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1KTtcbiAgfTtcbiAgWyBcInN1bmRheVwiLCBcIm1vbmRheVwiLCBcInR1ZXNkYXlcIiwgXCJ3ZWRuZXNkYXlcIiwgXCJ0aHVyc2RheVwiLCBcImZyaWRheVwiLCBcInNhdHVyZGF5XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKGRheSwgaSkge1xuICAgIGkgPSA3IC0gaTtcbiAgICB2YXIgaW50ZXJ2YWwgPSBkM190aW1lW2RheV0gPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIChkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSkpLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIGkpICUgNyk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkYXkgPSBkM190aW1lLnllYXIoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZDNfdGltZS5kYXlPZlllYXIoZGF0ZSkgKyAoZGF5ICsgaSkgJSA3KSAvIDcpIC0gKGRheSAhPT0gaSk7XG4gICAgfSk7XG4gICAgZDNfdGltZVtkYXkgKyBcInNcIl0gPSBpbnRlcnZhbC5yYW5nZTtcbiAgICBkM190aW1lW2RheSArIFwic1wiXS51dGMgPSBpbnRlcnZhbC51dGMucmFuZ2U7XG4gICAgZDNfdGltZVtkYXkgKyBcIk9mWWVhclwiXSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkYXkgPSBkM190aW1lLnllYXIoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZDNfdGltZS5kYXlPZlllYXIoZGF0ZSkgKyAoZGF5ICsgaSkgJSA3KSAvIDcpO1xuICAgIH07XG4gIH0pO1xuICBkM190aW1lLndlZWsgPSBkM190aW1lLnN1bmRheTtcbiAgZDNfdGltZS53ZWVrcyA9IGQzX3RpbWUuc3VuZGF5LnJhbmdlO1xuICBkM190aW1lLndlZWtzLnV0YyA9IGQzX3RpbWUuc3VuZGF5LnV0Yy5yYW5nZTtcbiAgZDNfdGltZS53ZWVrT2ZZZWFyID0gZDNfdGltZS5zdW5kYXlPZlllYXI7XG4gIGZ1bmN0aW9uIGQzX2xvY2FsZV90aW1lRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsIGxvY2FsZV9kYXRlID0gbG9jYWxlLmRhdGUsIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsIGxvY2FsZV9kYXlzID0gbG9jYWxlLmRheXMsIGxvY2FsZV9zaG9ydERheXMgPSBsb2NhbGUuc2hvcnREYXlzLCBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocywgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKSB7XG4gICAgICB2YXIgbiA9IHRlbXBsYXRlLmxlbmd0aDtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBbXSwgaSA9IC0xLCBqID0gMCwgYywgcCwgZjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKHRlbXBsYXRlLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICAgIGlmICgocCA9IGQzX3RpbWVfZm9ybWF0UGFkc1tjID0gdGVtcGxhdGUuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gdGVtcGxhdGUuY2hhckF0KCsraSk7XG4gICAgICAgICAgICBpZiAoZiA9IGQzX3RpbWVfZm9ybWF0c1tjXSkgYyA9IGYoZGF0ZSwgcCA9PSBudWxsID8gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiIDogcCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nLnB1c2godGVtcGxhdGUuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICBmb3JtYXQucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgeTogMTkwMCxcbiAgICAgICAgICBtOiAwLFxuICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgSDogMCxcbiAgICAgICAgICBNOiAwLFxuICAgICAgICAgIFM6IDAsXG4gICAgICAgICAgTDogMCxcbiAgICAgICAgICBaOiBudWxsXG4gICAgICAgIH0sIGkgPSBkM190aW1lX3BhcnNlKGQsIHRlbXBsYXRlLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG4gICAgICAgIHZhciBsb2NhbFogPSBkLlogIT0gbnVsbCAmJiBkM19kYXRlICE9PSBkM19kYXRlX3V0YywgZGF0ZSA9IG5ldyAobG9jYWxaID8gZDNfZGF0ZV91dGMgOiBkM19kYXRlKSgpO1xuICAgICAgICBpZiAoXCJqXCIgaW4gZCkgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIGQuaik7IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIDEpO1xuICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDYpICUgNyk7XG4gICAgICAgIH0gZWxzZSBkYXRlLnNldEZ1bGxZZWFyKGQueSwgZC5tLCBkLmQpO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGQuSCArIChkLlogLyAxMDAgfCAwKSwgZC5NICsgZC5aICUgMTAwLCBkLlMsIGQuTCk7XG4gICAgICAgIHJldHVybiBsb2NhbFogPyBkYXRlLl8gOiBkYXRlO1xuICAgICAgfTtcbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZShkYXRlLCB0ZW1wbGF0ZSwgc3RyaW5nLCBqKSB7XG4gICAgICB2YXIgYywgcCwgdCwgaSA9IDAsIG4gPSB0ZW1wbGF0ZS5sZW5ndGgsIG0gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgICAgYyA9IHRlbXBsYXRlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgdCA9IHRlbXBsYXRlLmNoYXJBdChpKyspO1xuICAgICAgICAgIHAgPSBkM190aW1lX3BhcnNlcnNbdCBpbiBkM190aW1lX2Zvcm1hdFBhZHMgPyB0ZW1wbGF0ZS5jaGFyQXQoaSsrKSA6IHRdO1xuICAgICAgICAgIGlmICghcCB8fCAoaiA9IHAoZGF0ZSwgc3RyaW5nLCBqKSkgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgICB9XG4gICAgZDNfdGltZV9mb3JtYXQudXRjID0gZnVuY3Rpb24odGVtcGxhdGUpIHtcbiAgICAgIHZhciBsb2NhbCA9IGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKTtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZSgpO1xuICAgICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgICByZXR1cm4gbG9jYWwodXRjKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciBkYXRlID0gbG9jYWwucGFyc2Uoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZSAmJiBkYXRlLl87XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBsb2NhbC50b1N0cmluZztcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBkM190aW1lX2Zvcm1hdC5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0LnV0Yy5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0TXVsdGk7XG4gICAgdmFyIGQzX3RpbWVfcGVyaW9kTG9va3VwID0gZDMubWFwKCksIGQzX3RpbWVfZGF5UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9kYXlzKSwgZDNfdGltZV9kYXlMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfZGF5cyksIGQzX3RpbWVfZGF5QWJicmV2UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX2RheUFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX21vbnRoUmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9tb250aHMpLCBkM190aW1lX21vbnRoTG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksIGQzX3RpbWVfbW9udGhBYmJyZXZSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSwgZDNfdGltZV9tb250aEFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG4gICAgbG9jYWxlX3BlcmlvZHMuZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG4gICAgICBkM190aW1lX3BlcmlvZExvb2t1cC5zZXQocC50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICB9KTtcbiAgICB2YXIgZDNfdGltZV9mb3JtYXRzID0ge1xuICAgICAgYTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3Nob3J0RGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBBOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfZGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBiOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICAgIH0sXG4gICAgICBCOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgICB9LFxuICAgICAgYzogZDNfdGltZV9mb3JtYXQobG9jYWxlX2RhdGVUaW1lKSxcbiAgICAgIGQ6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgSDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBJOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gICAgICB9LFxuICAgICAgajogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoMSArIGQzX3RpbWUuZGF5T2ZZZWFyKGQpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgcDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgVTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5zdW5kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gICAgICB9LFxuICAgICAgVzogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5tb25kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV9kYXRlKSxcbiAgICAgIFg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV90aW1lKSxcbiAgICAgIHk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gICAgICB9LFxuICAgICAgWTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRGdWxsWWVhcigpICUgMWU0LCBwLCA0KTtcbiAgICAgIH0sXG4gICAgICBaOiBkM190aW1lX3pvbmUsXG4gICAgICBcIiVcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkM190aW1lX3BhcnNlcnMgPSB7XG4gICAgICBhOiBkM190aW1lX3BhcnNlV2Vla2RheUFiYnJldixcbiAgICAgIEE6IGQzX3RpbWVfcGFyc2VXZWVrZGF5LFxuICAgICAgYjogZDNfdGltZV9wYXJzZU1vbnRoQWJicmV2LFxuICAgICAgQjogZDNfdGltZV9wYXJzZU1vbnRoLFxuICAgICAgYzogZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwsXG4gICAgICBkOiBkM190aW1lX3BhcnNlRGF5LFxuICAgICAgZTogZDNfdGltZV9wYXJzZURheSxcbiAgICAgIEg6IGQzX3RpbWVfcGFyc2VIb3VyMjQsXG4gICAgICBJOiBkM190aW1lX3BhcnNlSG91cjI0LFxuICAgICAgajogZDNfdGltZV9wYXJzZURheU9mWWVhcixcbiAgICAgIEw6IGQzX3RpbWVfcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBtOiBkM190aW1lX3BhcnNlTW9udGhOdW1iZXIsXG4gICAgICBNOiBkM190aW1lX3BhcnNlTWludXRlcyxcbiAgICAgIHA6IGQzX3RpbWVfcGFyc2VBbVBtLFxuICAgICAgUzogZDNfdGltZV9wYXJzZVNlY29uZHMsXG4gICAgICBVOiBkM190aW1lX3BhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIHc6IGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgVzogZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgICB4OiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFg6IGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgeTogZDNfdGltZV9wYXJzZVllYXIsXG4gICAgICBZOiBkM190aW1lX3BhcnNlRnVsbFllYXIsXG4gICAgICBaOiBkM190aW1lX3BhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5QWJicmV2KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheUFiYnJldlJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5QWJicmV2TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aEFiYnJldihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfbW9udGhBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX21vbnRoQWJicmV2UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gZDNfdGltZV9tb250aEFiYnJldkxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGgoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX21vbnRoUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9tb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUubSA9IGQzX3RpbWVfbW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMuYy50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy54LnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLlgudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUFtUG0oZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkYXRlLnAgPSBuLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0O1xuICB9XG4gIHZhciBkM190aW1lX2Zvcm1hdFBhZHMgPSB7XG4gICAgXCItXCI6IFwiXCIsXG4gICAgXzogXCIgXCIsXG4gICAgXCIwXCI6IFwiMFwiXG4gIH0sIGQzX3RpbWVfbnVtYmVyUmUgPSAvXlxccypcXGQrLywgZDNfdGltZV9wZXJjZW50UmUgPSAvXiUvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdFBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIiwgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKGQzLnJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgbWFwLnNldChuYW1lc1tpXS50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRnVsbFllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9IGQzX3RpbWVfZXhwYW5kWWVhcigrblswXSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlWm9uZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gL15bKy1dXFxkezR9JC8udGVzdChzdHJpbmcgPSBzdHJpbmcuc2xpY2UoaSwgaSArIDUpKSA/IChkYXRlLlogPSAtc3RyaW5nLCBcbiAgICBpICsgNSkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2V4cGFuZFllYXIoZCkge1xuICAgIHJldHVybiBkICsgKGQgPiA2OCA/IDE5MDAgOiAyZTMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aE51bWJlcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VEYXlPZlllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGRhdGUuaiA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUhvdXIyNChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWludXRlcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlU2Vjb25kcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWlsbGlzZWNvbmRzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfem9uZShkKSB7XG4gICAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCksIHpzID0geiA+IDAgPyBcIi1cIiA6IFwiK1wiLCB6aCA9IGFicyh6KSAvIDYwIHwgMCwgem0gPSBhYnMoeikgJSA2MDtcbiAgICByZXR1cm4genMgKyBkM190aW1lX2Zvcm1hdFBhZCh6aCwgXCIwXCIsIDIpICsgZDNfdGltZV9mb3JtYXRQYWQoem0sIFwiMFwiLCAyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnQoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9wZXJjZW50UmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdE11bHRpKGZvcm1hdHMpIHtcbiAgICB2YXIgbiA9IGZvcm1hdHMubGVuZ3RoLCBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IG4pIGZvcm1hdHNbaV1bMF0gPSB0aGlzKGZvcm1hdHNbaV1bMF0pO1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgaSA9IDAsIGYgPSBmb3JtYXRzW2ldO1xuICAgICAgd2hpbGUgKCFmWzFdKGRhdGUpKSBmID0gZm9ybWF0c1srK2ldO1xuICAgICAgcmV0dXJuIGZbMF0oZGF0ZSk7XG4gICAgfTtcbiAgfVxuICBkMy5sb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyRm9ybWF0OiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSksXG4gICAgICB0aW1lRm9ybWF0OiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpXG4gICAgfTtcbiAgfTtcbiAgdmFyIGQzX2xvY2FsZV9lblVTID0gZDMubG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbIDMgXSxcbiAgICBjdXJyZW5jeTogWyBcIiRcIiwgXCJcIiBdLFxuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbIFwiQU1cIiwgXCJQTVwiIF0sXG4gICAgZGF5czogWyBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIgXSxcbiAgICBzaG9ydERheXM6IFsgXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiBdLFxuICAgIG1vbnRoczogWyBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIgXSxcbiAgICBzaG9ydE1vbnRoczogWyBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiIF1cbiAgfSk7XG4gIGQzLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLm51bWJlckZvcm1hdDtcbiAgZDMuZ2VvID0ge307XG4gIGZ1bmN0aW9uIGQzX2FkZGVyKCkge31cbiAgZDNfYWRkZXIucHJvdG90eXBlID0ge1xuICAgIHM6IDAsXG4gICAgdDogMCxcbiAgICBhZGQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgIGQzX2FkZGVyU3VtKHksIHRoaXMudCwgZDNfYWRkZXJUZW1wKTtcbiAgICAgIGQzX2FkZGVyU3VtKGQzX2FkZGVyVGVtcC5zLCB0aGlzLnMsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMucykgdGhpcy50ICs9IGQzX2FkZGVyVGVtcC50OyBlbHNlIHRoaXMucyA9IGQzX2FkZGVyVGVtcC50O1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zID0gdGhpcy50ID0gMDtcbiAgICB9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9XG4gIH07XG4gIHZhciBkM19hZGRlclRlbXAgPSBuZXcgZDNfYWRkZXIoKTtcbiAgZnVuY3Rpb24gZDNfYWRkZXJTdW0oYSwgYiwgbykge1xuICAgIHZhciB4ID0gby5zID0gYSArIGIsIGJ2ID0geCAtIGEsIGF2ID0geCAtIGJ2O1xuICAgIG8udCA9IGEgLSBhdiArIChiIC0gYnYpO1xuICB9XG4gIGQzLmdlby5zdHJlYW0gPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgaWYgKG9iamVjdCAmJiBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KG9iamVjdCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBsaXN0ZW5lcikge1xuICAgIGlmIChnZW9tZXRyeSAmJiBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIHZhciBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgICBGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIHZhciBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICAgIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIuc3BoZXJlKCk7XG4gICAgfSxcbiAgICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgICAgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCBjbG9zZWQpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIsIDEpO1xuICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgfVxuICBkMy5nZW8uYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19hcmVhU3VtID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2FyZWEpO1xuICAgIHJldHVybiBkM19nZW9fYXJlYVN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19hcmVhU3VtLCBkM19nZW9fYXJlYVJpbmdTdW0gPSBuZXcgZDNfYWRkZXIoKTtcbiAgdmFyIGQzX2dlb19hcmVhID0ge1xuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fYXJlYVN1bSArPSA0ICogz4A7XG4gICAgfSxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQgPSBkM19nZW9fYXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZWEgPSAyICogZDNfZ2VvX2FyZWFSaW5nU3VtO1xuICAgICAgZDNfZ2VvX2FyZWFTdW0gKz0gYXJlYSA8IDAgPyA0ICogz4AgKyBhcmVhIDogYXJlYTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCA9IGQzX2dlb19hcmVhLmxpbmVFbmQgPSBkM19nZW9fYXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fYXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgzrswLCBjb3PPhjAsIHNpbs+GMDtcbiAgICBkM19nZW9fYXJlYS5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgZDNfZ2VvX2FyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICDOuzAgPSAozrswMCA9IM67KSAqIGQzX3JhZGlhbnMsIGNvc8+GMCA9IE1hdGguY29zKM+GID0gKM+GMDAgPSDPhikgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNCksIFxuICAgICAgc2luz4YwID0gTWF0aC5zaW4oz4YpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIM+GID0gz4YgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNDtcbiAgICAgIHZhciBkzrsgPSDOuyAtIM67MCwgc2TOuyA9IGTOuyA+PSAwID8gMSA6IC0xLCBhZM67ID0gc2TOuyAqIGTOuywgY29zz4YgPSBNYXRoLmNvcyjPhiksIHNpbs+GID0gTWF0aC5zaW4oz4YpLCBrID0gc2luz4YwICogc2luz4YsIHUgPSBjb3PPhjAgKiBjb3PPhiArIGsgKiBNYXRoLmNvcyhhZM67KSwgdiA9IGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyk7XG4gICAgICBkM19nZW9fYXJlYVJpbmdTdW0uYWRkKE1hdGguYXRhbjIodiwgdSkpO1xuICAgICAgzrswID0gzrssIGNvc8+GMCA9IGNvc8+GLCBzaW7PhjAgPSBzaW7PhjtcbiAgICB9XG4gICAgZDNfZ2VvX2FyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KM67MDAsIM+GMDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgICB2YXIgzrsgPSBzcGhlcmljYWxbMF0sIM+GID0gc3BoZXJpY2FsWzFdLCBjb3PPhiA9IE1hdGguY29zKM+GKTtcbiAgICByZXR1cm4gWyBjb3PPhiAqIE1hdGguY29zKM67KSwgY29zz4YgKiBNYXRoLnNpbijOuyksIE1hdGguc2luKM+GKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgICByZXR1cm4gWyBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkFkZChhLCBiKSB7XG4gICAgYVswXSArPSBiWzBdO1xuICAgIGFbMV0gKz0gYlsxXTtcbiAgICBhWzJdICs9IGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICAgIHJldHVybiBbIHZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGsgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGQpIHtcbiAgICB2YXIgbCA9IE1hdGguc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICAgIGRbMF0gLz0gbDtcbiAgICBkWzFdIC89IGw7XG4gICAgZFsyXSAvPSBsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5hdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGQzX2FzaW4oY2FydGVzaWFuWzJdKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWxFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCDOtSAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgzrU7XG4gIH1cbiAgZDMuZ2VvLmJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciDOuzAsIM+GMCwgzrsxLCDPhjEsIM67XywgzrtfXywgz4ZfXywgcDAsIGTOu1N1bSwgcmFuZ2VzLCByYW5nZTtcbiAgICB2YXIgYm91bmQgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBib3VuZC5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgZM67U3VtID0gMDtcbiAgICAgICAgZDNfZ2VvX2FyZWEucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzX2dlb19hcmVhLnBvbHlnb25FbmQoKTtcbiAgICAgICAgYm91bmQucG9pbnQgPSBwb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgaWYgKGQzX2dlb19hcmVhUmluZ1N1bSA8IDApIM67MCA9IC0ozrsxID0gMTgwKSwgz4YwID0gLSjPhjEgPSA5MCk7IGVsc2UgaWYgKGTOu1N1bSA+IM61KSDPhjEgPSA5MDsgZWxzZSBpZiAoZM67U3VtIDwgLc61KSDPhjAgPSAtOTA7XG4gICAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KM67LCDPhikge1xuICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbIM67MCA9IM67LCDOuzEgPSDOuyBdKTtcbiAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICBpZiAoz4YgPiDPhjEpIM+GMSA9IM+GO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgcCA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuyAqIGQzX3JhZGlhbnMsIM+GICogZDNfcmFkaWFucyBdKTtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgbm9ybWFsID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHAwLCBwKSwgZXF1YXRvcmlhbCA9IFsgbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwIF0sIGluZmxlY3Rpb24gPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShpbmZsZWN0aW9uKTtcbiAgICAgICAgaW5mbGVjdGlvbiA9IGQzX2dlb19zcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgICAgIHZhciBkzrsgPSDOuyAtIM67XywgcyA9IGTOuyA+IDAgPyAxIDogLTEsIM67aSA9IGluZmxlY3Rpb25bMF0gKiBkM19kZWdyZWVzICogcywgYW50aW1lcmlkaWFuID0gYWJzKGTOuykgPiAxODA7XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiAocyAqIM67XyA8IM67aSAmJiDOu2kgPCBzICogzrspKSB7XG4gICAgICAgICAgdmFyIM+GaSA9IGluZmxlY3Rpb25bMV0gKiBkM19kZWdyZWVzO1xuICAgICAgICAgIGlmICjPhmkgPiDPhjEpIM+GMSA9IM+GaTtcbiAgICAgICAgfSBlbHNlIGlmICjOu2kgPSAozrtpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHMgKiDOu18gPCDOu2kgJiYgzrtpIDwgcyAqIM67KSkge1xuICAgICAgICAgIHZhciDPhmkgPSAtaW5mbGVjdGlvblsxXSAqIGQzX2RlZ3JlZXM7XG4gICAgICAgICAgaWYgKM+GaSA8IM+GMCkgz4YwID0gz4ZpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICAgICAgaWYgKM+GID4gz4YxKSDPhjEgPSDPhjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICAgICAgaWYgKM67IDwgzrtfKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrssIM67MSkgPiBhbmdsZSjOuzAsIM67MSkpIM67MCA9IM67O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAozrsxID49IM67MCkge1xuICAgICAgICAgICAgaWYgKM67IDwgzrswKSDOuzAgPSDOuztcbiAgICAgICAgICAgIGlmICjOuyA+IM67MSkgzrsxID0gzrs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICjOuyA+IM67Xykge1xuICAgICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ2xlKM67LCDOuzEpID4gYW5nbGUozrswLCDOuzEpKSDOuzAgPSDOuztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBwMCA9IHAsIM67XyA9IM67O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBib3VuZC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIGJvdW5kLnBvaW50ID0gcG9pbnQ7XG4gICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgZM67ID0gzrsgLSDOu187XG4gICAgICAgIGTOu1N1bSArPSBhYnMoZM67KSA+IDE4MCA/IGTOuyArIChkzrsgPiAwID8gMzYwIDogLTM2MCkgOiBkzrs7XG4gICAgICB9IGVsc2UgzrtfXyA9IM67LCDPhl9fID0gz4Y7XG4gICAgICBkM19nZW9fYXJlYS5wb2ludCjOuywgz4YpO1xuICAgICAgbGluZVBvaW50KM67LCDPhik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmluZ1BvaW50KM67X18sIM+GX18pO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZUVuZCgpO1xuICAgICAgaWYgKGFicyhkzrtTdW0pID4gzrUpIM67MCA9IC0ozrsxID0gMTgwKTtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW5nbGUozrswLCDOuzEpIHtcbiAgICAgIHJldHVybiAozrsxIC09IM67MCkgPCAwID8gzrsxICsgMzYwIDogzrsxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUmFuZ2VzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aGluUmFuZ2UoeCwgcmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICDPhjEgPSDOuzEgPSAtKM67MCA9IM+GMCA9IEluZmluaXR5KTtcbiAgICAgIHJhbmdlcyA9IFtdO1xuICAgICAgZDMuZ2VvLnN0cmVhbShmZWF0dXJlLCBib3VuZCk7XG4gICAgICB2YXIgbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAobikge1xuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGEgPSByYW5nZXNbMF0sIGIsIG1lcmdlZCA9IFsgYSBdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAod2l0aGluUmFuZ2UoYlswXSwgYSkgfHwgd2l0aGluUmFuZ2UoYlsxXSwgYSkpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzFdID0gYlsxXTtcbiAgICAgICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVzdCA9IC1JbmZpbml0eSwgZM67O1xuICAgICAgICBmb3IgKHZhciBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dLCBiOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgICAgICBiID0gbWVyZ2VkW2ldO1xuICAgICAgICAgIGlmICgoZM67ID0gYW5nbGUoYVsxXSwgYlswXSkpID4gYmVzdCkgYmVzdCA9IGTOuywgzrswID0gYlswXSwgzrsxID0gYVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFuZ2VzID0gcmFuZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuIM67MCA9PT0gSW5maW5pdHkgfHwgz4YwID09PSBJbmZpbml0eSA/IFsgWyBOYU4sIE5hTiBdLCBbIE5hTiwgTmFOIF0gXSA6IFsgWyDOuzAsIM+GMCBdLCBbIM67MSwgz4YxIF0gXTtcbiAgICB9O1xuICB9KCk7XG4gIGQzLmdlby5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19jZW50cm9pZFcwID0gZDNfZ2VvX2NlbnRyb2lkVzEgPSBkM19nZW9fY2VudHJvaWRYMCA9IGQzX2dlb19jZW50cm9pZFkwID0gZDNfZ2VvX2NlbnRyb2lkWjAgPSBkM19nZW9fY2VudHJvaWRYMSA9IGQzX2dlb19jZW50cm9pZFkxID0gZDNfZ2VvX2NlbnRyb2lkWjEgPSBkM19nZW9fY2VudHJvaWRYMiA9IGQzX2dlb19jZW50cm9pZFkyID0gZDNfZ2VvX2NlbnRyb2lkWjIgPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fY2VudHJvaWQpO1xuICAgIHZhciB4ID0gZDNfZ2VvX2NlbnRyb2lkWDIsIHkgPSBkM19nZW9fY2VudHJvaWRZMiwgeiA9IGQzX2dlb19jZW50cm9pZFoyLCBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIGlmIChtIDwgzrUyKSB7XG4gICAgICB4ID0gZDNfZ2VvX2NlbnRyb2lkWDEsIHkgPSBkM19nZW9fY2VudHJvaWRZMSwgeiA9IGQzX2dlb19jZW50cm9pZFoxO1xuICAgICAgaWYgKGQzX2dlb19jZW50cm9pZFcxIDwgzrUpIHggPSBkM19nZW9fY2VudHJvaWRYMCwgeSA9IGQzX2dlb19jZW50cm9pZFkwLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjA7XG4gICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgaWYgKG0gPCDOtTIpIHJldHVybiBbIE5hTiwgTmFOIF07XG4gICAgfVxuICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBkM19hc2luKHogLyBNYXRoLnNxcnQobSkpICogZDNfZGVncmVlcyBdO1xuICB9O1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkVzAsIGQzX2dlb19jZW50cm9pZFcxLCBkM19nZW9fY2VudHJvaWRYMCwgZDNfZ2VvX2NlbnRyb2lkWTAsIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRYMSwgZDNfZ2VvX2NlbnRyb2lkWTEsIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRYMiwgZDNfZ2VvX2NlbnRyb2lkWTIsIGQzX2dlb19jZW50cm9pZFoyO1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfZ2VvX2NlbnRyb2lkUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX2NlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZExpbmVTdGFydDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50KM67LCDPhikge1xuICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooY29zz4YgKiBNYXRoLmNvcyjOuyksIGNvc8+GICogTWF0aC5zaW4ozrspLCBNYXRoLnNpbijPhikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgsIHksIHopIHtcbiAgICArK2QzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9ICh4IC0gZDNfZ2VvX2NlbnRyb2lkWDApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0gKHkgLSBkM19nZW9fY2VudHJvaWRZMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRaMCArPSAoeiAtIGQzX2dlb19jZW50cm9pZFowKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICB2YXIgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICAgIHgwID0gY29zz4YgKiBNYXRoLmNvcyjOuyk7XG4gICAgICB5MCA9IGNvc8+GICogTWF0aC5zaW4ozrspO1xuICAgICAgejAgPSBNYXRoLnNpbijPhik7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKSwgeCA9IGNvc8+GICogTWF0aC5jb3MozrspLCB5ID0gY29zz4YgKiBNYXRoLnNpbijOuyksIHogPSBNYXRoLnNpbijPhiksIHcgPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRMaW5lRW5kKCkge1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MDAgPSDOuywgz4YwMCA9IM+GO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgICAgeDAgPSBjb3PPhiAqIE1hdGguY29zKM67KTtcbiAgICAgIHkwID0gY29zz4YgKiBNYXRoLnNpbijOuyk7XG4gICAgICB6MCA9IE1hdGguc2luKM+GKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH07XG4gICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCjOuzAwLCDPhjAwKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX2NlbnRyb2lkTGluZUVuZDtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpLCB4ID0gY29zz4YgKiBNYXRoLmNvcyjOuyksIHkgPSBjb3PPhiAqIE1hdGguc2luKM67KSwgeiA9IE1hdGguc2luKM+GKSwgY3ggPSB5MCAqIHogLSB6MCAqIHksIGN5ID0gejAgKiB4IC0geDAgKiB6LCBjeiA9IHgwICogeSAtIHkwICogeCwgbSA9IE1hdGguc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLCB1ID0geDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6LCB2ID0gbSAmJiAtZDNfYWNvcyh1KSAvIG0sIHcgPSBNYXRoLmF0YW4yKG0sIHUpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDIgKz0gdiAqIGN4O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTIgKz0gdiAqIGN5O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjIgKz0gdiAqIGN6O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29tcG9zZShhLCBiKSB7XG4gICAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gICAgfVxuICAgIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbXBvc2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHN1YmplY3QgPSBbXSwgY2xpcCA9IFtdO1xuICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl07XG4gICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSksIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAwLCBudWxsLCBhLCBmYWxzZSk7XG4gICAgICBhLm8gPSBiO1xuICAgICAgc3ViamVjdC5wdXNoKGEpO1xuICAgICAgY2xpcC5wdXNoKGIpO1xuICAgICAgYSA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKTtcbiAgICAgIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAxLCBudWxsLCBhLCB0cnVlKTtcbiAgICAgIGEubyA9IGI7XG4gICAgICBzdWJqZWN0LnB1c2goYSk7XG4gICAgICBjbGlwLnB1c2goYik7XG4gICAgfSk7XG4gICAgY2xpcC5zb3J0KGNvbXBhcmUpO1xuICAgIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihzdWJqZWN0KTtcbiAgICBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoY2xpcCk7XG4gICAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeSA9IGNsaXBTdGFydEluc2lkZSwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjbGlwW2ldLmUgPSBlbnRyeSA9ICFlbnRyeTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSwgcG9pbnRzLCBwb2ludDtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydCwgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKGFycmF5KSB7XG4gICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgICB2YXIgbiwgaSA9IDAsIGEgPSBhcnJheVswXSwgYjtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgICAgYi5wID0gYTtcbiAgICAgIGEgPSBiO1xuICAgIH1cbiAgICBhLm4gPSBiID0gYXJyYXlbMF07XG4gICAgYi5wID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gICAgdGhpcy54ID0gcG9pbnQ7XG4gICAgdGhpcy56ID0gcG9pbnRzO1xuICAgIHRoaXMubyA9IG90aGVyO1xuICAgIHRoaXMuZSA9IGVudHJ5O1xuICAgIHRoaXMudiA9IGZhbHNlO1xuICAgIHRoaXMubiA9IHRoaXMucCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIGNsaXBTdGFydCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyb3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGluZSA9IGNsaXBMaW5lKGxpc3RlbmVyKSwgcm90YXRlZENsaXBTdGFydCA9IHJvdGF0ZS5pbnZlcnQoY2xpcFN0YXJ0WzBdLCBjbGlwU3RhcnRbMV0pO1xuICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gZDNfZ2VvX3BvaW50SW5Qb2x5Z29uKHJvdGF0ZWRDbGlwU3RhcnQsIHBvbHlnb24pO1xuICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGQzX2dlb19jbGlwU29ydCwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpcFN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCjOuywgz4YpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUozrsgPSBwb2ludFswXSwgz4YgPSBwb2ludFsxXSkpIGxpc3RlbmVyLnBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludExpbmUozrssIM+GKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICBsaW5lLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIHNlZ21lbnRzO1xuICAgICAgdmFyIGJ1ZmZlciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgcmluZ0xpc3RlbmVyID0gY2xpcExpbmUoYnVmZmVyKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSwgcG9seWdvbiwgcmluZztcbiAgICAgIGZ1bmN0aW9uIHBvaW50UmluZyjOuywgz4YpIHtcbiAgICAgICAgcmluZy5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgcmluZ0xpc3RlbmVyLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgcmluZyA9IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgICByaW5nTGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICB2YXIgY2xlYW4gPSByaW5nTGlzdGVuZXIuY2xlYW4oKSwgcmluZ1NlZ21lbnRzID0gYnVmZmVyLmJ1ZmZlcigpLCBzZWdtZW50LCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgcmluZy5wb3AoKTtcbiAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgICByaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKCFuKSByZXR1cm47XG4gICAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICAgIHZhciBuID0gc2VnbWVudC5sZW5ndGggLSAxLCBpID0gLTEsIHBvaW50O1xuICAgICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcihkM19nZW9fY2xpcFNlZ21lbnRMZW5ndGgxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwU2VnbWVudExlbmd0aDEoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpIHtcbiAgICB2YXIgbGluZXMgPSBbXSwgbGluZTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgbGluZS5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgICBidWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbGluZXM7XG4gICAgICAgIGxpbmVzID0gW107XG4gICAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgfSxcbiAgICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFNvcnQoYSwgYikge1xuICAgIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmz4AgLSDOtSA6IGhhbGbPgCAtIGFbMV0pIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZs+AIC0gzrUgOiBoYWxmz4AgLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4gPSBkM19nZW9fY2xpcChkM190cnVlLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUsIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsIFsgLc+ALCAtz4AgLyAyIF0pO1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUobGlzdGVuZXIpIHtcbiAgICB2YXIgzrswID0gTmFOLCDPhjAgPSBOYU4sIHPOuzAgPSBOYU4sIGNsZWFuO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuzEsIM+GMSkge1xuICAgICAgICB2YXIgc867MSA9IM67MSA+IDAgPyDPgCA6IC3PgCwgZM67ID0gYWJzKM67MSAtIM67MCk7XG4gICAgICAgIGlmIChhYnMoZM67IC0gz4ApIDwgzrUpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzAsIM+GMCA9ICjPhjAgKyDPhjEpIC8gMiA+IDAgPyBoYWxmz4AgOiAtaGFsZs+AKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrswLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrsxLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KM67MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc867MCAhPT0gc867MSAmJiBkzrsgPj0gz4ApIHtcbiAgICAgICAgICBpZiAoYWJzKM67MCAtIHPOuzApIDwgzrUpIM67MCAtPSBzzrswICogzrU7XG4gICAgICAgICAgaWYgKGFicyjOuzEgLSBzzrsxKSA8IM61KSDOuzEgLT0gc867MSAqIM61O1xuICAgICAgICAgIM+GMCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KM67MCwgz4YwLCDOuzEsIM+GMSk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MCwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucG9pbnQozrswID0gzrsxLCDPhjAgPSDPhjEpO1xuICAgICAgICBzzrswID0gc867MTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICDOuzAgPSDPhjAgPSBOYU47XG4gICAgICB9LFxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMiAtIGNsZWFuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QozrswLCDPhjAsIM67MSwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCwgY29zz4YxLCBzaW7OuzBfzrsxID0gTWF0aC5zaW4ozrswIC0gzrsxKTtcbiAgICByZXR1cm4gYWJzKHNpbs67MF/OuzEpID4gzrUgPyBNYXRoLmF0YW4oKE1hdGguc2luKM+GMCkgKiAoY29zz4YxID0gTWF0aC5jb3Moz4YxKSkgKiBNYXRoLnNpbijOuzEpIC0gTWF0aC5zaW4oz4YxKSAqIChjb3PPhjAgPSBNYXRoLmNvcyjPhjApKSAqIE1hdGguc2luKM67MCkpIC8gKGNvc8+GMCAqIGNvc8+GMSAqIHNpbs67MF/OuzEpKSA6ICjPhjAgKyDPhjEpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgdmFyIM+GO1xuICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogaGFsZs+AO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIDApO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAwKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgz4YpO1xuICAgIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiDOtSkge1xuICAgICAgdmFyIHMgPSBmcm9tWzBdIDwgdG9bMF0gPyDPgCA6IC3PgDtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogcyAvIDI7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtcywgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQocywgz4YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgICB2YXIgbWVyaWRpYW4gPSBwb2ludFswXSwgcGFyYWxsZWwgPSBwb2ludFsxXSwgbWVyaWRpYW5Ob3JtYWwgPSBbIE1hdGguc2luKG1lcmlkaWFuKSwgLU1hdGguY29zKG1lcmlkaWFuKSwgMCBdLCBwb2xhckFuZ2xlID0gMCwgd2luZGluZyA9IDA7XG4gICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBtID0gcmluZy5sZW5ndGg7XG4gICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgdmFyIHBvaW50MCA9IHJpbmdbMF0sIM67MCA9IHBvaW50MFswXSwgz4YwID0gcG9pbnQwWzFdIC8gMiArIM+AIC8gNCwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgaiA9IDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaiA9PT0gbSkgaiA9IDA7XG4gICAgICAgIHBvaW50ID0gcmluZ1tqXTtcbiAgICAgICAgdmFyIM67ID0gcG9pbnRbMF0sIM+GID0gcG9pbnRbMV0gLyAyICsgz4AgLyA0LCBzaW7PhiA9IE1hdGguc2luKM+GKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGTOuyA9IM67IC0gzrswLCBzZM67ID0gZM67ID49IDAgPyAxIDogLTEsIGFkzrsgPSBzZM67ICogZM67LCBhbnRpbWVyaWRpYW4gPSBhZM67ID4gz4AsIGsgPSBzaW7PhjAgKiBzaW7PhjtcbiAgICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLmFkZChNYXRoLmF0YW4yKGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyksIGNvc8+GMCAqIGNvc8+GICsgayAqIE1hdGguY29zKGFkzrspKSk7XG4gICAgICAgIHBvbGFyQW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZM67ICsgc2TOuyAqIM+EIDogZM67O1xuICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gzrswID49IG1lcmlkaWFuIF4gzrsgPj0gbWVyaWRpYW4pIHtcbiAgICAgICAgICB2YXIgYXJjID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQwKSwgZDNfZ2VvX2NhcnRlc2lhbihwb2ludCkpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoYXJjKTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG1lcmlkaWFuTm9ybWFsLCBhcmMpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICB2YXIgz4ZhcmMgPSAoYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAtMSA6IDEpICogZDNfYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICAgIGlmIChwYXJhbGxlbCA+IM+GYXJjIHx8IHBhcmFsbGVsID09PSDPhmFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaisrKSBicmVhaztcbiAgICAgICAgzrswID0gzrssIHNpbs+GMCA9IHNpbs+GLCBjb3PPhjAgPSBjb3PPhiwgcG9pbnQwID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAocG9sYXJBbmdsZSA8IC3OtSB8fCBwb2xhckFuZ2xlIDwgzrUgJiYgZDNfZ2VvX2FyZWFSaW5nU3VtIDwgLc61KSBeIHdpbmRpbmcgJiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwQ2lyY2xlKHJhZGl1cykge1xuICAgIHZhciBjciA9IE1hdGguY29zKHJhZGl1cyksIHNtYWxsUmFkaXVzID0gY3IgPiAwLCBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IM61LCBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShyYWRpdXMsIDYgKiBkM19yYWRpYW5zKTtcbiAgICByZXR1cm4gZDNfZ2VvX2NsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFsgMCwgLXJhZGl1cyBdIDogWyAtz4AsIHJhZGl1cyAtIM+AIF0pO1xuICAgIGZ1bmN0aW9uIHZpc2libGUozrssIM+GKSB7XG4gICAgICByZXR1cm4gTWF0aC5jb3MozrspICogTWF0aC5jb3Moz4YpID4gY3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBMaW5lKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgcG9pbnQwLCBjMCwgdjAsIHYwMCwgY2xlYW47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICAgICAgdmFyIHBvaW50MSA9IFsgzrssIM+GIF0sIHBvaW50MiwgdiA9IHZpc2libGUozrssIM+GKSwgYyA9IHNtYWxsUmFkaXVzID8gdiA/IDAgOiBjb2RlKM67LCDPhikgOiB2ID8gY29kZSjOuyArICjOuyA8IDAgPyDPgCA6IC3PgCksIM+GKSA6IDA7XG4gICAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgIGlmIChkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQwLCBwb2ludDIpIHx8IGQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDEsIHBvaW50MikpIHtcbiAgICAgICAgICAgICAgcG9pbnQxWzBdICs9IM61O1xuICAgICAgICAgICAgICBwb2ludDFbMV0gKz0gzrU7XG4gICAgICAgICAgICAgIHYgPSB2aXNpYmxlKHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChub3RIZW1pc3BoZXJlICYmIHBvaW50MCAmJiBzbWFsbFJhZGl1cyBeIHYpIHtcbiAgICAgICAgICAgIHZhciB0O1xuICAgICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzBdWzBdLCB0WzBdWzFdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQxLCB2MCA9IHYsIGMwID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHYwKSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBjbGVhbiB8ICh2MDAgJiYgdjApIDw8IDE7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICAgIHZhciBwYSA9IGQzX2dlb19jYXJ0ZXNpYW4oYSksIHBiID0gZDNfZ2VvX2NhcnRlc2lhbihiKTtcbiAgICAgIHZhciBuMSA9IFsgMSwgMCwgMCBdLCBuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLCBuMm4yID0gZDNfZ2VvX2NhcnRlc2lhbkRvdChuMiwgbjIpLCBuMW4yID0gbjJbMF0sIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xuICAgICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcbiAgICAgIHZhciBjMSA9IGNyICogbjJuMiAvIGRldGVybWluYW50LCBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCwgbjF4bjIgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSwgQSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZShuMSwgYzEpLCBCID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKG4yLCBjMik7XG4gICAgICBkM19nZW9fY2FydGVzaWFuQWRkKEEsIEIpO1xuICAgICAgdmFyIHUgPSBuMXhuMiwgdyA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QoQSwgdSksIHV1ID0gZDNfZ2VvX2NhcnRlc2lhbkRvdCh1LCB1KSwgdDIgPSB3ICogdyAtIHV1ICogKGQzX2dlb19jYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcbiAgICAgIGlmICh0MiA8IDApIHJldHVybjtcbiAgICAgIHZhciB0ID0gTWF0aC5zcXJ0KHQyKSwgcSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICAgIGQzX2dlb19jYXJ0ZXNpYW5BZGQocSwgQSk7XG4gICAgICBxID0gZDNfZ2VvX3NwaGVyaWNhbChxKTtcbiAgICAgIGlmICghdHdvKSByZXR1cm4gcTtcbiAgICAgIHZhciDOuzAgPSBhWzBdLCDOuzEgPSBiWzBdLCDPhjAgPSBhWzFdLCDPhjEgPSBiWzFdLCB6O1xuICAgICAgaWYgKM67MSA8IM67MCkgeiA9IM67MCwgzrswID0gzrsxLCDOuzEgPSB6O1xuICAgICAgdmFyIM60zrsgPSDOuzEgLSDOuzAsIHBvbGFyID0gYWJzKM60zrsgLSDPgCkgPCDOtSwgbWVyaWRpYW4gPSBwb2xhciB8fCDOtM67IDwgzrU7XG4gICAgICBpZiAoIXBvbGFyICYmIM+GMSA8IM+GMCkgeiA9IM+GMCwgz4YwID0gz4YxLCDPhjEgPSB6O1xuICAgICAgaWYgKG1lcmlkaWFuID8gcG9sYXIgPyDPhjAgKyDPhjEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIM67MCkgPCDOtSA/IM+GMCA6IM+GMSkgOiDPhjAgPD0gcVsxXSAmJiBxWzFdIDw9IM+GMSA6IM60zrsgPiDPgCBeICjOuzAgPD0gcVswXSAmJiBxWzBdIDw9IM67MSkpIHtcbiAgICAgICAgdmFyIHExID0gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHUsICgtdyArIHQpIC8gdXUpO1xuICAgICAgICBkM19nZW9fY2FydGVzaWFuQWRkKHExLCBBKTtcbiAgICAgICAgcmV0dXJuIFsgcSwgZDNfZ2VvX3NwaGVyaWNhbChxMSkgXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29kZSjOuywgz4YpIHtcbiAgICAgIHZhciByID0gc21hbGxSYWRpdXMgPyByYWRpdXMgOiDPgCAtIHJhZGl1cywgY29kZSA9IDA7XG4gICAgICBpZiAozrsgPCAtcikgY29kZSB8PSAxOyBlbHNlIGlmICjOuyA+IHIpIGNvZGUgfD0gMjtcbiAgICAgIGlmICjPhiA8IC1yKSBjb2RlIHw9IDQ7IGVsc2UgaWYgKM+GID4gcikgY29kZSB8PSA4O1xuICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fY2xpcExpbmUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGEgPSBsaW5lLmEsIGIgPSBsaW5lLmIsIGF4ID0gYS54LCBheSA9IGEueSwgYnggPSBiLngsIGJ5ID0gYi55LCB0MCA9IDAsIHQxID0gMSwgZHggPSBieCAtIGF4LCBkeSA9IGJ5IC0gYXksIHI7XG4gICAgICByID0geDAgLSBheDtcbiAgICAgIGlmICghZHggJiYgciA+IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHg7XG4gICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9XG4gICAgICByID0geDEgLSBheDtcbiAgICAgIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHg7XG4gICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9XG4gICAgICByID0geTAgLSBheTtcbiAgICAgIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHk7XG4gICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgICAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gICAgICB9XG4gICAgICByID0geTEgLSBheTtcbiAgICAgIGlmICghZHkgJiYgciA8IDApIHJldHVybjtcbiAgICAgIHIgLz0gZHk7XG4gICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgICAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gICAgICB9XG4gICAgICBpZiAodDAgPiAwKSBsaW5lLmEgPSB7XG4gICAgICAgIHg6IGF4ICsgdDAgKiBkeCxcbiAgICAgICAgeTogYXkgKyB0MCAqIGR5XG4gICAgICB9O1xuICAgICAgaWYgKHQxIDwgMSkgbGluZS5iID0ge1xuICAgICAgICB4OiBheCArIHQxICogZHgsXG4gICAgICAgIHk6IGF5ICsgdDEgKiBkeVxuICAgICAgfTtcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2dlb19jbGlwRXh0ZW50TUFYID0gMWU5O1xuICBkMy5nZW8uY2xpcEV4dGVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4MCwgeTAsIHgxLCB5MSwgc3RyZWFtLCBjbGlwLCBjbGlwRXh0ZW50ID0ge1xuICAgICAgc3RyZWFtOiBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbSA9IGNsaXAob3V0cHV0KTtcbiAgICAgICAgc3RyZWFtLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICBleHRlbnQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF07XG4gICAgICAgIGNsaXAgPSBkM19nZW9fY2xpcEV4dGVudCh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKTtcbiAgICAgICAgaWYgKHN0cmVhbSkgc3RyZWFtLnZhbGlkID0gZmFsc2UsIHN0cmVhbSA9IG51bGw7XG4gICAgICAgIHJldHVybiBjbGlwRXh0ZW50O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGNsaXBFeHRlbnQuZXh0ZW50KFsgWyAwLCAwIF0sIFsgOTYwLCA1MDAgXSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBFeHRlbnQoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0ZW5lcl8gPSBsaXN0ZW5lciwgYnVmZmVyTGlzdGVuZXIgPSBkM19nZW9fY2xpcEJ1ZmZlckxpc3RlbmVyKCksIGNsaXBMaW5lID0gZDNfZ2VvbV9jbGlwTGluZSh4MCwgeTAsIHgxLCB5MSksIHNlZ21lbnRzLCBwb2x5Z29uLCByaW5nO1xuICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIgPSBidWZmZXJMaXN0ZW5lcjtcbiAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgIHBvbHlnb24gPSBbXTtcbiAgICAgICAgICBjbGVhbiA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXJfO1xuICAgICAgICAgIHNlZ21lbnRzID0gZDMubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICAgIHZhciBjbGlwU3RhcnRJbnNpZGUgPSBpbnNpZGVQb2x5Z29uKFsgeDAsIHkxIF0pLCBpbnNpZGUgPSBjbGVhbiAmJiBjbGlwU3RhcnRJbnNpZGUsIHZpc2libGUgPSBzZWdtZW50cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGluc2lkZSB8fCB2aXNpYmxlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvX2NsaXBQb2x5Z29uKHNlZ21lbnRzLCBjb21wYXJlLCBjbGlwU3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaW5zaWRlUG9seWdvbihwKSB7XG4gICAgICAgIHZhciB3biA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aCwgeSA9IHBbMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDEsIHYgPSBwb2x5Z29uW2ldLCBtID0gdi5sZW5ndGgsIGEgPSB2WzBdLCBiOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICBiID0gdltqXTtcbiAgICAgICAgICAgIGlmIChhWzFdIDw9IHkpIHtcbiAgICAgICAgICAgICAgaWYgKGJbMV0gPiB5ICYmIGQzX2Nyb3NzMmQoYSwgYiwgcCkgPiAwKSArK3duO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJbMV0gPD0geSAmJiBkM19jcm9zczJkKGEsIGIsIHApIDwgMCkgLS13bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd24gIT09IDA7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKSB8fCBjb21wYXJlUG9pbnRzKGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgICAgICB9IHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50VmlzaWJsZSh4LCB5KSB7XG4gICAgICAgIHJldHVybiB4MCA8PSB4ICYmIHggPD0geDEgJiYgeTAgPD0geSAmJiB5IDw9IHkxO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICBpZiAocG9pbnRWaXNpYmxlKHgsIHkpKSBsaXN0ZW5lci5wb2ludCh4LCB5KTtcbiAgICAgIH1cbiAgICAgIHZhciB4X18sIHlfXywgdl9fLCB4XywgeV8sIHZfLCBmaXJzdCwgY2xlYW47XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICB2XyA9IGZhbHNlO1xuICAgICAgICB4XyA9IHlfID0gTmFOO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgICBpZiAodl9fICYmIHZfKSBidWZmZXJMaXN0ZW5lci5yZWpvaW4oKTtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlckxpc3RlbmVyLmJ1ZmZlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGlmICh2XykgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgICAgeCA9IE1hdGgubWF4KC1kM19nZW9fY2xpcEV4dGVudE1BWCwgTWF0aC5taW4oZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KC1kM19nZW9fY2xpcEV4dGVudE1BWCwgTWF0aC5taW4oZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIHkpKTtcbiAgICAgICAgdmFyIHYgPSBwb2ludFZpc2libGUoeCwgeSk7XG4gICAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goWyB4LCB5IF0pO1xuICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2ICYmIHZfKSBsaXN0ZW5lci5wb2ludCh4LCB5KTsgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbCA9IHtcbiAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgIHg6IHhfLFxuICAgICAgICAgICAgICAgIHk6IHlfXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGI6IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjbGlwTGluZShsKSkge1xuICAgICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQobC5hLngsIGwuYS55KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludChsLmIueCwgbC5iLnkpO1xuICAgICAgICAgICAgICBpZiAoIXYpIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodikge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvcm5lcihwLCBkaXJlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhYnMocFswXSAtIHgwKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzIDogYWJzKHBbMF0gLSB4MSkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMSA6IGFicyhwWzFdIC0geTApIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMSA6IDAgOiBkaXJlY3Rpb24gPiAwID8gMyA6IDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmVQb2ludHMoYS54LCBiLngpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKGEsIGIpIHtcbiAgICAgIHZhciBjYSA9IGNvcm5lcihhLCAxKSwgY2IgPSBjb3JuZXIoYiwgMSk7XG4gICAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYiA6IGNhID09PSAwID8gYlsxXSAtIGFbMV0gOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXSA6IGJbMF0gLSBhWzBdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29uaWMocHJvamVjdEF0KSB7XG4gICAgdmFyIM+GMCA9IDAsIM+GMSA9IM+AIC8gMywgbSA9IGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLCBwID0gbSjPhjAsIM+GMSk7XG4gICAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM+GMCAvIM+AICogMTgwLCDPhjEgLyDPgCAqIDE4MCBdO1xuICAgICAgcmV0dXJuIG0oz4YwID0gX1swXSAqIM+AIC8gMTgwLCDPhjEgPSBfWzFdICogz4AgLyAxODApO1xuICAgIH07XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljRXF1YWxBcmVhKM+GMCwgz4YxKSB7XG4gICAgdmFyIHNpbs+GMCA9IE1hdGguc2luKM+GMCksIG4gPSAoc2luz4YwICsgTWF0aC5zaW4oz4YxKSkgLyAyLCBDID0gMSArIHNpbs+GMCAqICgyICogbiAtIHNpbs+GMCksIM+BMCA9IE1hdGguc3FydChDKSAvIG47XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIHZhciDPgSA9IE1hdGguc3FydChDIC0gMiAqIG4gKiBNYXRoLnNpbijPhikpIC8gbjtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4ozrsgKj0gbiksIM+BMCAtIM+BICogTWF0aC5jb3MozrspIF07XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BMF95ID0gz4EwIC0geTtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeCwgz4EwX3kpIC8gbiwgZDNfYXNpbigoQyAtICh4ICogeCArIM+BMF95ICogz4EwX3kpICogbiAqIG4pIC8gKDIgKiBuKSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNFcXVhbEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2NvbmljKGQzX2dlb19jb25pY0VxdWFsQXJlYSk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0VxdWFsQXJlYTtcbiAgZDMuZ2VvLmFsYmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5nZW8uY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWyA5NiwgMCBdKS5jZW50ZXIoWyAtLjYsIDM4LjcgXSkucGFyYWxsZWxzKFsgMjkuNSwgNDUuNSBdKS5zY2FsZSgxMDcwKTtcbiAgfTtcbiAgZDMuZ2VvLmFsYmVyc1VzYSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsb3dlcjQ4ID0gZDMuZ2VvLmFsYmVycygpO1xuICAgIHZhciBhbGFza2EgPSBkMy5nZW8uY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWyAxNTQsIDAgXSkuY2VudGVyKFsgLTIsIDU4LjUgXSkucGFyYWxsZWxzKFsgNTUsIDY1IF0pO1xuICAgIHZhciBoYXdhaWkgPSBkMy5nZW8uY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWyAxNTcsIDAgXSkuY2VudGVyKFsgLTMsIDE5LjkgXSkucGFyYWxsZWxzKFsgOCwgMTggXSk7XG4gICAgdmFyIHBvaW50LCBwb2ludFN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHBvaW50ID0gWyB4LCB5IF07XG4gICAgICB9XG4gICAgfSwgbG93ZXI0OFBvaW50LCBhbGFza2FQb2ludCwgaGF3YWlpUG9pbnQ7XG4gICAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICBwb2ludCA9IG51bGw7XG4gICAgICAobG93ZXI0OFBvaW50KHgsIHkpLCBwb2ludCkgfHwgKGFsYXNrYVBvaW50KHgsIHkpLCBwb2ludCkgfHwgaGF3YWlpUG9pbnQoeCwgeSk7XG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgcmV0dXJuICh5ID49IC4xMiAmJiB5IDwgLjIzNCAmJiB4ID49IC0uNDI1ICYmIHggPCAtLjIxNCA/IGFsYXNrYSA6IHkgPj0gLjE2NiAmJiB5IDwgLjIzNCAmJiB4ID49IC0uMjE0ICYmIHggPCAtLjExNSA/IGhhd2FpaSA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgfTtcbiAgICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgbG93ZXI0OFN0cmVhbSA9IGxvd2VyNDguc3RyZWFtKHN0cmVhbSksIGFsYXNrYVN0cmVhbSA9IGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpU3RyZWFtID0gaGF3YWlpLnN0cmVhbShzdHJlYW0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgICBsb3dlcjQ4LnByZWNpc2lvbihfKTtcbiAgICAgIGFsYXNrYS5wcmVjaXNpb24oXyk7XG4gICAgICBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICAgIGxvd2VyNDguc2NhbGUoXyk7XG4gICAgICBhbGFza2Euc2NhbGUoXyAqIC4zNSk7XG4gICAgICBoYXdhaWkuc2NhbGUoXyk7XG4gICAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OC50cmFuc2xhdGUoXykuY2xpcEV4dGVudChbIFsgeCAtIC40NTUgKiBrLCB5IC0gLjIzOCAqIGsgXSwgWyB4ICsgLjQ1NSAqIGssIHkgKyAuMjM4ICogayBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICBhbGFza2FQb2ludCA9IGFsYXNrYS50cmFuc2xhdGUoWyB4IC0gLjMwNyAqIGssIHkgKyAuMjAxICogayBdKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjQyNSAqIGsgKyDOtSwgeSArIC4xMiAqIGsgKyDOtSBdLCBbIHggLSAuMjE0ICogayAtIM61LCB5ICsgLjIzNCAqIGsgLSDOtSBdIF0pLnN0cmVhbShwb2ludFN0cmVhbSkucG9pbnQ7XG4gICAgICBoYXdhaWlQb2ludCA9IGhhd2FpaS50cmFuc2xhdGUoWyB4IC0gLjIwNSAqIGssIHkgKyAuMjEyICogayBdKS5jbGlwRXh0ZW50KFsgWyB4IC0gLjIxNCAqIGsgKyDOtSwgeSArIC4xNjYgKiBrICsgzrUgXSwgWyB4IC0gLjExNSAqIGsgLSDOtSwgeSArIC4yMzQgKiBrIC0gzrUgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgICB9O1xuICAgIHJldHVybiBhbGJlcnNVc2Euc2NhbGUoMTA3MCk7XG4gIH07XG4gIHZhciBkM19nZW9fcGF0aEFyZWFTdW0sIGQzX2dlb19wYXRoQXJlYVBvbHlnb24sIGQzX2dlb19wYXRoQXJlYSA9IHtcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiA9IDA7XG4gICAgICBkM19nZW9fcGF0aEFyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhBcmVhUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWEubGluZVN0YXJ0ID0gZDNfZ2VvX3BhdGhBcmVhLmxpbmVFbmQgPSBkM19nZW9fcGF0aEFyZWEucG9pbnQgPSBkM19ub29wO1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhU3VtICs9IGFicyhkM19nZW9fcGF0aEFyZWFQb2x5Z29uIC8gMik7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aEFyZWFSaW5nU3RhcnQoKSB7XG4gICAgdmFyIHgwMCwgeTAwLCB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiArPSB5MCAqIHggLSB4MCAqIHk7XG4gICAgICB4MCA9IHgsIHkwID0geTtcbiAgICB9XG4gICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCh4MDAsIHkwMCk7XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZ2VvX3BhdGhCb3VuZHNYMCwgZDNfZ2VvX3BhdGhCb3VuZHNZMCwgZDNfZ2VvX3BhdGhCb3VuZHNYMSwgZDNfZ2VvX3BhdGhCb3VuZHNZMTtcbiAgdmFyIGQzX2dlb19wYXRoQm91bmRzID0ge1xuICAgIHBvaW50OiBkM19nZW9fcGF0aEJvdW5kc1BvaW50LFxuICAgIGxpbmVTdGFydDogZDNfbm9vcCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZDNfbm9vcCxcbiAgICBwb2x5Z29uRW5kOiBkM19ub29wXG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQm91bmRzUG9pbnQoeCwgeSkge1xuICAgIGlmICh4IDwgZDNfZ2VvX3BhdGhCb3VuZHNYMCkgZDNfZ2VvX3BhdGhCb3VuZHNYMCA9IHg7XG4gICAgaWYgKHggPiBkM19nZW9fcGF0aEJvdW5kc1gxKSBkM19nZW9fcGF0aEJvdW5kc1gxID0geDtcbiAgICBpZiAoeSA8IGQzX2dlb19wYXRoQm91bmRzWTApIGQzX2dlb19wYXRoQm91bmRzWTAgPSB5O1xuICAgIGlmICh5ID4gZDNfZ2VvX3BhdGhCb3VuZHNZMSkgZDNfZ2VvX3BhdGhCb3VuZHNZMSA9IHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhCdWZmZXIoKSB7XG4gICAgdmFyIHBvaW50Q2lyY2xlID0gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUoNC41KSwgYnVmZmVyID0gW107XG4gICAgdmFyIHN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZVN0YXJ0O1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmRQb2x5Z29uO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgfSxcbiAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHBvaW50Q2lyY2xlID0gZDNfZ2VvX3BhdGhCdWZmZXJDaXJjbGUoXyk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVmZmVyLmpvaW4oXCJcIik7XG4gICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5LCBwb2ludENpcmNsZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZVN0YXJ0KHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZSh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmRQb2x5Z29uKCkge1xuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKHJhZGl1cykge1xuICAgIHJldHVybiBcIm0wLFwiICsgcmFkaXVzICsgXCJhXCIgKyByYWRpdXMgKyBcIixcIiArIHJhZGl1cyArIFwiIDAgMSwxIDAsXCIgKyAtMiAqIHJhZGl1cyArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1cyArIFwielwiO1xuICB9XG4gIHZhciBkM19nZW9fcGF0aENlbnRyb2lkID0ge1xuICAgIHBvaW50OiBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0LFxuICAgIGxpbmVFbmQ6IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kLFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQ2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVFbmQgPSBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4LCB5KSB7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWDAgKz0geDtcbiAgICBkM19nZW9fY2VudHJvaWRZMCArPSB5O1xuICAgICsrZDNfZ2VvX2NlbnRyb2lkWjA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICB2YXIgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgZHggPSB4IC0geDAsIGR5ID0geSAtIHkwLCB6ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHogKiAoeDAgKyB4KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB6ICogKHkwICsgeSkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gejtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lRW5kKCkge1xuICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICB2YXIgeDAwLCB5MDAsIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MDAgPSB4MCA9IHgsIHkwMCA9IHkwID0geSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHo7XG4gICAgICB6ID0geTAgKiB4IC0geDAgKiB5O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDIgKz0geiAqICh4MCArIHgpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTIgKz0geiAqICh5MCArIHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjIgKz0geiAqIDM7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH1cbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCh4MDAsIHkwMCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENvbnRleHQoY29udGV4dCkge1xuICAgIHZhciBwb2ludFJhZGl1cyA9IDQuNTtcbiAgICB2YXIgc3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lU3RhcnQ7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZFBvbHlnb247XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICB9LFxuICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcG9pbnRSYWRpdXMgPSBfO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdDogZDNfbm9vcFxuICAgIH07XG4gICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCArIHBvaW50UmFkaXVzLCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKHgsIHksIHBvaW50UmFkaXVzLCAwLCDPhCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50TGluZVN0YXJ0KHgsIHkpIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmUoeCwgeSkge1xuICAgICAgY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZFBvbHlnb24oKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yZXNhbXBsZShwcm9qZWN0KSB7XG4gICAgdmFyIM60MiA9IC41LCBjb3NNaW5EaXN0YW5jZSA9IE1hdGguY29zKDMwICogZDNfcmFkaWFucyksIG1heERlcHRoID0gMTY7XG4gICAgZnVuY3Rpb24gcmVzYW1wbGUoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gKG1heERlcHRoID8gcmVzYW1wbGVSZWN1cnNpdmUgOiByZXNhbXBsZU5vbmUpKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTm9uZShzdHJlYW0pIHtcbiAgICAgIHJldHVybiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeFswXSwgeFsxXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVSZWN1cnNpdmUoc3RyZWFtKSB7XG4gICAgICB2YXIgzrswMCwgz4YwMCwgeDAwLCB5MDAsIGEwMCwgYjAwLCBjMDAsIM67MCwgeDAsIHkwLCBhMCwgYjAsIGMwO1xuICAgICAgdmFyIHJlc2FtcGxlID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICByZXNhbXBsZS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgcmVzYW1wbGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICB4MCA9IE5hTjtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludCjOuywgz4YpIHtcbiAgICAgICAgdmFyIGMgPSBkM19nZW9fY2FydGVzaWFuKFsgzrssIM+GIF0pLCBwID0gcHJvamVjdCjOuywgz4YpO1xuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDAgPSBwWzBdLCB5MCA9IHBbMV0sIM67MCA9IM67LCBhMCA9IGNbMF0sIGIwID0gY1sxXSwgYzAgPSBjWzJdLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHgwLCB5MCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IHBvaW50O1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgICBsaW5lU3RhcnQoKTtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICAgIHJlc2FtcGxlLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ1BvaW50KM67LCDPhikge1xuICAgICAgICBsaW5lUG9pbnQozrswMCA9IM67LCDPhjAwID0gz4YpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCDOuzAwLCBhMDAsIGIwMCwgYzAwLCBtYXhEZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgcmVzYW1wbGUubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIGxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNhbXBsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgxLCB5MSwgzrsxLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgICB2YXIgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTAsIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPiA0ICogzrQyICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFyIGEgPSBhMCArIGExLCBiID0gYjAgKyBiMSwgYyA9IGMwICsgYzEsIG0gPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSwgz4YyID0gTWF0aC5hc2luKGMgLz0gbSksIM67MiA9IGFicyhhYnMoYykgLSAxKSA8IM61IHx8IGFicyjOuzAgLSDOuzEpIDwgzrUgPyAozrswICsgzrsxKSAvIDIgOiBNYXRoLmF0YW4yKGIsIGEpLCBwID0gcHJvamVjdCjOuzIsIM+GMiksIHgyID0gcFswXSwgeTIgPSBwWzFdLCBkeDIgPSB4MiAtIHgwLCBkeTIgPSB5MiAtIHkwLCBkeiA9IGR5ICogZHgyIC0gZHggKiBkeTI7XG4gICAgICAgIGlmIChkeiAqIGR6IC8gZDIgPiDOtDIgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gLjUpID4gLjMgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHtcbiAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIM67MCwgYTAsIGIwLCBjMCwgeDIsIHkyLCDOuzIsIGEgLz0gbSwgYiAvPSBtLCBjLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MiwgeTIsIM67MiwgYSwgYiwgYywgeDEsIHkxLCDOuzEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2FtcGxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydCjOtDIpO1xuICAgICAgbWF4RGVwdGggPSAozrQyID0gXyAqIF8pID4gMCAmJiAxNjtcbiAgICAgIHJldHVybiByZXNhbXBsZTtcbiAgICB9O1xuICAgIHJldHVybiByZXNhbXBsZTtcbiAgfVxuICBkMy5nZW8ucGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwb2ludFJhZGl1cyA9IDQuNSwgcHJvamVjdGlvbiwgY29udGV4dCwgcHJvamVjdFN0cmVhbSwgY29udGV4dFN0cmVhbSwgY2FjaGVTdHJlYW07XG4gICAgZnVuY3Rpb24gcGF0aChvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtwb2ludFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgaWYgKCFjYWNoZVN0cmVhbSB8fCAhY2FjaGVTdHJlYW0udmFsaWQpIGNhY2hlU3RyZWFtID0gcHJvamVjdFN0cmVhbShjb250ZXh0U3RyZWFtKTtcbiAgICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGNhY2hlU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICAgIH1cbiAgICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVN1bSA9IDA7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aEFyZWEpKTtcbiAgICAgIHJldHVybiBkM19nZW9fcGF0aEFyZWFTdW07XG4gICAgfTtcbiAgICBwYXRoLmNlbnRyb2lkID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMCA9IGQzX2dlb19jZW50cm9pZFkwID0gZDNfZ2VvX2NlbnRyb2lkWjAgPSBkM19nZW9fY2VudHJvaWRYMSA9IGQzX2dlb19jZW50cm9pZFkxID0gZDNfZ2VvX2NlbnRyb2lkWjEgPSBkM19nZW9fY2VudHJvaWRYMiA9IGQzX2dlb19jZW50cm9pZFkyID0gZDNfZ2VvX2NlbnRyb2lkWjIgPSAwO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhDZW50cm9pZCkpO1xuICAgICAgcmV0dXJuIGQzX2dlb19jZW50cm9pZFoyID8gWyBkM19nZW9fY2VudHJvaWRYMiAvIGQzX2dlb19jZW50cm9pZFoyLCBkM19nZW9fY2VudHJvaWRZMiAvIGQzX2dlb19jZW50cm9pZFoyIF0gOiBkM19nZW9fY2VudHJvaWRaMSA/IFsgZDNfZ2VvX2NlbnRyb2lkWDEgLyBkM19nZW9fY2VudHJvaWRaMSwgZDNfZ2VvX2NlbnRyb2lkWTEgLyBkM19nZW9fY2VudHJvaWRaMSBdIDogZDNfZ2VvX2NlbnRyb2lkWjAgPyBbIGQzX2dlb19jZW50cm9pZFgwIC8gZDNfZ2VvX2NlbnRyb2lkWjAsIGQzX2dlb19jZW50cm9pZFkwIC8gZDNfZ2VvX2NlbnRyb2lkWjAgXSA6IFsgTmFOLCBOYU4gXTtcbiAgICB9O1xuICAgIHBhdGguYm91bmRzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fcGF0aEJvdW5kc1gxID0gZDNfZ2VvX3BhdGhCb3VuZHNZMSA9IC0oZDNfZ2VvX3BhdGhCb3VuZHNYMCA9IGQzX2dlb19wYXRoQm91bmRzWTAgPSBJbmZpbml0eSk7XG4gICAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgcHJvamVjdFN0cmVhbShkM19nZW9fcGF0aEJvdW5kcykpO1xuICAgICAgcmV0dXJuIFsgWyBkM19nZW9fcGF0aEJvdW5kc1gwLCBkM19nZW9fcGF0aEJvdW5kc1kwIF0sIFsgZDNfZ2VvX3BhdGhCb3VuZHNYMSwgZDNfZ2VvX3BhdGhCb3VuZHNZMSBdIF07XG4gICAgfTtcbiAgICBwYXRoLnByb2plY3Rpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgcHJvamVjdFN0cmVhbSA9IChwcm9qZWN0aW9uID0gXykgPyBfLnN0cmVhbSB8fCBkM19nZW9fcGF0aFByb2plY3RTdHJlYW0oXykgOiBkM19pZGVudGl0eTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcGF0aC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcbiAgICAgIGNvbnRleHRTdHJlYW0gPSAoY29udGV4dCA9IF8pID09IG51bGwgPyBuZXcgZDNfZ2VvX3BhdGhCdWZmZXIoKSA6IG5ldyBkM19nZW9fcGF0aENvbnRleHQoXyk7XG4gICAgICBpZiAodHlwZW9mIHBvaW50UmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnByb2plY3Rpb24oZDMuZ2VvLmFsYmVyc1VzYSgpKS5jb250ZXh0KG51bGwpO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aFByb2plY3RTdHJlYW0ocHJvamVjdCkge1xuICAgIHZhciByZXNhbXBsZSA9IGQzX2dlb19yZXNhbXBsZShmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gcHJvamVjdChbIHggKiBkM19kZWdyZWVzLCB5ICogZDNfZGVncmVlcyBdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHJlc2FtcGxlKHN0cmVhbSkpO1xuICAgIH07XG4gIH1cbiAgZDMuZ2VvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG1ldGhvZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBkM19nZW9fdHJhbnNmb3JtKHN0cmVhbSk7XG4gICAgICAgIGZvciAodmFyIGsgaW4gbWV0aG9kcykgdHJhbnNmb3JtW2tdID0gbWV0aG9kc1trXTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fdHJhbnNmb3JtKHN0cmVhbSkge1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICB9XG4gIGQzX2dlb190cmFuc2Zvcm0ucHJvdG90eXBlID0ge1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICB9LFxuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5zcGhlcmUoKTtcbiAgICB9LFxuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9LFxuICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ubGluZUVuZCgpO1xuICAgIH0sXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBwb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0uc3BoZXJlKCk7XG4gICAgICB9LFxuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzLmdlby5wcm9qZWN0aW9uID0gZDNfZ2VvX3Byb2plY3Rpb247XG4gIGQzLmdlby5wcm9qZWN0aW9uTXV0YXRvciA9IGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcjtcbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb24ocHJvamVjdCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9KSgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgICB2YXIgcHJvamVjdCwgcm90YXRlLCBwcm9qZWN0Um90YXRlLCBwcm9qZWN0UmVzYW1wbGUgPSBkM19nZW9fcmVzYW1wbGUoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICByZXR1cm4gWyB4WzBdICogayArIM60eCwgzrR5IC0geFsxXSAqIGsgXTtcbiAgICB9KSwgayA9IDE1MCwgeCA9IDQ4MCwgeSA9IDI1MCwgzrsgPSAwLCDPhiA9IDAsIM60zrsgPSAwLCDOtM+GID0gMCwgzrTOsyA9IDAsIM60eCwgzrR5LCBwcmVjbGlwID0gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4sIHBvc3RjbGlwID0gZDNfaWRlbnRpdHksIGNsaXBBbmdsZSA9IG51bGwsIGNsaXBFeHRlbnQgPSBudWxsLCBzdHJlYW07XG4gICAgZnVuY3Rpb24gcHJvamVjdGlvbihwb2ludCkge1xuICAgICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlKHBvaW50WzBdICogZDNfcmFkaWFucywgcG9pbnRbMV0gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBbIHBvaW50WzBdICogayArIM60eCwgzrR5IC0gcG9pbnRbMV0gKiBrIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmVydChwb2ludCkge1xuICAgICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlLmludmVydCgocG9pbnRbMF0gLSDOtHgpIC8gaywgKM60eSAtIHBvaW50WzFdKSAvIGspO1xuICAgICAgcmV0dXJuIHBvaW50ICYmIFsgcG9pbnRbMF0gKiBkM19kZWdyZWVzLCBwb2ludFsxXSAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9XG4gICAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtID0gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHByZWNsaXAocm90YXRlLCBwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAob3V0cHV0KSkpKTtcbiAgICAgIHN0cmVhbS52YWxpZCA9IHRydWU7XG4gICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwQW5nbGU7XG4gICAgICBwcmVjbGlwID0gXyA9PSBudWxsID8gKGNsaXBBbmdsZSA9IF8sIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuKSA6IGQzX2dlb19jbGlwQ2lyY2xlKChjbGlwQW5nbGUgPSArXykgKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50O1xuICAgICAgY2xpcEV4dGVudCA9IF87XG4gICAgICBwb3N0Y2xpcCA9IF8gPyBkM19nZW9fY2xpcEV4dGVudChfWzBdWzBdLCBfWzBdWzFdLCBfWzFdWzBdLCBfWzFdWzFdKSA6IGQzX2lkZW50aXR5O1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBrO1xuICAgICAgayA9ICtfO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgeCA9ICtfWzBdO1xuICAgICAgeSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgzrsgKiBkM19kZWdyZWVzLCDPhiAqIGQzX2RlZ3JlZXMgXTtcbiAgICAgIM67ID0gX1swXSAlIDM2MCAqIGQzX3JhZGlhbnM7XG4gICAgICDPhiA9IF9bMV0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgzrTOuyAqIGQzX2RlZ3JlZXMsIM60z4YgKiBkM19kZWdyZWVzLCDOtM6zICogZDNfZGVncmVlcyBdO1xuICAgICAgzrTOuyA9IF9bMF0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgzrTPhiA9IF9bMV0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgzrTOsyA9IF8ubGVuZ3RoID4gMiA/IF9bMl0gJSAzNjAgKiBkM19yYWRpYW5zIDogMDtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgZDMucmViaW5kKHByb2plY3Rpb24sIHByb2plY3RSZXNhbXBsZSwgXCJwcmVjaXNpb25cIik7XG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBwcm9qZWN0Um90YXRlID0gZDNfZ2VvX2NvbXBvc2Uocm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKM60zrssIM60z4YsIM60zrMpLCBwcm9qZWN0KTtcbiAgICAgIHZhciBjZW50ZXIgPSBwcm9qZWN0KM67LCDPhik7XG4gICAgICDOtHggPSB4IC0gY2VudGVyWzBdICogaztcbiAgICAgIM60eSA9IHkgKyBjZW50ZXJbMV0gKiBrO1xuICAgICAgcmV0dXJuIGludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlLCBzdHJlYW0gPSBudWxsO1xuICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvblJhZGlhbnMoc3RyZWFtKSB7XG4gICAgcmV0dXJuIGQzX2dlb190cmFuc2Zvcm1Qb2ludChzdHJlYW0sIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHN0cmVhbS5wb2ludCh4ICogZDNfcmFkaWFucywgeSAqIGQzX3JhZGlhbnMpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrssIM+GIF07XG4gIH1cbiAgKGQzLmdlby5lcXVpcmVjdGFuZ3VsYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcik7XG4gIH0pLnJhdyA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIuaW52ZXJ0ID0gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgZDMuZ2VvLnJvdGF0aW9uID0gZnVuY3Rpb24ocm90YXRlKSB7XG4gICAgcm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKHJvdGF0ZVswXSAlIDM2MCAqIGQzX3JhZGlhbnMsIHJvdGF0ZVsxXSAqIGQzX3JhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogZDNfcmFkaWFucyA6IDApO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQoY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlKGNvb3JkaW5hdGVzWzBdICogZDNfcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlcztcbiAgICB9XG4gICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgY29vcmRpbmF0ZXMgPSByb3RhdGUuaW52ZXJ0KGNvb3JkaW5hdGVzWzBdICogZDNfcmFkaWFucywgY29vcmRpbmF0ZXNbMV0gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkM19kZWdyZWVzLCBjb29yZGluYXRlcztcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9faWRlbnRpdHlSb3RhdGlvbijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuyA+IM+AID8gzrsgLSDPhCA6IM67IDwgLc+AID8gzrsgKyDPhCA6IM67LCDPhiBdO1xuICB9XG4gIGQzX2dlb19pZGVudGl0eVJvdGF0aW9uLmludmVydCA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbijOtM67LCDOtM+GLCDOtM6zKSB7XG4gICAgcmV0dXJuIM60zrsgPyDOtM+GIHx8IM60zrMgPyBkM19nZW9fY29tcG9zZShkM19nZW9fcm90YXRpb27OuyjOtM67KSwgZDNfZ2VvX3JvdGF0aW9uz4bOsyjOtM+GLCDOtM6zKSkgOiBkM19nZW9fcm90YXRpb27OuyjOtM67KSA6IM60z4YgfHwgzrTOsyA/IGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykgOiBkM19nZW9faWRlbnRpdHlSb3RhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsozrTOuykge1xuICAgIHJldHVybiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIHJldHVybiDOuyArPSDOtM67LCBbIM67ID4gz4AgPyDOuyAtIM+EIDogzrsgPCAtz4AgPyDOuyArIM+EIDogzrssIM+GIF07XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb27OuyjOtM67KSB7XG4gICAgdmFyIHJvdGF0aW9uID0gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KM60zrspO1xuICAgIHJvdGF0aW9uLmludmVydCA9IGQzX2dlb19mb3J3YXJkUm90YXRpb27OuygtzrTOuyk7XG4gICAgcmV0dXJuIHJvdGF0aW9uO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykge1xuICAgIHZhciBjb3POtM+GID0gTWF0aC5jb3MozrTPhiksIHNpbs60z4YgPSBNYXRoLnNpbijOtM+GKSwgY29zzrTOsyA9IE1hdGguY29zKM60zrMpLCBzaW7OtM6zID0gTWF0aC5zaW4ozrTOsyk7XG4gICAgZnVuY3Rpb24gcm90YXRpb24ozrssIM+GKSB7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiksIHggPSBNYXRoLmNvcyjOuykgKiBjb3PPhiwgeSA9IE1hdGguc2luKM67KSAqIGNvc8+GLCB6ID0gTWF0aC5zaW4oz4YpLCBrID0geiAqIGNvc860z4YgKyB4ICogc2luzrTPhjtcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSAqIGNvc860zrMgLSBrICogc2luzrTOsywgeCAqIGNvc860z4YgLSB6ICogc2luzrTPhiksIGQzX2FzaW4oayAqIGNvc860zrMgKyB5ICogc2luzrTOsykgXTtcbiAgICB9XG4gICAgcm90YXRpb24uaW52ZXJ0ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiksIHggPSBNYXRoLmNvcyjOuykgKiBjb3PPhiwgeSA9IE1hdGguc2luKM67KSAqIGNvc8+GLCB6ID0gTWF0aC5zaW4oz4YpLCBrID0geiAqIGNvc860zrMgLSB5ICogc2luzrTOsztcbiAgICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSAqIGNvc860zrMgKyB6ICogc2luzrTOsywgeCAqIGNvc860z4YgKyBrICogc2luzrTPhiksIGQzX2FzaW4oayAqIGNvc860z4YgLSB4ICogc2luzrTPhikgXTtcbiAgICB9O1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICBkMy5nZW8uY2lyY2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9yaWdpbiA9IFsgMCwgMCBdLCBhbmdsZSwgcHJlY2lzaW9uID0gNiwgaW50ZXJwb2xhdGU7XG4gICAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgICAgdmFyIGNlbnRlciA9IHR5cGVvZiBvcmlnaW4gPT09IFwiZnVuY3Rpb25cIiA/IG9yaWdpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb3JpZ2luLCByb3RhdGUgPSBkM19nZW9fcm90YXRpb24oLWNlbnRlclswXSAqIGQzX3JhZGlhbnMsIC1jZW50ZXJbMV0gKiBkM19yYWRpYW5zLCAwKS5pbnZlcnQsIHJpbmcgPSBbXTtcbiAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICByaW5nLnB1c2goeCA9IHJvdGF0ZSh4LCB5KSk7XG4gICAgICAgICAgeFswXSAqPSBkM19kZWdyZWVzLCB4WzFdICo9IGQzX2RlZ3JlZXM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIHJpbmcgXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2lyY2xlLm9yaWdpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWdpbjtcbiAgICAgIG9yaWdpbiA9IHg7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgY2lyY2xlLmFuZ2xlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYW5nbGU7XG4gICAgICBpbnRlcnBvbGF0ZSA9IGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZSgoYW5nbGUgPSAreCkgKiBkM19yYWRpYW5zLCBwcmVjaXNpb24gKiBkM19yYWRpYW5zKTtcbiAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfTtcbiAgICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgICAgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUoYW5nbGUgKiBkM19yYWRpYW5zLCAocHJlY2lzaW9uID0gK18pICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgcmV0dXJuIGNpcmNsZS5hbmdsZSg5MCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jaXJjbGVJbnRlcnBvbGF0ZShyYWRpdXMsIHByZWNpc2lvbikge1xuICAgIHZhciBjciA9IE1hdGguY29zKHJhZGl1cyksIHNyID0gTWF0aC5zaW4ocmFkaXVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBzdGVwID0gZGlyZWN0aW9uICogcHJlY2lzaW9uO1xuICAgICAgaWYgKGZyb20gIT0gbnVsbCkge1xuICAgICAgICBmcm9tID0gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCBmcm9tKTtcbiAgICAgICAgdG8gPSBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIHRvKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDAgPyBmcm9tIDwgdG8gOiBmcm9tID4gdG8pIGZyb20gKz0gZGlyZWN0aW9uICogz4Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gcmFkaXVzICsgZGlyZWN0aW9uICogz4Q7XG4gICAgICAgIHRvID0gcmFkaXVzIC0gLjUgKiBzdGVwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgcG9pbnQsIHQgPSBmcm9tOyBkaXJlY3Rpb24gPiAwID8gdCA+IHRvIDogdCA8IHRvOyB0IC09IHN0ZXApIHtcbiAgICAgICAgbGlzdGVuZXIucG9pbnQoKHBvaW50ID0gZDNfZ2VvX3NwaGVyaWNhbChbIGNyLCAtc3IgKiBNYXRoLmNvcyh0KSwgLXNyICogTWF0aC5zaW4odCkgXSkpWzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2lyY2xlQW5nbGUoY3IsIHBvaW50KSB7XG4gICAgdmFyIGEgPSBkM19nZW9fY2FydGVzaWFuKHBvaW50KTtcbiAgICBhWzBdIC09IGNyO1xuICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoYSk7XG4gICAgdmFyIGFuZ2xlID0gZDNfYWNvcygtYVsxXSk7XG4gICAgcmV0dXJuICgoLWFbMl0gPCAwID8gLWFuZ2xlIDogYW5nbGUpICsgMiAqIE1hdGguUEkgLSDOtSkgJSAoMiAqIE1hdGguUEkpO1xuICB9XG4gIGQzLmdlby5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgzpTOuyA9IChiWzBdIC0gYVswXSkgKiBkM19yYWRpYW5zLCDPhjAgPSBhWzFdICogZDNfcmFkaWFucywgz4YxID0gYlsxXSAqIGQzX3JhZGlhbnMsIHNpbs6UzrsgPSBNYXRoLnNpbijOlM67KSwgY29zzpTOuyA9IE1hdGguY29zKM6UzrspLCBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBzaW7PhjEgPSBNYXRoLnNpbijPhjEpLCBjb3PPhjEgPSBNYXRoLmNvcyjPhjEpLCB0O1xuICAgIHJldHVybiBNYXRoLmF0YW4yKE1hdGguc3FydCgodCA9IGNvc8+GMSAqIHNpbs6UzrspICogdCArICh0ID0gY29zz4YwICogc2luz4YxIC0gc2luz4YwICogY29zz4YxICogY29zzpTOuykgKiB0KSwgc2luz4YwICogc2luz4YxICsgY29zz4YwICogY29zz4YxICogY29zzpTOuyk7XG4gIH07XG4gIGQzLmdlby5ncmF0aWN1bGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeDEsIHgwLCBYMSwgWDAsIHkxLCB5MCwgWTEsIFkwLCBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCwgeCwgeSwgWCwgWSwgcHJlY2lzaW9uID0gMi41O1xuICAgIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBsaW5lcygpXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShNYXRoLmNlaWwoWDAgLyBEWCkgKiBEWCwgWDEsIERYKS5tYXAoWCkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbChZMCAvIERZKSAqIERZLCBZMSwgRFkpLm1hcChZKSkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBhYnMoeCAlIERYKSA+IM61O1xuICAgICAgfSkubWFwKHgpKS5jb25jYXQoZDMucmFuZ2UoTWF0aC5jZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIGFicyh5ICUgRFkpID4gzrU7XG4gICAgICB9KS5tYXAoeSkpO1xuICAgIH1cbiAgICBncmF0aWN1bGUubGluZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIFgoWDApLmNvbmNhdChZKFkxKS5zbGljZSgxKSwgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLCBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpIF1cbiAgICAgIH07XG4gICAgfTtcbiAgICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLm1pbm9yRXh0ZW50KCk7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yRXh0ZW50KF8pLm1pbm9yRXh0ZW50KF8pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1ham9yRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIFgwLCBZMCBdLCBbIFgxLCBZMSBdIF07XG4gICAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICAgIGlmIChYMCA+IFgxKSBfID0gWDAsIFgwID0gWDEsIFgxID0gXztcbiAgICAgIGlmIChZMCA+IFkxKSBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWlub3JFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXTtcbiAgICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgICAgaWYgKHgwID4geDEpIF8gPSB4MCwgeDAgPSB4MSwgeDEgPSBfO1xuICAgICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLm1pbm9yU3RlcCgpO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvclN0ZXAoXykubWlub3JTdGVwKF8pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1ham9yU3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgRFgsIERZIF07XG4gICAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5taW5vclN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIGR4LCBkeSBdO1xuICAgICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJlY2lzaW9uO1xuICAgICAgcHJlY2lzaW9uID0gK187XG4gICAgICB4ID0gZDNfZ2VvX2dyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgICB5ID0gZDNfZ2VvX2dyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgICAgWCA9IGQzX2dlb19ncmF0aWN1bGVYKFkwLCBZMSwgOTApO1xuICAgICAgWSA9IGQzX2dlb19ncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICByZXR1cm4gZ3JhdGljdWxlLm1ham9yRXh0ZW50KFsgWyAtMTgwLCAtOTAgKyDOtSBdLCBbIDE4MCwgOTAgLSDOtSBdIF0pLm1pbm9yRXh0ZW50KFsgWyAtMTgwLCAtODAgLSDOtSBdLCBbIDE4MCwgODAgKyDOtSBdIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fZ3JhdGljdWxlWCh5MCwgeTEsIGR5KSB7XG4gICAgdmFyIHkgPSBkMy5yYW5nZSh5MCwgeTEgLSDOtSwgZHkpLmNvbmNhdCh5MSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2dyYXRpY3VsZVkoeDAsIHgxLCBkeCkge1xuICAgIHZhciB4ID0gZDMucmFuZ2UoeDAsIHgxIC0gzrUsIGR4KS5jb25jYXQoeDEpO1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gWyB4LCB5IF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NvdXJjZShkKSB7XG4gICAgcmV0dXJuIGQuc291cmNlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RhcmdldChkKSB7XG4gICAgcmV0dXJuIGQudGFyZ2V0O1xuICB9XG4gIGQzLmdlby5ncmVhdEFyYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHNvdXJjZV8sIHRhcmdldCA9IGQzX3RhcmdldCwgdGFyZ2V0XztcbiAgICBmdW5jdGlvbiBncmVhdEFyYygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogWyBzb3VyY2VfIHx8IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0YXJnZXRfIHx8IHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGdyZWF0QXJjLmRpc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDMuZ2VvLmRpc3RhbmNlKHNvdXJjZV8gfHwgc291cmNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRhcmdldF8gfHwgdGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gICAgZ3JlYXRBcmMuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gXywgc291cmNlXyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBudWxsIDogXztcbiAgICAgIHJldHVybiBncmVhdEFyYztcbiAgICB9O1xuICAgIGdyZWF0QXJjLnRhcmdldCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IF8sIHRhcmdldF8gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IF87XG4gICAgICByZXR1cm4gZ3JlYXRBcmM7XG4gICAgfTtcbiAgICBncmVhdEFyYy5wcmVjaXNpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZ3JlYXRBcmMgOiAwO1xuICAgIH07XG4gICAgcmV0dXJuIGdyZWF0QXJjO1xuICB9O1xuICBkMy5nZW8uaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCkge1xuICAgIHJldHVybiBkM19nZW9faW50ZXJwb2xhdGUoc291cmNlWzBdICogZDNfcmFkaWFucywgc291cmNlWzFdICogZDNfcmFkaWFucywgdGFyZ2V0WzBdICogZDNfcmFkaWFucywgdGFyZ2V0WzFdICogZDNfcmFkaWFucyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19pbnRlcnBvbGF0ZSh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHZhciBjeTAgPSBNYXRoLmNvcyh5MCksIHN5MCA9IE1hdGguc2luKHkwKSwgY3kxID0gTWF0aC5jb3MoeTEpLCBzeTEgPSBNYXRoLnNpbih5MSksIGt4MCA9IGN5MCAqIE1hdGguY29zKHgwKSwga3kwID0gY3kwICogTWF0aC5zaW4oeDApLCBreDEgPSBjeTEgKiBNYXRoLmNvcyh4MSksIGt5MSA9IGN5MSAqIE1hdGguc2luKHgxKSwgZCA9IDIgKiBNYXRoLmFzaW4oTWF0aC5zcXJ0KGQzX2hhdmVyc2luKHkxIC0geTApICsgY3kwICogY3kxICogZDNfaGF2ZXJzaW4oeDEgLSB4MCkpKSwgayA9IDEgLyBNYXRoLnNpbihkKTtcbiAgICB2YXIgaW50ZXJwb2xhdGUgPSBkID8gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIEIgPSBNYXRoLnNpbih0ICo9IGQpICogaywgQSA9IE1hdGguc2luKGQgLSB0KSAqIGssIHggPSBBICoga3gwICsgQiAqIGt4MSwgeSA9IEEgKiBreTAgKyBCICoga3kxLCB6ID0gQSAqIHN5MCArIEIgKiBzeTE7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHksIHgpICogZDNfZGVncmVlcywgTWF0aC5hdGFuMih6LCBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpICogZDNfZGVncmVlcyBdO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbIHgwICogZDNfZGVncmVlcywgeTAgKiBkM19kZWdyZWVzIF07XG4gICAgfTtcbiAgICBpbnRlcnBvbGF0ZS5kaXN0YW5jZSA9IGQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9XG4gIGQzLmdlby5sZW5ndGggPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBkM19nZW9fbGVuZ3RoU3VtID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2xlbmd0aCk7XG4gICAgcmV0dXJuIGQzX2dlb19sZW5ndGhTdW07XG4gIH07XG4gIHZhciBkM19nZW9fbGVuZ3RoU3VtO1xuICB2YXIgZDNfZ2VvX2xlbmd0aCA9IHtcbiAgICBzcGhlcmU6IGQzX25vb3AsXG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fbGVuZ3RoTGluZVN0YXJ0LFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBkM19ub29wLFxuICAgIHBvbHlnb25FbmQ6IGQzX25vb3BcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2xlbmd0aExpbmVTdGFydCgpIHtcbiAgICB2YXIgzrswLCBzaW7PhjAsIGNvc8+GMDtcbiAgICBkM19nZW9fbGVuZ3RoLnBvaW50ID0gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICDOuzAgPSDOuyAqIGQzX3JhZGlhbnMsIHNpbs+GMCA9IE1hdGguc2luKM+GICo9IGQzX3JhZGlhbnMpLCBjb3PPhjAgPSBNYXRoLmNvcyjPhik7XG4gICAgICBkM19nZW9fbGVuZ3RoLnBvaW50ID0gbmV4dFBvaW50O1xuICAgIH07XG4gICAgZDNfZ2VvX2xlbmd0aC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fbGVuZ3RoLnBvaW50ID0gZDNfZ2VvX2xlbmd0aC5saW5lRW5kID0gZDNfbm9vcDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIHZhciBzaW7PhiA9IE1hdGguc2luKM+GICo9IGQzX3JhZGlhbnMpLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgdCA9IGFicygozrsgKj0gZDNfcmFkaWFucykgLSDOuzApLCBjb3POlM67ID0gTWF0aC5jb3ModCk7XG4gICAgICBkM19nZW9fbGVuZ3RoU3VtICs9IE1hdGguYXRhbjIoTWF0aC5zcXJ0KCh0ID0gY29zz4YgKiBNYXRoLnNpbih0KSkgKiB0ICsgKHQgPSBjb3PPhjAgKiBzaW7PhiAtIHNpbs+GMCAqIGNvc8+GICogY29zzpTOuykgKiB0KSwgc2luz4YwICogc2luz4YgKyBjb3PPhjAgKiBjb3PPhiAqIGNvc86UzrspO1xuICAgICAgzrswID0gzrssIHNpbs+GMCA9IHNpbs+GLCBjb3PPhjAgPSBjb3PPhjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2F6aW11dGhhbChzY2FsZSwgYW5nbGUpIHtcbiAgICBmdW5jdGlvbiBhemltdXRoYWwozrssIM+GKSB7XG4gICAgICB2YXIgY29zzrsgPSBNYXRoLmNvcyjOuyksIGNvc8+GID0gTWF0aC5jb3Moz4YpLCBrID0gc2NhbGUoY29zzrsgKiBjb3PPhik7XG4gICAgICByZXR1cm4gWyBrICogY29zz4YgKiBNYXRoLnNpbijOuyksIGsgKiBNYXRoLnNpbijPhikgXTtcbiAgICB9XG4gICAgYXppbXV0aGFsLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KSwgYyA9IGFuZ2xlKM+BKSwgc2luYyA9IE1hdGguc2luKGMpLCBjb3NjID0gTWF0aC5jb3MoYyk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHggKiBzaW5jLCDPgSAqIGNvc2MpLCBNYXRoLmFzaW4oz4EgJiYgeSAqIHNpbmMgLyDPgSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBhemltdXRoYWw7XG4gIH1cbiAgdmFyIGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWEgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIgLyAoMSArIGNvc867Y29zz4YpKTtcbiAgfSwgZnVuY3Rpb24oz4EpIHtcbiAgICByZXR1cm4gMiAqIE1hdGguYXNpbijPgSAvIDIpO1xuICB9KTtcbiAgKGQzLmdlby5hemltdXRoYWxFcXVhbEFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2F6aW11dGhhbEVxdWFsQXJlYSk7XG4gIH0pLnJhdyA9IGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWE7XG4gIHZhciBkM19nZW9fYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKGNvc867Y29zz4YpIHtcbiAgICB2YXIgYyA9IE1hdGguYWNvcyhjb3POu2Nvc8+GKTtcbiAgICByZXR1cm4gYyAmJiBjIC8gTWF0aC5zaW4oYyk7XG4gIH0sIGQzX2lkZW50aXR5KTtcbiAgKGQzLmdlby5hemltdXRoYWxFcXVpZGlzdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fYXppbXV0aGFsRXF1aWRpc3RhbnQpO1xuICB9KS5yYXcgPSBkM19nZW9fYXppbXV0aGFsRXF1aWRpc3RhbnQ7XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0NvbmZvcm1hbCjPhjAsIM+GMSkge1xuICAgIHZhciBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCB0ID0gZnVuY3Rpb24oz4YpIHtcbiAgICAgIHJldHVybiBNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpO1xuICAgIH0sIG4gPSDPhjAgPT09IM+GMSA/IE1hdGguc2luKM+GMCkgOiBNYXRoLmxvZyhjb3PPhjAgLyBNYXRoLmNvcyjPhjEpKSAvIE1hdGgubG9nKHQoz4YxKSAvIHQoz4YwKSksIEYgPSBjb3PPhjAgKiBNYXRoLnBvdyh0KM+GMCksIG4pIC8gbjtcbiAgICBpZiAoIW4pIHJldHVybiBkM19nZW9fbWVyY2F0b3I7XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIGlmIChGID4gMCkge1xuICAgICAgICBpZiAoz4YgPCAtaGFsZs+AICsgzrUpIM+GID0gLWhhbGbPgCArIM61O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKM+GID4gaGFsZs+AIC0gzrUpIM+GID0gaGFsZs+AIC0gzrU7XG4gICAgICB9XG4gICAgICB2YXIgz4EgPSBGIC8gTWF0aC5wb3codCjPhiksIG4pO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbihuICogzrspLCBGIC0gz4EgKiBNYXRoLmNvcyhuICogzrspIF07XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BMF95ID0gRiAtIHksIM+BID0gZDNfc2duKG4pICogTWF0aC5zcXJ0KHggKiB4ICsgz4EwX3kgKiDPgTBfeSk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIDIgKiBNYXRoLmF0YW4oTWF0aC5wb3coRiAvIM+BLCAxIC8gbikpIC0gaGFsZs+AIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljQ29uZm9ybWFsID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNDb25mb3JtYWwpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNDb25mb3JtYWw7XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0VxdWlkaXN0YW50KM+GMCwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCA9IE1hdGguY29zKM+GMCksIG4gPSDPhjAgPT09IM+GMSA/IE1hdGguc2luKM+GMCkgOiAoY29zz4YwIC0gTWF0aC5jb3Moz4YxKSkgLyAoz4YxIC0gz4YwKSwgRyA9IGNvc8+GMCAvIG4gKyDPhjA7XG4gICAgaWYgKGFicyhuKSA8IM61KSByZXR1cm4gZDNfZ2VvX2VxdWlyZWN0YW5ndWxhcjtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKM67LCDPhikge1xuICAgICAgdmFyIM+BID0gRyAtIM+GO1xuICAgICAgcmV0dXJuIFsgz4EgKiBNYXRoLnNpbihuICogzrspLCBHIC0gz4EgKiBNYXRoLmNvcyhuICogzrspIF07XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIM+BMF95ID0gRyAtIHk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIEcgLSBkM19zZ24obikgKiBNYXRoLnNxcnQoeCAqIHggKyDPgTBfeSAqIM+BMF95KSBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0VxdWlkaXN0YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNFcXVpZGlzdGFudCk7XG4gIH0pLnJhdyA9IGQzX2dlb19jb25pY0VxdWlkaXN0YW50O1xuICB2YXIgZDNfZ2VvX2dub21vbmljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIDEgLyBjb3POu2Nvc8+GO1xuICB9LCBNYXRoLmF0YW4pO1xuICAoZDMuZ2VvLmdub21vbmljID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19nbm9tb25pYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19nbm9tb25pYztcbiAgZnVuY3Rpb24gZDNfZ2VvX21lcmNhdG9yKM67LCDPhikge1xuICAgIHJldHVybiBbIM67LCBNYXRoLmxvZyhNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpKSBdO1xuICB9XG4gIGQzX2dlb19tZXJjYXRvci5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsgeCwgMiAqIE1hdGguYXRhbihNYXRoLmV4cCh5KSkgLSBoYWxmz4AgXTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgdmFyIG0gPSBkM19nZW9fcHJvamVjdGlvbihwcm9qZWN0KSwgc2NhbGUgPSBtLnNjYWxlLCB0cmFuc2xhdGUgPSBtLnRyYW5zbGF0ZSwgY2xpcEV4dGVudCA9IG0uY2xpcEV4dGVudCwgY2xpcEF1dG87XG4gICAgbS5zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSBzY2FsZS5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHYgPT09IG0gPyBjbGlwQXV0byA/IG0uY2xpcEV4dGVudChudWxsKSA6IG0gOiB2O1xuICAgIH07XG4gICAgbS50cmFuc2xhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdHJhbnNsYXRlLmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdiA9PT0gbSA/IGNsaXBBdXRvID8gbS5jbGlwRXh0ZW50KG51bGwpIDogbSA6IHY7XG4gICAgfTtcbiAgICBtLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICB2YXIgdiA9IGNsaXBFeHRlbnQuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIGlmICh2ID09PSBtKSB7XG4gICAgICAgIGlmIChjbGlwQXV0byA9IF8gPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBrID0gz4AgKiBzY2FsZSgpLCB0ID0gdHJhbnNsYXRlKCk7XG4gICAgICAgICAgY2xpcEV4dGVudChbIFsgdFswXSAtIGssIHRbMV0gLSBrIF0sIFsgdFswXSArIGssIHRbMV0gKyBrIF0gXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2xpcEF1dG8pIHtcbiAgICAgICAgdiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9O1xuICAgIHJldHVybiBtLmNsaXBFeHRlbnQobnVsbCk7XG4gIH1cbiAgKGQzLmdlby5tZXJjYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKGQzX2dlb19tZXJjYXRvcik7XG4gIH0pLnJhdyA9IGQzX2dlb19tZXJjYXRvcjtcbiAgdmFyIGQzX2dlb19vcnRob2dyYXBoaWMgPSBkM19nZW9fYXppbXV0aGFsKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxO1xuICB9LCBNYXRoLmFzaW4pO1xuICAoZDMuZ2VvLm9ydGhvZ3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fb3J0aG9ncmFwaGljKTtcbiAgfSkucmF3ID0gZDNfZ2VvX29ydGhvZ3JhcGhpYztcbiAgdmFyIGQzX2dlb19zdGVyZW9ncmFwaGljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIDEgLyAoMSArIGNvc867Y29zz4YpO1xuICB9LCBmdW5jdGlvbijPgSkge1xuICAgIHJldHVybiAyICogTWF0aC5hdGFuKM+BKTtcbiAgfSk7XG4gIChkMy5nZW8uc3RlcmVvZ3JhcGhpYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fc3RlcmVvZ3JhcGhpYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19zdGVyZW9ncmFwaGljO1xuICBmdW5jdGlvbiBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yKM67LCDPhikge1xuICAgIHJldHVybiBbIE1hdGgubG9nKE1hdGgudGFuKM+AIC8gNCArIM+GIC8gMikpLCAtzrsgXTtcbiAgfVxuICBkM19nZW9fdHJhbnN2ZXJzZU1lcmNhdG9yLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gWyAteSwgMiAqIE1hdGguYXRhbihNYXRoLmV4cCh4KSkgLSBoYWxmz4AgXTtcbiAgfTtcbiAgKGQzLmdlby50cmFuc3ZlcnNlTWVyY2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvamVjdGlvbiA9IGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24oZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvciksIGNlbnRlciA9IHByb2plY3Rpb24uY2VudGVyLCByb3RhdGUgPSBwcm9qZWN0aW9uLnJvdGF0ZTtcbiAgICBwcm9qZWN0aW9uLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBfID8gY2VudGVyKFsgLV9bMV0sIF9bMF0gXSkgOiAoXyA9IGNlbnRlcigpLCBbIF9bMV0sIC1fWzBdIF0pO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gXyA/IHJvdGF0ZShbIF9bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwIF0pIDogKF8gPSByb3RhdGUoKSwgXG4gICAgICBbIF9bMF0sIF9bMV0sIF9bMl0gLSA5MCBdKTtcbiAgICB9O1xuICAgIHJldHVybiByb3RhdGUoWyAwLCAwLCA5MCBdKTtcbiAgfSkucmF3ID0gZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvcjtcbiAgZDMuZ2VvbSA9IHt9O1xuICBmdW5jdGlvbiBkM19nZW9tX3BvaW50WChkKSB7XG4gICAgcmV0dXJuIGRbMF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2ludFkoZCkge1xuICAgIHJldHVybiBkWzFdO1xuICB9XG4gIGQzLmdlb20uaHVsbCA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaHVsbCh2ZXJ0aWNlcyk7XG4gICAgZnVuY3Rpb24gaHVsbChkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPCAzKSByZXR1cm4gW107XG4gICAgICB2YXIgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSksIGksIG4gPSBkYXRhLmxlbmd0aCwgcG9pbnRzID0gW10sIGZsaXBwZWRQb2ludHMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcG9pbnRzLnB1c2goWyArZnguY2FsbCh0aGlzLCBkYXRhW2ldLCBpKSwgK2Z5LmNhbGwodGhpcywgZGF0YVtpXSwgaSksIGkgXSk7XG4gICAgICB9XG4gICAgICBwb2ludHMuc29ydChkM19nZW9tX2h1bGxPcmRlcik7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBmbGlwcGVkUG9pbnRzLnB1c2goWyBwb2ludHNbaV1bMF0sIC1wb2ludHNbaV1bMV0gXSk7XG4gICAgICB2YXIgdXBwZXIgPSBkM19nZW9tX2h1bGxVcHBlcihwb2ludHMpLCBsb3dlciA9IGQzX2dlb21faHVsbFVwcGVyKGZsaXBwZWRQb2ludHMpO1xuICAgICAgdmFyIHNraXBMZWZ0ID0gbG93ZXJbMF0gPT09IHVwcGVyWzBdLCBza2lwUmlnaHQgPSBsb3dlcltsb3dlci5sZW5ndGggLSAxXSA9PT0gdXBwZXJbdXBwZXIubGVuZ3RoIC0gMV0sIHBvbHlnb24gPSBbXTtcbiAgICAgIGZvciAoaSA9IHVwcGVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBwb2x5Z29uLnB1c2goZGF0YVtwb2ludHNbdXBwZXJbaV1dWzJdXSk7XG4gICAgICBmb3IgKGkgPSArc2tpcExlZnQ7IGkgPCBsb3dlci5sZW5ndGggLSBza2lwUmlnaHQ7ICsraSkgcG9seWdvbi5wdXNoKGRhdGFbcG9pbnRzW2xvd2VyW2ldXVsyXV0pO1xuICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgfVxuICAgIGh1bGwueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBfLCBodWxsKSA6IHg7XG4gICAgfTtcbiAgICBodWxsLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gXywgaHVsbCkgOiB5O1xuICAgIH07XG4gICAgcmV0dXJuIGh1bGw7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21faHVsbFVwcGVyKHBvaW50cykge1xuICAgIHZhciBuID0gcG9pbnRzLmxlbmd0aCwgaHVsbCA9IFsgMCwgMSBdLCBocyA9IDI7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBuOyBpKyspIHtcbiAgICAgIHdoaWxlIChocyA+IDEgJiYgZDNfY3Jvc3MyZChwb2ludHNbaHVsbFtocyAtIDJdXSwgcG9pbnRzW2h1bGxbaHMgLSAxXV0sIHBvaW50c1tpXSkgPD0gMCkgLS1ocztcbiAgICAgIGh1bGxbaHMrK10gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gaHVsbC5zbGljZSgwLCBocyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9odWxsT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBhWzBdIC0gYlswXSB8fCBhWzFdIC0gYlsxXTtcbiAgfVxuICBkMy5nZW9tLnBvbHlnb24gPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgIGQzX3N1YmNsYXNzKGNvb3JkaW5hdGVzLCBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUpO1xuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfTtcbiAgdmFyIGQzX2dlb21fcG9seWdvblByb3RvdHlwZSA9IGQzLmdlb20ucG9seWdvbi5wcm90b3R5cGUgPSBbXTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIGEsIGIgPSB0aGlzW24gLSAxXSwgYXJlYSA9IDA7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHRoaXNbaV07XG4gICAgICBhcmVhICs9IGFbMV0gKiBiWzBdIC0gYVswXSAqIGJbMV07XG4gICAgfVxuICAgIHJldHVybiBhcmVhICogLjU7XG4gIH07XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5jZW50cm9pZCA9IGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIHggPSAwLCB5ID0gMCwgYSwgYiA9IHRoaXNbbiAtIDFdLCBjO1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgayA9IC0xIC8gKDYgKiB0aGlzLmFyZWEoKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGEgPSBiO1xuICAgICAgYiA9IHRoaXNbaV07XG4gICAgICBjID0gYVswXSAqIGJbMV0gLSBiWzBdICogYVsxXTtcbiAgICAgIHggKz0gKGFbMF0gKyBiWzBdKSAqIGM7XG4gICAgICB5ICs9IChhWzFdICsgYlsxXSkgKiBjO1xuICAgIH1cbiAgICByZXR1cm4gWyB4ICogaywgeSAqIGsgXTtcbiAgfTtcbiAgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlLmNsaXAgPSBmdW5jdGlvbihzdWJqZWN0KSB7XG4gICAgdmFyIGlucHV0LCBjbG9zZWQgPSBkM19nZW9tX3BvbHlnb25DbG9zZWQoc3ViamVjdCksIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoIC0gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKHRoaXMpLCBqLCBtLCBhID0gdGhpc1tuIC0gMV0sIGIsIGMsIGQ7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlucHV0ID0gc3ViamVjdC5zbGljZSgpO1xuICAgICAgc3ViamVjdC5sZW5ndGggPSAwO1xuICAgICAgYiA9IHRoaXNbaV07XG4gICAgICBjID0gaW5wdXRbKG0gPSBpbnB1dC5sZW5ndGggLSBjbG9zZWQpIC0gMV07XG4gICAgICBqID0gLTE7XG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICBkID0gaW5wdXRbal07XG4gICAgICAgIGlmIChkM19nZW9tX3BvbHlnb25JbnNpZGUoZCwgYSwgYikpIHtcbiAgICAgICAgICBpZiAoIWQzX2dlb21fcG9seWdvbkluc2lkZShjLCBhLCBiKSkge1xuICAgICAgICAgICAgc3ViamVjdC5wdXNoKGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YmplY3QucHVzaChkKTtcbiAgICAgICAgfSBlbHNlIGlmIChkM19nZW9tX3BvbHlnb25JbnNpZGUoYywgYSwgYikpIHtcbiAgICAgICAgICBzdWJqZWN0LnB1c2goZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpKTtcbiAgICAgICAgfVxuICAgICAgICBjID0gZDtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZWQpIHN1YmplY3QucHVzaChzdWJqZWN0WzBdKTtcbiAgICAgIGEgPSBiO1xuICAgIH1cbiAgICByZXR1cm4gc3ViamVjdDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKHAsIGEsIGIpIHtcbiAgICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChwWzFdIC0gYVsxXSkgPCAoYlsxXSAtIGFbMV0pICogKHBbMF0gLSBhWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikge1xuICAgIHZhciB4MSA9IGNbMF0sIHgzID0gYVswXSwgeDIxID0gZFswXSAtIHgxLCB4NDMgPSBiWzBdIC0geDMsIHkxID0gY1sxXSwgeTMgPSBhWzFdLCB5MjEgPSBkWzFdIC0geTEsIHk0MyA9IGJbMV0gLSB5MywgdWEgPSAoeDQzICogKHkxIC0geTMpIC0geTQzICogKHgxIC0geDMpKSAvICh5NDMgKiB4MjEgLSB4NDMgKiB5MjEpO1xuICAgIHJldHVybiBbIHgxICsgdWEgKiB4MjEsIHkxICsgdWEgKiB5MjEgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3BvbHlnb25DbG9zZWQoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgYSA9IGNvb3JkaW5hdGVzWzBdLCBiID0gY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuICEoYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0pO1xuICB9XG4gIHZhciBkM19nZW9tX3Zvcm9ub2lFZGdlcywgZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsIGQzX2dlb21fdm9yb25vaUJlYWNoZXMsIGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbCA9IFtdLCBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSwgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcywgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbCA9IFtdO1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lCZWFjaCgpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUodGhpcyk7XG4gICAgdGhpcy5lZGdlID0gdGhpcy5zaXRlID0gdGhpcy5jaXJjbGUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKHNpdGUpIHtcbiAgICB2YXIgYmVhY2ggPSBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wucG9wKCkgfHwgbmV3IGQzX2dlb21fdm9yb25vaUJlYWNoKCk7XG4gICAgYmVhY2guc2l0ZSA9IHNpdGU7XG4gICAgcmV0dXJuIGJlYWNoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKGJlYWNoKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLnJlbW92ZShiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sLnB1c2goYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShiZWFjaCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVtb3ZlQmVhY2goYmVhY2gpIHtcbiAgICB2YXIgY2lyY2xlID0gYmVhY2guY2lyY2xlLCB4ID0gY2lyY2xlLngsIHkgPSBjaXJjbGUuY3ksIHZlcnRleCA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSwgcHJldmlvdXMgPSBiZWFjaC5QLCBuZXh0ID0gYmVhY2guTiwgZGlzYXBwZWFyaW5nID0gWyBiZWFjaCBdO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKGJlYWNoKTtcbiAgICB2YXIgbEFyYyA9IHByZXZpb3VzO1xuICAgIHdoaWxlIChsQXJjLmNpcmNsZSAmJiBhYnMoeCAtIGxBcmMuY2lyY2xlLngpIDwgzrUgJiYgYWJzKHkgLSBsQXJjLmNpcmNsZS5jeSkgPCDOtSkge1xuICAgICAgcHJldmlvdXMgPSBsQXJjLlA7XG4gICAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKGxBcmMpO1xuICAgICAgbEFyYyA9IHByZXZpb3VzO1xuICAgIH1cbiAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgdmFyIHJBcmMgPSBuZXh0O1xuICAgIHdoaWxlIChyQXJjLmNpcmNsZSAmJiBhYnMoeCAtIHJBcmMuY2lyY2xlLngpIDwgzrUgJiYgYWJzKHkgLSByQXJjLmNpcmNsZS5jeSkgPCDOtSkge1xuICAgICAgbmV4dCA9IHJBcmMuTjtcbiAgICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQmVhY2gockFyYyk7XG4gICAgICByQXJjID0gbmV4dDtcbiAgICB9XG4gICAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHZhciBuQXJjcyA9IGRpc2FwcGVhcmluZy5sZW5ndGgsIGlBcmM7XG4gICAgZm9yIChpQXJjID0gMTsgaUFyYyA8IG5BcmNzOyArK2lBcmMpIHtcbiAgICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbaUFyY107XG4gICAgICBsQXJjID0gZGlzYXBwZWFyaW5nW2lBcmMgLSAxXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQockFyYy5lZGdlLCBsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgdmVydGV4KTtcbiAgICB9XG4gICAgbEFyYyA9IGRpc2FwcGVhcmluZ1swXTtcbiAgICByQXJjID0gZGlzYXBwZWFyaW5nW25BcmNzIC0gMV07XG4gICAgckFyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUFkZEJlYWNoKHNpdGUpIHtcbiAgICB2YXIgeCA9IHNpdGUueCwgZGlyZWN0cml4ID0gc2l0ZS55LCBsQXJjLCByQXJjLCBkeGwsIGR4ciwgbm9kZSA9IGQzX2dlb21fdm9yb25vaUJlYWNoZXMuXztcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgZHhsID0gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KSAtIHg7XG4gICAgICBpZiAoZHhsID4gzrUpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgICBkeHIgPSB4IC0gZDNfZ2VvbV92b3Jvbm9pUmlnaHRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCk7XG4gICAgICAgIGlmIChkeHIgPiDOtSkge1xuICAgICAgICAgIGlmICghbm9kZS5SKSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChkeGwgPiAtzrUpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlLlA7XG4gICAgICAgICAgICByQXJjID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGR4ciA+IC3OtSkge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgICByQXJjID0gbm9kZS5OO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsQXJjID0gckFyYyA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXdBcmMgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChzaXRlKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLmluc2VydChsQXJjLCBuZXdBcmMpO1xuICAgIGlmICghbEFyYyAmJiAhckFyYykgcmV0dXJuO1xuICAgIGlmIChsQXJjID09PSByQXJjKSB7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgICByQXJjID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMuaW5zZXJ0KG5ld0FyYywgckFyYyk7XG4gICAgICBuZXdBcmMuZWRnZSA9IHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghckFyYykge1xuICAgICAgbmV3QXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSwgYXggPSBsU2l0ZS54LCBheSA9IGxTaXRlLnksIGJ4ID0gc2l0ZS54IC0gYXgsIGJ5ID0gc2l0ZS55IC0gYXksIHJTaXRlID0gckFyYy5zaXRlLCBjeCA9IHJTaXRlLnggLSBheCwgY3kgPSByU2l0ZS55IC0gYXksIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSwgaGIgPSBieCAqIGJ4ICsgYnkgKiBieSwgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSwgdmVydGV4ID0ge1xuICAgICAgeDogKGN5ICogaGIgLSBieSAqIGhjKSAvIGQgKyBheCxcbiAgICAgIHk6IChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXlcbiAgICB9O1xuICAgIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQockFyYy5lZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCk7XG4gICAgbmV3QXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxTaXRlLCBzaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2Uoc2l0ZSwgclNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgIHZhciBzaXRlID0gYXJjLnNpdGUsIHJmb2N4ID0gc2l0ZS54LCByZm9jeSA9IHNpdGUueSwgcGJ5MiA9IHJmb2N5IC0gZGlyZWN0cml4O1xuICAgIGlmICghcGJ5MikgcmV0dXJuIHJmb2N4O1xuICAgIHZhciBsQXJjID0gYXJjLlA7XG4gICAgaWYgKCFsQXJjKSByZXR1cm4gLUluZmluaXR5O1xuICAgIHNpdGUgPSBsQXJjLnNpdGU7XG4gICAgdmFyIGxmb2N4ID0gc2l0ZS54LCBsZm9jeSA9IHNpdGUueSwgcGxieTIgPSBsZm9jeSAtIGRpcmVjdHJpeDtcbiAgICBpZiAoIXBsYnkyKSByZXR1cm4gbGZvY3g7XG4gICAgdmFyIGhsID0gbGZvY3ggLSByZm9jeCwgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLCBiID0gaGwgLyBwbGJ5MjtcbiAgICBpZiAoYWJ5MikgcmV0dXJuICgtYiArIE1hdGguc3FydChiICogYiAtIDIgKiBhYnkyICogKGhsICogaGwgLyAoLTIgKiBwbGJ5MikgLSBsZm9jeSArIHBsYnkyIC8gMiArIHJmb2N5IC0gcGJ5MiAvIDIpKSkgLyBhYnkyICsgcmZvY3g7XG4gICAgcmV0dXJuIChyZm9jeCArIGxmb2N4KSAvIDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmlnaHRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gICAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgICBpZiAockFyYykgcmV0dXJuIGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KHJBcmMsIGRpcmVjdHJpeCk7XG4gICAgdmFyIHNpdGUgPSBhcmMuc2l0ZTtcbiAgICByZXR1cm4gc2l0ZS55ID09PSBkaXJlY3RyaXggPyBzaXRlLnggOiBJbmZpbml0eTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDZWxsKHNpdGUpIHtcbiAgICB0aGlzLnNpdGUgPSBzaXRlO1xuICAgIHRoaXMuZWRnZXMgPSBbXTtcbiAgfVxuICBkM19nZW9tX3Zvcm9ub2lDZWxsLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhhbGZFZGdlcyA9IHRoaXMuZWRnZXMsIGlIYWxmRWRnZSA9IGhhbGZFZGdlcy5sZW5ndGgsIGVkZ2U7XG4gICAgd2hpbGUgKGlIYWxmRWRnZS0tKSB7XG4gICAgICBlZGdlID0gaGFsZkVkZ2VzW2lIYWxmRWRnZV0uZWRnZTtcbiAgICAgIGlmICghZWRnZS5iIHx8ICFlZGdlLmEpIGhhbGZFZGdlcy5zcGxpY2UoaUhhbGZFZGdlLCAxKTtcbiAgICB9XG4gICAgaGFsZkVkZ2VzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlcik7XG4gICAgcmV0dXJuIGhhbGZFZGdlcy5sZW5ndGg7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNsb3NlQ2VsbHMoZXh0ZW50KSB7XG4gICAgdmFyIHgwID0gZXh0ZW50WzBdWzBdLCB4MSA9IGV4dGVudFsxXVswXSwgeTAgPSBleHRlbnRbMF1bMV0sIHkxID0gZXh0ZW50WzFdWzFdLCB4MiwgeTIsIHgzLCB5MywgY2VsbHMgPSBkM19nZW9tX3Zvcm9ub2lDZWxscywgaUNlbGwgPSBjZWxscy5sZW5ndGgsIGNlbGwsIGlIYWxmRWRnZSwgaGFsZkVkZ2VzLCBuSGFsZkVkZ2VzLCBzdGFydCwgZW5kO1xuICAgIHdoaWxlIChpQ2VsbC0tKSB7XG4gICAgICBjZWxsID0gY2VsbHNbaUNlbGxdO1xuICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLnByZXBhcmUoKSkgY29udGludWU7XG4gICAgICBoYWxmRWRnZXMgPSBjZWxsLmVkZ2VzO1xuICAgICAgbkhhbGZFZGdlcyA9IGhhbGZFZGdlcy5sZW5ndGg7XG4gICAgICBpSGFsZkVkZ2UgPSAwO1xuICAgICAgd2hpbGUgKGlIYWxmRWRnZSA8IG5IYWxmRWRnZXMpIHtcbiAgICAgICAgZW5kID0gaGFsZkVkZ2VzW2lIYWxmRWRnZV0uZW5kKCksIHgzID0gZW5kLngsIHkzID0gZW5kLnk7XG4gICAgICAgIHN0YXJ0ID0gaGFsZkVkZ2VzWysraUhhbGZFZGdlICUgbkhhbGZFZGdlc10uc3RhcnQoKSwgeDIgPSBzdGFydC54LCB5MiA9IHN0YXJ0Lnk7XG4gICAgICAgIGlmIChhYnMoeDMgLSB4MikgPiDOtSB8fCBhYnMoeTMgLSB5MikgPiDOtSkge1xuICAgICAgICAgIGhhbGZFZGdlcy5zcGxpY2UoaUhhbGZFZGdlLCAwLCBuZXcgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQm9yZGVyRWRnZShjZWxsLnNpdGUsIGVuZCwgYWJzKHgzIC0geDApIDwgzrUgJiYgeTEgLSB5MyA+IM61ID8ge1xuICAgICAgICAgICAgeDogeDAsXG4gICAgICAgICAgICB5OiBhYnMoeDIgLSB4MCkgPCDOtSA/IHkyIDogeTFcbiAgICAgICAgICB9IDogYWJzKHkzIC0geTEpIDwgzrUgJiYgeDEgLSB4MyA+IM61ID8ge1xuICAgICAgICAgICAgeDogYWJzKHkyIC0geTEpIDwgzrUgPyB4MiA6IHgxLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9IDogYWJzKHgzIC0geDEpIDwgzrUgJiYgeTMgLSB5MCA+IM61ID8ge1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiBhYnMoeDIgLSB4MSkgPCDOtSA/IHkyIDogeTBcbiAgICAgICAgICB9IDogYWJzKHkzIC0geTApIDwgzrUgJiYgeDMgLSB4MCA+IM61ID8ge1xuICAgICAgICAgICAgeDogYWJzKHkyIC0geTApIDwgzrUgPyB4MiA6IHgwLFxuICAgICAgICAgICAgeTogeTBcbiAgICAgICAgICB9IDogbnVsbCksIGNlbGwuc2l0ZSwgbnVsbCkpO1xuICAgICAgICAgICsrbkhhbGZFZGdlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hbmdsZSAtIGEuYW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlKCkge1xuICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZSh0aGlzKTtcbiAgICB0aGlzLnggPSB0aGlzLnkgPSB0aGlzLmFyYyA9IHRoaXMuc2l0ZSA9IHRoaXMuY3kgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShhcmMpIHtcbiAgICB2YXIgbEFyYyA9IGFyYy5QLCByQXJjID0gYXJjLk47XG4gICAgaWYgKCFsQXJjIHx8ICFyQXJjKSByZXR1cm47XG4gICAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLCBjU2l0ZSA9IGFyYy5zaXRlLCByU2l0ZSA9IHJBcmMuc2l0ZTtcbiAgICBpZiAobFNpdGUgPT09IHJTaXRlKSByZXR1cm47XG4gICAgdmFyIGJ4ID0gY1NpdGUueCwgYnkgPSBjU2l0ZS55LCBheCA9IGxTaXRlLnggLSBieCwgYXkgPSBsU2l0ZS55IC0gYnksIGN4ID0gclNpdGUueCAtIGJ4LCBjeSA9IHJTaXRlLnkgLSBieTtcbiAgICB2YXIgZCA9IDIgKiAoYXggKiBjeSAtIGF5ICogY3gpO1xuICAgIGlmIChkID49IC3OtTIpIHJldHVybjtcbiAgICB2YXIgaGEgPSBheCAqIGF4ICsgYXkgKiBheSwgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSwgeCA9IChjeSAqIGhhIC0gYXkgKiBoYykgLyBkLCB5ID0gKGF4ICogaGMgLSBjeCAqIGhhKSAvIGQsIGN5ID0geSArIGJ5O1xuICAgIHZhciBjaXJjbGUgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVQb29sLnBvcCgpIHx8IG5ldyBkM19nZW9tX3Zvcm9ub2lDaXJjbGUoKTtcbiAgICBjaXJjbGUuYXJjID0gYXJjO1xuICAgIGNpcmNsZS5zaXRlID0gY1NpdGU7XG4gICAgY2lyY2xlLnggPSB4ICsgYng7XG4gICAgY2lyY2xlLnkgPSBjeSArIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICBjaXJjbGUuY3kgPSBjeTtcbiAgICBhcmMuY2lyY2xlID0gY2lyY2xlO1xuICAgIHZhciBiZWZvcmUgPSBudWxsLCBub2RlID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5fO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBpZiAoY2lyY2xlLnkgPCBub2RlLnkgfHwgY2lyY2xlLnkgPT09IG5vZGUueSAmJiBjaXJjbGUueCA8PSBub2RlLngpIHtcbiAgICAgICAgaWYgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDsgZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gbm9kZS5QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZS5SKSBub2RlID0gbm9kZS5SOyBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBub2RlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMuaW5zZXJ0KGJlZm9yZSwgY2lyY2xlKTtcbiAgICBpZiAoIWJlZm9yZSkgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUgPSBjaXJjbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGFyYykge1xuICAgIHZhciBjaXJjbGUgPSBhcmMuY2lyY2xlO1xuICAgIGlmIChjaXJjbGUpIHtcbiAgICAgIGlmICghY2lyY2xlLlApIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlID0gY2lyY2xlLk47XG4gICAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLnJlbW92ZShjaXJjbGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbC5wdXNoKGNpcmNsZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUoY2lyY2xlKTtcbiAgICAgIGFyYy5jaXJjbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDbGlwRWRnZXMoZXh0ZW50KSB7XG4gICAgdmFyIGVkZ2VzID0gZDNfZ2VvbV92b3Jvbm9pRWRnZXMsIGNsaXAgPSBkM19nZW9tX2NsaXBMaW5lKGV4dGVudFswXVswXSwgZXh0ZW50WzBdWzFdLCBleHRlbnRbMV1bMF0sIGV4dGVudFsxXVsxXSksIGkgPSBlZGdlcy5sZW5ndGgsIGU7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgZSA9IGVkZ2VzW2ldO1xuICAgICAgaWYgKCFkM19nZW9tX3Zvcm9ub2lDb25uZWN0RWRnZShlLCBleHRlbnQpIHx8ICFjbGlwKGUpIHx8IGFicyhlLmEueCAtIGUuYi54KSA8IM61ICYmIGFicyhlLmEueSAtIGUuYi55KSA8IM61KSB7XG4gICAgICAgIGUuYSA9IGUuYiA9IG51bGw7XG4gICAgICAgIGVkZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ29ubmVjdEVkZ2UoZWRnZSwgZXh0ZW50KSB7XG4gICAgdmFyIHZiID0gZWRnZS5iO1xuICAgIGlmICh2YikgcmV0dXJuIHRydWU7XG4gICAgdmFyIHZhID0gZWRnZS5hLCB4MCA9IGV4dGVudFswXVswXSwgeDEgPSBleHRlbnRbMV1bMF0sIHkwID0gZXh0ZW50WzBdWzFdLCB5MSA9IGV4dGVudFsxXVsxXSwgbFNpdGUgPSBlZGdlLmwsIHJTaXRlID0gZWRnZS5yLCBseCA9IGxTaXRlLngsIGx5ID0gbFNpdGUueSwgcnggPSByU2l0ZS54LCByeSA9IHJTaXRlLnksIGZ4ID0gKGx4ICsgcngpIC8gMiwgZnkgPSAobHkgKyByeSkgLyAyLCBmbSwgZmI7XG4gICAgaWYgKHJ5ID09PSBseSkge1xuICAgICAgaWYgKGZ4IDwgeDAgfHwgZnggPj0geDEpIHJldHVybjtcbiAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkwXG4gICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPj0geTEpIHJldHVybjtcbiAgICAgICAgdmIgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkxXG4gICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPCB5MCkgcmV0dXJuO1xuICAgICAgICB2YiA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmbSA9IChseCAtIHJ4KSAvIChyeSAtIGx5KTtcbiAgICAgIGZiID0gZnkgLSBmbSAqIGZ4O1xuICAgICAgaWYgKGZtIDwgLTEgfHwgZm0gPiAxKSB7XG4gICAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiAoeTAgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueSA+PSB5MSkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogKHkxIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiAoeTEgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueSA8IHkwKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiAoeTAgLSBmYikgLyBmbSxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGx5IDwgcnkpIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogZm0gKiB4MCArIGZiXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueCA+PSB4MSkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiBmbSAqIHgxICsgZmJcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogeDEsXG4gICAgICAgICAgICB5OiBmbSAqIHgxICsgZmJcbiAgICAgICAgICB9OyBlbHNlIGlmICh2YS54IDwgeDApIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogZm0gKiB4MCArIGZiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlZGdlLmEgPSB2YTtcbiAgICBlZGdlLmIgPSB2YjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCByU2l0ZSkge1xuICAgIHRoaXMubCA9IGxTaXRlO1xuICAgIHRoaXMuciA9IHJTaXRlO1xuICAgIHRoaXMuYSA9IHRoaXMuYiA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsU2l0ZSwgclNpdGUsIHZhLCB2Yikge1xuICAgIHZhciBlZGdlID0gbmV3IGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIHJTaXRlKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIGlmICh2YSkgZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCBsU2l0ZSwgclNpdGUsIHZhKTtcbiAgICBpZiAodmIpIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgclNpdGUsIGxTaXRlLCB2Yik7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbbFNpdGUuaV0uZWRnZXMucHVzaChuZXcgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgbFNpdGUsIHJTaXRlKSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHNbclNpdGUuaV0uZWRnZXMucHVzaChuZXcgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgclNpdGUsIGxTaXRlKSk7XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQm9yZGVyRWRnZShsU2l0ZSwgdmEsIHZiKSB7XG4gICAgdmFyIGVkZ2UgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgbnVsbCk7XG4gICAgZWRnZS5hID0gdmE7XG4gICAgZWRnZS5iID0gdmI7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMucHVzaChlZGdlKTtcbiAgICByZXR1cm4gZWRnZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIGxTaXRlLCByU2l0ZSwgdmVydGV4KSB7XG4gICAgaWYgKCFlZGdlLmEgJiYgIWVkZ2UuYikge1xuICAgICAgZWRnZS5hID0gdmVydGV4O1xuICAgICAgZWRnZS5sID0gbFNpdGU7XG4gICAgICBlZGdlLnIgPSByU2l0ZTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UubCA9PT0gclNpdGUpIHtcbiAgICAgIGVkZ2UuYiA9IHZlcnRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZS5hID0gdmVydGV4O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZShlZGdlLCBsU2l0ZSwgclNpdGUpIHtcbiAgICB2YXIgdmEgPSBlZGdlLmEsIHZiID0gZWRnZS5iO1xuICAgIHRoaXMuZWRnZSA9IGVkZ2U7XG4gICAgdGhpcy5zaXRlID0gbFNpdGU7XG4gICAgdGhpcy5hbmdsZSA9IHJTaXRlID8gTWF0aC5hdGFuMihyU2l0ZS55IC0gbFNpdGUueSwgclNpdGUueCAtIGxTaXRlLngpIDogZWRnZS5sID09PSBsU2l0ZSA/IE1hdGguYXRhbjIodmIueCAtIHZhLngsIHZhLnkgLSB2Yi55KSA6IE1hdGguYXRhbjIodmEueCAtIHZiLngsIHZiLnkgLSB2YS55KTtcbiAgfVxuICBkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZS5wcm90b3R5cGUgPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWRnZS5sID09PSB0aGlzLnNpdGUgPyB0aGlzLmVkZ2UuYSA6IHRoaXMuZWRnZS5iO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2UubCA9PT0gdGhpcy5zaXRlID8gdGhpcy5lZGdlLmIgOiB0aGlzLmVkZ2UuYTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpIHtcbiAgICB0aGlzLl8gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrTm9kZShub2RlKSB7XG4gICAgbm9kZS5VID0gbm9kZS5DID0gbm9kZS5MID0gbm9kZS5SID0gbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgfVxuICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUucHJvdG90eXBlID0ge1xuICAgIGluc2VydDogZnVuY3Rpb24oYWZ0ZXIsIG5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnQsIGdyYW5kcGEsIHVuY2xlO1xuICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgIG5vZGUuUCA9IGFmdGVyO1xuICAgICAgICBub2RlLk4gPSBhZnRlci5OO1xuICAgICAgICBpZiAoYWZ0ZXIuTikgYWZ0ZXIuTi5QID0gbm9kZTtcbiAgICAgICAgYWZ0ZXIuTiA9IG5vZGU7XG4gICAgICAgIGlmIChhZnRlci5SKSB7XG4gICAgICAgICAgYWZ0ZXIgPSBhZnRlci5SO1xuICAgICAgICAgIHdoaWxlIChhZnRlci5MKSBhZnRlciA9IGFmdGVyLkw7XG4gICAgICAgICAgYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZ0ZXIuUiA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuXykge1xuICAgICAgICBhZnRlciA9IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3QodGhpcy5fKTtcbiAgICAgICAgbm9kZS5QID0gbnVsbDtcbiAgICAgICAgbm9kZS5OID0gYWZ0ZXI7XG4gICAgICAgIGFmdGVyLlAgPSBhZnRlci5MID0gbm9kZTtcbiAgICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLlAgPSBub2RlLk4gPSBudWxsO1xuICAgICAgICB0aGlzLl8gPSBub2RlO1xuICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZS5MID0gbm9kZS5SID0gbnVsbDtcbiAgICAgIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgIG5vZGUuQyA9IHRydWU7XG4gICAgICBhZnRlciA9IG5vZGU7XG4gICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5DKSB7XG4gICAgICAgIGdyYW5kcGEgPSBwYXJlbnQuVTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gZ3JhbmRwYS5MKSB7XG4gICAgICAgICAgdW5jbGUgPSBncmFuZHBhLlI7XG4gICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFmdGVyID09PSBwYXJlbnQuUikge1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuY2xlID0gZ3JhbmRwYS5MO1xuICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgfVxuICAgICAgdGhpcy5fLkMgPSBmYWxzZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24obm9kZSkge1xuICAgICAgaWYgKG5vZGUuTikgbm9kZS5OLlAgPSBub2RlLlA7XG4gICAgICBpZiAobm9kZS5QKSBub2RlLlAuTiA9IG5vZGUuTjtcbiAgICAgIG5vZGUuTiA9IG5vZGUuUCA9IG51bGw7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5VLCBzaWJsaW5nLCBsZWZ0ID0gbm9kZS5MLCByaWdodCA9IG5vZGUuUiwgbmV4dCwgcmVkO1xuICAgICAgaWYgKCFsZWZ0KSBuZXh0ID0gcmlnaHQ7IGVsc2UgaWYgKCFyaWdodCkgbmV4dCA9IGxlZnQ7IGVsc2UgbmV4dCA9IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrRmlyc3QocmlnaHQpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LkwgPT09IG5vZGUpIHBhcmVudC5MID0gbmV4dDsgZWxzZSBwYXJlbnQuUiA9IG5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl8gPSBuZXh0O1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgICAgcmVkID0gbmV4dC5DO1xuICAgICAgICBuZXh0LkMgPSBub2RlLkM7XG4gICAgICAgIG5leHQuTCA9IGxlZnQ7XG4gICAgICAgIGxlZnQuVSA9IG5leHQ7XG4gICAgICAgIGlmIChuZXh0ICE9PSByaWdodCkge1xuICAgICAgICAgIHBhcmVudCA9IG5leHQuVTtcbiAgICAgICAgICBuZXh0LlUgPSBub2RlLlU7XG4gICAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgICBwYXJlbnQuTCA9IG5vZGU7XG4gICAgICAgICAgbmV4dC5SID0gcmlnaHQ7XG4gICAgICAgICAgcmlnaHQuVSA9IG5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dC5VID0gcGFyZW50O1xuICAgICAgICAgIHBhcmVudCA9IG5leHQ7XG4gICAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVkID0gbm9kZS5DO1xuICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlKSBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICBpZiAocmVkKSByZXR1cm47XG4gICAgICBpZiAobm9kZSAmJiBub2RlLkMpIHtcbiAgICAgICAgbm9kZS5DID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuXykgYnJlYWs7XG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2libGluZy5MICYmIHNpYmxpbmcuTC5DIHx8IHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgaWYgKCFzaWJsaW5nLlIgfHwgIXNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQyB8fCBzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIGlmICghc2libGluZy5MIHx8ICFzaWJsaW5nLkwuQykge1xuICAgICAgICAgICAgICBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuVTtcbiAgICAgIH0gd2hpbGUgKCFub2RlLkMpO1xuICAgICAgaWYgKG5vZGUpIG5vZGUuQyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRyZWUsIG5vZGUpIHtcbiAgICB2YXIgcCA9IG5vZGUsIHEgPSBub2RlLlIsIHBhcmVudCA9IHAuVTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTsgZWxzZSBwYXJlbnQuUiA9IHE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWUuXyA9IHE7XG4gICAgfVxuICAgIHEuVSA9IHBhcmVudDtcbiAgICBwLlUgPSBxO1xuICAgIHAuUiA9IHEuTDtcbiAgICBpZiAocC5SKSBwLlIuVSA9IHA7XG4gICAgcS5MID0gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRyZWUsIG5vZGUpIHtcbiAgICB2YXIgcCA9IG5vZGUsIHEgPSBub2RlLkwsIHBhcmVudCA9IHAuVTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTsgZWxzZSBwYXJlbnQuUiA9IHE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWUuXyA9IHE7XG4gICAgfVxuICAgIHEuVSA9IHBhcmVudDtcbiAgICBwLlUgPSBxO1xuICAgIHAuTCA9IHEuUjtcbiAgICBpZiAocC5MKSBwLkwuVSA9IHA7XG4gICAgcS5SID0gcDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KG5vZGUpIHtcbiAgICB3aGlsZSAobm9kZS5MKSBub2RlID0gbm9kZS5MO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaShzaXRlcywgYmJveCkge1xuICAgIHZhciBzaXRlID0gc2l0ZXMuc29ydChkM19nZW9tX3Zvcm9ub2lWZXJ0ZXhPcmRlcikucG9wKCksIHgwLCB5MCwgY2lyY2xlO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzID0gW107XG4gICAgZDNfZ2VvbV92b3Jvbm9pQ2VsbHMgPSBuZXcgQXJyYXkoc2l0ZXMubGVuZ3RoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzID0gbmV3IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpO1xuICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZXMgPSBuZXcgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNpcmNsZSA9IGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlO1xuICAgICAgaWYgKHNpdGUgJiYgKCFjaXJjbGUgfHwgc2l0ZS55IDwgY2lyY2xlLnkgfHwgc2l0ZS55ID09PSBjaXJjbGUueSAmJiBzaXRlLnggPCBjaXJjbGUueCkpIHtcbiAgICAgICAgaWYgKHNpdGUueCAhPT0geDAgfHwgc2l0ZS55ICE9PSB5MCkge1xuICAgICAgICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW3NpdGUuaV0gPSBuZXcgZDNfZ2VvbV92b3Jvbm9pQ2VsbChzaXRlKTtcbiAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lBZGRCZWFjaChzaXRlKTtcbiAgICAgICAgICB4MCA9IHNpdGUueCwgeTAgPSBzaXRlLnk7XG4gICAgICAgIH1cbiAgICAgICAgc2l0ZSA9IHNpdGVzLnBvcCgpO1xuICAgICAgfSBlbHNlIGlmIChjaXJjbGUpIHtcbiAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVtb3ZlQmVhY2goY2lyY2xlLmFyYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJib3gpIGQzX2dlb21fdm9yb25vaUNsaXBFZGdlcyhiYm94KSwgZDNfZ2VvbV92b3Jvbm9pQ2xvc2VDZWxscyhiYm94KTtcbiAgICB2YXIgZGlhZ3JhbSA9IHtcbiAgICAgIGNlbGxzOiBkM19nZW9tX3Zvcm9ub2lDZWxscyxcbiAgICAgIGVkZ2VzOiBkM19nZW9tX3Zvcm9ub2lFZGdlc1xuICAgIH07XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcyA9IGQzX2dlb21fdm9yb25vaUNpcmNsZXMgPSBkM19nZW9tX3Zvcm9ub2lFZGdlcyA9IGQzX2dlb21fdm9yb25vaUNlbGxzID0gbnVsbDtcbiAgICByZXR1cm4gZGlhZ3JhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lWZXJ0ZXhPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGIueSAtIGEueSB8fCBiLnggLSBhLng7XG4gIH1cbiAgZDMuZ2VvbS52b3Jvbm9pID0gZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBmeCA9IHgsIGZ5ID0geSwgY2xpcEV4dGVudCA9IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQ7XG4gICAgaWYgKHBvaW50cykgcmV0dXJuIHZvcm9ub2kocG9pbnRzKTtcbiAgICBmdW5jdGlvbiB2b3Jvbm9pKGRhdGEpIHtcbiAgICAgIHZhciBwb2x5Z29ucyA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCksIHgwID0gY2xpcEV4dGVudFswXVswXSwgeTAgPSBjbGlwRXh0ZW50WzBdWzFdLCB4MSA9IGNsaXBFeHRlbnRbMV1bMF0sIHkxID0gY2xpcEV4dGVudFsxXVsxXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSwgY2xpcEV4dGVudCkuY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBpKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IGNlbGwuZWRnZXMsIHNpdGUgPSBjZWxsLnNpdGUsIHBvbHlnb24gPSBwb2x5Z29uc1tpXSA9IGVkZ2VzLmxlbmd0aCA/IGVkZ2VzLm1hcChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHMgPSBlLnN0YXJ0KCk7XG4gICAgICAgICAgcmV0dXJuIFsgcy54LCBzLnkgXTtcbiAgICAgICAgfSkgOiBzaXRlLnggPj0geDAgJiYgc2l0ZS54IDw9IHgxICYmIHNpdGUueSA+PSB5MCAmJiBzaXRlLnkgPD0geTEgPyBbIFsgeDAsIHkxIF0sIFsgeDEsIHkxIF0sIFsgeDEsIHkwIF0sIFsgeDAsIHkwIF0gXSA6IFtdO1xuICAgICAgICBwb2x5Z29uLnBvaW50ID0gZGF0YVtpXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBvbHlnb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaXRlcyhkYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IE1hdGgucm91bmQoZngoZCwgaSkgLyDOtSkgKiDOtSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKGZ5KGQsIGkpIC8gzrUpICogzrUsXG4gICAgICAgICAgaTogaVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZvcm9ub2kubGlua3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpKS5lZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5sICYmIGVkZ2UucjtcbiAgICAgIH0pLm1hcChmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBkYXRhW2VkZ2UubC5pXSxcbiAgICAgICAgICB0YXJnZXQ6IGRhdGFbZWRnZS5yLmldXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZvcm9ub2kudHJpYW5nbGVzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIHRyaWFuZ2xlcyA9IFtdO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pKHNpdGVzKGRhdGEpKS5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIGkpIHtcbiAgICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsIGVkZ2VzID0gY2VsbC5lZGdlcy5zb3J0KGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIpLCBqID0gLTEsIG0gPSBlZGdlcy5sZW5ndGgsIGUwLCBzMCwgZTEgPSBlZGdlc1ttIC0gMV0uZWRnZSwgczEgPSBlMS5sID09PSBzaXRlID8gZTEuciA6IGUxLmw7XG4gICAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgICAgZTAgPSBlMTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIGUxID0gZWRnZXNbal0uZWRnZTtcbiAgICAgICAgICBzMSA9IGUxLmwgPT09IHNpdGUgPyBlMS5yIDogZTEubDtcbiAgICAgICAgICBpZiAoaSA8IHMwLmkgJiYgaSA8IHMxLmkgJiYgZDNfZ2VvbV92b3Jvbm9pVHJpYW5nbGVBcmVhKHNpdGUsIHMwLCBzMSkgPCAwKSB7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChbIGRhdGFbaV0sIGRhdGFbczAuaV0sIGRhdGFbczEuaV0gXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmlhbmdsZXM7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmeCA9IGQzX2Z1bmN0b3IoeCA9IF8pLCB2b3Jvbm9pKSA6IHg7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmeSA9IGQzX2Z1bmN0b3IoeSA9IF8pLCB2b3Jvbm9pKSA6IHk7XG4gICAgfTtcbiAgICB2b3Jvbm9pLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50ID09PSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID8gbnVsbCA6IGNsaXBFeHRlbnQ7XG4gICAgICBjbGlwRXh0ZW50ID0gXyA9PSBudWxsID8gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA6IF87XG4gICAgICByZXR1cm4gdm9yb25vaTtcbiAgICB9O1xuICAgIHZvcm9ub2kuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsaXBFeHRlbnQgPT09IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPyBudWxsIDogY2xpcEV4dGVudCAmJiBjbGlwRXh0ZW50WzFdO1xuICAgICAgcmV0dXJuIHZvcm9ub2kuY2xpcEV4dGVudChfICYmIFsgWyAwLCAwIF0sIF8gXSk7XG4gICAgfTtcbiAgICByZXR1cm4gdm9yb25vaTtcbiAgfTtcbiAgdmFyIGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgPSBbIFsgLTFlNiwgLTFlNiBdLCBbIDFlNiwgMWU2IF0gXTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pVHJpYW5nbGVBcmVhKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEueCAtIGMueCkgKiAoYi55IC0gYS55KSAtIChhLnggLSBiLngpICogKGMueSAtIGEueSk7XG4gIH1cbiAgZDMuZ2VvbS5kZWxhdW5heSA9IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG4gICAgcmV0dXJuIGQzLmdlb20udm9yb25vaSgpLnRyaWFuZ2xlcyh2ZXJ0aWNlcyk7XG4gIH07XG4gIGQzLmdlb20ucXVhZHRyZWUgPSBmdW5jdGlvbihwb2ludHMsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHggPSBkM19nZW9tX3BvaW50WCwgeSA9IGQzX2dlb21fcG9pbnRZLCBjb21wYXQ7XG4gICAgaWYgKGNvbXBhdCA9IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHggPSBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WDtcbiAgICAgIHkgPSBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WTtcbiAgICAgIGlmIChjb21wYXQgPT09IDMpIHtcbiAgICAgICAgeTIgPSB5MTtcbiAgICAgICAgeDIgPSB4MTtcbiAgICAgICAgeTEgPSB4MSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVhZHRyZWUocG9pbnRzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVhZHRyZWUoZGF0YSkge1xuICAgICAgdmFyIGQsIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpLCB4cywgeXMsIGksIG4sIHgxXywgeTFfLCB4Ml8sIHkyXztcbiAgICAgIGlmICh4MSAhPSBudWxsKSB7XG4gICAgICAgIHgxXyA9IHgxLCB5MV8gPSB5MSwgeDJfID0geDIsIHkyXyA9IHkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDJfID0geTJfID0gLSh4MV8gPSB5MV8gPSBJbmZpbml0eSk7XG4gICAgICAgIHhzID0gW10sIHlzID0gW107XG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvbXBhdCkgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGQgPSBkYXRhW2ldO1xuICAgICAgICAgIGlmIChkLnggPCB4MV8pIHgxXyA9IGQueDtcbiAgICAgICAgICBpZiAoZC55IDwgeTFfKSB5MV8gPSBkLnk7XG4gICAgICAgICAgaWYgKGQueCA+IHgyXykgeDJfID0gZC54O1xuICAgICAgICAgIGlmIChkLnkgPiB5Ml8pIHkyXyA9IGQueTtcbiAgICAgICAgICB4cy5wdXNoKGQueCk7XG4gICAgICAgICAgeXMucHVzaChkLnkpO1xuICAgICAgICB9IGVsc2UgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHZhciB4XyA9ICtmeChkID0gZGF0YVtpXSwgaSksIHlfID0gK2Z5KGQsIGkpO1xuICAgICAgICAgIGlmICh4XyA8IHgxXykgeDFfID0geF87XG4gICAgICAgICAgaWYgKHlfIDwgeTFfKSB5MV8gPSB5XztcbiAgICAgICAgICBpZiAoeF8gPiB4Ml8pIHgyXyA9IHhfO1xuICAgICAgICAgIGlmICh5XyA+IHkyXykgeTJfID0geV87XG4gICAgICAgICAgeHMucHVzaCh4Xyk7XG4gICAgICAgICAgeXMucHVzaCh5Xyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IHgyXyAtIHgxXywgZHkgPSB5Ml8gLSB5MV87XG4gICAgICBpZiAoZHggPiBkeSkgeTJfID0geTFfICsgZHg7IGVsc2UgeDJfID0geDFfICsgZHk7XG4gICAgICBmdW5jdGlvbiBpbnNlcnQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm47XG4gICAgICAgIGlmIChuLmxlYWYpIHtcbiAgICAgICAgICB2YXIgbnggPSBuLngsIG55ID0gbi55O1xuICAgICAgICAgIGlmIChueCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYWJzKG54IC0geCkgKyBhYnMobnkgLSB5KSA8IC4wMSkge1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgblBvaW50ID0gbi5wb2ludDtcbiAgICAgICAgICAgICAgbi54ID0gbi55ID0gbi5wb2ludCA9IG51bGw7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIG5Qb2ludCwgbngsIG55LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbi54ID0geCwgbi55ID0geSwgbi5wb2ludCA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgICAgdmFyIHhtID0gKHgxICsgeDIpICogLjUsIHltID0gKHkxICsgeTIpICogLjUsIHJpZ2h0ID0geCA+PSB4bSwgYmVsb3cgPSB5ID49IHltLCBpID0gYmVsb3cgPDwgMSB8IHJpZ2h0O1xuICAgICAgICBuLmxlYWYgPSBmYWxzZTtcbiAgICAgICAgbiA9IG4ubm9kZXNbaV0gfHwgKG4ubm9kZXNbaV0gPSBkM19nZW9tX3F1YWR0cmVlTm9kZSgpKTtcbiAgICAgICAgaWYgKHJpZ2h0KSB4MSA9IHhtOyBlbHNlIHgyID0geG07XG4gICAgICAgIGlmIChiZWxvdykgeTEgPSB5bTsgZWxzZSB5MiA9IHltO1xuICAgICAgICBpbnNlcnQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgfVxuICAgICAgdmFyIHJvb3QgPSBkM19nZW9tX3F1YWR0cmVlTm9kZSgpO1xuICAgICAgcm9vdC5hZGQgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIGluc2VydChyb290LCBkLCArZngoZCwgKytpKSwgK2Z5KGQsIGkpLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIHJvb3QudmlzaXQgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCByb290LCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIHJvb3QuZmluZCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBkM19nZW9tX3F1YWR0cmVlRmluZChyb290LCBwb2ludFswXSwgcG9pbnRbMV0sIHgxXywgeTFfLCB4Ml8sIHkyXyk7XG4gICAgICB9O1xuICAgICAgaSA9IC0xO1xuICAgICAgaWYgKHgxID09IG51bGwpIHtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpbnNlcnQocm9vdCwgZGF0YVtpXSwgeHNbaV0sIHlzW2ldLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgICB9XG4gICAgICAgIC0taTtcbiAgICAgIH0gZWxzZSBkYXRhLmZvckVhY2gocm9vdC5hZGQpO1xuICAgICAgeHMgPSB5cyA9IGRhdGEgPSBkID0gbnVsbDtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBxdWFkdHJlZS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IF8sIHF1YWR0cmVlKSA6IHg7XG4gICAgfTtcbiAgICBxdWFkdHJlZS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IF8sIHF1YWR0cmVlKSA6IHk7XG4gICAgfTtcbiAgICBxdWFkdHJlZS5leHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MSA9PSBudWxsID8gbnVsbCA6IFsgWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSBdO1xuICAgICAgaWYgKF8gPT0gbnVsbCkgeDEgPSB5MSA9IHgyID0geTIgPSBudWxsOyBlbHNlIHgxID0gK19bMF1bMF0sIHkxID0gK19bMF1bMV0sIHgyID0gK19bMV1bMF0sIFxuICAgICAgeTIgPSArX1sxXVsxXTtcbiAgICAgIHJldHVybiBxdWFkdHJlZTtcbiAgICB9O1xuICAgIHF1YWR0cmVlLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MSA9PSBudWxsID8gbnVsbCA6IFsgeDIgLSB4MSwgeTIgLSB5MSBdO1xuICAgICAgaWYgKF8gPT0gbnVsbCkgeDEgPSB5MSA9IHgyID0geTIgPSBudWxsOyBlbHNlIHgxID0geTEgPSAwLCB4MiA9ICtfWzBdLCB5MiA9ICtfWzFdO1xuICAgICAgcmV0dXJuIHF1YWR0cmVlO1xuICAgIH07XG4gICAgcmV0dXJuIHF1YWR0cmVlO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WChkKSB7XG4gICAgcmV0dXJuIGQueDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlQ29tcGF0WShkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlTm9kZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgIG5vZGVzOiBbXSxcbiAgICAgIHBvaW50OiBudWxsLFxuICAgICAgeDogbnVsbCxcbiAgICAgIHk6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBub2RlLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGlmICghZihub2RlLCB4MSwgeTEsIHgyLCB5MikpIHtcbiAgICAgIHZhciBzeCA9ICh4MSArIHgyKSAqIC41LCBzeSA9ICh5MSArIHkyKSAqIC41LCBjaGlsZHJlbiA9IG5vZGUubm9kZXM7XG4gICAgICBpZiAoY2hpbGRyZW5bMF0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblswXSwgeDEsIHkxLCBzeCwgc3kpO1xuICAgICAgaWYgKGNoaWxkcmVuWzFdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMV0sIHN4LCB5MSwgeDIsIHN5KTtcbiAgICAgIGlmIChjaGlsZHJlblsyXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzJdLCB4MSwgc3ksIHN4LCB5Mik7XG4gICAgICBpZiAoY2hpbGRyZW5bM10pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblszXSwgc3gsIHN5LCB4MiwgeTIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlRmluZChyb290LCB4LCB5LCB4MCwgeTAsIHgzLCB5Mykge1xuICAgIHZhciBtaW5EaXN0YW5jZTIgPSBJbmZpbml0eSwgY2xvc2VzdFBvaW50O1xuICAgIChmdW5jdGlvbiBmaW5kKG5vZGUsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBpZiAoeDEgPiB4MyB8fCB5MSA+IHkzIHx8IHgyIDwgeDAgfHwgeTIgPCB5MCkgcmV0dXJuO1xuICAgICAgaWYgKHBvaW50ID0gbm9kZS5wb2ludCkge1xuICAgICAgICB2YXIgcG9pbnQsIGR4ID0geCAtIG5vZGUueCwgZHkgPSB5IC0gbm9kZS55LCBkaXN0YW5jZTIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGRpc3RhbmNlMiA8IG1pbkRpc3RhbmNlMikge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChtaW5EaXN0YW5jZTIgPSBkaXN0YW5jZTIpO1xuICAgICAgICAgIHgwID0geCAtIGRpc3RhbmNlLCB5MCA9IHkgLSBkaXN0YW5jZTtcbiAgICAgICAgICB4MyA9IHggKyBkaXN0YW5jZSwgeTMgPSB5ICsgZGlzdGFuY2U7XG4gICAgICAgICAgY2xvc2VzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUubm9kZXMsIHhtID0gKHgxICsgeDIpICogLjUsIHltID0gKHkxICsgeTIpICogLjUsIHJpZ2h0ID0geCA+PSB4bSwgYmVsb3cgPSB5ID49IHltO1xuICAgICAgZm9yICh2YXIgaSA9IGJlbG93IDw8IDEgfCByaWdodCwgaiA9IGkgKyA0OyBpIDwgajsgKytpKSB7XG4gICAgICAgIGlmIChub2RlID0gY2hpbGRyZW5baSAmIDNdKSBzd2l0Y2ggKGkgJiAzKSB7XG4gICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgZmluZChub2RlLCB4MSwgeTEsIHhtLCB5bSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBmaW5kKG5vZGUsIHhtLCB5MSwgeDIsIHltKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGZpbmQobm9kZSwgeDEsIHltLCB4bSwgeTIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZmluZChub2RlLCB4bSwgeW0sIHgyLCB5Mik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KShyb290LCB4MCwgeTAsIHgzLCB5Myk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQb2ludDtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZVJnYiA9IGQzX2ludGVycG9sYXRlUmdiO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVJnYihhLCBiKSB7XG4gICAgYSA9IGQzLnJnYihhKTtcbiAgICBiID0gZDMucmdiKGIpO1xuICAgIHZhciBhciA9IGEuciwgYWcgPSBhLmcsIGFiID0gYS5iLCBiciA9IGIuciAtIGFyLCBiZyA9IGIuZyAtIGFnLCBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gXCIjXCIgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYXIgKyBiciAqIHQpKSArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhZyArIGJnICogdCkpICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFiICsgYmIgKiB0KSk7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZU9iamVjdCA9IGQzX2ludGVycG9sYXRlT2JqZWN0O1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZU9iamVjdChhLCBiKSB7XG4gICAgdmFyIGkgPSB7fSwgYyA9IHt9LCBrO1xuICAgIGZvciAoayBpbiBhKSB7XG4gICAgICBpZiAoayBpbiBiKSB7XG4gICAgICAgIGlba10gPSBkM19pbnRlcnBvbGF0ZShhW2tdLCBiW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNba10gPSBhW2tdO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGsgaW4gYikge1xuICAgICAgaWYgKCEoayBpbiBhKSkge1xuICAgICAgICBjW2tdID0gYltrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAoayBpbiBpKSBjW2tdID0gaVtrXSh0KTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVOdW1iZXIgPSBkM19pbnRlcnBvbGF0ZU51bWJlcjtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVOdW1iZXIoYSwgYikge1xuICAgIGEgPSArYSwgYiA9ICtiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gYSAqICgxIC0gdCkgKyBiICogdDtcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlU3RyaW5nID0gZDNfaW50ZXJwb2xhdGVTdHJpbmc7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlU3RyaW5nKGEsIGIpIHtcbiAgICB2YXIgYmkgPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJBLmxhc3RJbmRleCA9IGQzX2ludGVycG9sYXRlX251bWJlckIubGFzdEluZGV4ID0gMCwgYW0sIGJtLCBicywgaSA9IC0xLCBzID0gW10sIHEgPSBbXTtcbiAgICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcbiAgICB3aGlsZSAoKGFtID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQS5leGVjKGEpKSAmJiAoYm0gPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJCLmV4ZWMoYikpKSB7XG4gICAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHtcbiAgICAgICAgYnMgPSBiLnNsaWNlKGJpLCBicyk7XG4gICAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyBlbHNlIHNbKytpXSA9IGJzO1xuICAgICAgfVxuICAgICAgaWYgKChhbSA9IGFtWzBdKSA9PT0gKGJtID0gYm1bMF0pKSB7XG4gICAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJtOyBlbHNlIHNbKytpXSA9IGJtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc1srK2ldID0gbnVsbDtcbiAgICAgICAgcS5wdXNoKHtcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKGFtLCBibSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiaSA9IGQzX2ludGVycG9sYXRlX251bWJlckIubGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgICAgYnMgPSBiLnNsaWNlKGJpKTtcbiAgICAgIGlmIChzW2ldKSBzW2ldICs9IGJzOyBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICByZXR1cm4gcy5sZW5ndGggPCAyID8gcVswXSA/IChiID0gcVswXS54LCBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gICAgfSkgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gOiAoYiA9IHEubGVuZ3RoLCBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbzsgaSA8IGI7ICsraSkgc1sobyA9IHFbaV0pLmldID0gby54KHQpO1xuICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgZDNfaW50ZXJwb2xhdGVfbnVtYmVyQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZywgZDNfaW50ZXJwb2xhdGVfbnVtYmVyQiA9IG5ldyBSZWdFeHAoZDNfaW50ZXJwb2xhdGVfbnVtYmVyQS5zb3VyY2UsIFwiZ1wiKTtcbiAgZDMuaW50ZXJwb2xhdGUgPSBkM19pbnRlcnBvbGF0ZTtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIHZhciBpID0gZDMuaW50ZXJwb2xhdG9ycy5sZW5ndGgsIGY7XG4gICAgd2hpbGUgKC0taSA+PSAwICYmICEoZiA9IGQzLmludGVycG9sYXRvcnNbaV0oYSwgYikpKSA7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZDMuaW50ZXJwb2xhdG9ycyA9IFsgZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB0ID0gdHlwZW9mIGI7XG4gICAgcmV0dXJuICh0ID09PSBcInN0cmluZ1wiID8gZDNfcmdiX25hbWVzLmhhcyhiLnRvTG93ZXJDYXNlKCkpIHx8IC9eKCN8cmdiXFwofGhzbFxcKCkvaS50ZXN0KGIpID8gZDNfaW50ZXJwb2xhdGVSZ2IgOiBkM19pbnRlcnBvbGF0ZVN0cmluZyA6IGIgaW5zdGFuY2VvZiBkM19jb2xvciA/IGQzX2ludGVycG9sYXRlUmdiIDogQXJyYXkuaXNBcnJheShiKSA/IGQzX2ludGVycG9sYXRlQXJyYXkgOiB0ID09PSBcIm9iamVjdFwiICYmIGlzTmFOKGIpID8gZDNfaW50ZXJwb2xhdGVPYmplY3QgOiBkM19pbnRlcnBvbGF0ZU51bWJlcikoYSwgYik7XG4gIH0gXTtcbiAgZDMuaW50ZXJwb2xhdGVBcnJheSA9IGQzX2ludGVycG9sYXRlQXJyYXk7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlQXJyYXkoYSwgYikge1xuICAgIHZhciB4ID0gW10sIGMgPSBbXSwgbmEgPSBhLmxlbmd0aCwgbmIgPSBiLmxlbmd0aCwgbjAgPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuMDsgKytpKSB4LnB1c2goZDNfaW50ZXJwb2xhdGUoYVtpXSwgYltpXSkpO1xuICAgIGZvciAoO2kgPCBuYTsgKytpKSBjW2ldID0gYVtpXTtcbiAgICBmb3IgKDtpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuMDsgKytpKSBjW2ldID0geFtpXSh0KTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2Vhc2VfZGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19pZGVudGl0eTtcbiAgfTtcbiAgdmFyIGQzX2Vhc2UgPSBkMy5tYXAoe1xuICAgIGxpbmVhcjogZDNfZWFzZV9kZWZhdWx0LFxuICAgIHBvbHk6IGQzX2Vhc2VfcG9seSxcbiAgICBxdWFkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX3F1YWQ7XG4gICAgfSxcbiAgICBjdWJpYzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9jdWJpYztcbiAgICB9LFxuICAgIHNpbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9zaW47XG4gICAgfSxcbiAgICBleHA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfZXhwO1xuICAgIH0sXG4gICAgY2lyY2xlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2NpcmNsZTtcbiAgICB9LFxuICAgIGVsYXN0aWM6IGQzX2Vhc2VfZWxhc3RpYyxcbiAgICBiYWNrOiBkM19lYXNlX2JhY2ssXG4gICAgYm91bmNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2JvdW5jZTtcbiAgICB9XG4gIH0pO1xuICB2YXIgZDNfZWFzZV9tb2RlID0gZDMubWFwKHtcbiAgICBcImluXCI6IGQzX2lkZW50aXR5LFxuICAgIG91dDogZDNfZWFzZV9yZXZlcnNlLFxuICAgIFwiaW4tb3V0XCI6IGQzX2Vhc2VfcmVmbGVjdCxcbiAgICBcIm91dC1pblwiOiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9yZWZsZWN0KGQzX2Vhc2VfcmV2ZXJzZShmKSk7XG4gICAgfVxuICB9KTtcbiAgZDMuZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi1cIiksIHQgPSBpID49IDAgPyBuYW1lLnNsaWNlKDAsIGkpIDogbmFtZSwgbSA9IGkgPj0gMCA/IG5hbWUuc2xpY2UoaSArIDEpIDogXCJpblwiO1xuICAgIHQgPSBkM19lYXNlLmdldCh0KSB8fCBkM19lYXNlX2RlZmF1bHQ7XG4gICAgbSA9IGQzX2Vhc2VfbW9kZS5nZXQobSkgfHwgZDNfaWRlbnRpdHk7XG4gICAgcmV0dXJuIGQzX2Vhc2VfY2xhbXAobSh0LmFwcGx5KG51bGwsIGQzX2FycmF5U2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19lYXNlX2NsYW1wKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQgPD0gMCA/IDAgOiB0ID49IDEgPyAxIDogZih0KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcmV2ZXJzZShmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAxIC0gZigxIC0gdCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3JlZmxlY3QoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gLjUgKiAodCA8IC41ID8gZigyICogdCkgOiAyIC0gZigyIC0gMiAqIHQpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9jdWJpY0luT3V0KHQpIHtcbiAgICBpZiAodCA8PSAwKSByZXR1cm4gMDtcbiAgICBpZiAodCA+PSAxKSByZXR1cm4gMTtcbiAgICB2YXIgdDIgPSB0ICogdCwgdDMgPSB0MiAqIHQ7XG4gICAgcmV0dXJuIDQgKiAodCA8IC41ID8gdDMgOiAzICogKHQgLSB0MikgKyB0MyAtIC43NSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9wb2x5KGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9zaW4odCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3ModCAqIGhhbGbPgCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9leHAodCkge1xuICAgIHJldHVybiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY2lyY2xlKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfZWxhc3RpYyhhLCBwKSB7XG4gICAgdmFyIHM7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwID0gLjQ1O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSBzID0gcCAvIM+EICogTWF0aC5hc2luKDEgLyBhKTsgZWxzZSBhID0gMSwgcyA9IHAgLyA0O1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gMSArIGEgKiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiDPhCAvIHApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9iYWNrKHMpIHtcbiAgICBpZiAoIXMpIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfYm91bmNlKHQpIHtcbiAgICByZXR1cm4gdCA8IDEgLyAyLjc1ID8gNy41NjI1ICogdCAqIHQgOiB0IDwgMiAvIDIuNzUgPyA3LjU2MjUgKiAodCAtPSAxLjUgLyAyLjc1KSAqIHQgKyAuNzUgOiB0IDwgMi41IC8gMi43NSA/IDcuNTYyNSAqICh0IC09IDIuMjUgLyAyLjc1KSAqIHQgKyAuOTM3NSA6IDcuNTYyNSAqICh0IC09IDIuNjI1IC8gMi43NSkgKiB0ICsgLjk4NDM3NTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZUhjbCA9IGQzX2ludGVycG9sYXRlSGNsO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUhjbChhLCBiKSB7XG4gICAgYSA9IGQzLmhjbChhKTtcbiAgICBiID0gZDMuaGNsKGIpO1xuICAgIHZhciBhaCA9IGEuaCwgYWMgPSBhLmMsIGFsID0gYS5sLCBiaCA9IGIuaCAtIGFoLCBiYyA9IGIuYyAtIGFjLCBibCA9IGIubCAtIGFsO1xuICAgIGlmIChpc05hTihiYykpIGJjID0gMCwgYWMgPSBpc05hTihhYykgPyBiLmMgOiBhYztcbiAgICBpZiAoaXNOYU4oYmgpKSBiaCA9IDAsIGFoID0gaXNOYU4oYWgpID8gYi5oIDogYWg7IGVsc2UgaWYgKGJoID4gMTgwKSBiaCAtPSAzNjA7IGVsc2UgaWYgKGJoIDwgLTE4MCkgYmggKz0gMzYwO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZDNfaGNsX2xhYihhaCArIGJoICogdCwgYWMgKyBiYyAqIHQsIGFsICsgYmwgKiB0KSArIFwiXCI7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZUhzbCA9IGQzX2ludGVycG9sYXRlSHNsO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUhzbChhLCBiKSB7XG4gICAgYSA9IGQzLmhzbChhKTtcbiAgICBiID0gZDMuaHNsKGIpO1xuICAgIHZhciBhaCA9IGEuaCwgYXMgPSBhLnMsIGFsID0gYS5sLCBiaCA9IGIuaCAtIGFoLCBicyA9IGIucyAtIGFzLCBibCA9IGIubCAtIGFsO1xuICAgIGlmIChpc05hTihicykpIGJzID0gMCwgYXMgPSBpc05hTihhcykgPyBiLnMgOiBhcztcbiAgICBpZiAoaXNOYU4oYmgpKSBiaCA9IDAsIGFoID0gaXNOYU4oYWgpID8gYi5oIDogYWg7IGVsc2UgaWYgKGJoID4gMTgwKSBiaCAtPSAzNjA7IGVsc2UgaWYgKGJoIDwgLTE4MCkgYmggKz0gMzYwO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZDNfaHNsX3JnYihhaCArIGJoICogdCwgYXMgKyBicyAqIHQsIGFsICsgYmwgKiB0KSArIFwiXCI7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZUxhYiA9IGQzX2ludGVycG9sYXRlTGFiO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUxhYihhLCBiKSB7XG4gICAgYSA9IGQzLmxhYihhKTtcbiAgICBiID0gZDMubGFiKGIpO1xuICAgIHZhciBhbCA9IGEubCwgYWEgPSBhLmEsIGFiID0gYS5iLCBibCA9IGIubCAtIGFsLCBiYSA9IGIuYSAtIGFhLCBiYiA9IGIuYiAtIGFiO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZDNfbGFiX3JnYihhbCArIGJsICogdCwgYWEgKyBiYSAqIHQsIGFiICsgYmIgKiB0KSArIFwiXCI7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZVJvdW5kID0gZDNfaW50ZXJwb2xhdGVSb3VuZDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVSb3VuZChhLCBiKSB7XG4gICAgYiAtPSBhO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChhICsgYiAqIHQpO1xuICAgIH07XG4gIH1cbiAgZDMudHJhbnNmb3JtID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGcgPSBkM19kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoZDMubnMucHJlZml4LnN2ZywgXCJnXCIpO1xuICAgIHJldHVybiAoZDMudHJhbnNmb3JtID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBpZiAoc3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RyaW5nKTtcbiAgICAgICAgdmFyIHQgPSBnLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGQzX3RyYW5zZm9ybSh0ID8gdC5tYXRyaXggOiBkM190cmFuc2Zvcm1JZGVudGl0eSk7XG4gICAgfSkoc3RyaW5nKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtKG0pIHtcbiAgICB2YXIgcjAgPSBbIG0uYSwgbS5iIF0sIHIxID0gWyBtLmMsIG0uZCBdLCBreCA9IGQzX3RyYW5zZm9ybU5vcm1hbGl6ZShyMCksIGt6ID0gZDNfdHJhbnNmb3JtRG90KHIwLCByMSksIGt5ID0gZDNfdHJhbnNmb3JtTm9ybWFsaXplKGQzX3RyYW5zZm9ybUNvbWJpbmUocjEsIHIwLCAta3opKSB8fCAwO1xuICAgIGlmIChyMFswXSAqIHIxWzFdIDwgcjFbMF0gKiByMFsxXSkge1xuICAgICAgcjBbMF0gKj0gLTE7XG4gICAgICByMFsxXSAqPSAtMTtcbiAgICAgIGt4ICo9IC0xO1xuICAgICAga3ogKj0gLTE7XG4gICAgfVxuICAgIHRoaXMucm90YXRlID0gKGt4ID8gTWF0aC5hdGFuMihyMFsxXSwgcjBbMF0pIDogTWF0aC5hdGFuMigtcjFbMF0sIHIxWzFdKSkgKiBkM19kZWdyZWVzO1xuICAgIHRoaXMudHJhbnNsYXRlID0gWyBtLmUsIG0uZiBdO1xuICAgIHRoaXMuc2NhbGUgPSBbIGt4LCBreSBdO1xuICAgIHRoaXMuc2tldyA9IGt5ID8gTWF0aC5hdGFuMihreiwga3kpICogZDNfZGVncmVlcyA6IDA7XG4gIH1cbiAgZDNfdHJhbnNmb3JtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHRoaXMudHJhbnNsYXRlICsgXCIpcm90YXRlKFwiICsgdGhpcy5yb3RhdGUgKyBcIilza2V3WChcIiArIHRoaXMuc2tldyArIFwiKXNjYWxlKFwiICsgdGhpcy5zY2FsZSArIFwiKVwiO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2Zvcm1Eb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybU5vcm1hbGl6ZShhKSB7XG4gICAgdmFyIGsgPSBNYXRoLnNxcnQoZDNfdHJhbnNmb3JtRG90KGEsIGEpKTtcbiAgICBpZiAoaykge1xuICAgICAgYVswXSAvPSBrO1xuICAgICAgYVsxXSAvPSBrO1xuICAgIH1cbiAgICByZXR1cm4gaztcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2Zvcm1Db21iaW5lKGEsIGIsIGspIHtcbiAgICBhWzBdICs9IGsgKiBiWzBdO1xuICAgIGFbMV0gKz0gayAqIGJbMV07XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgdmFyIGQzX3RyYW5zZm9ybUlkZW50aXR5ID0ge1xuICAgIGE6IDEsXG4gICAgYjogMCxcbiAgICBjOiAwLFxuICAgIGQ6IDEsXG4gICAgZTogMCxcbiAgICBmOiAwXG4gIH07XG4gIGQzLmludGVycG9sYXRlVHJhbnNmb3JtID0gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm07XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPyBzLnBvcCgpICsgXCIsXCIgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlVHJhbnNsYXRlKHRhLCB0YiwgcywgcSkge1xuICAgIGlmICh0YVswXSAhPT0gdGJbMF0gfHwgdGFbMV0gIT09IHRiWzFdKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChcInRyYW5zbGF0ZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IGkgLSA0LFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih0YVswXSwgdGJbMF0pXG4gICAgICB9LCB7XG4gICAgICAgIGk6IGkgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih0YVsxXSwgdGJbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRiWzBdIHx8IHRiWzFdKSB7XG4gICAgICBzLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyB0YiArIFwiKVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVSb3RhdGUocmEsIHJiLCBzLCBxKSB7XG4gICAgaWYgKHJhICE9PSByYikge1xuICAgICAgaWYgKHJhIC0gcmIgPiAxODApIHJiICs9IDM2MDsgZWxzZSBpZiAocmIgLSByYSA+IDE4MCkgcmEgKz0gMzYwO1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJyb3RhdGUoXCIsIG51bGwsIFwiKVwiKSAtIDIsXG4gICAgICAgIHg6IGQzX2ludGVycG9sYXRlTnVtYmVyKHJhLCByYilcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocmIpIHtcbiAgICAgIHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwicm90YXRlKFwiICsgcmIgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlU2tldyh3YSwgd2IsIHMsIHEpIHtcbiAgICBpZiAod2EgIT09IHdiKSB7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBcIilcIikgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcih3YSwgd2IpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHdiKSB7XG4gICAgICBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNrZXdYKFwiICsgd2IgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlU2NhbGUoa2EsIGtiLCBzLCBxKSB7XG4gICAgaWYgKGthWzBdICE9PSBrYlswXSB8fCBrYVsxXSAhPT0ga2JbMV0pIHtcbiAgICAgIHZhciBpID0gcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJzY2FsZShcIiwgbnVsbCwgXCIsXCIsIG51bGwsIFwiKVwiKTtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IGkgLSA0LFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihrYVswXSwga2JbMF0pXG4gICAgICB9LCB7XG4gICAgICAgIGk6IGkgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihrYVsxXSwga2JbMV0pXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGtiWzBdICE9PSAxIHx8IGtiWzFdICE9PSAxKSB7XG4gICAgICBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInNjYWxlKFwiICsga2IgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlVHJhbnNmb3JtKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCBxID0gW107XG4gICAgYSA9IGQzLnRyYW5zZm9ybShhKSwgYiA9IGQzLnRyYW5zZm9ybShiKTtcbiAgICBkM19pbnRlcnBvbGF0ZVRyYW5zbGF0ZShhLnRyYW5zbGF0ZSwgYi50cmFuc2xhdGUsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlUm90YXRlKGEucm90YXRlLCBiLnJvdGF0ZSwgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVTa2V3KGEuc2tldywgYi5za2V3LCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVNjYWxlKGEuc2NhbGUsIGIuc2NhbGUsIHMsIHEpO1xuICAgIGEgPSBiID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IHEubGVuZ3RoLCBvO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM191bmludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgICBiID0gKGIgLT0gYSA9ICthKSB8fCAxIC8gYjtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuICh4IC0gYSkgLyBiO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdW5pbnRlcnBvbGF0ZUNsYW1wKGEsIGIpIHtcbiAgICBiID0gKGIgLT0gYSA9ICthKSB8fCAxIC8gYjtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDEsICh4IC0gYSkgLyBiKSk7XG4gICAgfTtcbiAgfVxuICBkMy5sYXlvdXQgPSB7fTtcbiAgZDMubGF5b3V0LmJ1bmRsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbihsaW5rcykge1xuICAgICAgdmFyIHBhdGhzID0gW10sIGkgPSAtMSwgbiA9IGxpbmtzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBwYXRocy5wdXNoKGQzX2xheW91dF9idW5kbGVQYXRoKGxpbmtzW2ldKSk7XG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZVBhdGgobGluaykge1xuICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlLCBlbmQgPSBsaW5rLnRhcmdldCwgbGNhID0gZDNfbGF5b3V0X2J1bmRsZUxlYXN0Q29tbW9uQW5jZXN0b3Ioc3RhcnQsIGVuZCksIHBvaW50cyA9IFsgc3RhcnQgXTtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGxjYSkge1xuICAgICAgc3RhcnQgPSBzdGFydC5wYXJlbnQ7XG4gICAgICBwb2ludHMucHVzaChzdGFydCk7XG4gICAgfVxuICAgIHZhciBrID0gcG9pbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoZW5kICE9PSBsY2EpIHtcbiAgICAgIHBvaW50cy5zcGxpY2UoaywgMCwgZW5kKTtcbiAgICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhub2RlKSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdLCBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgIHJldHVybiBhbmNlc3RvcnM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2J1bmRsZUxlYXN0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gYTtcbiAgICB2YXIgYU5vZGVzID0gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhhKSwgYk5vZGVzID0gZDNfbGF5b3V0X2J1bmRsZUFuY2VzdG9ycyhiKSwgYU5vZGUgPSBhTm9kZXMucG9wKCksIGJOb2RlID0gYk5vZGVzLnBvcCgpLCBzaGFyZWROb2RlID0gbnVsbDtcbiAgICB3aGlsZSAoYU5vZGUgPT09IGJOb2RlKSB7XG4gICAgICBzaGFyZWROb2RlID0gYU5vZGU7XG4gICAgICBhTm9kZSA9IGFOb2Rlcy5wb3AoKTtcbiAgICAgIGJOb2RlID0gYk5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcmVkTm9kZTtcbiAgfVxuICBkMy5sYXlvdXQuY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2hvcmQgPSB7fSwgY2hvcmRzLCBncm91cHMsIG1hdHJpeCwgbiwgcGFkZGluZyA9IDAsIHNvcnRHcm91cHMsIHNvcnRTdWJncm91cHMsIHNvcnRDaG9yZHM7XG4gICAgZnVuY3Rpb24gcmVsYXlvdXQoKSB7XG4gICAgICB2YXIgc3ViZ3JvdXBzID0ge30sIGdyb3VwU3VtcyA9IFtdLCBncm91cEluZGV4ID0gZDMucmFuZ2UobiksIHN1Ymdyb3VwSW5kZXggPSBbXSwgaywgeCwgeDAsIGksIGo7XG4gICAgICBjaG9yZHMgPSBbXTtcbiAgICAgIGdyb3VwcyA9IFtdO1xuICAgICAgayA9IDAsIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIHggPSAwLCBqID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgeCArPSBtYXRyaXhbaV1bal07XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBTdW1zLnB1c2goeCk7XG4gICAgICAgIHN1Ymdyb3VwSW5kZXgucHVzaChkMy5yYW5nZShuKSk7XG4gICAgICAgIGsgKz0geDtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0R3JvdXBzKSB7XG4gICAgICAgIGdyb3VwSW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIHNvcnRHcm91cHMoZ3JvdXBTdW1zW2FdLCBncm91cFN1bXNbYl0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzb3J0U3ViZ3JvdXBzKSB7XG4gICAgICAgIHN1Ymdyb3VwSW5kZXguZm9yRWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3J0U3ViZ3JvdXBzKG1hdHJpeFtpXVthXSwgbWF0cml4W2ldW2JdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBrID0gKM+EIC0gcGFkZGluZyAqIG4pIC8gaztcbiAgICAgIHggPSAwLCBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICB4MCA9IHgsIGogPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB2YXIgZGkgPSBncm91cEluZGV4W2ldLCBkaiA9IHN1Ymdyb3VwSW5kZXhbZGldW2pdLCB2ID0gbWF0cml4W2RpXVtkal0sIGEwID0geCwgYTEgPSB4ICs9IHYgKiBrO1xuICAgICAgICAgIHN1Ymdyb3Vwc1tkaSArIFwiLVwiICsgZGpdID0ge1xuICAgICAgICAgICAgaW5kZXg6IGRpLFxuICAgICAgICAgICAgc3ViaW5kZXg6IGRqLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgICBlbmRBbmdsZTogYTEsXG4gICAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzW2RpXSA9IHtcbiAgICAgICAgICBpbmRleDogZGksXG4gICAgICAgICAgc3RhcnRBbmdsZTogeDAsXG4gICAgICAgICAgZW5kQW5nbGU6IHgsXG4gICAgICAgICAgdmFsdWU6IGdyb3VwU3Vtc1tkaV1cbiAgICAgICAgfTtcbiAgICAgICAgeCArPSBwYWRkaW5nO1xuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaiA9IGkgLSAxO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBzdWJncm91cHNbaSArIFwiLVwiICsgal0sIHRhcmdldCA9IHN1Ymdyb3Vwc1tqICsgXCItXCIgKyBpXTtcbiAgICAgICAgICBpZiAoc291cmNlLnZhbHVlIHx8IHRhcmdldC52YWx1ZSkge1xuICAgICAgICAgICAgY2hvcmRzLnB1c2goc291cmNlLnZhbHVlIDwgdGFyZ2V0LnZhbHVlID8ge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRhcmdldCxcbiAgICAgICAgICAgICAgdGFyZ2V0OiBzb3VyY2VcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc29ydENob3JkcykgcmVzb3J0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29ydCgpIHtcbiAgICAgIGNob3Jkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRDaG9yZHMoKGEuc291cmNlLnZhbHVlICsgYS50YXJnZXQudmFsdWUpIC8gMiwgKGIuc291cmNlLnZhbHVlICsgYi50YXJnZXQudmFsdWUpIC8gMik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2hvcmQubWF0cml4ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWF0cml4O1xuICAgICAgbiA9IChtYXRyaXggPSB4KSAmJiBtYXRyaXgubGVuZ3RoO1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgcGFkZGluZyA9IHg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydEdyb3VwcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRHcm91cHM7XG4gICAgICBzb3J0R3JvdXBzID0geDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0U3ViZ3JvdXBzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydFN1Ymdyb3VwcztcbiAgICAgIHNvcnRTdWJncm91cHMgPSB4O1xuICAgICAgY2hvcmRzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRDaG9yZHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0Q2hvcmRzO1xuICAgICAgc29ydENob3JkcyA9IHg7XG4gICAgICBpZiAoY2hvcmRzKSByZXNvcnQoKTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLmNob3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjaG9yZHMpIHJlbGF5b3V0KCk7XG4gICAgICByZXR1cm4gY2hvcmRzO1xuICAgIH07XG4gICAgY2hvcmQuZ3JvdXBzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWdyb3VwcykgcmVsYXlvdXQoKTtcbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfTtcbiAgICByZXR1cm4gY2hvcmQ7XG4gIH07XG4gIGQzLmxheW91dC5mb3JjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb3JjZSA9IHt9LCBldmVudCA9IGQzLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJ0aWNrXCIsIFwiZW5kXCIpLCB0aW1lciwgc2l6ZSA9IFsgMSwgMSBdLCBkcmFnLCBhbHBoYSwgZnJpY3Rpb24gPSAuOSwgbGlua0Rpc3RhbmNlID0gZDNfbGF5b3V0X2ZvcmNlTGlua0Rpc3RhbmNlLCBsaW5rU3RyZW5ndGggPSBkM19sYXlvdXRfZm9yY2VMaW5rU3RyZW5ndGgsIGNoYXJnZSA9IC0zMCwgY2hhcmdlRGlzdGFuY2UyID0gZDNfbGF5b3V0X2ZvcmNlQ2hhcmdlRGlzdGFuY2UyLCBncmF2aXR5ID0gLjEsIHRoZXRhMiA9IC42NCwgbm9kZXMgPSBbXSwgbGlua3MgPSBbXSwgZGlzdGFuY2VzLCBzdHJlbmd0aHMsIGNoYXJnZXM7XG4gICAgZnVuY3Rpb24gcmVwdWxzZShub2RlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocXVhZCwgeDEsIF8sIHgyKSB7XG4gICAgICAgIGlmIChxdWFkLnBvaW50ICE9PSBub2RlKSB7XG4gICAgICAgICAgdmFyIGR4ID0gcXVhZC5jeCAtIG5vZGUueCwgZHkgPSBxdWFkLmN5IC0gbm9kZS55LCBkdyA9IHgyIC0geDEsIGRuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgaWYgKGR3ICogZHcgLyB0aGV0YTIgPCBkbikge1xuICAgICAgICAgICAgaWYgKGRuIDwgY2hhcmdlRGlzdGFuY2UyKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gcXVhZC5jaGFyZ2UgLyBkbjtcbiAgICAgICAgICAgICAgbm9kZS5weCAtPSBkeCAqIGs7XG4gICAgICAgICAgICAgIG5vZGUucHkgLT0gZHkgKiBrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChxdWFkLnBvaW50ICYmIGRuICYmIGRuIDwgY2hhcmdlRGlzdGFuY2UyKSB7XG4gICAgICAgICAgICB2YXIgayA9IHF1YWQucG9pbnRDaGFyZ2UgLyBkbjtcbiAgICAgICAgICAgIG5vZGUucHggLT0gZHggKiBrO1xuICAgICAgICAgICAgbm9kZS5weSAtPSBkeSAqIGs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcXVhZC5jaGFyZ2U7XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3JjZS50aWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKGFscGhhICo9IC45OSkgPCAuMDA1KSB7XG4gICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgZXZlbnQuZW5kKHtcbiAgICAgICAgICB0eXBlOiBcImVuZFwiLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSA9IDBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIG4gPSBub2Rlcy5sZW5ndGgsIG0gPSBsaW5rcy5sZW5ndGgsIHEsIGksIG8sIHMsIHQsIGwsIGssIHgsIHk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIG8gPSBsaW5rc1tpXTtcbiAgICAgICAgcyA9IG8uc291cmNlO1xuICAgICAgICB0ID0gby50YXJnZXQ7XG4gICAgICAgIHggPSB0LnggLSBzLng7XG4gICAgICAgIHkgPSB0LnkgLSBzLnk7XG4gICAgICAgIGlmIChsID0geCAqIHggKyB5ICogeSkge1xuICAgICAgICAgIGwgPSBhbHBoYSAqIHN0cmVuZ3Roc1tpXSAqICgobCA9IE1hdGguc3FydChsKSkgLSBkaXN0YW5jZXNbaV0pIC8gbDtcbiAgICAgICAgICB4ICo9IGw7XG4gICAgICAgICAgeSAqPSBsO1xuICAgICAgICAgIHQueCAtPSB4ICogKGsgPSBzLndlaWdodCArIHQud2VpZ2h0ID8gcy53ZWlnaHQgLyAocy53ZWlnaHQgKyB0LndlaWdodCkgOiAuNSk7XG4gICAgICAgICAgdC55IC09IHkgKiBrO1xuICAgICAgICAgIHMueCArPSB4ICogKGsgPSAxIC0gayk7XG4gICAgICAgICAgcy55ICs9IHkgKiBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoayA9IGFscGhhICogZ3Jhdml0eSkge1xuICAgICAgICB4ID0gc2l6ZVswXSAvIDI7XG4gICAgICAgIHkgPSBzaXplWzFdIC8gMjtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICBpZiAoaykgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgICAgby54ICs9ICh4IC0gby54KSAqIGs7XG4gICAgICAgICAgby55ICs9ICh5IC0gby55KSAqIGs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyZ2UpIHtcbiAgICAgICAgZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShxID0gZDMuZ2VvbS5xdWFkdHJlZShub2RlcyksIGFscGhhLCBjaGFyZ2VzKTtcbiAgICAgICAgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIGlmICghKG8gPSBub2Rlc1tpXSkuZml4ZWQpIHtcbiAgICAgICAgICAgIHEudmlzaXQocmVwdWxzZShvKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBvID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChvLmZpeGVkKSB7XG4gICAgICAgICAgby54ID0gby5weDtcbiAgICAgICAgICBvLnkgPSBvLnB5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8ueCAtPSAoby5weCAtIChvLnB4ID0gby54KSkgKiBmcmljdGlvbjtcbiAgICAgICAgICBvLnkgLT0gKG8ucHkgLSAoby5weSA9IG8ueSkpICogZnJpY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV2ZW50LnRpY2soe1xuICAgICAgICB0eXBlOiBcInRpY2tcIixcbiAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvcmNlLm5vZGVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZXM7XG4gICAgICBub2RlcyA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5saW5rcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtzO1xuICAgICAgbGlua3MgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2Uuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmxpbmtEaXN0YW5jZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmtEaXN0YW5jZTtcbiAgICAgIGxpbmtEaXN0YW5jZSA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5kaXN0YW5jZSA9IGZvcmNlLmxpbmtEaXN0YW5jZTtcbiAgICBmb3JjZS5saW5rU3RyZW5ndGggPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rU3RyZW5ndGg7XG4gICAgICBsaW5rU3RyZW5ndGggPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuZnJpY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmcmljdGlvbjtcbiAgICAgIGZyaWN0aW9uID0gK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5jaGFyZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGFyZ2U7XG4gICAgICBjaGFyZ2UgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuY2hhcmdlRGlzdGFuY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQoY2hhcmdlRGlzdGFuY2UyKTtcbiAgICAgIGNoYXJnZURpc3RhbmNlMiA9IHggKiB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuZ3Jhdml0eSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXZpdHk7XG4gICAgICBncmF2aXR5ID0gK3g7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydCh0aGV0YTIpO1xuICAgICAgdGhldGEyID0geCAqIHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5hbHBoYSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFscGhhO1xuICAgICAgeCA9ICt4O1xuICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICAgIGFscGhhID0geDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lci5jID0gbnVsbCwgdGltZXIudCA9IE5hTiwgdGltZXIgPSBudWxsO1xuICAgICAgICAgIGV2ZW50LmVuZCh7XG4gICAgICAgICAgICB0eXBlOiBcImVuZFwiLFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhID0gMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHggPiAwKSB7XG4gICAgICAgIGV2ZW50LnN0YXJ0KHtcbiAgICAgICAgICB0eXBlOiBcInN0YXJ0XCIsXG4gICAgICAgICAgYWxwaGE6IGFscGhhID0geFxuICAgICAgICB9KTtcbiAgICAgICAgdGltZXIgPSBkM190aW1lcihmb3JjZS50aWNrKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbSA9IGxpbmtzLmxlbmd0aCwgdyA9IHNpemVbMF0sIGggPSBzaXplWzFdLCBuZWlnaGJvcnMsIG87XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIChvID0gbm9kZXNbaV0pLmluZGV4ID0gaTtcbiAgICAgICAgby53ZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICBvID0gbGlua3NbaV07XG4gICAgICAgIGlmICh0eXBlb2Ygby5zb3VyY2UgPT0gXCJudW1iZXJcIikgby5zb3VyY2UgPSBub2Rlc1tvLnNvdXJjZV07XG4gICAgICAgIGlmICh0eXBlb2Ygby50YXJnZXQgPT0gXCJudW1iZXJcIikgby50YXJnZXQgPSBub2Rlc1tvLnRhcmdldF07XG4gICAgICAgICsrby5zb3VyY2Uud2VpZ2h0O1xuICAgICAgICArK28udGFyZ2V0LndlaWdodDtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbyA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoaXNOYU4oby54KSkgby54ID0gcG9zaXRpb24oXCJ4XCIsIHcpO1xuICAgICAgICBpZiAoaXNOYU4oby55KSkgby55ID0gcG9zaXRpb24oXCJ5XCIsIGgpO1xuICAgICAgICBpZiAoaXNOYU4oby5weCkpIG8ucHggPSBvLng7XG4gICAgICAgIGlmIChpc05hTihvLnB5KSkgby5weSA9IG8ueTtcbiAgICAgIH1cbiAgICAgIGRpc3RhbmNlcyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rRGlzdGFuY2UgPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG07ICsraSkgZGlzdGFuY2VzW2ldID0gK2xpbmtEaXN0YW5jZS5jYWxsKHRoaXMsIGxpbmtzW2ldLCBpKTsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBkaXN0YW5jZXNbaV0gPSBsaW5rRGlzdGFuY2U7XG4gICAgICBzdHJlbmd0aHMgPSBbXTtcbiAgICAgIGlmICh0eXBlb2YgbGlua1N0cmVuZ3RoID09PSBcImZ1bmN0aW9uXCIpIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHN0cmVuZ3Roc1tpXSA9ICtsaW5rU3RyZW5ndGguY2FsbCh0aGlzLCBsaW5rc1tpXSwgaSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc3RyZW5ndGhzW2ldID0gbGlua1N0cmVuZ3RoO1xuICAgICAgY2hhcmdlcyA9IFtdO1xuICAgICAgaWYgKHR5cGVvZiBjaGFyZ2UgPT09IFwiZnVuY3Rpb25cIikgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hhcmdlc1tpXSA9ICtjaGFyZ2UuY2FsbCh0aGlzLCBub2Rlc1tpXSwgaSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IG47ICsraSkgY2hhcmdlc1tpXSA9IGNoYXJnZTtcbiAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uKGRpbWVuc2lvbiwgc2l6ZSkge1xuICAgICAgICBpZiAoIW5laWdoYm9ycykge1xuICAgICAgICAgIG5laWdoYm9ycyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICBuZWlnaGJvcnNbal0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgdmFyIG8gPSBsaW5rc1tqXTtcbiAgICAgICAgICAgIG5laWdoYm9yc1tvLnNvdXJjZS5pbmRleF0ucHVzaChvLnRhcmdldCk7XG4gICAgICAgICAgICBuZWlnaGJvcnNbby50YXJnZXQuaW5kZXhdLnB1c2goby5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IG5laWdoYm9yc1tpXSwgaiA9IC0xLCBsID0gY2FuZGlkYXRlcy5sZW5ndGgsIHg7XG4gICAgICAgIHdoaWxlICgrK2ogPCBsKSBpZiAoIWlzTmFOKHggPSBjYW5kaWRhdGVzW2pdW2RpbWVuc2lvbl0pKSByZXR1cm4geDtcbiAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiBzaXplO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcmNlLnJlc3VtZSgpO1xuICAgIH07XG4gICAgZm9yY2UucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9yY2UuYWxwaGEoLjEpO1xuICAgIH07XG4gICAgZm9yY2Uuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcmNlLmFscGhhKDApO1xuICAgIH07XG4gICAgZm9yY2UuZHJhZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFkcmFnKSBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpLm9yaWdpbihkM19pZGVudGl0eSkub24oXCJkcmFnc3RhcnQuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlRHJhZ3N0YXJ0KS5vbihcImRyYWcuZm9yY2VcIiwgZHJhZ21vdmUpLm9uKFwiZHJhZ2VuZC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VEcmFnZW5kKTtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRyYWc7XG4gICAgICB0aGlzLm9uKFwibW91c2VvdmVyLmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZU1vdXNlb3Zlcikub24oXCJtb3VzZW91dC5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VNb3VzZW91dCkuY2FsbChkcmFnKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRyYWdtb3ZlKGQpIHtcbiAgICAgIGQucHggPSBkMy5ldmVudC54LCBkLnB5ID0gZDMuZXZlbnQueTtcbiAgICAgIGZvcmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZDMucmViaW5kKGZvcmNlLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlRHJhZ3N0YXJ0KGQpIHtcbiAgICBkLmZpeGVkIHw9IDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlRHJhZ2VuZChkKSB7XG4gICAgZC5maXhlZCAmPSB+NjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VNb3VzZW92ZXIoZCkge1xuICAgIGQuZml4ZWQgfD0gNDtcbiAgICBkLnB4ID0gZC54LCBkLnB5ID0gZC55O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZU1vdXNlb3V0KGQpIHtcbiAgICBkLmZpeGVkICY9IH40O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUocXVhZCwgYWxwaGEsIGNoYXJnZXMpIHtcbiAgICB2YXIgY3ggPSAwLCBjeSA9IDA7XG4gICAgcXVhZC5jaGFyZ2UgPSAwO1xuICAgIGlmICghcXVhZC5sZWFmKSB7XG4gICAgICB2YXIgbm9kZXMgPSBxdWFkLm5vZGVzLCBuID0gbm9kZXMubGVuZ3RoLCBpID0gLTEsIGM7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBjID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChjID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKGMsIGFscGhhLCBjaGFyZ2VzKTtcbiAgICAgICAgcXVhZC5jaGFyZ2UgKz0gYy5jaGFyZ2U7XG4gICAgICAgIGN4ICs9IGMuY2hhcmdlICogYy5jeDtcbiAgICAgICAgY3kgKz0gYy5jaGFyZ2UgKiBjLmN5O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVhZC5wb2ludCkge1xuICAgICAgaWYgKCFxdWFkLmxlYWYpIHtcbiAgICAgICAgcXVhZC5wb2ludC54ICs9IE1hdGgucmFuZG9tKCkgLSAuNTtcbiAgICAgICAgcXVhZC5wb2ludC55ICs9IE1hdGgucmFuZG9tKCkgLSAuNTtcbiAgICAgIH1cbiAgICAgIHZhciBrID0gYWxwaGEgKiBjaGFyZ2VzW3F1YWQucG9pbnQuaW5kZXhdO1xuICAgICAgcXVhZC5jaGFyZ2UgKz0gcXVhZC5wb2ludENoYXJnZSA9IGs7XG4gICAgICBjeCArPSBrICogcXVhZC5wb2ludC54O1xuICAgICAgY3kgKz0gayAqIHF1YWQucG9pbnQueTtcbiAgICB9XG4gICAgcXVhZC5jeCA9IGN4IC8gcXVhZC5jaGFyZ2U7XG4gICAgcXVhZC5jeSA9IGN5IC8gcXVhZC5jaGFyZ2U7XG4gIH1cbiAgdmFyIGQzX2xheW91dF9mb3JjZUxpbmtEaXN0YW5jZSA9IDIwLCBkM19sYXlvdXRfZm9yY2VMaW5rU3RyZW5ndGggPSAxLCBkM19sYXlvdXRfZm9yY2VDaGFyZ2VEaXN0YW5jZTIgPSBJbmZpbml0eTtcbiAgZDMubGF5b3V0LmhpZXJhcmNoeSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3J0ID0gZDNfbGF5b3V0X2hpZXJhcmNoeVNvcnQsIGNoaWxkcmVuID0gZDNfbGF5b3V0X2hpZXJhcmNoeUNoaWxkcmVuLCB2YWx1ZSA9IGQzX2xheW91dF9oaWVyYXJjaHlWYWx1ZTtcbiAgICBmdW5jdGlvbiBoaWVyYXJjaHkocm9vdCkge1xuICAgICAgdmFyIHN0YWNrID0gWyByb290IF0sIG5vZGVzID0gW10sIG5vZGU7XG4gICAgICByb290LmRlcHRoID0gMDtcbiAgICAgIHdoaWxlICgobm9kZSA9IHN0YWNrLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4uY2FsbChoaWVyYXJjaHksIG5vZGUsIG5vZGUuZGVwdGgpKSAmJiAobiA9IGNoaWxkcy5sZW5ndGgpKSB7XG4gICAgICAgICAgdmFyIG4sIGNoaWxkcywgY2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGNoaWxkID0gY2hpbGRzW25dKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUpIG5vZGUudmFsdWUgPSAwO1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHZhbHVlKSBub2RlLnZhbHVlID0gK3ZhbHVlLmNhbGwoaGllcmFyY2h5LCBub2RlLCBub2RlLmRlcHRoKSB8fCAwO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBjaGlsZHMsIHBhcmVudDtcbiAgICAgICAgaWYgKHNvcnQgJiYgKGNoaWxkcyA9IG5vZGUuY2hpbGRyZW4pKSBjaGlsZHMuc29ydChzb3J0KTtcbiAgICAgICAgaWYgKHZhbHVlICYmIChwYXJlbnQgPSBub2RlLnBhcmVudCkpIHBhcmVudC52YWx1ZSArPSBub2RlLnZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGhpZXJhcmNoeS5zb3J0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydDtcbiAgICAgIHNvcnQgPSB4O1xuICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9O1xuICAgIGhpZXJhcmNoeS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgY2hpbGRyZW4gPSB4O1xuICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9O1xuICAgIGhpZXJhcmNoeS52YWx1ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlO1xuICAgICAgdmFsdWUgPSB4O1xuICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9O1xuICAgIGhpZXJhcmNoeS5yZXZhbHVlID0gZnVuY3Rpb24ocm9vdCkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIG5vZGUudmFsdWUgPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHZhciBwYXJlbnQ7XG4gICAgICAgICAgaWYgKCFub2RlLmNoaWxkcmVuKSBub2RlLnZhbHVlID0gK3ZhbHVlLmNhbGwoaGllcmFyY2h5LCBub2RlLCBub2RlLmRlcHRoKSB8fCAwO1xuICAgICAgICAgIGlmIChwYXJlbnQgPSBub2RlLnBhcmVudCkgcGFyZW50LnZhbHVlICs9IG5vZGUudmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgICByZXR1cm4gaGllcmFyY2h5O1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKG9iamVjdCwgaGllcmFyY2h5KSB7XG4gICAgZDMucmViaW5kKG9iamVjdCwgaGllcmFyY2h5LCBcInNvcnRcIiwgXCJjaGlsZHJlblwiLCBcInZhbHVlXCIpO1xuICAgIG9iamVjdC5ub2RlcyA9IG9iamVjdDtcbiAgICBvYmplY3QubGlua3MgPSBkM19sYXlvdXRfaGllcmFyY2h5TGlua3M7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUobm9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbm9kZXMgPSBbIG5vZGUgXTtcbiAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICBpZiAoKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBuLCBjaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKC0tbiA+PSAwKSBub2Rlcy5wdXNoKGNoaWxkcmVuW25dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIobm9kZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbm9kZXMgPSBbIG5vZGUgXSwgbm9kZXMyID0gW107XG4gICAgd2hpbGUgKChub2RlID0gbm9kZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgIG5vZGVzMi5wdXNoKG5vZGUpO1xuICAgICAgaWYgKChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuLCBjaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoKG5vZGUgPSBub2RlczIucG9wKCkpICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5Q2hpbGRyZW4oZCkge1xuICAgIHJldHVybiBkLmNoaWxkcmVuO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWYWx1ZShkKSB7XG4gICAgcmV0dXJuIGQudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVNvcnQoYSwgYikge1xuICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5TGlua3Mobm9kZXMpIHtcbiAgICByZXR1cm4gZDMubWVyZ2Uobm9kZXMubWFwKGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgcmV0dXJuIChwYXJlbnQuY2hpbGRyZW4gfHwgW10pLm1hcChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogcGFyZW50LFxuICAgICAgICAgIHRhcmdldDogY2hpbGRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuICBkMy5sYXlvdXQucGFydGl0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKSwgc2l6ZSA9IFsgMSwgMSBdO1xuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKG5vZGUsIHgsIGR4LCBkeSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIG5vZGUueCA9IHg7XG4gICAgICBub2RlLnkgPSBub2RlLmRlcHRoICogZHk7XG4gICAgICBub2RlLmR4ID0gZHg7XG4gICAgICBub2RlLmR5ID0gZHk7XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgKG4gPSBjaGlsZHJlbi5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4sIGMsIGQ7XG4gICAgICAgIGR4ID0gbm9kZS52YWx1ZSA/IGR4IC8gbm9kZS52YWx1ZSA6IDA7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgcG9zaXRpb24oYyA9IGNoaWxkcmVuW2ldLCB4LCBkID0gYy52YWx1ZSAqIGR4LCBkeSk7XG4gICAgICAgICAgeCArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlcHRoKG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sIGQgPSAwO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgZCA9IE1hdGgubWF4KGQsIGRlcHRoKGNoaWxkcmVuW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMSArIGQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnRpdGlvbihkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgIHBvc2l0aW9uKG5vZGVzWzBdLCAwLCBzaXplWzBdLCBzaXplWzFdIC8gZGVwdGgobm9kZXNbMF0pKTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgcGFydGl0aW9uLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IHg7XG4gICAgICByZXR1cm4gcGFydGl0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQocGFydGl0aW9uLCBoaWVyYXJjaHkpO1xuICB9O1xuICBkMy5sYXlvdXQucGllID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gTnVtYmVyLCBzb3J0ID0gZDNfbGF5b3V0X3BpZVNvcnRCeVZhbHVlLCBzdGFydEFuZ2xlID0gMCwgZW5kQW5nbGUgPSDPhCwgcGFkQW5nbGUgPSAwO1xuICAgIGZ1bmN0aW9uIHBpZShkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCB2YWx1ZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiArdmFsdWUuY2FsbChwaWUsIGQsIGkpO1xuICAgICAgfSksIGEgPSArKHR5cGVvZiBzdGFydEFuZ2xlID09PSBcImZ1bmN0aW9uXCIgPyBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzdGFydEFuZ2xlKSwgZGEgPSAodHlwZW9mIGVuZEFuZ2xlID09PSBcImZ1bmN0aW9uXCIgPyBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogZW5kQW5nbGUpIC0gYSwgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sICsodHlwZW9mIHBhZEFuZ2xlID09PSBcImZ1bmN0aW9uXCIgPyBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogcGFkQW5nbGUpKSwgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksIHN1bSA9IGQzLnN1bSh2YWx1ZXMpLCBrID0gc3VtID8gKGRhIC0gbiAqIHBhKSAvIHN1bSA6IDAsIGluZGV4ID0gZDMucmFuZ2UobiksIGFyY3MgPSBbXSwgdjtcbiAgICAgIGlmIChzb3J0ICE9IG51bGwpIGluZGV4LnNvcnQoc29ydCA9PT0gZDNfbGF5b3V0X3BpZVNvcnRCeVZhbHVlID8gZnVuY3Rpb24oaSwgaikge1xuICAgICAgICByZXR1cm4gdmFsdWVzW2pdIC0gdmFsdWVzW2ldO1xuICAgICAgfSA6IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHNvcnQoZGF0YVtpXSwgZGF0YVtqXSk7XG4gICAgICB9KTtcbiAgICAgIGluZGV4LmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBhcmNzW2ldID0ge1xuICAgICAgICAgIGRhdGE6IGRhdGFbaV0sXG4gICAgICAgICAgdmFsdWU6IHYgPSB2YWx1ZXNbaV0sXG4gICAgICAgICAgc3RhcnRBbmdsZTogYSxcbiAgICAgICAgICBlbmRBbmdsZTogYSArPSB2ICogayArIHBhLFxuICAgICAgICAgIHBhZEFuZ2xlOiBwXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhcmNzO1xuICAgIH1cbiAgICBwaWUudmFsdWUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnQ7XG4gICAgICBzb3J0ID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUuZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRBbmdsZTtcbiAgICAgIHBhZEFuZ2xlID0gXztcbiAgICAgIHJldHVybiBwaWU7XG4gICAgfTtcbiAgICByZXR1cm4gcGllO1xuICB9O1xuICB2YXIgZDNfbGF5b3V0X3BpZVNvcnRCeVZhbHVlID0ge307XG4gIGQzLmxheW91dC5zdGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBkM19pZGVudGl0eSwgb3JkZXIgPSBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQsIG9mZnNldCA9IGQzX2xheW91dF9zdGFja09mZnNldFplcm8sIG91dCA9IGQzX2xheW91dF9zdGFja091dCwgeCA9IGQzX2xheW91dF9zdGFja1gsIHkgPSBkM19sYXlvdXRfc3RhY2tZO1xuICAgIGZ1bmN0aW9uIHN0YWNrKGRhdGEsIGluZGV4KSB7XG4gICAgICBpZiAoIShuID0gZGF0YS5sZW5ndGgpKSByZXR1cm4gZGF0YTtcbiAgICAgIHZhciBzZXJpZXMgPSBkYXRhLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXMuY2FsbChzdGFjaywgZCwgaSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludHMgPSBzZXJpZXMubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICByZXR1cm4gWyB4LmNhbGwoc3RhY2ssIHYsIGkpLCB5LmNhbGwoc3RhY2ssIHYsIGkpIF07XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3JkZXJzID0gb3JkZXIuY2FsbChzdGFjaywgcG9pbnRzLCBpbmRleCk7XG4gICAgICBzZXJpZXMgPSBkMy5wZXJtdXRlKHNlcmllcywgb3JkZXJzKTtcbiAgICAgIHBvaW50cyA9IGQzLnBlcm11dGUocG9pbnRzLCBvcmRlcnMpO1xuICAgICAgdmFyIG9mZnNldHMgPSBvZmZzZXQuY2FsbChzdGFjaywgcG9pbnRzLCBpbmRleCk7XG4gICAgICB2YXIgbSA9IHNlcmllc1swXS5sZW5ndGgsIG4sIGksIGosIG87XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIG91dC5jYWxsKHN0YWNrLCBzZXJpZXNbMF1bal0sIG8gPSBvZmZzZXRzW2pdLCBwb2ludHNbMF1bal1bMV0pO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgb3V0LmNhbGwoc3RhY2ssIHNlcmllc1tpXVtqXSwgbyArPSBwb2ludHNbaSAtIDFdW2pdWzFdLCBwb2ludHNbaV1bal1bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgc3RhY2sudmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVzO1xuICAgICAgdmFsdWVzID0geDtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JkZXI7XG4gICAgICBvcmRlciA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogZDNfbGF5b3V0X3N0YWNrT3JkZXJzLmdldCh4KSB8fCBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHQ7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGQzX2xheW91dF9zdGFja09mZnNldHMuZ2V0KHgpIHx8IGQzX2xheW91dF9zdGFja09mZnNldFplcm87XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay54ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLm91dCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dDtcbiAgICAgIG91dCA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1goZCkge1xuICAgIHJldHVybiBkLng7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrWShkKSB7XG4gICAgcmV0dXJuIGQueTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPdXQoZCwgeTAsIHkpIHtcbiAgICBkLnkwID0geTA7XG4gICAgZC55ID0geTtcbiAgfVxuICB2YXIgZDNfbGF5b3V0X3N0YWNrT3JkZXJzID0gZDMubWFwKHtcbiAgICBcImluc2lkZS1vdXRcIjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgaSwgaiwgbWF4ID0gZGF0YS5tYXAoZDNfbGF5b3V0X3N0YWNrTWF4SW5kZXgpLCBzdW1zID0gZGF0YS5tYXAoZDNfbGF5b3V0X3N0YWNrUmVkdWNlU3VtKSwgaW5kZXggPSBkMy5yYW5nZShuKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG1heFthXSAtIG1heFtiXTtcbiAgICAgIH0pLCB0b3AgPSAwLCBib3R0b20gPSAwLCB0b3BzID0gW10sIGJvdHRvbXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaiA9IGluZGV4W2ldO1xuICAgICAgICBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICAgICAgdG9wICs9IHN1bXNbal07XG4gICAgICAgICAgdG9wcy5wdXNoKGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvdHRvbSArPSBzdW1zW2pdO1xuICAgICAgICAgIGJvdHRvbXMucHVzaChqKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbiAgICB9LFxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShkYXRhLmxlbmd0aCkucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdFxuICB9KTtcbiAgdmFyIGQzX2xheW91dF9zdGFja09mZnNldHMgPSBkMy5tYXAoe1xuICAgIHNpbGhvdWV0dGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIG0gPSBkYXRhWzBdLmxlbmd0aCwgc3VtcyA9IFtdLCBtYXggPSAwLCBpLCBqLCBvLCB5MCA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IG47IGkrKykgbyArPSBkYXRhW2ldW2pdWzFdO1xuICAgICAgICBpZiAobyA+IG1heCkgbWF4ID0gbztcbiAgICAgICAgc3Vtcy5wdXNoKG8pO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICB5MFtqXSA9IChtYXggLSBzdW1zW2pdKSAvIDI7XG4gICAgICB9XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICB3aWdnbGU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIHggPSBkYXRhWzBdLCBtID0geC5sZW5ndGgsIGksIGosIGssIHMxLCBzMiwgczMsIGR4LCBvLCBvMCwgeTAgPSBbXTtcbiAgICAgIHkwWzBdID0gbyA9IG8wID0gMDtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgczEgPSAwOyBpIDwgbjsgKytpKSBzMSArPSBkYXRhW2ldW2pdWzFdO1xuICAgICAgICBmb3IgKGkgPSAwLCBzMiA9IDAsIGR4ID0geFtqXVswXSAtIHhbaiAtIDFdWzBdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgZm9yIChrID0gMCwgczMgPSAoZGF0YVtpXVtqXVsxXSAtIGRhdGFbaV1baiAtIDFdWzFdKSAvICgyICogZHgpOyBrIDwgaTsgKytrKSB7XG4gICAgICAgICAgICBzMyArPSAoZGF0YVtrXVtqXVsxXSAtIGRhdGFba11baiAtIDFdWzFdKSAvIGR4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzMiArPSBzMyAqIGRhdGFbaV1bal1bMV07XG4gICAgICAgIH1cbiAgICAgICAgeTBbal0gPSBvIC09IHMxID8gczIgLyBzMSAqIGR4IDogMDtcbiAgICAgICAgaWYgKG8gPCBvMCkgbzAgPSBvO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeTBbal0gLT0gbzA7XG4gICAgICByZXR1cm4geTA7XG4gICAgfSxcbiAgICBleHBhbmQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIG0gPSBkYXRhWzBdLmxlbmd0aCwgayA9IDEgLyBuLCBpLCBqLCBvLCB5MCA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IG47IGkrKykgbyArPSBkYXRhW2ldW2pdWzFdO1xuICAgICAgICBpZiAobykgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZGF0YVtpXVtqXVsxXSAvPSBvOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGRhdGFbaV1bal1bMV0gPSBrO1xuICAgICAgfVxuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeTBbal0gPSAwO1xuICAgICAgcmV0dXJuIHkwO1xuICAgIH0sXG4gICAgemVybzogZDNfbGF5b3V0X3N0YWNrT2Zmc2V0WmVyb1xuICB9KTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0KGRhdGEpIHtcbiAgICByZXR1cm4gZDMucmFuZ2UoZGF0YS5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja09mZnNldFplcm8oZGF0YSkge1xuICAgIHZhciBqID0gLTEsIG0gPSBkYXRhWzBdLmxlbmd0aCwgeTAgPSBbXTtcbiAgICB3aGlsZSAoKytqIDwgbSkgeTBbal0gPSAwO1xuICAgIHJldHVybiB5MDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tNYXhJbmRleChhcnJheSkge1xuICAgIHZhciBpID0gMSwgaiA9IDAsIHYgPSBhcnJheVswXVsxXSwgaywgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKDtpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKGsgPSBhcnJheVtpXVsxXSkgPiB2KSB7XG4gICAgICAgIGogPSBpO1xuICAgICAgICB2ID0gaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGo7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrUmVkdWNlU3VtKGQpIHtcbiAgICByZXR1cm4gZC5yZWR1Y2UoZDNfbGF5b3V0X3N0YWNrU3VtLCAwKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tTdW0ocCwgZCkge1xuICAgIHJldHVybiBwICsgZFsxXTtcbiAgfVxuICBkMy5sYXlvdXQuaGlzdG9ncmFtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZyZXF1ZW5jeSA9IHRydWUsIHZhbHVlciA9IE51bWJlciwgcmFuZ2VyID0gZDNfbGF5b3V0X2hpc3RvZ3JhbVJhbmdlLCBiaW5uZXIgPSBkM19sYXlvdXRfaGlzdG9ncmFtQmluU3R1cmdlcztcbiAgICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSwgaSkge1xuICAgICAgdmFyIGJpbnMgPSBbXSwgdmFsdWVzID0gZGF0YS5tYXAodmFsdWVyLCB0aGlzKSwgcmFuZ2UgPSByYW5nZXIuY2FsbCh0aGlzLCB2YWx1ZXMsIGkpLCB0aHJlc2hvbGRzID0gYmlubmVyLmNhbGwodGhpcywgcmFuZ2UsIHZhbHVlcywgaSksIGJpbiwgaSA9IC0xLCBuID0gdmFsdWVzLmxlbmd0aCwgbSA9IHRocmVzaG9sZHMubGVuZ3RoIC0gMSwgayA9IGZyZXF1ZW5jeSA/IDEgOiAxIC8gbiwgeDtcbiAgICAgIHdoaWxlICgrK2kgPCBtKSB7XG4gICAgICAgIGJpbiA9IGJpbnNbaV0gPSBbXTtcbiAgICAgICAgYmluLmR4ID0gdGhyZXNob2xkc1tpICsgMV0gLSAoYmluLnggPSB0aHJlc2hvbGRzW2ldKTtcbiAgICAgICAgYmluLnkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG0gPiAwKSB7XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICB4ID0gdmFsdWVzW2ldO1xuICAgICAgICAgIGlmICh4ID49IHJhbmdlWzBdICYmIHggPD0gcmFuZ2VbMV0pIHtcbiAgICAgICAgICAgIGJpbiA9IGJpbnNbZDMuYmlzZWN0KHRocmVzaG9sZHMsIHgsIDEsIG0pIC0gMV07XG4gICAgICAgICAgICBiaW4ueSArPSBrO1xuICAgICAgICAgICAgYmluLnB1c2goZGF0YVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmlucztcbiAgICB9XG4gICAgaGlzdG9ncmFtLnZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWVyO1xuICAgICAgdmFsdWVyID0geDtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICBoaXN0b2dyYW0ucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZXI7XG4gICAgICByYW5nZXIgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5iaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmlubmVyO1xuICAgICAgYmlubmVyID0gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCB4KTtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIGhpc3RvZ3JhbS5mcmVxdWVuY3kgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmcmVxdWVuY3k7XG4gICAgICBmcmVxdWVuY3kgPSAhIXg7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpblN0dXJnZXMocmFuZ2UsIHZhbHVlcykge1xuICAgIHJldHVybiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIE1hdGguY2VpbChNYXRoLmxvZyh2YWx1ZXMubGVuZ3RoKSAvIE1hdGguTE4yICsgMSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgbikge1xuICAgIHZhciB4ID0gLTEsIGIgPSArcmFuZ2VbMF0sIG0gPSAocmFuZ2VbMV0gLSBiKSAvIG4sIGYgPSBbXTtcbiAgICB3aGlsZSAoKyt4IDw9IG4pIGZbeF0gPSBtICogeCArIGI7XG4gICAgcmV0dXJuIGY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpc3RvZ3JhbVJhbmdlKHZhbHVlcykge1xuICAgIHJldHVybiBbIGQzLm1pbih2YWx1ZXMpLCBkMy5tYXgodmFsdWVzKSBdO1xuICB9XG4gIGQzLmxheW91dC5wYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KGQzX2xheW91dF9wYWNrU29ydCksIHBhZGRpbmcgPSAwLCBzaXplID0gWyAxLCAxIF0sIHJhZGl1cztcbiAgICBmdW5jdGlvbiBwYWNrKGQsIGkpIHtcbiAgICAgIHZhciBub2RlcyA9IGhpZXJhcmNoeS5jYWxsKHRoaXMsIGQsIGkpLCByb290ID0gbm9kZXNbMF0sIHcgPSBzaXplWzBdLCBoID0gc2l6ZVsxXSwgciA9IHJhZGl1cyA9PSBudWxsID8gTWF0aC5zcXJ0IDogdHlwZW9mIHJhZGl1cyA9PT0gXCJmdW5jdGlvblwiID8gcmFkaXVzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYWRpdXM7XG4gICAgICB9O1xuICAgICAgcm9vdC54ID0gcm9vdC55ID0gMDtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgZC5yID0gK3IoZC52YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGQzX2xheW91dF9wYWNrU2libGluZ3MpO1xuICAgICAgaWYgKHBhZGRpbmcpIHtcbiAgICAgICAgdmFyIGRyID0gcGFkZGluZyAqIChyYWRpdXMgPyAxIDogTWF0aC5tYXgoMiAqIHJvb3QuciAvIHcsIDIgKiByb290LnIgLyBoKSkgLyAyO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5yICs9IGRyO1xuICAgICAgICB9KTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkLnIgLT0gZHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZDNfbGF5b3V0X3BhY2tUcmFuc2Zvcm0ocm9vdCwgdyAvIDIsIGggLyAyLCByYWRpdXMgPyAxIDogMSAvIE1hdGgubWF4KDIgKiByb290LnIgLyB3LCAyICogcm9vdC5yIC8gaCkpO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBwYWNrLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IF87XG4gICAgICByZXR1cm4gcGFjaztcbiAgICB9O1xuICAgIHBhY2sucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFkaXVzO1xuICAgICAgcmFkaXVzID0gXyA9PSBudWxsIHx8IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogK187XG4gICAgICByZXR1cm4gcGFjaztcbiAgICB9O1xuICAgIHBhY2sucGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBwYWRkaW5nID0gK187XG4gICAgICByZXR1cm4gcGFjaztcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHBhY2ssIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGEudmFsdWUgLSBiLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGIpIHtcbiAgICB2YXIgYyA9IGEuX3BhY2tfbmV4dDtcbiAgICBhLl9wYWNrX25leHQgPSBiO1xuICAgIGIuX3BhY2tfcHJldiA9IGE7XG4gICAgYi5fcGFja19uZXh0ID0gYztcbiAgICBjLl9wYWNrX3ByZXYgPSBiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrU3BsaWNlKGEsIGIpIHtcbiAgICBhLl9wYWNrX25leHQgPSBiO1xuICAgIGIuX3BhY2tfcHJldiA9IGE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tJbnRlcnNlY3RzKGEsIGIpIHtcbiAgICB2YXIgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55LCBkciA9IGEuciArIGIucjtcbiAgICByZXR1cm4gLjk5OSAqIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1NpYmxpbmdzKG5vZGUpIHtcbiAgICBpZiAoIShub2RlcyA9IG5vZGUuY2hpbGRyZW4pIHx8ICEobiA9IG5vZGVzLmxlbmd0aCkpIHJldHVybjtcbiAgICB2YXIgbm9kZXMsIHhNaW4gPSBJbmZpbml0eSwgeE1heCA9IC1JbmZpbml0eSwgeU1pbiA9IEluZmluaXR5LCB5TWF4ID0gLUluZmluaXR5LCBhLCBiLCBjLCBpLCBqLCBrLCBuO1xuICAgIGZ1bmN0aW9uIGJvdW5kKG5vZGUpIHtcbiAgICAgIHhNaW4gPSBNYXRoLm1pbihub2RlLnggLSBub2RlLnIsIHhNaW4pO1xuICAgICAgeE1heCA9IE1hdGgubWF4KG5vZGUueCArIG5vZGUuciwgeE1heCk7XG4gICAgICB5TWluID0gTWF0aC5taW4obm9kZS55IC0gbm9kZS5yLCB5TWluKTtcbiAgICAgIHlNYXggPSBNYXRoLm1heChub2RlLnkgKyBub2RlLnIsIHlNYXgpO1xuICAgIH1cbiAgICBub2Rlcy5mb3JFYWNoKGQzX2xheW91dF9wYWNrTGluayk7XG4gICAgYSA9IG5vZGVzWzBdO1xuICAgIGEueCA9IC1hLnI7XG4gICAgYS55ID0gMDtcbiAgICBib3VuZChhKTtcbiAgICBpZiAobiA+IDEpIHtcbiAgICAgIGIgPSBub2Rlc1sxXTtcbiAgICAgIGIueCA9IGIucjtcbiAgICAgIGIueSA9IDA7XG4gICAgICBib3VuZChiKTtcbiAgICAgIGlmIChuID4gMikge1xuICAgICAgICBjID0gbm9kZXNbMl07XG4gICAgICAgIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYyk7XG4gICAgICAgIGJvdW5kKGMpO1xuICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChhLCBjKTtcbiAgICAgICAgYS5fcGFja19wcmV2ID0gYztcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYywgYik7XG4gICAgICAgIGIgPSBhLl9wYWNrX25leHQ7XG4gICAgICAgIGZvciAoaSA9IDM7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMgPSBub2Rlc1tpXSk7XG4gICAgICAgICAgdmFyIGlzZWN0ID0gMCwgczEgPSAxLCBzMiA9IDE7XG4gICAgICAgICAgZm9yIChqID0gYi5fcGFja19uZXh0OyBqICE9PSBiOyBqID0gai5fcGFja19uZXh0LCBzMSsrKSB7XG4gICAgICAgICAgICBpZiAoZDNfbGF5b3V0X3BhY2tJbnRlcnNlY3RzKGosIGMpKSB7XG4gICAgICAgICAgICAgIGlzZWN0ID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc2VjdCA9PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGsgPSBhLl9wYWNrX3ByZXY7IGsgIT09IGouX3BhY2tfcHJldjsgayA9IGsuX3BhY2tfcHJldiwgczIrKykge1xuICAgICAgICAgICAgICBpZiAoZDNfbGF5b3V0X3BhY2tJbnRlcnNlY3RzKGssIGMpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzZWN0KSB7XG4gICAgICAgICAgICBpZiAoczEgPCBzMiB8fCBzMSA9PSBzMiAmJiBiLnIgPCBhLnIpIGQzX2xheW91dF9wYWNrU3BsaWNlKGEsIGIgPSBqKTsgZWxzZSBkM19sYXlvdXRfcGFja1NwbGljZShhID0gaywgYik7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGEsIGMpO1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgICAgICBib3VuZChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGN4ID0gKHhNaW4gKyB4TWF4KSAvIDIsIGN5ID0gKHlNaW4gKyB5TWF4KSAvIDIsIGNyID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjID0gbm9kZXNbaV07XG4gICAgICBjLnggLT0gY3g7XG4gICAgICBjLnkgLT0gY3k7XG4gICAgICBjciA9IE1hdGgubWF4KGNyLCBjLnIgKyBNYXRoLnNxcnQoYy54ICogYy54ICsgYy55ICogYy55KSk7XG4gICAgfVxuICAgIG5vZGUuciA9IGNyO1xuICAgIG5vZGVzLmZvckVhY2goZDNfbGF5b3V0X3BhY2tVbmxpbmspO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrTGluayhub2RlKSB7XG4gICAgbm9kZS5fcGFja19uZXh0ID0gbm9kZS5fcGFja19wcmV2ID0gbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1VubGluayhub2RlKSB7XG4gICAgZGVsZXRlIG5vZGUuX3BhY2tfbmV4dDtcbiAgICBkZWxldGUgbm9kZS5fcGFja19wcmV2O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrVHJhbnNmb3JtKG5vZGUsIHgsIHksIGspIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIG5vZGUueCA9IHggKz0gayAqIG5vZGUueDtcbiAgICBub2RlLnkgPSB5ICs9IGsgKiBub2RlLnk7XG4gICAgbm9kZS5yICo9IGs7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGQzX2xheW91dF9wYWNrVHJhbnNmb3JtKGNoaWxkcmVuW2ldLCB4LCB5LCBrKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjKSB7XG4gICAgdmFyIGRiID0gYS5yICsgYy5yLCBkeCA9IGIueCAtIGEueCwgZHkgPSBiLnkgLSBhLnk7XG4gICAgaWYgKGRiICYmIChkeCB8fCBkeSkpIHtcbiAgICAgIHZhciBkYSA9IGIuciArIGMuciwgZGMgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIGRhICo9IGRhO1xuICAgICAgZGIgKj0gZGI7XG4gICAgICB2YXIgeCA9IC41ICsgKGRiIC0gZGEpIC8gKDIgKiBkYyksIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgMiAqIGRhICogKGRiICsgZGMpIC0gKGRiIC09IGRjKSAqIGRiIC0gZGEgKiBkYSkpIC8gKDIgKiBkYyk7XG4gICAgICBjLnggPSBhLnggKyB4ICogZHggKyB5ICogZHk7XG4gICAgICBjLnkgPSBhLnkgKyB4ICogZHkgLSB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMueCA9IGEueCArIGRiO1xuICAgICAgYy55ID0gYS55O1xuICAgIH1cbiAgfVxuICBkMy5sYXlvdXQudHJlZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCkuc29ydChudWxsKS52YWx1ZShudWxsKSwgc2VwYXJhdGlvbiA9IGQzX2xheW91dF90cmVlU2VwYXJhdGlvbiwgc2l6ZSA9IFsgMSwgMSBdLCBub2RlU2l6ZSA9IG51bGw7XG4gICAgZnVuY3Rpb24gdHJlZShkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKSwgcm9vdDAgPSBub2Rlc1swXSwgcm9vdDEgPSB3cmFwVHJlZShyb290MCk7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290MSwgZmlyc3RXYWxrKSwgcm9vdDEucGFyZW50Lm0gPSAtcm9vdDEuejtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MSwgc2Vjb25kV2Fsayk7XG4gICAgICBpZiAobm9kZVNpemUpIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgc2l6ZU5vZGUpOyBlbHNlIHtcbiAgICAgICAgdmFyIGxlZnQgPSByb290MCwgcmlnaHQgPSByb290MCwgYm90dG9tID0gcm9vdDA7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEJlZm9yZShyb290MCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLnggPCBsZWZ0LngpIGxlZnQgPSBub2RlO1xuICAgICAgICAgIGlmIChub2RlLnggPiByaWdodC54KSByaWdodCA9IG5vZGU7XG4gICAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdHggPSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIgLSBsZWZ0LngsIGt4ID0gc2l6ZVswXSAvIChyaWdodC54ICsgc2VwYXJhdGlvbihyaWdodCwgbGVmdCkgLyAyICsgdHgpLCBreSA9IHNpemVbMV0gLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDAsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBub2RlLnggPSAobm9kZS54ICsgdHgpICoga3g7XG4gICAgICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGt5O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcFRyZWUocm9vdDApIHtcbiAgICAgIHZhciByb290MSA9IHtcbiAgICAgICAgQTogbnVsbCxcbiAgICAgICAgY2hpbGRyZW46IFsgcm9vdDAgXVxuICAgICAgfSwgcXVldWUgPSBbIHJvb3QxIF0sIG5vZGUxO1xuICAgICAgd2hpbGUgKChub2RlMSA9IHF1ZXVlLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gbm9kZTEuY2hpbGRyZW4sIGNoaWxkLCBpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2goKGNoaWxkcmVuW2ldID0gY2hpbGQgPSB7XG4gICAgICAgICAgICBfOiBjaGlsZHJlbltpXSxcbiAgICAgICAgICAgIHBhcmVudDogbm9kZTEsXG4gICAgICAgICAgICBjaGlsZHJlbjogKGNoaWxkID0gY2hpbGRyZW5baV0uY2hpbGRyZW4pICYmIGNoaWxkLnNsaWNlKCkgfHwgW10sXG4gICAgICAgICAgICBBOiBudWxsLFxuICAgICAgICAgICAgYTogbnVsbCxcbiAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICBtOiAwLFxuICAgICAgICAgICAgYzogMCxcbiAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICB0OiBudWxsLFxuICAgICAgICAgICAgaTogaVxuICAgICAgICAgIH0pLmEgPSBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb290MS5jaGlsZHJlblswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIHNpYmxpbmdzID0gdi5wYXJlbnQuY2hpbGRyZW4sIHcgPSB2LmkgPyBzaWJsaW5nc1t2LmkgLSAxXSA6IG51bGw7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGQzX2xheW91dF90cmVlU2hpZnQodik7XG4gICAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgICBpZiAodykge1xuICAgICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgICAgIHYubSA9IHYueiAtIG1pZHBvaW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHYueiA9IG1pZHBvaW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHcpIHtcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICB9XG4gICAgICB2LnBhcmVudC5BID0gYXBwb3J0aW9uKHYsIHcsIHYucGFyZW50LkEgfHwgc2libGluZ3NbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICAgIHYuXy54ID0gdi56ICsgdi5wYXJlbnQubTtcbiAgICAgIHYubSArPSB2LnBhcmVudC5tO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBvcnRpb24odiwgdywgYW5jZXN0b3IpIHtcbiAgICAgIGlmICh3KSB7XG4gICAgICAgIHZhciB2aXAgPSB2LCB2b3AgPSB2LCB2aW0gPSB3LCB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLCBzaXAgPSB2aXAubSwgc29wID0gdm9wLm0sIHNpbSA9IHZpbS5tLCBzb20gPSB2b20ubSwgc2hpZnQ7XG4gICAgICAgIHdoaWxlICh2aW0gPSBkM19sYXlvdXRfdHJlZVJpZ2h0KHZpbSksIHZpcCA9IGQzX2xheW91dF90cmVlTGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XG4gICAgICAgICAgdm9tID0gZDNfbGF5b3V0X3RyZWVMZWZ0KHZvbSk7XG4gICAgICAgICAgdm9wID0gZDNfbGF5b3V0X3RyZWVSaWdodCh2b3ApO1xuICAgICAgICAgIHZvcC5hID0gdjtcbiAgICAgICAgICBzaGlmdCA9IHZpbS56ICsgc2ltIC0gdmlwLnogLSBzaXAgKyBzZXBhcmF0aW9uKHZpbS5fLCB2aXAuXyk7XG4gICAgICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICAgICAgZDNfbGF5b3V0X3RyZWVNb3ZlKGQzX2xheW91dF90cmVlQW5jZXN0b3IodmltLCB2LCBhbmNlc3RvciksIHYsIHNoaWZ0KTtcbiAgICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2ltICs9IHZpbS5tO1xuICAgICAgICAgIHNpcCArPSB2aXAubTtcbiAgICAgICAgICBzb20gKz0gdm9tLm07XG4gICAgICAgICAgc29wICs9IHZvcC5tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aW0gJiYgIWQzX2xheW91dF90cmVlUmlnaHQodm9wKSkge1xuICAgICAgICAgIHZvcC50ID0gdmltO1xuICAgICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlwICYmICFkM19sYXlvdXRfdHJlZUxlZnQodm9tKSkge1xuICAgICAgICAgIHZvbS50ID0gdmlwO1xuICAgICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgICBhbmNlc3RvciA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhbmNlc3RvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2l6ZU5vZGUobm9kZSkge1xuICAgICAgbm9kZS54ICo9IHNpemVbMF07XG4gICAgICBub2RlLnkgPSBub2RlLmRlcHRoICogc2l6ZVsxXTtcbiAgICB9XG4gICAgdHJlZS5zZXBhcmF0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2VwYXJhdGlvbjtcbiAgICAgIHNlcGFyYXRpb24gPSB4O1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICB0cmVlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IG51bGwgOiBzaXplO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGwgPyBzaXplTm9kZSA6IG51bGw7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHRyZWUubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBub2RlU2l6ZSA/IHNpemUgOiBudWxsO1xuICAgICAgbm9kZVNpemUgPSAoc2l6ZSA9IHgpID09IG51bGwgPyBudWxsIDogc2l6ZU5vZGU7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHRyZWUsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlU2VwYXJhdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEucGFyZW50ID09IGIucGFyZW50ID8gMSA6IDI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVMZWZ0KHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlblswXSA6IHYudDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZVJpZ2h0KHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBuO1xuICAgIHJldHVybiAobiA9IGNoaWxkcmVuLmxlbmd0aCkgPyBjaGlsZHJlbltuIC0gMV0gOiB2LnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVNb3ZlKHdtLCB3cCwgc2hpZnQpIHtcbiAgICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICAgIHdwLmMgLT0gY2hhbmdlO1xuICAgIHdwLnMgKz0gc2hpZnQ7XG4gICAgd20uYyArPSBjaGFuZ2U7XG4gICAgd3AueiArPSBzaGlmdDtcbiAgICB3cC5tICs9IHNoaWZ0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlU2hpZnQodikge1xuICAgIHZhciBzaGlmdCA9IDAsIGNoYW5nZSA9IDAsIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgaSA9IGNoaWxkcmVuLmxlbmd0aCwgdztcbiAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgIHcgPSBjaGlsZHJlbltpXTtcbiAgICAgIHcueiArPSBzaGlmdDtcbiAgICAgIHcubSArPSBzaGlmdDtcbiAgICAgIHNoaWZ0ICs9IHcucyArIChjaGFuZ2UgKz0gdy5jKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gICAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xuICB9XG4gIGQzLmxheW91dC5jbHVzdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKS5zb3J0KG51bGwpLnZhbHVlKG51bGwpLCBzZXBhcmF0aW9uID0gZDNfbGF5b3V0X3RyZWVTZXBhcmF0aW9uLCBzaXplID0gWyAxLCAxIF0sIG5vZGVTaXplID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY2x1c3RlcihkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKSwgcm9vdCA9IG5vZGVzWzBdLCBwcmV2aW91c05vZGUsIHggPSAwO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS54ID0gZDNfbGF5b3V0X2NsdXN0ZXJYKGNoaWxkcmVuKTtcbiAgICAgICAgICBub2RlLnkgPSBkM19sYXlvdXRfY2x1c3RlclkoY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUueCA9IHByZXZpb3VzTm9kZSA/IHggKz0gc2VwYXJhdGlvbihub2RlLCBwcmV2aW91c05vZGUpIDogMDtcbiAgICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICAgIHByZXZpb3VzTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGxlZnQgPSBkM19sYXlvdXRfY2x1c3RlckxlZnQocm9vdCksIHJpZ2h0ID0gZDNfbGF5b3V0X2NsdXN0ZXJSaWdodChyb290KSwgeDAgPSBsZWZ0LnggLSBzZXBhcmF0aW9uKGxlZnQsIHJpZ2h0KSAvIDIsIHgxID0gcmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMjtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIG5vZGVTaXplID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSAobm9kZS54IC0gcm9vdC54KSAqIHNpemVbMF07XG4gICAgICAgIG5vZGUueSA9IChyb290LnkgLSBub2RlLnkpICogc2l6ZVsxXTtcbiAgICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIG5vZGUueCA9IChub2RlLnggLSB4MCkgLyAoeDEgLSB4MCkgKiBzaXplWzBdO1xuICAgICAgICBub2RlLnkgPSAoMSAtIChyb290LnkgPyBub2RlLnkgLyByb290LnkgOiAxKSkgKiBzaXplWzFdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGNsdXN0ZXIuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlcGFyYXRpb247XG4gICAgICBzZXBhcmF0aW9uID0geDtcbiAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH07XG4gICAgY2x1c3Rlci5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBudWxsIDogc2l6ZTtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSA9PSBudWxsO1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICBjbHVzdGVyLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBzaXplIDogbnVsbDtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSAhPSBudWxsO1xuICAgICAgcmV0dXJuIGNsdXN0ZXI7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChjbHVzdGVyLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlclkoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gMSArIGQzLm1heChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC55O1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyWChjaGlsZHJlbikge1xuICAgIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24oeCwgY2hpbGQpIHtcbiAgICAgIHJldHVybiB4ICsgY2hpbGQueDtcbiAgICB9LCAwKSAvIGNoaWxkcmVuLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlckxlZnQobm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA/IGQzX2xheW91dF9jbHVzdGVyTGVmdChjaGlsZHJlblswXSkgOiBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9jbHVzdGVyUmlnaHQobm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sIG47XG4gICAgcmV0dXJuIGNoaWxkcmVuICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSA/IGQzX2xheW91dF9jbHVzdGVyUmlnaHQoY2hpbGRyZW5bbiAtIDFdKSA6IG5vZGU7XG4gIH1cbiAgZDMubGF5b3V0LnRyZWVtYXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLCByb3VuZCA9IE1hdGgucm91bmQsIHNpemUgPSBbIDEsIDEgXSwgcGFkZGluZyA9IG51bGwsIHBhZCA9IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbCwgc3RpY2t5ID0gZmFsc2UsIHN0aWNraWVzLCBtb2RlID0gXCJzcXVhcmlmeVwiLCByYXRpbyA9IC41ICogKDEgKyBNYXRoLnNxcnQoNSkpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKGNoaWxkcmVuLCBrKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZCwgYXJlYTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGFyZWEgPSAoY2hpbGQgPSBjaGlsZHJlbltpXSkudmFsdWUgKiAoayA8IDAgPyAwIDogayk7XG4gICAgICAgIGNoaWxkLmFyZWEgPSBpc05hTihhcmVhKSB8fCBhcmVhIDw9IDAgPyAwIDogYXJlYTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3F1YXJpZnkobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBwYWQobm9kZSksIHJvdyA9IFtdLCByZW1haW5pbmcgPSBjaGlsZHJlbi5zbGljZSgpLCBjaGlsZCwgYmVzdCA9IEluZmluaXR5LCBzY29yZSwgdSA9IG1vZGUgPT09IFwic2xpY2VcIiA/IHJlY3QuZHggOiBtb2RlID09PSBcImRpY2VcIiA/IHJlY3QuZHkgOiBtb2RlID09PSBcInNsaWNlLWRpY2VcIiA/IG5vZGUuZGVwdGggJiAxID8gcmVjdC5keSA6IHJlY3QuZHggOiBNYXRoLm1pbihyZWN0LmR4LCByZWN0LmR5KSwgbjtcbiAgICAgICAgc2NhbGUocmVtYWluaW5nLCByZWN0LmR4ICogcmVjdC5keSAvIG5vZGUudmFsdWUpO1xuICAgICAgICByb3cuYXJlYSA9IDA7XG4gICAgICAgIHdoaWxlICgobiA9IHJlbWFpbmluZy5sZW5ndGgpID4gMCkge1xuICAgICAgICAgIHJvdy5wdXNoKGNoaWxkID0gcmVtYWluaW5nW24gLSAxXSk7XG4gICAgICAgICAgcm93LmFyZWEgKz0gY2hpbGQuYXJlYTtcbiAgICAgICAgICBpZiAobW9kZSAhPT0gXCJzcXVhcmlmeVwiIHx8IChzY29yZSA9IHdvcnN0KHJvdywgdSkpIDw9IGJlc3QpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZy5wb3AoKTtcbiAgICAgICAgICAgIGJlc3QgPSBzY29yZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcm93LmFyZWEgLT0gcm93LnBvcCgpLmFyZWE7XG4gICAgICAgICAgICBwb3NpdGlvbihyb3csIHUsIHJlY3QsIGZhbHNlKTtcbiAgICAgICAgICAgIHUgPSBNYXRoLm1pbihyZWN0LmR4LCByZWN0LmR5KTtcbiAgICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgICAgICBiZXN0ID0gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cubGVuZ3RoKSB7XG4gICAgICAgICAgcG9zaXRpb24ocm93LCB1LCByZWN0LCB0cnVlKTtcbiAgICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goc3F1YXJpZnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzdGlja2lmeShub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgcmVjdCA9IHBhZChub2RlKSwgcmVtYWluaW5nID0gY2hpbGRyZW4uc2xpY2UoKSwgY2hpbGQsIHJvdyA9IFtdO1xuICAgICAgICBzY2FsZShyZW1haW5pbmcsIHJlY3QuZHggKiByZWN0LmR5IC8gbm9kZS52YWx1ZSk7XG4gICAgICAgIHJvdy5hcmVhID0gMDtcbiAgICAgICAgd2hpbGUgKGNoaWxkID0gcmVtYWluaW5nLnBvcCgpKSB7XG4gICAgICAgICAgcm93LnB1c2goY2hpbGQpO1xuICAgICAgICAgIHJvdy5hcmVhICs9IGNoaWxkLmFyZWE7XG4gICAgICAgICAgaWYgKGNoaWxkLnogIT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zaXRpb24ocm93LCBjaGlsZC56ID8gcmVjdC5keCA6IHJlY3QuZHksIHJlY3QsICFyZW1haW5pbmcubGVuZ3RoKTtcbiAgICAgICAgICAgIHJvdy5sZW5ndGggPSByb3cuYXJlYSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goc3RpY2tpZnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3b3JzdChyb3csIHUpIHtcbiAgICAgIHZhciBzID0gcm93LmFyZWEsIHIsIHJtYXggPSAwLCBybWluID0gSW5maW5pdHksIGkgPSAtMSwgbiA9IHJvdy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAoIShyID0gcm93W2ldLmFyZWEpKSBjb250aW51ZTtcbiAgICAgICAgaWYgKHIgPCBybWluKSBybWluID0gcjtcbiAgICAgICAgaWYgKHIgPiBybWF4KSBybWF4ID0gcjtcbiAgICAgIH1cbiAgICAgIHMgKj0gcztcbiAgICAgIHUgKj0gdTtcbiAgICAgIHJldHVybiBzID8gTWF0aC5tYXgodSAqIHJtYXggKiByYXRpbyAvIHMsIHMgLyAodSAqIHJtaW4gKiByYXRpbykpIDogSW5maW5pdHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgZmx1c2gpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSByb3cubGVuZ3RoLCB4ID0gcmVjdC54LCB5ID0gcmVjdC55LCB2ID0gdSA/IHJvdW5kKHJvdy5hcmVhIC8gdSkgOiAwLCBvO1xuICAgICAgaWYgKHUgPT0gcmVjdC5keCkge1xuICAgICAgICBpZiAoZmx1c2ggfHwgdiA+IHJlY3QuZHkpIHYgPSByZWN0LmR5O1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIG8gPSByb3dbaV07XG4gICAgICAgICAgby54ID0geDtcbiAgICAgICAgICBvLnkgPSB5O1xuICAgICAgICAgIG8uZHkgPSB2O1xuICAgICAgICAgIHggKz0gby5keCA9IE1hdGgubWluKHJlY3QueCArIHJlY3QuZHggLSB4LCB2ID8gcm91bmQoby5hcmVhIC8gdikgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBvLnogPSB0cnVlO1xuICAgICAgICBvLmR4ICs9IHJlY3QueCArIHJlY3QuZHggLSB4O1xuICAgICAgICByZWN0LnkgKz0gdjtcbiAgICAgICAgcmVjdC5keSAtPSB2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZsdXNoIHx8IHYgPiByZWN0LmR4KSB2ID0gcmVjdC5keDtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBvID0gcm93W2ldO1xuICAgICAgICAgIG8ueCA9IHg7XG4gICAgICAgICAgby55ID0geTtcbiAgICAgICAgICBvLmR4ID0gdjtcbiAgICAgICAgICB5ICs9IG8uZHkgPSBNYXRoLm1pbihyZWN0LnkgKyByZWN0LmR5IC0geSwgdiA/IHJvdW5kKG8uYXJlYSAvIHYpIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgby56ID0gZmFsc2U7XG4gICAgICAgIG8uZHkgKz0gcmVjdC55ICsgcmVjdC5keSAtIHk7XG4gICAgICAgIHJlY3QueCArPSB2O1xuICAgICAgICByZWN0LmR4IC09IHY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyZWVtYXAoZCkge1xuICAgICAgdmFyIG5vZGVzID0gc3RpY2tpZXMgfHwgaGllcmFyY2h5KGQpLCByb290ID0gbm9kZXNbMF07XG4gICAgICByb290LnggPSByb290LnkgPSAwO1xuICAgICAgaWYgKHJvb3QudmFsdWUpIHJvb3QuZHggPSBzaXplWzBdLCByb290LmR5ID0gc2l6ZVsxXTsgZWxzZSByb290LmR4ID0gcm9vdC5keSA9IDA7XG4gICAgICBpZiAoc3RpY2tpZXMpIGhpZXJhcmNoeS5yZXZhbHVlKHJvb3QpO1xuICAgICAgc2NhbGUoWyByb290IF0sIHJvb3QuZHggKiByb290LmR5IC8gcm9vdC52YWx1ZSk7XG4gICAgICAoc3RpY2tpZXMgPyBzdGlja2lmeSA6IHNxdWFyaWZ5KShyb290KTtcbiAgICAgIGlmIChzdGlja3kpIHN0aWNraWVzID0gbm9kZXM7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0geDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIGZ1bmN0aW9uIHBhZEZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIHAgPSB4LmNhbGwodHJlZW1hcCwgbm9kZSwgbm9kZS5kZXB0aCk7XG4gICAgICAgIHJldHVybiBwID09IG51bGwgPyBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwobm9kZSkgOiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCB0eXBlb2YgcCA9PT0gXCJudW1iZXJcIiA/IFsgcCwgcCwgcCwgcCBdIDogcCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWRDb25zdGFudChub2RlKSB7XG4gICAgICAgIHJldHVybiBkM19sYXlvdXRfdHJlZW1hcFBhZChub2RlLCB4KTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlO1xuICAgICAgcGFkID0gKHBhZGRpbmcgPSB4KSA9PSBudWxsID8gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsIDogKHR5cGUgPSB0eXBlb2YgeCkgPT09IFwiZnVuY3Rpb25cIiA/IHBhZEZ1bmN0aW9uIDogdHlwZSA9PT0gXCJudW1iZXJcIiA/ICh4ID0gWyB4LCB4LCB4LCB4IF0sIFxuICAgICAgcGFkQ29uc3RhbnQpIDogcGFkQ29uc3RhbnQ7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByb3VuZCAhPSBOdW1iZXI7XG4gICAgICByb3VuZCA9IHggPyBNYXRoLnJvdW5kIDogTnVtYmVyO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnN0aWNreSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0aWNreTtcbiAgICAgIHN0aWNreSA9IHg7XG4gICAgICBzdGlja2llcyA9IG51bGw7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYXRpbztcbiAgICAgIHJhdGlvID0geDtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5tb2RlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbW9kZTtcbiAgICAgIG1vZGUgPSB4ICsgXCJcIjtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQodHJlZW1hcCwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsKG5vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogbm9kZS54LFxuICAgICAgeTogbm9kZS55LFxuICAgICAgZHg6IG5vZGUuZHgsXG4gICAgICBkeTogbm9kZS5keVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVtYXBQYWQobm9kZSwgcGFkZGluZykge1xuICAgIHZhciB4ID0gbm9kZS54ICsgcGFkZGluZ1szXSwgeSA9IG5vZGUueSArIHBhZGRpbmdbMF0sIGR4ID0gbm9kZS5keCAtIHBhZGRpbmdbMV0gLSBwYWRkaW5nWzNdLCBkeSA9IG5vZGUuZHkgLSBwYWRkaW5nWzBdIC0gcGFkZGluZ1syXTtcbiAgICBpZiAoZHggPCAwKSB7XG4gICAgICB4ICs9IGR4IC8gMjtcbiAgICAgIGR4ID0gMDtcbiAgICB9XG4gICAgaWYgKGR5IDwgMCkge1xuICAgICAgeSArPSBkeSAvIDI7XG4gICAgICBkeSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIGR4OiBkeCxcbiAgICAgIGR5OiBkeVxuICAgIH07XG4gIH1cbiAgZDMucmFuZG9tID0ge1xuICAgIG5vcm1hbDogZnVuY3Rpb24owrUsIM+DKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobiA8IDIpIM+DID0gMTtcbiAgICAgIGlmIChuIDwgMSkgwrUgPSAwO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCwgeSwgcjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIHggPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgICAgeSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICByID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgfSB3aGlsZSAoIXIgfHwgciA+IDEpO1xuICAgICAgICByZXR1cm4gwrUgKyDPgyAqIHggKiBNYXRoLnNxcnQoLTIgKiBNYXRoLmxvZyhyKSAvIHIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGxvZ05vcm1hbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmFuZG9tID0gZDMucmFuZG9tLm5vcm1hbC5hcHBseShkMywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZXhwKHJhbmRvbSgpKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBiYXRlczogZnVuY3Rpb24obSkge1xuICAgICAgdmFyIHJhbmRvbSA9IGQzLnJhbmRvbS5pcndpbkhhbGwobSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYW5kb20oKSAvIG07XG4gICAgICB9O1xuICAgIH0sXG4gICAgaXJ3aW5IYWxsOiBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBqID0gMDsgaiA8IG07IGorKykgcyArPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBkMy5zY2FsZSA9IHt9O1xuICBmdW5jdGlvbiBkM19zY2FsZUV4dGVudChkb21haW4pIHtcbiAgICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBzdGFydCA8IHN0b3AgPyBbIHN0YXJ0LCBzdG9wIF0gOiBbIHN0b3AsIHN0YXJ0IF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVSYW5nZShzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudCA/IHNjYWxlLnJhbmdlRXh0ZW50KCkgOiBkM19zY2FsZUV4dGVudChzY2FsZS5yYW5nZSgpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9iaWxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSkge1xuICAgIHZhciB1ID0gdW5pbnRlcnBvbGF0ZShkb21haW5bMF0sIGRvbWFpblsxXSksIGkgPSBpbnRlcnBvbGF0ZShyYW5nZVswXSwgcmFuZ2VbMV0pO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaSh1KHgpKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX25pY2UoZG9tYWluLCBuaWNlKSB7XG4gICAgdmFyIGkwID0gMCwgaTEgPSBkb21haW4ubGVuZ3RoIC0gMSwgeDAgPSBkb21haW5baTBdLCB4MSA9IGRvbWFpbltpMV0sIGR4O1xuICAgIGlmICh4MSA8IHgwKSB7XG4gICAgICBkeCA9IGkwLCBpMCA9IGkxLCBpMSA9IGR4O1xuICAgICAgZHggPSB4MCwgeDAgPSB4MSwgeDEgPSBkeDtcbiAgICB9XG4gICAgZG9tYWluW2kwXSA9IG5pY2UuZmxvb3IoeDApO1xuICAgIGRvbWFpbltpMV0gPSBuaWNlLmNlaWwoeDEpO1xuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbmljZVN0ZXAoc3RlcCkge1xuICAgIHJldHVybiBzdGVwID8ge1xuICAgICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH0sXG4gICAgICBjZWlsOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoeCAvIHN0ZXApICogc3RlcDtcbiAgICAgIH1cbiAgICB9IDogZDNfc2NhbGVfbmljZUlkZW50aXR5O1xuICB9XG4gIHZhciBkM19zY2FsZV9uaWNlSWRlbnRpdHkgPSB7XG4gICAgZmxvb3I6IGQzX2lkZW50aXR5LFxuICAgIGNlaWw6IGQzX2lkZW50aXR5XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3BvbHlsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpIHtcbiAgICB2YXIgdSA9IFtdLCBpID0gW10sIGogPSAwLCBrID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UubGVuZ3RoKSAtIDE7XG4gICAgaWYgKGRvbWFpbltrXSA8IGRvbWFpblswXSkge1xuICAgICAgZG9tYWluID0gZG9tYWluLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgd2hpbGUgKCsraiA8PSBrKSB7XG4gICAgICB1LnB1c2godW5pbnRlcnBvbGF0ZShkb21haW5baiAtIDFdLCBkb21haW5bal0pKTtcbiAgICAgIGkucHVzaChpbnRlcnBvbGF0ZShyYW5nZVtqIC0gMV0sIHJhbmdlW2pdKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgaiA9IGQzLmJpc2VjdChkb21haW4sIHgsIDEsIGspIC0gMTtcbiAgICAgIHJldHVybiBpW2pdKHVbal0oeCkpO1xuICAgIH07XG4gIH1cbiAgZDMuc2NhbGUubGluZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhcihbIDAsIDEgXSwgWyAwLCAxIF0sIGQzX2ludGVycG9sYXRlLCBmYWxzZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhcihkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSwgY2xhbXApIHtcbiAgICB2YXIgb3V0cHV0LCBpbnB1dDtcbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgdmFyIGxpbmVhciA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgPiAyID8gZDNfc2NhbGVfcG9seWxpbmVhciA6IGQzX3NjYWxlX2JpbGluZWFyLCB1bmludGVycG9sYXRlID0gY2xhbXAgPyBkM191bmludGVycG9sYXRlQ2xhbXAgOiBkM191bmludGVycG9sYXRlTnVtYmVyO1xuICAgICAgb3V0cHV0ID0gbGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKTtcbiAgICAgIGlucHV0ID0gbGluZWFyKHJhbmdlLCBkb21haW4sIHVuaW50ZXJwb2xhdGUsIGQzX2ludGVycG9sYXRlKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIG91dHB1dCh4KTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIGlucHV0KHkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoTnVtYmVyKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gc2NhbGUucmFuZ2UoeCkuaW50ZXJwb2xhdGUoZDNfaW50ZXJwb2xhdGVSb3VuZCk7XG4gICAgfTtcbiAgICBzY2FsZS5jbGFtcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNsYW1wO1xuICAgICAgY2xhbXAgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmludGVycG9sYXRlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGU7XG4gICAgICBpbnRlcnBvbGF0ZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihtLCBmb3JtYXQpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrRm9ybWF0KGRvbWFpbiwgbSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihtKSB7XG4gICAgICBkM19zY2FsZV9saW5lYXJOaWNlKGRvbWFpbiwgbSk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhcihkb21haW4sIHJhbmdlLCBpbnRlcnBvbGF0ZSwgY2xhbXApO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcikge1xuICAgIHJldHVybiBkMy5yZWJpbmQoc2NhbGUsIGxpbmVhciwgXCJyYW5nZVwiLCBcInJhbmdlUm91bmRcIiwgXCJpbnRlcnBvbGF0ZVwiLCBcImNsYW1wXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhck5pY2UoZG9tYWluLCBtKSB7XG4gICAgZDNfc2NhbGVfbmljZShkb21haW4sIGQzX3NjYWxlX25pY2VTdGVwKGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pWzJdKSk7XG4gICAgZDNfc2NhbGVfbmljZShkb21haW4sIGQzX3NjYWxlX25pY2VTdGVwKGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pWzJdKSk7XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKSB7XG4gICAgaWYgKG0gPT0gbnVsbCkgbSA9IDEwO1xuICAgIHZhciBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCBzdGVwID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3BhbiAvIG0pIC8gTWF0aC5MTjEwKSksIGVyciA9IG0gLyBzcGFuICogc3RlcDtcbiAgICBpZiAoZXJyIDw9IC4xNSkgc3RlcCAqPSAxMDsgZWxzZSBpZiAoZXJyIDw9IC4zNSkgc3RlcCAqPSA1OyBlbHNlIGlmIChlcnIgPD0gLjc1KSBzdGVwICo9IDI7XG4gICAgZXh0ZW50WzBdID0gTWF0aC5jZWlsKGV4dGVudFswXSAvIHN0ZXApICogc3RlcDtcbiAgICBleHRlbnRbMV0gPSBNYXRoLmZsb29yKGV4dGVudFsxXSAvIHN0ZXApICogc3RlcCArIHN0ZXAgKiAuNTtcbiAgICBleHRlbnRbMl0gPSBzdGVwO1xuICAgIHJldHVybiBleHRlbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja3MoZG9tYWluLCBtKSB7XG4gICAgcmV0dXJuIGQzLnJhbmdlLmFwcGx5KGQzLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCkge1xuICAgIHZhciByYW5nZSA9IGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShkb21haW4sIG0pO1xuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIHZhciBtYXRjaCA9IGQzX2Zvcm1hdF9yZS5leGVjKGZvcm1hdCk7XG4gICAgICBtYXRjaC5zaGlmdCgpO1xuICAgICAgaWYgKG1hdGNoWzhdID09PSBcInNcIikge1xuICAgICAgICB2YXIgcHJlZml4ID0gZDMuZm9ybWF0UHJlZml4KE1hdGgubWF4KGFicyhyYW5nZVswXSksIGFicyhyYW5nZVsxXSkpKTtcbiAgICAgICAgaWYgKCFtYXRjaFs3XSkgbWF0Y2hbN10gPSBcIi5cIiArIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihwcmVmaXguc2NhbGUocmFuZ2VbMl0pKTtcbiAgICAgICAgbWF0Y2hbOF0gPSBcImZcIjtcbiAgICAgICAgZm9ybWF0ID0gZDMuZm9ybWF0KG1hdGNoLmpvaW4oXCJcIikpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXQocHJlZml4LnNjYWxlKGQpKSArIHByZWZpeC5zeW1ib2w7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoIW1hdGNoWzddKSBtYXRjaFs3XSA9IFwiLlwiICsgZDNfc2NhbGVfbGluZWFyRm9ybWF0UHJlY2lzaW9uKG1hdGNoWzhdLCByYW5nZSk7XG4gICAgICBmb3JtYXQgPSBtYXRjaC5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtYXQgPSBcIiwuXCIgKyBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocmFuZ2VbMl0pICsgXCJmXCI7XG4gICAgfVxuICAgIHJldHVybiBkMy5mb3JtYXQoZm9ybWF0KTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbGluZWFyRm9ybWF0U2lnbmlmaWNhbnQgPSB7XG4gICAgczogMSxcbiAgICBnOiAxLFxuICAgIHA6IDEsXG4gICAgcjogMSxcbiAgICBlOiAxXG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbih2YWx1ZSkge1xuICAgIHJldHVybiAtTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMTAgKyAuMDEpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhckZvcm1hdFByZWNpc2lvbih0eXBlLCByYW5nZSkge1xuICAgIHZhciBwID0gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHJhbmdlWzJdKTtcbiAgICByZXR1cm4gdHlwZSBpbiBkM19zY2FsZV9saW5lYXJGb3JtYXRTaWduaWZpY2FudCA/IE1hdGguYWJzKHAgLSBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24oTWF0aC5tYXgoYWJzKHJhbmdlWzBdKSwgYWJzKHJhbmdlWzFdKSkpKSArICsodHlwZSAhPT0gXCJlXCIpIDogcCAtICh0eXBlID09PSBcIiVcIikgKiAyO1xuICB9XG4gIGQzLnNjYWxlLmxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9sb2coZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFsgMCwgMSBdKSwgMTAsIHRydWUsIFsgMSwgMTAgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xvZyhsaW5lYXIsIGJhc2UsIHBvc2l0aXZlLCBkb21haW4pIHtcbiAgICBmdW5jdGlvbiBsb2coeCkge1xuICAgICAgcmV0dXJuIChwb3NpdGl2ZSA/IE1hdGgubG9nKHggPCAwID8gMCA6IHgpIDogLU1hdGgubG9nKHggPiAwID8gMCA6IC14KSkgLyBNYXRoLmxvZyhiYXNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG93KHgpIHtcbiAgICAgIHJldHVybiBwb3NpdGl2ZSA/IE1hdGgucG93KGJhc2UsIHgpIDogLU1hdGgucG93KGJhc2UsIC14KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIGxpbmVhcihsb2coeCkpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gcG93KGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgcG9zaXRpdmUgPSB4WzBdID49IDA7XG4gICAgICBsaW5lYXIuZG9tYWluKChkb21haW4gPSB4Lm1hcChOdW1iZXIpKS5tYXAobG9nKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5iYXNlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmFzZTtcbiAgICAgIGJhc2UgPSArXztcbiAgICAgIGxpbmVhci5kb21haW4oZG9tYWluLm1hcChsb2cpKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuaWNlZCA9IGQzX3NjYWxlX25pY2UoZG9tYWluLm1hcChsb2cpLCBwb3NpdGl2ZSA/IE1hdGggOiBkM19zY2FsZV9sb2dOaWNlTmVnYXRpdmUpO1xuICAgICAgbGluZWFyLmRvbWFpbihuaWNlZCk7XG4gICAgICBkb21haW4gPSBuaWNlZC5tYXAocG93KTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgdGlja3MgPSBbXSwgdSA9IGV4dGVudFswXSwgdiA9IGV4dGVudFsxXSwgaSA9IE1hdGguZmxvb3IobG9nKHUpKSwgaiA9IE1hdGguY2VpbChsb2codikpLCBuID0gYmFzZSAlIDEgPyAyIDogYmFzZTtcbiAgICAgIGlmIChpc0Zpbml0ZShqIC0gaSkpIHtcbiAgICAgICAgaWYgKHBvc2l0aXZlKSB7XG4gICAgICAgICAgZm9yICg7aSA8IGo7IGkrKykgZm9yICh2YXIgayA9IDE7IGsgPCBuOyBrKyspIHRpY2tzLnB1c2gocG93KGkpICogayk7XG4gICAgICAgICAgdGlja3MucHVzaChwb3coaSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tzLnB1c2gocG93KGkpKTtcbiAgICAgICAgICBmb3IgKDtpKysgPCBqOyApIGZvciAodmFyIGsgPSBuIC0gMTsgayA+IDA7IGstLSkgdGlja3MucHVzaChwb3coaSkgKiBrKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyB0aWNrc1tpXSA8IHU7IGkrKykge31cbiAgICAgICAgZm9yIChqID0gdGlja3MubGVuZ3RoOyB0aWNrc1tqIC0gMV0gPiB2OyBqLS0pIHt9XG4gICAgICAgIHRpY2tzID0gdGlja3Muc2xpY2UoaSwgaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGlja3M7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obiwgZm9ybWF0KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkM19zY2FsZV9sb2dGb3JtYXQ7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIGZvcm1hdCA9IGQzX3NjYWxlX2xvZ0Zvcm1hdDsgZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPT0gXCJmdW5jdGlvblwiKSBmb3JtYXQgPSBkMy5mb3JtYXQoZm9ybWF0KTtcbiAgICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIG4gLyBzY2FsZS50aWNrcygpLmxlbmd0aCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgaSA9IGQgLyBwb3coTWF0aC5yb3VuZChsb2coZCkpKTtcbiAgICAgICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIC41KSBpICo9IGJhc2U7XG4gICAgICAgIHJldHVybiBpIDw9IGsgPyBmb3JtYXQoZCkgOiBcIlwiO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9sb2cobGluZWFyLmNvcHkoKSwgYmFzZSwgcG9zaXRpdmUsIGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIHZhciBkM19zY2FsZV9sb2dGb3JtYXQgPSBkMy5mb3JtYXQoXCIuMGVcIiksIGQzX3NjYWxlX2xvZ05pY2VOZWdhdGl2ZSA9IHtcbiAgICBmbG9vcjogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC1NYXRoLmNlaWwoLXgpO1xuICAgIH0sXG4gICAgY2VpbDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC1NYXRoLmZsb29yKC14KTtcbiAgICB9XG4gIH07XG4gIGQzLnNjYWxlLnBvdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9wb3coZDMuc2NhbGUubGluZWFyKCksIDEsIFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG93KGxpbmVhciwgZXhwb25lbnQsIGRvbWFpbikge1xuICAgIHZhciBwb3dwID0gZDNfc2NhbGVfcG93UG93KGV4cG9uZW50KSwgcG93YiA9IGQzX3NjYWxlX3Bvd1BvdygxIC8gZXhwb25lbnQpO1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIocG93cCh4KSk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBwb3diKGxpbmVhci5pbnZlcnQoeCkpO1xuICAgIH07XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgbGluZWFyLmRvbWFpbigoZG9tYWluID0geC5tYXAoTnVtYmVyKSkubWFwKHBvd3ApKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCk7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkM19zY2FsZV9saW5lYXJOaWNlKGRvbWFpbiwgbSkpO1xuICAgIH07XG4gICAgc2NhbGUuZXhwb25lbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBleHBvbmVudDtcbiAgICAgIHBvd3AgPSBkM19zY2FsZV9wb3dQb3coZXhwb25lbnQgPSB4KTtcbiAgICAgIHBvd2IgPSBkM19zY2FsZV9wb3dQb3coMSAvIGV4cG9uZW50KTtcbiAgICAgIGxpbmVhci5kb21haW4oZG9tYWluLm1hcChwb3dwKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcG93KGxpbmVhci5jb3B5KCksIGV4cG9uZW50LCBkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9wb3dQb3coZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGUpIDogTWF0aC5wb3coeCwgZSk7XG4gICAgfTtcbiAgfVxuICBkMy5zY2FsZS5zcXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLnBvdygpLmV4cG9uZW50KC41KTtcbiAgfTtcbiAgZDMuc2NhbGUub3JkaW5hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9vcmRpbmFsKFtdLCB7XG4gICAgICB0OiBcInJhbmdlXCIsXG4gICAgICBhOiBbIFtdIF1cbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfb3JkaW5hbChkb21haW4sIHJhbmdlcikge1xuICAgIHZhciBpbmRleCwgcmFuZ2UsIHJhbmdlQmFuZDtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gcmFuZ2VbKChpbmRleC5nZXQoeCkgfHwgKHJhbmdlci50ID09PSBcInJhbmdlXCIgPyBpbmRleC5zZXQoeCwgZG9tYWluLnB1c2goeCkpIDogTmFOKSkgLSAxKSAlIHJhbmdlLmxlbmd0aF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXBzKHN0YXJ0LCBzdGVwKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoZG9tYWluLmxlbmd0aCkubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgc3RlcCAqIGk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0gW107XG4gICAgICBpbmRleCA9IG5ldyBkM19NYXAoKTtcbiAgICAgIHZhciBpID0gLTEsIG4gPSB4Lmxlbmd0aCwgeGk7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoeGkgPSB4W2ldKSkgaW5kZXguc2V0KHhpLCBkb21haW4ucHVzaCh4aSkpO1xuICAgICAgcmV0dXJuIHNjYWxlW3Jhbmdlci50XS5hcHBseShzY2FsZSwgcmFuZ2VyLmEpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VQb2ludHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgdmFyIHN0YXJ0ID0geFswXSwgc3RvcCA9IHhbMV0sIHN0ZXAgPSBkb21haW4ubGVuZ3RoIDwgMiA/IChzdGFydCA9IChzdGFydCArIHN0b3ApIC8gMiwgXG4gICAgICAwKSA6IChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZyk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgc3RlcCAqIHBhZGRpbmcgLyAyLCBzdGVwKTtcbiAgICAgIHJhbmdlQmFuZCA9IDA7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VQb2ludHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZFBvaW50cyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICB2YXIgc3RhcnQgPSB4WzBdLCBzdG9wID0geFsxXSwgc3RlcCA9IGRvbWFpbi5sZW5ndGggPCAyID8gKHN0YXJ0ID0gc3RvcCA9IE1hdGgucm91bmQoKHN0YXJ0ICsgc3RvcCkgLyAyKSwgXG4gICAgICAwKSA6IChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSAxICsgcGFkZGluZykgfCAwO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIE1hdGgucm91bmQoc3RlcCAqIHBhZGRpbmcgLyAyICsgKHN0b3AgLSBzdGFydCAtIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpICogc3RlcCkgLyAyKSwgc3RlcCk7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUm91bmRQb2ludHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VCYW5kcyA9IGZ1bmN0aW9uKHgsIHBhZGRpbmcsIG91dGVyUGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgb3V0ZXJQYWRkaW5nID0gcGFkZGluZztcbiAgICAgIHZhciByZXZlcnNlID0geFsxXSA8IHhbMF0sIHN0YXJ0ID0geFtyZXZlcnNlIC0gMF0sIHN0b3AgPSB4WzEgLSByZXZlcnNlXSwgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nICsgMiAqIG91dGVyUGFkZGluZyk7XG4gICAgICByYW5nZSA9IHN0ZXBzKHN0YXJ0ICsgc3RlcCAqIG91dGVyUGFkZGluZywgc3RlcCk7XG4gICAgICBpZiAocmV2ZXJzZSkgcmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2VCYW5kID0gc3RlcCAqICgxIC0gcGFkZGluZyk7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VCYW5kc1wiLFxuICAgICAgICBhOiBhcmd1bWVudHNcbiAgICAgIH07XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kQmFuZHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nLCBvdXRlclBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIG91dGVyUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHhbMV0gPCB4WzBdLCBzdGFydCA9IHhbcmV2ZXJzZSAtIDBdLCBzdG9wID0geFsxIC0gcmV2ZXJzZV0sIHN0ZXAgPSBNYXRoLmZsb29yKChzdG9wIC0gc3RhcnQpIC8gKGRvbWFpbi5sZW5ndGggLSBwYWRkaW5nICsgMiAqIG91dGVyUGFkZGluZykpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIE1hdGgucm91bmQoKHN0b3AgLSBzdGFydCAtIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZykgKiBzdGVwKSAvIDIpLCBzdGVwKTtcbiAgICAgIGlmIChyZXZlcnNlKSByYW5nZS5yZXZlcnNlKCk7XG4gICAgICByYW5nZUJhbmQgPSBNYXRoLnJvdW5kKHN0ZXAgKiAoMSAtIHBhZGRpbmcpKTtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVJvdW5kQmFuZHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VCYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZ2VCYW5kO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZUV4dGVudChyYW5nZXIuYVswXSk7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfb3JkaW5hbChkb21haW4sIHJhbmdlcik7XG4gICAgfTtcbiAgICByZXR1cm4gc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gIH1cbiAgZDMuc2NhbGUuY2F0ZWdvcnkxMCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkxMCk7XG4gIH07XG4gIGQzLnNjYWxlLmNhdGVnb3J5MjAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjApO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwYiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMGIpO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkucmFuZ2UoZDNfY2F0ZWdvcnkyMGMpO1xuICB9O1xuICB2YXIgZDNfY2F0ZWdvcnkxMCA9IFsgMjA2MjI2MCwgMTY3NDQyMDYsIDI5MjQ1ODgsIDE0MDM0NzI4LCA5NzI1ODg1LCA5MTk3MTMxLCAxNDkwNzMzMCwgODM1NTcxMSwgMTIzNjkxODYsIDE1NTYxNzUgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjAgPSBbIDIwNjIyNjAsIDExNDU0NDQwLCAxNjc0NDIwNiwgMTY3NTk2NzIsIDI5MjQ1ODgsIDEwMDE4Njk4LCAxNDAzNDcyOCwgMTY3NTA3NDIsIDk3MjU4ODUsIDEyOTU1ODYxLCA5MTk3MTMxLCAxMjg4NTE0MCwgMTQ5MDczMzAsIDE2MjM0MTk0LCA4MzU1NzExLCAxMzA5MjgwNywgMTIzNjkxODYsIDE0NDA4NTg5LCAxNTU2MTc1LCAxMDQxMDcyNSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICB2YXIgZDNfY2F0ZWdvcnkyMGIgPSBbIDM3NTA3NzcsIDUzOTU2MTksIDcwNDA3MTksIDEwMjY0Mjg2LCA2NTE5MDk3LCA5MjE2NTk0LCAxMTkxNTExNSwgMTM1NTY2MzYsIDkyMDI5OTMsIDEyNDI2ODA5LCAxNTE4NjUxNCwgMTUxOTA5MzIsIDg2NjYxNjksIDExMzU2NDkwLCAxNDA0OTY0MywgMTUxNzczNzIsIDgwNzc2ODMsIDEwODM0MzI0LCAxMzUyODUwOSwgMTQ1ODk2NTQgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjBjID0gWyAzMjQ0NzMzLCA3MDU3MTEwLCAxMDQwNjYyNSwgMTMwMzI0MzEsIDE1MDk1MDUzLCAxNjYxNjc2NCwgMTY2MjUyNTksIDE2NjM0MDE4LCAzMjUzMDc2LCA3NjUyNDcwLCAxMDYwNzAwMywgMTMxMDE1MDQsIDc2OTUyODEsIDEwMzk0MzEyLCAxMjM2OTM3MiwgMTQzNDI4OTEsIDY1MTM1MDcsIDk4Njg5NTAsIDEyNDM0ODc3LCAxNDI3NzA4MSBdLm1hcChkM19yZ2JTdHJpbmcpO1xuICBkMy5zY2FsZS5xdWFudGlsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9xdWFudGlsZShbXSwgW10pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9xdWFudGlsZShkb21haW4sIHJhbmdlKSB7XG4gICAgdmFyIHRocmVzaG9sZHM7XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBrID0gMCwgcSA9IHJhbmdlLmxlbmd0aDtcbiAgICAgIHRocmVzaG9sZHMgPSBbXTtcbiAgICAgIHdoaWxlICgrK2sgPCBxKSB0aHJlc2hvbGRzW2sgLSAxXSA9IGQzLnF1YW50aWxlKGRvbWFpbiwgayAvIHEpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoIWlzTmFOKHggPSAreCkpIHJldHVybiByYW5nZVtkMy5iaXNlY3QodGhyZXNob2xkcywgeCldO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChkM19udW1iZXIpLmZpbHRlcihkM19udW1lcmljKS5zb3J0KGQzX2FzY2VuZGluZyk7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5xdWFudGlsZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aHJlc2hvbGRzO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICByZXR1cm4geSA8IDAgPyBbIE5hTiwgTmFOIF0gOiBbIHkgPiAwID8gdGhyZXNob2xkc1t5IC0gMV0gOiBkb21haW5bMF0sIHkgPCB0aHJlc2hvbGRzLmxlbmd0aCA/IHRocmVzaG9sZHNbeV0gOiBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdIF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpbGUoZG9tYWluLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGQzLnNjYWxlLnF1YW50aXplID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aXplKDAsIDEsIFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcXVhbnRpemUoeDAsIHgxLCByYW5nZSkge1xuICAgIHZhciBreCwgaTtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gcmFuZ2VbTWF0aC5tYXgoMCwgTWF0aC5taW4oaSwgTWF0aC5mbG9vcihreCAqICh4IC0geDApKSkpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIGt4ID0gcmFuZ2UubGVuZ3RoIC8gKHgxIC0geDApO1xuICAgICAgaSA9IHJhbmdlLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgeDAsIHgxIF07XG4gICAgICB4MCA9ICt4WzBdO1xuICAgICAgeDEgPSAreFt4Lmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUuaW52ZXJ0RXh0ZW50ID0gZnVuY3Rpb24oeSkge1xuICAgICAgeSA9IHJhbmdlLmluZGV4T2YoeSk7XG4gICAgICB5ID0geSA8IDAgPyBOYU4gOiB5IC8ga3ggKyB4MDtcbiAgICAgIHJldHVybiBbIHksIHkgKyAxIC8ga3ggXTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9xdWFudGl6ZSh4MCwgeDEsIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZDMuc2NhbGUudGhyZXNob2xkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX3RocmVzaG9sZChbIC41IF0sIFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfdGhyZXNob2xkKGRvbWFpbiwgcmFuZ2UpIHtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICBpZiAoeCA8PSB4KSByZXR1cm4gcmFuZ2VbZDMuYmlzZWN0KGRvbWFpbiwgeCldO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSBfO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0gXztcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIFsgZG9tYWluW3kgLSAxXSwgZG9tYWluW3ldIF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfdGhyZXNob2xkKGRvbWFpbiwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG4gIGQzLnNjYWxlLmlkZW50aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3NjYWxlX2lkZW50aXR5KFsgMCwgMSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfaWRlbnRpdHkoZG9tYWluKSB7XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgICAgcmV0dXJuICt4O1xuICAgIH1cbiAgICBpZGVudGl0eS5pbnZlcnQgPSBpZGVudGl0eTtcbiAgICBpZGVudGl0eS5kb21haW4gPSBpZGVudGl0eS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKGlkZW50aXR5KTtcbiAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9O1xuICAgIGlkZW50aXR5LnRpY2tzID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSk7XG4gICAgfTtcbiAgICBpZGVudGl0eS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCk7XG4gICAgfTtcbiAgICBpZGVudGl0eS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfaWRlbnRpdHkoZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBkMy5zdmcgPSB7fTtcbiAgZnVuY3Rpb24gZDNfemVybygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBkMy5zdmcuYXJjID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlubmVyUmFkaXVzID0gZDNfc3ZnX2FyY0lubmVyUmFkaXVzLCBvdXRlclJhZGl1cyA9IGQzX3N2Z19hcmNPdXRlclJhZGl1cywgY29ybmVyUmFkaXVzID0gZDNfemVybywgcGFkUmFkaXVzID0gZDNfc3ZnX2FyY0F1dG8sIHN0YXJ0QW5nbGUgPSBkM19zdmdfYXJjU3RhcnRBbmdsZSwgZW5kQW5nbGUgPSBkM19zdmdfYXJjRW5kQW5nbGUsIHBhZEFuZ2xlID0gZDNfc3ZnX2FyY1BhZEFuZ2xlO1xuICAgIGZ1bmN0aW9uIGFyYygpIHtcbiAgICAgIHZhciByMCA9IE1hdGgubWF4KDAsICtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSwgcjEgPSBNYXRoLm1heCgwLCArb3V0ZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZs+ALCBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmz4AsIGRhID0gTWF0aC5hYnMoYTEgLSBhMCksIGN3ID0gYTAgPiBhMSA/IDAgOiAxO1xuICAgICAgaWYgKHIxIDwgcjApIHJjID0gcjEsIHIxID0gcjAsIHIwID0gcmM7XG4gICAgICBpZiAoZGEgPj0gz4TOtSkgcmV0dXJuIGNpcmNsZVNlZ21lbnQocjEsIGN3KSArIChyMCA/IGNpcmNsZVNlZ21lbnQocjAsIDEgLSBjdykgOiBcIlwiKSArIFwiWlwiO1xuICAgICAgdmFyIHJjLCBjciwgcnAsIGFwLCBwMCA9IDAsIHAxID0gMCwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBwYXRoID0gW107XG4gICAgICBpZiAoYXAgPSAoK3BhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMCkgLyAyKSB7XG4gICAgICAgIHJwID0gcGFkUmFkaXVzID09PSBkM19zdmdfYXJjQXV0byA/IE1hdGguc3FydChyMCAqIHIwICsgcjEgKiByMSkgOiArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghY3cpIHAxICo9IC0xO1xuICAgICAgICBpZiAocjEpIHAxID0gZDNfYXNpbihycCAvIHIxICogTWF0aC5zaW4oYXApKTtcbiAgICAgICAgaWYgKHIwKSBwMCA9IGQzX2FzaW4ocnAgLyByMCAqIE1hdGguc2luKGFwKSk7XG4gICAgICB9XG4gICAgICBpZiAocjEpIHtcbiAgICAgICAgeDAgPSByMSAqIE1hdGguY29zKGEwICsgcDEpO1xuICAgICAgICB5MCA9IHIxICogTWF0aC5zaW4oYTAgKyBwMSk7XG4gICAgICAgIHgxID0gcjEgKiBNYXRoLmNvcyhhMSAtIHAxKTtcbiAgICAgICAgeTEgPSByMSAqIE1hdGguc2luKGExIC0gcDEpO1xuICAgICAgICB2YXIgbDEgPSBNYXRoLmFicyhhMSAtIGEwIC0gMiAqIHAxKSA8PSDPgCA/IDAgOiAxO1xuICAgICAgICBpZiAocDEgJiYgZDNfc3ZnX2FyY1N3ZWVwKHgwLCB5MCwgeDEsIHkxKSA9PT0gY3cgXiBsMSkge1xuICAgICAgICAgIHZhciBoMSA9IChhMCArIGExKSAvIDI7XG4gICAgICAgICAgeDAgPSByMSAqIE1hdGguY29zKGgxKTtcbiAgICAgICAgICB5MCA9IHIxICogTWF0aC5zaW4oaDEpO1xuICAgICAgICAgIHgxID0geTEgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MCA9IHkwID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChyMCkge1xuICAgICAgICB4MiA9IHIwICogTWF0aC5jb3MoYTEgLSBwMCk7XG4gICAgICAgIHkyID0gcjAgKiBNYXRoLnNpbihhMSAtIHAwKTtcbiAgICAgICAgeDMgPSByMCAqIE1hdGguY29zKGEwICsgcDApO1xuICAgICAgICB5MyA9IHIwICogTWF0aC5zaW4oYTAgKyBwMCk7XG4gICAgICAgIHZhciBsMCA9IE1hdGguYWJzKGEwIC0gYTEgKyAyICogcDApIDw9IM+AID8gMCA6IDE7XG4gICAgICAgIGlmIChwMCAmJiBkM19zdmdfYXJjU3dlZXAoeDIsIHkyLCB4MywgeTMpID09PSAxIC0gY3cgXiBsMCkge1xuICAgICAgICAgIHZhciBoMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgICAgeDIgPSByMCAqIE1hdGguY29zKGgwKTtcbiAgICAgICAgICB5MiA9IHIwICogTWF0aC5zaW4oaDApO1xuICAgICAgICAgIHgzID0geTMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHkyID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChkYSA+IM61ICYmIChyYyA9IE1hdGgubWluKE1hdGguYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSkgPiAuMDAxKSB7XG4gICAgICAgIGNyID0gcjAgPCByMSBeIGN3ID8gMCA6IDE7XG4gICAgICAgIHZhciByYzEgPSByYywgcmMwID0gcmM7XG4gICAgICAgIGlmIChkYSA8IM+AKSB7XG4gICAgICAgICAgdmFyIG9jID0geDMgPT0gbnVsbCA/IFsgeDIsIHkyIF0gOiB4MSA9PSBudWxsID8gWyB4MCwgeTAgXSA6IGQzX2dlb21fcG9seWdvbkludGVyc2VjdChbIHgwLCB5MCBdLCBbIHgzLCB5MyBdLCBbIHgxLCB5MSBdLCBbIHgyLCB5MiBdKSwgYXggPSB4MCAtIG9jWzBdLCBheSA9IHkwIC0gb2NbMV0sIGJ4ID0geDEgLSBvY1swXSwgYnkgPSB5MSAtIG9jWzFdLCBrYyA9IDEgLyBNYXRoLnNpbihNYXRoLmFjb3MoKGF4ICogYnggKyBheSAqIGJ5KSAvIChNYXRoLnNxcnQoYXggKiBheCArIGF5ICogYXkpICogTWF0aC5zcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksIGxjID0gTWF0aC5zcXJ0KG9jWzBdICogb2NbMF0gKyBvY1sxXSAqIG9jWzFdKTtcbiAgICAgICAgICByYzAgPSBNYXRoLm1pbihyYywgKHIwIC0gbGMpIC8gKGtjIC0gMSkpO1xuICAgICAgICAgIHJjMSA9IE1hdGgubWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgxICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgdDMwID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKHgzID09IG51bGwgPyBbIHgyLCB5MiBdIDogWyB4MywgeTMgXSwgWyB4MCwgeTAgXSwgcjEsIHJjMSwgY3cpLCB0MTIgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICAgIGlmIChyYyA9PT0gcmMxKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHQzMFswXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQzMFsxXSwgXCJBXCIsIHIxLCBcIixcIiwgcjEsIFwiIDAgXCIsIDEgLSBjdyBeIGQzX3N2Z19hcmNTd2VlcCh0MzBbMV1bMF0sIHQzMFsxXVsxXSwgdDEyWzFdWzBdLCB0MTJbMV1bMV0pLCBcIixcIiwgY3csIFwiIFwiLCB0MTJbMV0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MTJbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHQzMFswXSwgXCJBXCIsIHJjMSwgXCIsXCIsIHJjMSwgXCIgMCAxLFwiLCBjciwgXCIgXCIsIHQxMlswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChcIk1cIiwgeDAsIFwiLFwiLCB5MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHgzICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgdDAzID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDAsIHkwIF0sIFsgeDMsIHkzIF0sIHIwLCAtcmMwLCBjdyksIHQyMSA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgyLCB5MiBdLCB4MSA9PSBudWxsID8gWyB4MCwgeTAgXSA6IFsgeDEsIHkxIF0sIHIwLCAtcmMwLCBjdyk7XG4gICAgICAgICAgaWYgKHJjID09PSByYzApIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgdDIxWzBdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDIxWzFdLCBcIkFcIiwgcjAsIFwiLFwiLCByMCwgXCIgMCBcIiwgY3cgXiBkM19zdmdfYXJjU3dlZXAodDIxWzFdWzBdLCB0MjFbMV1bMV0sIHQwM1sxXVswXSwgdDAzWzFdWzFdKSwgXCIsXCIsIDEgLSBjdywgXCIgXCIsIHQwM1sxXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQwM1swXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgdDIxWzBdLCBcIkFcIiwgcmMwLCBcIixcIiwgcmMwLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDAzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB4MiwgXCIsXCIsIHkyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB4MCwgXCIsXCIsIHkwKTtcbiAgICAgICAgaWYgKHgxICE9IG51bGwpIHBhdGgucHVzaChcIkFcIiwgcjEsIFwiLFwiLCByMSwgXCIgMCBcIiwgbDEsIFwiLFwiLCBjdywgXCIgXCIsIHgxLCBcIixcIiwgeTEpO1xuICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHgyLCBcIixcIiwgeTIpO1xuICAgICAgICBpZiAoeDMgIT0gbnVsbCkgcGF0aC5wdXNoKFwiQVwiLCByMCwgXCIsXCIsIHIwLCBcIiAwIFwiLCBsMCwgXCIsXCIsIDEgLSBjdywgXCIgXCIsIHgzLCBcIixcIiwgeTMpO1xuICAgICAgfVxuICAgICAgcGF0aC5wdXNoKFwiWlwiKTtcbiAgICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNpcmNsZVNlZ21lbnQocjEsIGN3KSB7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIHIxICsgXCJBXCIgKyByMSArIFwiLFwiICsgcjEgKyBcIiAwIDEsXCIgKyBjdyArIFwiIDAsXCIgKyAtcjEgKyBcIkFcIiArIHIxICsgXCIsXCIgKyByMSArIFwiIDAgMSxcIiArIGN3ICsgXCIgMCxcIiArIHIxO1xuICAgIH1cbiAgICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRlclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29ybmVyUmFkaXVzO1xuICAgICAgY29ybmVyUmFkaXVzID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkUmFkaXVzO1xuICAgICAgcGFkUmFkaXVzID0gdiA9PSBkM19zdmdfYXJjQXV0byA/IGQzX3N2Z19hcmNBdXRvIDogZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHN0YXJ0QW5nbGU7XG4gICAgICBzdGFydEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuZW5kQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMucGFkQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRBbmdsZTtcbiAgICAgIHBhZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBhcmM7XG4gICAgfTtcbiAgICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByID0gKCtpbm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiwgYSA9ICgrc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICsgK2VuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIC8gMiAtIGhhbGbPgDtcbiAgICAgIHJldHVybiBbIE1hdGguY29zKGEpICogciwgTWF0aC5zaW4oYSkgKiByIF07XG4gICAgfTtcbiAgICByZXR1cm4gYXJjO1xuICB9O1xuICB2YXIgZDNfc3ZnX2FyY0F1dG8gPSBcImF1dG9cIjtcbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY0lubmVyUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5pbm5lclJhZGl1cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjT3V0ZXJSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLm91dGVyUmFkaXVzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNTdGFydEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZC5zdGFydEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNFbmRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQuZW5kQW5nbGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY1BhZEFuZ2xlKGQpIHtcbiAgICByZXR1cm4gZCAmJiBkLnBhZEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNTd2VlcCh4MCwgeTAsIHgxLCB5MSkge1xuICAgIHJldHVybiAoeDAgLSB4MSkgKiB5MCAtICh5MCAtIHkxKSAqIHgwID4gMCA/IDAgOiAxO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhwMCwgcDEsIHIxLCByYywgY3cpIHtcbiAgICB2YXIgeDAxID0gcDBbMF0gLSBwMVswXSwgeTAxID0gcDBbMV0gLSBwMVsxXSwgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBNYXRoLnNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSwgb3ggPSBsbyAqIHkwMSwgb3kgPSAtbG8gKiB4MDEsIHgxID0gcDBbMF0gKyBveCwgeTEgPSBwMFsxXSArIG95LCB4MiA9IHAxWzBdICsgb3gsIHkyID0gcDFbMV0gKyBveSwgeDMgPSAoeDEgKyB4MikgLyAyLCB5MyA9ICh5MSArIHkyKSAvIDIsIGR4ID0geDIgLSB4MSwgZHkgPSB5MiAtIHkxLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5LCByID0gcjEgLSByYywgRCA9IHgxICogeTIgLSB4MiAqIHkxLCBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgciAqIHIgKiBkMiAtIEQgKiBEKSksIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsIGN5MCA9ICgtRCAqIGR4IC0gZHkgKiBkKSAvIGQyLCBjeDEgPSAoRCAqIGR5ICsgZHggKiBkKSAvIGQyLCBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMiwgZHgwID0gY3gwIC0geDMsIGR5MCA9IGN5MCAtIHkzLCBkeDEgPSBjeDEgLSB4MywgZHkxID0gY3kxIC0geTM7XG4gICAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG4gICAgcmV0dXJuIFsgWyBjeDAgLSBveCwgY3kwIC0gb3kgXSwgWyBjeDAgKiByMSAvIHIsIGN5MCAqIHIxIC8gciBdIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmUocHJvamVjdGlvbikge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgZGVmaW5lZCA9IGQzX3RydWUsIGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVMaW5lYXIsIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUua2V5LCB0ZW5zaW9uID0gLjc7XG4gICAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBbXSwgcG9pbnRzID0gW10sIGkgPSAtMSwgbiA9IGRhdGEubGVuZ3RoLCBkLCBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KTtcbiAgICAgIGZ1bmN0aW9uIHNlZ21lbnQoKSB7XG4gICAgICAgIHNlZ21lbnRzLnB1c2goXCJNXCIsIGludGVycG9sYXRlKHByb2plY3Rpb24ocG9pbnRzKSwgdGVuc2lvbikpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGRlZmluZWQuY2FsbCh0aGlzLCBkID0gZGF0YVtpXSwgaSkpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChbICtmeC5jYWxsKHRoaXMsIGQsIGkpLCArZnkuY2FsbCh0aGlzLCBkLCBpKSBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgc2VnbWVudCgpO1xuICAgICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCkgc2VnbWVudCgpO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA/IHNlZ21lbnRzLmpvaW4oXCJcIikgOiBudWxsO1xuICAgIH1cbiAgICBsaW5lLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGVmaW5lZDtcbiAgICAgIGRlZmluZWQgPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLmludGVycG9sYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGVLZXk7XG4gICAgICBpZiAodHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIikgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZSA9IF87IGVsc2UgaW50ZXJwb2xhdGVLZXkgPSAoaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZ2V0KF8pIHx8IGQzX3N2Z19saW5lTGluZWFyKS5rZXk7XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUudGVuc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRlbnNpb247XG4gICAgICB0ZW5zaW9uID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgcmV0dXJuIGxpbmU7XG4gIH1cbiAgZDMuc3ZnLmxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc3ZnX2xpbmUoZDNfaWRlbnRpdHkpO1xuICB9O1xuICB2YXIgZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzID0gZDMubWFwKHtcbiAgICBsaW5lYXI6IGQzX3N2Z19saW5lTGluZWFyLFxuICAgIFwibGluZWFyLWNsb3NlZFwiOiBkM19zdmdfbGluZUxpbmVhckNsb3NlZCxcbiAgICBzdGVwOiBkM19zdmdfbGluZVN0ZXAsXG4gICAgXCJzdGVwLWJlZm9yZVwiOiBkM19zdmdfbGluZVN0ZXBCZWZvcmUsXG4gICAgXCJzdGVwLWFmdGVyXCI6IGQzX3N2Z19saW5lU3RlcEFmdGVyLFxuICAgIGJhc2lzOiBkM19zdmdfbGluZUJhc2lzLFxuICAgIFwiYmFzaXMtb3BlblwiOiBkM19zdmdfbGluZUJhc2lzT3BlbixcbiAgICBcImJhc2lzLWNsb3NlZFwiOiBkM19zdmdfbGluZUJhc2lzQ2xvc2VkLFxuICAgIGJ1bmRsZTogZDNfc3ZnX2xpbmVCdW5kbGUsXG4gICAgY2FyZGluYWw6IGQzX3N2Z19saW5lQ2FyZGluYWwsXG4gICAgXCJjYXJkaW5hbC1vcGVuXCI6IGQzX3N2Z19saW5lQ2FyZGluYWxPcGVuLFxuICAgIFwiY2FyZGluYWwtY2xvc2VkXCI6IGQzX3N2Z19saW5lQ2FyZGluYWxDbG9zZWQsXG4gICAgbW9ub3RvbmU6IGQzX3N2Z19saW5lTW9ub3RvbmVcbiAgfSk7XG4gIGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICB2YWx1ZS5rZXkgPSBrZXk7XG4gICAgdmFsdWUuY2xvc2VkID0gLy1jbG9zZWQkLy50ZXN0KGtleSk7XG4gIH0pO1xuICBmdW5jdGlvbiBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA+IDEgPyBwb2ludHMuam9pbihcIkxcIikgOiBwb2ludHMgKyBcIlpcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUxpbmVhckNsb3NlZChwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLmpvaW4oXCJMXCIpICsgXCJaXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIkhcIiwgKHBbMF0gKyAocCA9IHBvaW50c1tpXSlbMF0pIC8gMiwgXCJWXCIsIHBbMV0pO1xuICAgIGlmIChuID4gMSkgcGF0aC5wdXNoKFwiSFwiLCBwWzBdKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU3RlcEJlZm9yZShwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJWXCIsIChwID0gcG9pbnRzW2ldKVsxXSwgXCJIXCIsIHBbMF0pO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTdGVwQWZ0ZXIocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiSFwiLCAocCA9IHBvaW50c1tpXSlbMF0sIFwiVlwiLCBwWzFdKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWxPcGVuKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgNCA/IGQzX3N2Z19saW5lTGluZWFyKHBvaW50cykgOiBwb2ludHNbMV0gKyBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLnNsaWNlKDEsIC0xKSwgZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWxDbG9zZWQocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCAzID8gZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQocG9pbnRzKSA6IHBvaW50c1swXSArIGQzX3N2Z19saW5lSGVybWl0ZSgocG9pbnRzLnB1c2gocG9pbnRzWzBdKSwgXG4gICAgcG9pbnRzKSwgZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKFsgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSBdLmNvbmNhdChwb2ludHMsIFsgcG9pbnRzWzFdIF0pLCB0ZW5zaW9uKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVDYXJkaW5hbChwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgZDNfc3ZnX2xpbmVDYXJkaW5hbFRhbmdlbnRzKHBvaW50cywgdGVuc2lvbikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMsIHRhbmdlbnRzKSB7XG4gICAgaWYgKHRhbmdlbnRzLmxlbmd0aCA8IDEgfHwgcG9pbnRzLmxlbmd0aCAhPSB0YW5nZW50cy5sZW5ndGggJiYgcG9pbnRzLmxlbmd0aCAhPSB0YW5nZW50cy5sZW5ndGggKyAyKSB7XG4gICAgICByZXR1cm4gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKTtcbiAgICB9XG4gICAgdmFyIHF1YWQgPSBwb2ludHMubGVuZ3RoICE9IHRhbmdlbnRzLmxlbmd0aCwgcGF0aCA9IFwiXCIsIHAwID0gcG9pbnRzWzBdLCBwID0gcG9pbnRzWzFdLCB0MCA9IHRhbmdlbnRzWzBdLCB0ID0gdDAsIHBpID0gMTtcbiAgICBpZiAocXVhZCkge1xuICAgICAgcGF0aCArPSBcIlFcIiArIChwWzBdIC0gdDBbMF0gKiAyIC8gMykgKyBcIixcIiArIChwWzFdIC0gdDBbMV0gKiAyIC8gMykgKyBcIixcIiArIHBbMF0gKyBcIixcIiArIHBbMV07XG4gICAgICBwMCA9IHBvaW50c1sxXTtcbiAgICAgIHBpID0gMjtcbiAgICB9XG4gICAgaWYgKHRhbmdlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHQgPSB0YW5nZW50c1sxXTtcbiAgICAgIHAgPSBwb2ludHNbcGldO1xuICAgICAgcGkrKztcbiAgICAgIHBhdGggKz0gXCJDXCIgKyAocDBbMF0gKyB0MFswXSkgKyBcIixcIiArIChwMFsxXSArIHQwWzFdKSArIFwiLFwiICsgKHBbMF0gLSB0WzBdKSArIFwiLFwiICsgKHBbMV0gLSB0WzFdKSArIFwiLFwiICsgcFswXSArIFwiLFwiICsgcFsxXTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgdGFuZ2VudHMubGVuZ3RoOyBpKyssIHBpKyspIHtcbiAgICAgICAgcCA9IHBvaW50c1twaV07XG4gICAgICAgIHQgPSB0YW5nZW50c1tpXTtcbiAgICAgICAgcGF0aCArPSBcIlNcIiArIChwWzBdIC0gdFswXSkgKyBcIixcIiArIChwWzFdIC0gdFsxXSkgKyBcIixcIiArIHBbMF0gKyBcIixcIiArIHBbMV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWFkKSB7XG4gICAgICB2YXIgbHAgPSBwb2ludHNbcGldO1xuICAgICAgcGF0aCArPSBcIlFcIiArIChwWzBdICsgdFswXSAqIDIgLyAzKSArIFwiLFwiICsgKHBbMV0gKyB0WzFdICogMiAvIDMpICsgXCIsXCIgKyBscFswXSArIFwiLFwiICsgbHBbMV07XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhwb2ludHMsIHRlbnNpb24pIHtcbiAgICB2YXIgdGFuZ2VudHMgPSBbXSwgYSA9ICgxIC0gdGVuc2lvbikgLyAyLCBwMCwgcDEgPSBwb2ludHNbMF0sIHAyID0gcG9pbnRzWzFdLCBpID0gMSwgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHAwID0gcDE7XG4gICAgICBwMSA9IHAyO1xuICAgICAgcDIgPSBwb2ludHNbaV07XG4gICAgICB0YW5nZW50cy5wdXNoKFsgYSAqIChwMlswXSAtIHAwWzBdKSwgYSAqIChwMlsxXSAtIHAwWzFdKSBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhbmdlbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXMocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSByZXR1cm4gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKTtcbiAgICB2YXIgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoLCBwaSA9IHBvaW50c1swXSwgeDAgPSBwaVswXSwgeTAgPSBwaVsxXSwgcHggPSBbIHgwLCB4MCwgeDAsIChwaSA9IHBvaW50c1sxXSlbMF0gXSwgcHkgPSBbIHkwLCB5MCwgeTAsIHBpWzFdIF0sIHBhdGggPSBbIHgwLCBcIixcIiwgeTAsIFwiTFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHkpIF07XG4gICAgcG9pbnRzLnB1c2gocG9pbnRzW24gLSAxXSk7XG4gICAgd2hpbGUgKCsraSA8PSBuKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnNoaWZ0KCk7XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnNoaWZ0KCk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICAgIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgcHgsIHB5KTtcbiAgICB9XG4gICAgcG9pbnRzLnBvcCgpO1xuICAgIHBhdGgucHVzaChcIkxcIiwgcGkpO1xuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc09wZW4ocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCA0KSByZXR1cm4gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKTtcbiAgICB2YXIgcGF0aCA9IFtdLCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCBwaSwgcHggPSBbIDAgXSwgcHkgPSBbIDAgXTtcbiAgICB3aGlsZSAoKytpIDwgMykge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgIH1cbiAgICBwYXRoLnB1c2goZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCkgKyBcIixcIiArIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHkpKTtcbiAgICAtLWk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHguc2hpZnQoKTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkuc2hpZnQoKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgICAgZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCBweCwgcHkpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNDbG9zZWQocG9pbnRzKSB7XG4gICAgdmFyIHBhdGgsIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIG0gPSBuICsgNCwgcGksIHB4ID0gW10sIHB5ID0gW107XG4gICAgd2hpbGUgKCsraSA8IDQpIHtcbiAgICAgIHBpID0gcG9pbnRzW2kgJSBuXTtcbiAgICAgIHB4LnB1c2gocGlbMF0pO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgfVxuICAgIHBhdGggPSBbIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweSkgXTtcbiAgICAtLWk7XG4gICAgd2hpbGUgKCsraSA8IG0pIHtcbiAgICAgIHBpID0gcG9pbnRzW2kgJSBuXTtcbiAgICAgIHB4LnNoaWZ0KCk7XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnNoaWZ0KCk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICAgIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgcHgsIHB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJ1bmRsZShwb2ludHMsIHRlbnNpb24pIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGlmIChuKSB7XG4gICAgICB2YXIgeDAgPSBwb2ludHNbMF1bMF0sIHkwID0gcG9pbnRzWzBdWzFdLCBkeCA9IHBvaW50c1tuXVswXSAtIHgwLCBkeSA9IHBvaW50c1tuXVsxXSAtIHkwLCBpID0gLTEsIHAsIHQ7XG4gICAgICB3aGlsZSAoKytpIDw9IG4pIHtcbiAgICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdCA9IGkgLyBuO1xuICAgICAgICBwWzBdID0gdGVuc2lvbiAqIHBbMF0gKyAoMSAtIHRlbnNpb24pICogKHgwICsgdCAqIGR4KTtcbiAgICAgICAgcFsxXSA9IHRlbnNpb24gKiBwWzFdICsgKDEgLSB0ZW5zaW9uKSAqICh5MCArIHQgKiBkeSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM19zdmdfbGluZUJhc2lzKHBvaW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVEb3Q0KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG4gIH1cbiAgdmFyIGQzX3N2Z19saW5lQmFzaXNCZXppZXIxID0gWyAwLCAyIC8gMywgMSAvIDMsIDAgXSwgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIgPSBbIDAsIDEgLyAzLCAyIC8gMywgMCBdLCBkM19zdmdfbGluZUJhc2lzQmV6aWVyMyA9IFsgMCwgMSAvIDYsIDIgLyAzLCAxIC8gNiBdO1xuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHgsIHkpIHtcbiAgICBwYXRoLnB1c2goXCJDXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMSwgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEsIHkpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIyLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMiwgeSksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCB5KSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVTbG9wZShwMCwgcDEpIHtcbiAgICByZXR1cm4gKHAxWzFdIC0gcDBbMV0pIC8gKHAxWzBdIC0gcDBbMF0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lRmluaXRlRGlmZmVyZW5jZXMocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBqID0gcG9pbnRzLmxlbmd0aCAtIDEsIG0gPSBbXSwgcDAgPSBwb2ludHNbMF0sIHAxID0gcG9pbnRzWzFdLCBkID0gbVswXSA9IGQzX3N2Z19saW5lU2xvcGUocDAsIHAxKTtcbiAgICB3aGlsZSAoKytpIDwgaikge1xuICAgICAgbVtpXSA9IChkICsgKGQgPSBkM19zdmdfbGluZVNsb3BlKHAwID0gcDEsIHAxID0gcG9pbnRzW2kgKyAxXSkpKSAvIDI7XG4gICAgfVxuICAgIG1baV0gPSBkO1xuICAgIHJldHVybiBtO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTW9ub3RvbmVUYW5nZW50cyhwb2ludHMpIHtcbiAgICB2YXIgdGFuZ2VudHMgPSBbXSwgZCwgYSwgYiwgcywgbSA9IGQzX3N2Z19saW5lRmluaXRlRGlmZmVyZW5jZXMocG9pbnRzKSwgaSA9IC0xLCBqID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraSA8IGopIHtcbiAgICAgIGQgPSBkM19zdmdfbGluZVNsb3BlKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICBpZiAoYWJzKGQpIDwgzrUpIHtcbiAgICAgICAgbVtpXSA9IG1baSArIDFdID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSBtW2ldIC8gZDtcbiAgICAgICAgYiA9IG1baSArIDFdIC8gZDtcbiAgICAgICAgcyA9IGEgKiBhICsgYiAqIGI7XG4gICAgICAgIGlmIChzID4gOSkge1xuICAgICAgICAgIHMgPSBkICogMyAvIE1hdGguc3FydChzKTtcbiAgICAgICAgICBtW2ldID0gcyAqIGE7XG4gICAgICAgICAgbVtpICsgMV0gPSBzICogYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8PSBqKSB7XG4gICAgICBzID0gKHBvaW50c1tNYXRoLm1pbihqLCBpICsgMSldWzBdIC0gcG9pbnRzW01hdGgubWF4KDAsIGkgLSAxKV1bMF0pIC8gKDYgKiAoMSArIG1baV0gKiBtW2ldKSk7XG4gICAgICB0YW5nZW50cy5wdXNoKFsgcyB8fCAwLCBtW2ldICogcyB8fCAwIF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFuZ2VudHM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVNb25vdG9uZShwb2ludHMpIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDMgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzBdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cywgZDNfc3ZnX2xpbmVNb25vdG9uZVRhbmdlbnRzKHBvaW50cykpO1xuICB9XG4gIGQzLnN2Zy5saW5lLnJhZGlhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsaW5lID0gZDNfc3ZnX2xpbmUoZDNfc3ZnX2xpbmVSYWRpYWwpO1xuICAgIGxpbmUucmFkaXVzID0gbGluZS54LCBkZWxldGUgbGluZS54O1xuICAgIGxpbmUuYW5nbGUgPSBsaW5lLnksIGRlbGV0ZSBsaW5lLnk7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lUmFkaWFsKHBvaW50cykge1xuICAgIHZhciBwb2ludCwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgciwgYTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICByID0gcG9pbnRbMF07XG4gICAgICBhID0gcG9pbnRbMV0gLSBoYWxmz4A7XG4gICAgICBwb2ludFswXSA9IHIgKiBNYXRoLmNvcyhhKTtcbiAgICAgIHBvaW50WzFdID0gciAqIE1hdGguc2luKGEpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmVhKHByb2plY3Rpb24pIHtcbiAgICB2YXIgeDAgPSBkM19nZW9tX3BvaW50WCwgeDEgPSBkM19nZW9tX3BvaW50WCwgeTAgPSAwLCB5MSA9IGQzX2dlb21fcG9pbnRZLCBkZWZpbmVkID0gZDNfdHJ1ZSwgaW50ZXJwb2xhdGUgPSBkM19zdmdfbGluZUxpbmVhciwgaW50ZXJwb2xhdGVLZXkgPSBpbnRlcnBvbGF0ZS5rZXksIGludGVycG9sYXRlUmV2ZXJzZSA9IGludGVycG9sYXRlLCBMID0gXCJMXCIsIHRlbnNpb24gPSAuNztcbiAgICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdLCBwb2ludHMwID0gW10sIHBvaW50czEgPSBbXSwgaSA9IC0xLCBuID0gZGF0YS5sZW5ndGgsIGQsIGZ4MCA9IGQzX2Z1bmN0b3IoeDApLCBmeTAgPSBkM19mdW5jdG9yKHkwKSwgZngxID0geDAgPT09IHgxID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeDEpLCBmeTEgPSB5MCA9PT0geTEgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9IDogZDNfZnVuY3Rvcih5MSksIHgsIHk7XG4gICAgICBmdW5jdGlvbiBzZWdtZW50KCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFwiTVwiLCBpbnRlcnBvbGF0ZShwcm9qZWN0aW9uKHBvaW50czEpLCB0ZW5zaW9uKSwgTCwgaW50ZXJwb2xhdGVSZXZlcnNlKHByb2plY3Rpb24ocG9pbnRzMC5yZXZlcnNlKCkpLCB0ZW5zaW9uKSwgXCJaXCIpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGRlZmluZWQuY2FsbCh0aGlzLCBkID0gZGF0YVtpXSwgaSkpIHtcbiAgICAgICAgICBwb2ludHMwLnB1c2goWyB4ID0gK2Z4MC5jYWxsKHRoaXMsIGQsIGkpLCB5ID0gK2Z5MC5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICAgIHBvaW50czEucHVzaChbICtmeDEuY2FsbCh0aGlzLCBkLCBpKSwgK2Z5MS5jYWxsKHRoaXMsIGQsIGkpIF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvaW50czAubGVuZ3RoKSB7XG4gICAgICAgICAgc2VnbWVudCgpO1xuICAgICAgICAgIHBvaW50czAgPSBbXTtcbiAgICAgICAgICBwb2ludHMxID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludHMwLmxlbmd0aCkgc2VnbWVudCgpO1xuICAgICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA/IHNlZ21lbnRzLmpvaW4oXCJcIikgOiBudWxsO1xuICAgIH1cbiAgICBhcmVhLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgwID0geDEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDA7XG4gICAgICB4MCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueDEgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4MTtcbiAgICAgIHgxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTE7XG4gICAgICB5MCA9IHkxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS55MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkwO1xuICAgICAgeTAgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTE7XG4gICAgICB5MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmluZWQ7XG4gICAgICBkZWZpbmVkID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlS2V5O1xuICAgICAgaWYgKHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIpIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUgPSBfOyBlbHNlIGludGVycG9sYXRlS2V5ID0gKGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmdldChfKSB8fCBkM19zdmdfbGluZUxpbmVhcikua2V5O1xuICAgICAgaW50ZXJwb2xhdGVSZXZlcnNlID0gaW50ZXJwb2xhdGUucmV2ZXJzZSB8fCBpbnRlcnBvbGF0ZTtcbiAgICAgIEwgPSBpbnRlcnBvbGF0ZS5jbG9zZWQgPyBcIk1cIiA6IFwiTFwiO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLnRlbnNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZW5zaW9uO1xuICAgICAgdGVuc2lvbiA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIHJldHVybiBhcmVhO1xuICB9XG4gIGQzX3N2Z19saW5lU3RlcEJlZm9yZS5yZXZlcnNlID0gZDNfc3ZnX2xpbmVTdGVwQWZ0ZXI7XG4gIGQzX3N2Z19saW5lU3RlcEFmdGVyLnJldmVyc2UgPSBkM19zdmdfbGluZVN0ZXBCZWZvcmU7XG4gIGQzLnN2Zy5hcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3N2Z19hcmVhKGQzX2lkZW50aXR5KTtcbiAgfTtcbiAgZDMuc3ZnLmFyZWEucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBkM19zdmdfYXJlYShkM19zdmdfbGluZVJhZGlhbCk7XG4gICAgYXJlYS5yYWRpdXMgPSBhcmVhLngsIGRlbGV0ZSBhcmVhLng7XG4gICAgYXJlYS5pbm5lclJhZGl1cyA9IGFyZWEueDAsIGRlbGV0ZSBhcmVhLngwO1xuICAgIGFyZWEub3V0ZXJSYWRpdXMgPSBhcmVhLngxLCBkZWxldGUgYXJlYS54MTtcbiAgICBhcmVhLmFuZ2xlID0gYXJlYS55LCBkZWxldGUgYXJlYS55O1xuICAgIGFyZWEuc3RhcnRBbmdsZSA9IGFyZWEueTAsIGRlbGV0ZSBhcmVhLnkwO1xuICAgIGFyZWEuZW5kQW5nbGUgPSBhcmVhLnkxLCBkZWxldGUgYXJlYS55MTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfTtcbiAgZDMuc3ZnLmNob3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgdGFyZ2V0ID0gZDNfdGFyZ2V0LCByYWRpdXMgPSBkM19zdmdfY2hvcmRSYWRpdXMsIHN0YXJ0QW5nbGUgPSBkM19zdmdfYXJjU3RhcnRBbmdsZSwgZW5kQW5nbGUgPSBkM19zdmdfYXJjRW5kQW5nbGU7XG4gICAgZnVuY3Rpb24gY2hvcmQoZCwgaSkge1xuICAgICAgdmFyIHMgPSBzdWJncm91cCh0aGlzLCBzb3VyY2UsIGQsIGkpLCB0ID0gc3ViZ3JvdXAodGhpcywgdGFyZ2V0LCBkLCBpKTtcbiAgICAgIHJldHVybiBcIk1cIiArIHMucDAgKyBhcmMocy5yLCBzLnAxLCBzLmExIC0gcy5hMCkgKyAoZXF1YWxzKHMsIHQpID8gY3VydmUocy5yLCBzLnAxLCBzLnIsIHMucDApIDogY3VydmUocy5yLCBzLnAxLCB0LnIsIHQucDApICsgYXJjKHQuciwgdC5wMSwgdC5hMSAtIHQuYTApICsgY3VydmUodC5yLCB0LnAxLCBzLnIsIHMucDApKSArIFwiWlwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdWJncm91cChzZWxmLCBmLCBkLCBpKSB7XG4gICAgICB2YXIgc3ViZ3JvdXAgPSBmLmNhbGwoc2VsZiwgZCwgaSksIHIgPSByYWRpdXMuY2FsbChzZWxmLCBzdWJncm91cCwgaSksIGEwID0gc3RhcnRBbmdsZS5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSAtIGhhbGbPgCwgYTEgPSBlbmRBbmdsZS5jYWxsKHNlbGYsIHN1Ymdyb3VwLCBpKSAtIGhhbGbPgDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHI6IHIsXG4gICAgICAgIGEwOiBhMCxcbiAgICAgICAgYTE6IGExLFxuICAgICAgICBwMDogWyByICogTWF0aC5jb3MoYTApLCByICogTWF0aC5zaW4oYTApIF0sXG4gICAgICAgIHAxOiBbIHIgKiBNYXRoLmNvcyhhMSksIHIgKiBNYXRoLnNpbihhMSkgXVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmEwID09IGIuYTAgJiYgYS5hMSA9PSBiLmExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmMociwgcCwgYSkge1xuICAgICAgcmV0dXJuIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiIDAgXCIgKyArKGEgPiDPgCkgKyBcIiwxIFwiICsgcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3VydmUocjAsIHAwLCByMSwgcDEpIHtcbiAgICAgIHJldHVybiBcIlEgMCwwIFwiICsgcDE7XG4gICAgfVxuICAgIGNob3JkLnJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhZGl1cztcbiAgICAgIHJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3VyY2UgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQudGFyZ2V0ID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5lbmRBbmdsZSA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGVuZEFuZ2xlO1xuICAgICAgZW5kQW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgcmV0dXJuIGNob3JkO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfY2hvcmRSYWRpdXMoZCkge1xuICAgIHJldHVybiBkLnJhZGl1cztcbiAgfVxuICBkMy5zdmcuZGlhZ29uYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCB0YXJnZXQgPSBkM190YXJnZXQsIHByb2plY3Rpb24gPSBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uO1xuICAgIGZ1bmN0aW9uIGRpYWdvbmFsKGQsIGkpIHtcbiAgICAgIHZhciBwMCA9IHNvdXJjZS5jYWxsKHRoaXMsIGQsIGkpLCBwMyA9IHRhcmdldC5jYWxsKHRoaXMsIGQsIGkpLCBtID0gKHAwLnkgKyBwMy55KSAvIDIsIHAgPSBbIHAwLCB7XG4gICAgICAgIHg6IHAwLngsXG4gICAgICAgIHk6IG1cbiAgICAgIH0sIHtcbiAgICAgICAgeDogcDMueCxcbiAgICAgICAgeTogbVxuICAgICAgfSwgcDMgXTtcbiAgICAgIHAgPSBwLm1hcChwcm9qZWN0aW9uKTtcbiAgICAgIHJldHVybiBcIk1cIiArIHBbMF0gKyBcIkNcIiArIHBbMV0gKyBcIiBcIiArIHBbMl0gKyBcIiBcIiArIHBbM107XG4gICAgfVxuICAgIGRpYWdvbmFsLnNvdXJjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IGQzX2Z1bmN0b3IoeCk7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICBkaWFnb25hbC50YXJnZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgZGlhZ29uYWwucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICBwcm9qZWN0aW9uID0geDtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIHJldHVybiBkaWFnb25hbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2RpYWdvbmFsUHJvamVjdGlvbihkKSB7XG4gICAgcmV0dXJuIFsgZC54LCBkLnkgXTtcbiAgfVxuICBkMy5zdmcuZGlhZ29uYWwucmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpYWdvbmFsID0gZDMuc3ZnLmRpYWdvbmFsKCksIHByb2plY3Rpb24gPSBkM19zdmdfZGlhZ29uYWxQcm9qZWN0aW9uLCBwcm9qZWN0aW9uXyA9IGRpYWdvbmFsLnByb2plY3Rpb247XG4gICAgZGlhZ29uYWwucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcHJvamVjdGlvbl8oZDNfc3ZnX2RpYWdvbmFsUmFkaWFsUHJvamVjdGlvbihwcm9qZWN0aW9uID0geCkpIDogcHJvamVjdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBkaWFnb25hbDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2RpYWdvbmFsUmFkaWFsUHJvamVjdGlvbihwcm9qZWN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGQgPSBwcm9qZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHIgPSBkWzBdLCBhID0gZFsxXSAtIGhhbGbPgDtcbiAgICAgIHJldHVybiBbIHIgKiBNYXRoLmNvcyhhKSwgciAqIE1hdGguc2luKGEpIF07XG4gICAgfTtcbiAgfVxuICBkMy5zdmcuc3ltYm9sID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUgPSBkM19zdmdfc3ltYm9sVHlwZSwgc2l6ZSA9IGQzX3N2Z19zeW1ib2xTaXplO1xuICAgIGZ1bmN0aW9uIHN5bWJvbChkLCBpKSB7XG4gICAgICByZXR1cm4gKGQzX3N2Z19zeW1ib2xzLmdldCh0eXBlLmNhbGwodGhpcywgZCwgaSkpIHx8IGQzX3N2Z19zeW1ib2xDaXJjbGUpKHNpemUuY2FsbCh0aGlzLCBkLCBpKSk7XG4gICAgfVxuICAgIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdHlwZTtcbiAgICAgIHR5cGUgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHN5bWJvbC5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9O1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19zeW1ib2xTaXplKCkge1xuICAgIHJldHVybiA2NDtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfc3ltYm9sVHlwZSgpIHtcbiAgICByZXR1cm4gXCJjaXJjbGVcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfc3ltYm9sQ2lyY2xlKHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gz4ApO1xuICAgIHJldHVybiBcIk0wLFwiICsgciArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiIDAgMSwxIDAsXCIgKyAtciArIFwiQVwiICsgciArIFwiLFwiICsgciArIFwiIDAgMSwxIDAsXCIgKyByICsgXCJaXCI7XG4gIH1cbiAgdmFyIGQzX3N2Z19zeW1ib2xzID0gZDMubWFwKHtcbiAgICBjaXJjbGU6IGQzX3N2Z19zeW1ib2xDaXJjbGUsXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICByZXR1cm4gXCJNXCIgKyAtMyAqIHIgKyBcIixcIiArIC1yICsgXCJIXCIgKyAtciArIFwiVlwiICsgLTMgKiByICsgXCJIXCIgKyByICsgXCJWXCIgKyAtciArIFwiSFwiICsgMyAqIHIgKyBcIlZcIiArIHIgKyBcIkhcIiArIHIgKyBcIlZcIiArIDMgKiByICsgXCJIXCIgKyAtciArIFwiVlwiICsgciArIFwiSFwiICsgLTMgKiByICsgXCJaXCI7XG4gICAgfSxcbiAgICBkaWFtb25kOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogZDNfc3ZnX3N5bWJvbFRhbjMwKSksIHJ4ID0gcnkgKiBkM19zdmdfc3ltYm9sVGFuMzA7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIC1yeSArIFwiTFwiICsgcnggKyBcIiwwXCIgKyBcIiAwLFwiICsgcnkgKyBcIiBcIiArIC1yeCArIFwiLDBcIiArIFwiWlwiO1xuICAgIH0sXG4gICAgc3F1YXJlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDI7XG4gICAgICByZXR1cm4gXCJNXCIgKyAtciArIFwiLFwiICsgLXIgKyBcIkxcIiArIHIgKyBcIixcIiArIC1yICsgXCIgXCIgKyByICsgXCIsXCIgKyByICsgXCIgXCIgKyAtciArIFwiLFwiICsgciArIFwiWlwiO1xuICAgIH0sXG4gICAgXCJ0cmlhbmdsZS1kb3duXCI6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHZhciByeCA9IE1hdGguc3FydChzaXplIC8gZDNfc3ZnX3N5bWJvbFNxcnQzKSwgcnkgPSByeCAqIGQzX3N2Z19zeW1ib2xTcXJ0MyAvIDI7XG4gICAgICByZXR1cm4gXCJNMCxcIiArIHJ5ICsgXCJMXCIgKyByeCArIFwiLFwiICsgLXJ5ICsgXCIgXCIgKyAtcnggKyBcIixcIiArIC1yeSArIFwiWlwiO1xuICAgIH0sXG4gICAgXCJ0cmlhbmdsZS11cFwiOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIGQzX3N2Z19zeW1ib2xTcXJ0MyksIHJ5ID0gcnggKiBkM19zdmdfc3ltYm9sU3FydDMgLyAyO1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyAtcnkgKyBcIkxcIiArIHJ4ICsgXCIsXCIgKyByeSArIFwiIFwiICsgLXJ4ICsgXCIsXCIgKyByeSArIFwiWlwiO1xuICAgIH1cbiAgfSk7XG4gIGQzLnN2Zy5zeW1ib2xUeXBlcyA9IGQzX3N2Z19zeW1ib2xzLmtleXMoKTtcbiAgdmFyIGQzX3N2Z19zeW1ib2xTcXJ0MyA9IE1hdGguc3FydCgzKSwgZDNfc3ZnX3N5bWJvbFRhbjMwID0gTWF0aC50YW4oMzAgKiBkM19yYWRpYW5zKTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGlkID0gZDNfdHJhbnNpdGlvbkluaGVyaXRJZCB8fCArK2QzX3RyYW5zaXRpb25JZCwgbnMgPSBkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIG5vZGUsIHRyYW5zaXRpb24gPSBkM190cmFuc2l0aW9uSW5oZXJpdCB8fCB7XG4gICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgZWFzZTogZDNfZWFzZV9jdWJpY0luT3V0LFxuICAgICAgZGVsYXk6IDAsXG4gICAgICBkdXJhdGlvbjogMjUwXG4gICAgfTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2gobmFtZSA9PSBudWxsID8gZDNfc2VsZWN0aW9uX2ludGVycnVwdCA6IGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHROUyhkM190cmFuc2l0aW9uTmFtZXNwYWNlKG5hbWUpKSk7XG4gIH07XG4gIHZhciBkM19zZWxlY3Rpb25faW50ZXJydXB0ID0gZDNfc2VsZWN0aW9uX2ludGVycnVwdE5TKGQzX3RyYW5zaXRpb25OYW1lc3BhY2UoKSk7XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHROUyhucykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsb2NrLCBhY3RpdmVJZCwgYWN0aXZlO1xuICAgICAgaWYgKChsb2NrID0gdGhpc1tuc10pICYmIChhY3RpdmUgPSBsb2NrW2FjdGl2ZUlkID0gbG9jay5hY3RpdmVdKSkge1xuICAgICAgICBhY3RpdmUudGltZXIuYyA9IG51bGw7XG4gICAgICAgIGFjdGl2ZS50aW1lci50ID0gTmFOO1xuICAgICAgICBpZiAoLS1sb2NrLmNvdW50KSBkZWxldGUgbG9ja1thY3RpdmVJZF07IGVsc2UgZGVsZXRlIHRoaXNbbnNdO1xuICAgICAgICBsb2NrLmFjdGl2ZSArPSAuNTtcbiAgICAgICAgYWN0aXZlLmV2ZW50ICYmIGFjdGl2ZS5ldmVudC5pbnRlcnJ1cHQuY2FsbCh0aGlzLCB0aGlzLl9fZGF0YV9fLCBhY3RpdmUuaW5kZXgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbihncm91cHMsIG5zLCBpZCkge1xuICAgIGQzX3N1YmNsYXNzKGdyb3VwcywgZDNfdHJhbnNpdGlvblByb3RvdHlwZSk7XG4gICAgZ3JvdXBzLm5hbWVzcGFjZSA9IG5zO1xuICAgIGdyb3Vwcy5pZCA9IGlkO1xuICAgIHJldHVybiBncm91cHM7XG4gIH1cbiAgdmFyIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUgPSBbXSwgZDNfdHJhbnNpdGlvbklkID0gMCwgZDNfdHJhbnNpdGlvbkluaGVyaXRJZCwgZDNfdHJhbnNpdGlvbkluaGVyaXQ7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuY2FsbCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmVtcHR5ID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLm5vZGUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zaXplID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemU7XG4gIGQzLnRyYW5zaXRpb24gPSBmdW5jdGlvbihzZWxlY3Rpb24sIG5hbWUpIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uICYmIHNlbGVjdGlvbi50cmFuc2l0aW9uID8gZDNfdHJhbnNpdGlvbkluaGVyaXRJZCA/IHNlbGVjdGlvbi50cmFuc2l0aW9uKG5hbWUpIDogc2VsZWN0aW9uIDogZDMuc2VsZWN0aW9uKCkudHJhbnNpdGlvbihzZWxlY3Rpb24pO1xuICB9O1xuICBkMy50cmFuc2l0aW9uLnByb3RvdHlwZSA9IGQzX3RyYW5zaXRpb25Qcm90b3R5cGU7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGUsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgKHN1Ym5vZGUgPSBzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSkge1xuICAgICAgICAgIGlmIChcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbk5vZGUoc3Vibm9kZSwgaSwgbnMsIGlkLCBub2RlW25zXVtpZF0pO1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlLCBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIHN1Ym5vZGVzLCBub2RlLCBzdWJub2RlLCB0cmFuc2l0aW9uO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbm9kZVtuc11baWRdO1xuICAgICAgICAgIHN1Ym5vZGVzID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gLTEsIG8gPSBzdWJub2Rlcy5sZW5ndGg7ICsrayA8IG87ICkge1xuICAgICAgICAgICAgaWYgKHN1Ym5vZGUgPSBzdWJub2Rlc1trXSkgZDNfdHJhbnNpdGlvbk5vZGUoc3Vibm9kZSwgaywgbnMsIGlkLCB0cmFuc2l0aW9uKTtcbiAgICAgICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZTtcbiAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gXCJmdW5jdGlvblwiKSBmaWx0ZXIgPSBkM19zZWxlY3Rpb25fZmlsdGVyKGZpbHRlcik7XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLm5hbWVzcGFjZSwgdGhpcy5pZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudHdlZW4gPSBmdW5jdGlvbihuYW1lLCB0d2Vlbikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS50d2Vlbi5nZXQobmFtZSk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR3ZWVuID09IG51bGwgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4ucmVtb3ZlKG5hbWUpO1xuICAgIH0gOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0udHdlZW4uc2V0KG5hbWUsIHR3ZWVuKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbl90d2Vlbihncm91cHMsIG5hbWUsIHZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBpZCA9IGdyb3Vwcy5pZCwgbnMgPSBncm91cHMubmFtZXNwYWNlO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaChncm91cHMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB0d2Vlbih2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSk7XG4gICAgfSA6ICh2YWx1ZSA9IHR3ZWVuKHZhbHVlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfSkpO1xuICB9XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWVOUywgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZU5TKSB0aGlzLmF0dHIodmFsdWUsIG5hbWVOU1t2YWx1ZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IG5hbWVOUyA9PSBcInRyYW5zZm9ybVwiID8gZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm0gOiBkM19pbnRlcnBvbGF0ZSwgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZU5TKTtcbiAgICBmdW5jdGlvbiBhdHRyTnVsbCgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyTnVsbE5TKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0clR3ZWVuKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBhdHRyTnVsbCA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgaSh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBhdHRyTnVsbE5TIDogKGIgKz0gXCJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBpbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgaSh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwiYXR0ci5cIiArIG5hbWVOUywgdmFsdWUsIG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuYXR0clR3ZWVuID0gZnVuY3Rpb24obmFtZU5TLCB0d2Vlbikge1xuICAgIHZhciBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lTlMpO1xuICAgIGZ1bmN0aW9uIGF0dHJUd2VlbihkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBmKHQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2Vlbk5TKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCB0aGlzLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCBmKHQpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR3ZWVuKFwiYXR0ci5cIiArIG5hbWVOUywgbmFtZS5sb2NhbCA/IGF0dHJUd2Vlbk5TIDogYXR0clR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBpZiAobiA8IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAobiA8IDIpIHZhbHVlID0gXCJcIjtcbiAgICAgICAgZm9yIChwcmlvcml0eSBpbiBuYW1lKSB0aGlzLnN0eWxlKHByaW9yaXR5LCBuYW1lW3ByaW9yaXR5XSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHByaW9yaXR5ID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVOdWxsKCkge1xuICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3R5bGVTdHJpbmcoYikge1xuICAgICAgcmV0dXJuIGIgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IGQzX3dpbmRvdyh0aGlzKS5nZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gZDNfaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkodCksIHByaW9yaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlLCBzdHlsZVN0cmluZyk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc3R5bGVUd2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHR3ZWVuLCBwcmlvcml0eSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgcHJpb3JpdHkgPSBcIlwiO1xuICAgIGZ1bmN0aW9uIHN0eWxlVHdlZW4oZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIGQzX3dpbmRvdyh0aGlzKS5nZXRDb21wdXRlZFN0eWxlKHRoaXMsIG51bGwpLmdldFByb3BlcnR5VmFsdWUobmFtZSkpO1xuICAgICAgcmV0dXJuIGYgJiYgZnVuY3Rpb24odCkge1xuICAgICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGYodCksIHByaW9yaXR5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnR3ZWVuKFwic3R5bGUuXCIgKyBuYW1lLCBzdHlsZVR3ZWVuKTtcbiAgfTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcInRleHRcIiwgdmFsdWUsIGQzX3RyYW5zaXRpb25fdGV4dCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25fdGV4dChiKSB7XG4gICAgaWYgKGIgPT0gbnVsbCkgYiA9IFwiXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IGI7XG4gICAgfTtcbiAgfVxuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIHJldHVybiB0aGlzLmVhY2goXCJlbmQudHJhbnNpdGlvblwiLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKHRoaXNbbnNdLmNvdW50IDwgMiAmJiAocCA9IHRoaXMucGFyZW50Tm9kZSkpIHAucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZWFzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzLm5vZGUoKVtuc11baWRdLmVhc2U7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGQzLmVhc2UuYXBwbHkoZDMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS5lYXNlID0gdmFsdWU7XG4gICAgfSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZGVsYXkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5kZWxheTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0uZGVsYXkgPSArdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICB9IDogKHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZGVsYXkgPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5kdXJhdGlvbjtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICBub2RlW25zXVtpZF0uZHVyYXRpb24gPSBNYXRoLm1heCgxLCB2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKTtcbiAgICB9IDogKHZhbHVlID0gTWF0aC5tYXgoMSwgdmFsdWUpLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZHVyYXRpb24gPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHZhciBpbmhlcml0ID0gZDNfdHJhbnNpdGlvbkluaGVyaXQsIGluaGVyaXRJZCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQ7XG4gICAgICB0cnkge1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdElkID0gaWQ7XG4gICAgICAgIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdCA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgICB0eXBlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgICAgIH0pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXQgPSBpbmhlcml0O1xuICAgICAgICBkM190cmFuc2l0aW9uSW5oZXJpdElkID0gaW5oZXJpdElkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gbm9kZVtuc11baWRdO1xuICAgICAgICAodHJhbnNpdGlvbi5ldmVudCB8fCAodHJhbnNpdGlvbi5ldmVudCA9IGQzLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJlbmRcIiwgXCJpbnRlcnJ1cHRcIikpKS5vbih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZDAgPSB0aGlzLmlkLCBpZDEgPSArK2QzX3RyYW5zaXRpb25JZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBncm91cCwgbm9kZSwgdHJhbnNpdGlvbjtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIHRyYW5zaXRpb24gPSBub2RlW25zXVtpZDBdO1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZDEsIHtcbiAgICAgICAgICAgIHRpbWU6IHRyYW5zaXRpb24udGltZSxcbiAgICAgICAgICAgIGVhc2U6IHRyYW5zaXRpb24uZWFzZSxcbiAgICAgICAgICAgIGRlbGF5OiB0cmFuc2l0aW9uLmRlbGF5ICsgdHJhbnNpdGlvbi5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0cmFuc2l0aW9uLmR1cmF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQxKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgPT0gbnVsbCA/IFwiX190cmFuc2l0aW9uX19cIiA6IFwiX190cmFuc2l0aW9uX1wiICsgbmFtZSArIFwiX19cIjtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQsIGluaGVyaXQpIHtcbiAgICB2YXIgbG9jayA9IG5vZGVbbnNdIHx8IChub2RlW25zXSA9IHtcbiAgICAgIGFjdGl2ZTogMCxcbiAgICAgIGNvdW50OiAwXG4gICAgfSksIHRyYW5zaXRpb24gPSBsb2NrW2lkXSwgdGltZSwgdGltZXIsIGR1cmF0aW9uLCBlYXNlLCB0d2VlbnM7XG4gICAgZnVuY3Rpb24gc2NoZWR1bGUoZWxhcHNlZCkge1xuICAgICAgdmFyIGRlbGF5ID0gdHJhbnNpdGlvbi5kZWxheTtcbiAgICAgIHRpbWVyLnQgPSBkZWxheSArIHRpbWU7XG4gICAgICBpZiAoZGVsYXkgPD0gZWxhcHNlZCkgcmV0dXJuIHN0YXJ0KGVsYXBzZWQgLSBkZWxheSk7XG4gICAgICB0aW1lci5jID0gc3RhcnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICAgIHZhciBhY3RpdmVJZCA9IGxvY2suYWN0aXZlLCBhY3RpdmUgPSBsb2NrW2FjdGl2ZUlkXTtcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgYWN0aXZlLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICBhY3RpdmUudGltZXIudCA9IE5hTjtcbiAgICAgICAgLS1sb2NrLmNvdW50O1xuICAgICAgICBkZWxldGUgbG9ja1thY3RpdmVJZF07XG4gICAgICAgIGFjdGl2ZS5ldmVudCAmJiBhY3RpdmUuZXZlbnQuaW50ZXJydXB0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgYWN0aXZlLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGNhbmNlbElkIGluIGxvY2spIHtcbiAgICAgICAgaWYgKCtjYW5jZWxJZCA8IGlkKSB7XG4gICAgICAgICAgdmFyIGNhbmNlbCA9IGxvY2tbY2FuY2VsSWRdO1xuICAgICAgICAgIGNhbmNlbC50aW1lci5jID0gbnVsbDtcbiAgICAgICAgICBjYW5jZWwudGltZXIudCA9IE5hTjtcbiAgICAgICAgICAtLWxvY2suY291bnQ7XG4gICAgICAgICAgZGVsZXRlIGxvY2tbY2FuY2VsSWRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aW1lci5jID0gdGljaztcbiAgICAgIGQzX3RpbWVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZXIuYyAmJiB0aWNrKGVsYXBzZWQgfHwgMSkpIHtcbiAgICAgICAgICB0aW1lci5jID0gbnVsbDtcbiAgICAgICAgICB0aW1lci50ID0gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSwgMCwgdGltZSk7XG4gICAgICBsb2NrLmFjdGl2ZSA9IGlkO1xuICAgICAgdHJhbnNpdGlvbi5ldmVudCAmJiB0cmFuc2l0aW9uLmV2ZW50LnN0YXJ0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSk7XG4gICAgICB0d2VlbnMgPSBbXTtcbiAgICAgIHRyYW5zaXRpb24udHdlZW4uZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9IHZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSkpIHtcbiAgICAgICAgICB0d2VlbnMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZWFzZSA9IHRyYW5zaXRpb24uZWFzZTtcbiAgICAgIGR1cmF0aW9uID0gdHJhbnNpdGlvbi5kdXJhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGljayhlbGFwc2VkKSB7XG4gICAgICB2YXIgdCA9IGVsYXBzZWQgLyBkdXJhdGlvbiwgZSA9IGVhc2UodCksIG4gPSB0d2VlbnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAgIHR3ZWVuc1stLW5dLmNhbGwobm9kZSwgZSk7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgIHRyYW5zaXRpb24uZXZlbnQgJiYgdHJhbnNpdGlvbi5ldmVudC5lbmQuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgICAgaWYgKC0tbG9jay5jb3VudCkgZGVsZXRlIGxvY2tbaWRdOyBlbHNlIGRlbGV0ZSBub2RlW25zXTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgdGltZSA9IGluaGVyaXQudGltZTtcbiAgICAgIHRpbWVyID0gZDNfdGltZXIoc2NoZWR1bGUsIDAsIHRpbWUpO1xuICAgICAgdHJhbnNpdGlvbiA9IGxvY2tbaWRdID0ge1xuICAgICAgICB0d2VlbjogbmV3IGQzX01hcCgpLFxuICAgICAgICB0aW1lOiB0aW1lLFxuICAgICAgICB0aW1lcjogdGltZXIsXG4gICAgICAgIGRlbGF5OiBpbmhlcml0LmRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogaW5oZXJpdC5kdXJhdGlvbixcbiAgICAgICAgZWFzZTogaW5oZXJpdC5lYXNlLFxuICAgICAgICBpbmRleDogaVxuICAgICAgfTtcbiAgICAgIGluaGVyaXQgPSBudWxsO1xuICAgICAgKytsb2NrLmNvdW50O1xuICAgIH1cbiAgfVxuICBkMy5zdmcuYXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLCBvcmllbnQgPSBkM19zdmdfYXhpc0RlZmF1bHRPcmllbnQsIGlubmVyVGlja1NpemUgPSA2LCBvdXRlclRpY2tTaXplID0gNiwgdGlja1BhZGRpbmcgPSAzLCB0aWNrQXJndW1lbnRzXyA9IFsgMTAgXSwgdGlja1ZhbHVlcyA9IG51bGwsIHRpY2tGb3JtYXRfO1xuICAgIGZ1bmN0aW9uIGF4aXMoZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgdmFyIHNjYWxlMCA9IHRoaXMuX19jaGFydF9fIHx8IHNjYWxlLCBzY2FsZTEgPSB0aGlzLl9fY2hhcnRfXyA9IHNjYWxlLmNvcHkoKTtcbiAgICAgICAgdmFyIHRpY2tzID0gdGlja1ZhbHVlcyA9PSBudWxsID8gc2NhbGUxLnRpY2tzID8gc2NhbGUxLnRpY2tzLmFwcGx5KHNjYWxlMSwgdGlja0FyZ3VtZW50c18pIDogc2NhbGUxLmRvbWFpbigpIDogdGlja1ZhbHVlcywgdGlja0Zvcm1hdCA9IHRpY2tGb3JtYXRfID09IG51bGwgPyBzY2FsZTEudGlja0Zvcm1hdCA/IHNjYWxlMS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlMSwgdGlja0FyZ3VtZW50c18pIDogZDNfaWRlbnRpdHkgOiB0aWNrRm9ybWF0XywgdGljayA9IGcuc2VsZWN0QWxsKFwiLnRpY2tcIikuZGF0YSh0aWNrcywgc2NhbGUxKSwgdGlja0VudGVyID0gdGljay5lbnRlcigpLmluc2VydChcImdcIiwgXCIuZG9tYWluXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIikuc3R5bGUoXCJvcGFjaXR5XCIsIM61KSwgdGlja0V4aXQgPSBkMy50cmFuc2l0aW9uKHRpY2suZXhpdCgpKS5zdHlsZShcIm9wYWNpdHlcIiwgzrUpLnJlbW92ZSgpLCB0aWNrVXBkYXRlID0gZDMudHJhbnNpdGlvbih0aWNrLm9yZGVyKCkpLnN0eWxlKFwib3BhY2l0eVwiLCAxKSwgdGlja1NwYWNpbmcgPSBNYXRoLm1heChpbm5lclRpY2tTaXplLCAwKSArIHRpY2tQYWRkaW5nLCB0aWNrVHJhbnNmb3JtO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHNjYWxlMSksIHBhdGggPSBnLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbIDAgXSksIHBhdGhVcGRhdGUgPSAocGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpLCBcbiAgICAgICAgZDMudHJhbnNpdGlvbihwYXRoKSk7XG4gICAgICAgIHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xuICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcbiAgICAgICAgdmFyIGxpbmVFbnRlciA9IHRpY2tFbnRlci5zZWxlY3QoXCJsaW5lXCIpLCBsaW5lVXBkYXRlID0gdGlja1VwZGF0ZS5zZWxlY3QoXCJsaW5lXCIpLCB0ZXh0ID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpLnRleHQodGlja0Zvcm1hdCksIHRleHRFbnRlciA9IHRpY2tFbnRlci5zZWxlY3QoXCJ0ZXh0XCIpLCB0ZXh0VXBkYXRlID0gdGlja1VwZGF0ZS5zZWxlY3QoXCJ0ZXh0XCIpLCBzaWduID0gb3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJsZWZ0XCIgPyAtMSA6IDEsIHgxLCB4MiwgeTEsIHkyO1xuICAgICAgICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIHRpY2tUcmFuc2Zvcm0gPSBkM19zdmdfYXhpc1gsIHgxID0gXCJ4XCIsIHkxID0gXCJ5XCIsIHgyID0gXCJ4MlwiLCB5MiA9IFwieTJcIjtcbiAgICAgICAgICB0ZXh0LmF0dHIoXCJkeVwiLCBzaWduIDwgMCA/IFwiMGVtXCIgOiBcIi43MWVtXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIHJhbmdlWzBdICsgXCIsXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSArIFwiVjBIXCIgKyByYW5nZVsxXSArIFwiVlwiICsgc2lnbiAqIG91dGVyVGlja1NpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tUcmFuc2Zvcm0gPSBkM19zdmdfYXhpc1ksIHgxID0gXCJ5XCIsIHkxID0gXCJ4XCIsIHgyID0gXCJ5MlwiLCB5MiA9IFwieDJcIjtcbiAgICAgICAgICB0ZXh0LmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgc2lnbiA8IDAgPyBcImVuZFwiIDogXCJzdGFydFwiKTtcbiAgICAgICAgICBwYXRoVXBkYXRlLmF0dHIoXCJkXCIsIFwiTVwiICsgc2lnbiAqIG91dGVyVGlja1NpemUgKyBcIixcIiArIHJhbmdlWzBdICsgXCJIMFZcIiArIHJhbmdlWzFdICsgXCJIXCIgKyBzaWduICogb3V0ZXJUaWNrU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZUVudGVyLmF0dHIoeTIsIHNpZ24gKiBpbm5lclRpY2tTaXplKTtcbiAgICAgICAgdGV4dEVudGVyLmF0dHIoeTEsIHNpZ24gKiB0aWNrU3BhY2luZyk7XG4gICAgICAgIGxpbmVVcGRhdGUuYXR0cih4MiwgMCkuYXR0cih5Miwgc2lnbiAqIGlubmVyVGlja1NpemUpO1xuICAgICAgICB0ZXh0VXBkYXRlLmF0dHIoeDEsIDApLmF0dHIoeTEsIHNpZ24gKiB0aWNrU3BhY2luZyk7XG4gICAgICAgIGlmIChzY2FsZTEucmFuZ2VCYW5kKSB7XG4gICAgICAgICAgdmFyIHggPSBzY2FsZTEsIGR4ID0geC5yYW5nZUJhbmQoKSAvIDI7XG4gICAgICAgICAgc2NhbGUwID0gc2NhbGUxID0gZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgcmV0dXJuIHgoZCkgKyBkeDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNjYWxlMC5yYW5nZUJhbmQpIHtcbiAgICAgICAgICBzY2FsZTAgPSBzY2FsZTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlja0V4aXQuY2FsbCh0aWNrVHJhbnNmb3JtLCBzY2FsZTEsIHNjYWxlMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGlja0VudGVyLmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUwLCBzY2FsZTEpO1xuICAgICAgICB0aWNrVXBkYXRlLmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBzY2FsZTEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZTtcbiAgICAgIHNjYWxlID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy5vcmllbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmllbnQ7XG4gICAgICBvcmllbnQgPSB4IGluIGQzX3N2Z19heGlzT3JpZW50cyA/IHggKyBcIlwiIDogZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrQXJndW1lbnRzXztcbiAgICAgIHRpY2tBcmd1bWVudHNfID0gZDNfYXJyYXkoYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1ZhbHVlcztcbiAgICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tGb3JtYXQgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0XztcbiAgICAgIHRpY2tGb3JtYXRfID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmICghbikgcmV0dXJuIGlubmVyVGlja1NpemU7XG4gICAgICBpbm5lclRpY2tTaXplID0gK3g7XG4gICAgICBvdXRlclRpY2tTaXplID0gK2FyZ3VtZW50c1tuIC0gMV07XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMuaW5uZXJUaWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGlubmVyVGlja1NpemU7XG4gICAgICBpbm5lclRpY2tTaXplID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMub3V0ZXJUaWNrU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG91dGVyVGlja1NpemU7XG4gICAgICBvdXRlclRpY2tTaXplID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrUGFkZGluZztcbiAgICAgIHRpY2tQYWRkaW5nID0gK3g7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1N1YmRpdmlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggJiYgYXhpcztcbiAgICB9O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICB2YXIgZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50ID0gXCJib3R0b21cIiwgZDNfc3ZnX2F4aXNPcmllbnRzID0ge1xuICAgIHRvcDogMSxcbiAgICByaWdodDogMSxcbiAgICBib3R0b206IDEsXG4gICAgbGVmdDogMVxuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfYXhpc1goc2VsZWN0aW9uLCB4MCwgeDEpIHtcbiAgICBzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICB2YXIgdjAgPSB4MChkKTtcbiAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIChpc0Zpbml0ZSh2MCkgPyB2MCA6IHgxKGQpKSArIFwiLDApXCI7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2F4aXNZKHNlbGVjdGlvbiwgeTAsIHkxKSB7XG4gICAgc2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIHYwID0geTAoZCk7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoMCxcIiArIChpc0Zpbml0ZSh2MCkgPyB2MCA6IHkxKGQpKSArIFwiKVwiO1xuICAgIH0pO1xuICB9XG4gIGQzLnN2Zy5icnVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goYnJ1c2gsIFwiYnJ1c2hzdGFydFwiLCBcImJydXNoXCIsIFwiYnJ1c2hlbmRcIiksIHggPSBudWxsLCB5ID0gbnVsbCwgeEV4dGVudCA9IFsgMCwgMCBdLCB5RXh0ZW50ID0gWyAwLCAwIF0sIHhFeHRlbnREb21haW4sIHlFeHRlbnREb21haW4sIHhDbGFtcCA9IHRydWUsIHlDbGFtcCA9IHRydWUsIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWzBdO1xuICAgIGZ1bmN0aW9uIGJydXNoKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKS5zdHlsZShcIi13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvclwiLCBcInJnYmEoMCwwLDAsMClcIikub24oXCJtb3VzZWRvd24uYnJ1c2hcIiwgYnJ1c2hzdGFydCkub24oXCJ0b3VjaHN0YXJ0LmJydXNoXCIsIGJydXNoc3RhcnQpO1xuICAgICAgICB2YXIgYmFja2dyb3VuZCA9IGcuc2VsZWN0QWxsKFwiLmJhY2tncm91bmRcIikuZGF0YShbIDAgXSk7XG4gICAgICAgIGJhY2tncm91bmQuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImJhY2tncm91bmRcIikuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpLnN0eWxlKFwiY3Vyc29yXCIsIFwiY3Jvc3NoYWlyXCIpO1xuICAgICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnRcIikuZGF0YShbIDAgXSkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLCBcImV4dGVudFwiKS5zdHlsZShcImN1cnNvclwiLCBcIm1vdmVcIik7XG4gICAgICAgIHZhciByZXNpemUgPSBnLnNlbGVjdEFsbChcIi5yZXNpemVcIikuZGF0YShyZXNpemVzLCBkM19pZGVudGl0eSk7XG4gICAgICAgIHJlc2l6ZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgIHJlc2l6ZS5lbnRlcigpLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gXCJyZXNpemUgXCIgKyBkO1xuICAgICAgICB9KS5zdHlsZShcImN1cnNvclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIGQzX3N2Z19icnVzaEN1cnNvcltkXTtcbiAgICAgICAgfSkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwieFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIC9bZXddJC8udGVzdChkKSA/IC0zIDogbnVsbDtcbiAgICAgICAgfSkuYXR0cihcInlcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAvXltuc10vLnRlc3QoZCkgPyAtMyA6IG51bGw7XG4gICAgICAgIH0pLmF0dHIoXCJ3aWR0aFwiLCA2KS5hdHRyKFwiaGVpZ2h0XCIsIDYpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgcmVzaXplLnN0eWxlKFwiZGlzcGxheVwiLCBicnVzaC5lbXB0eSgpID8gXCJub25lXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGdVcGRhdGUgPSBkMy50cmFuc2l0aW9uKGcpLCBiYWNrZ3JvdW5kVXBkYXRlID0gZDMudHJhbnNpdGlvbihiYWNrZ3JvdW5kKSwgcmFuZ2U7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHgpO1xuICAgICAgICAgIGJhY2tncm91bmRVcGRhdGUuYXR0cihcInhcIiwgcmFuZ2VbMF0pLmF0dHIoXCJ3aWR0aFwiLCByYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICAgICAgICByZWRyYXdYKGdVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgcmFuZ2UgPSBkM19zY2FsZVJhbmdlKHkpO1xuICAgICAgICAgIGJhY2tncm91bmRVcGRhdGUuYXR0cihcInlcIiwgcmFuZ2VbMF0pLmF0dHIoXCJoZWlnaHRcIiwgcmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gICAgICAgICAgcmVkcmF3WShnVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZWRyYXcoZ1VwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgYnJ1c2guZXZlbnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudF8gPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpLCBleHRlbnQxID0ge1xuICAgICAgICAgIHg6IHhFeHRlbnQsXG4gICAgICAgICAgeTogeUV4dGVudCxcbiAgICAgICAgICBpOiB4RXh0ZW50RG9tYWluLFxuICAgICAgICAgIGo6IHlFeHRlbnREb21haW5cbiAgICAgICAgfSwgZXh0ZW50MCA9IHRoaXMuX19jaGFydF9fIHx8IGV4dGVudDE7XG4gICAgICAgIHRoaXMuX19jaGFydF9fID0gZXh0ZW50MTtcbiAgICAgICAgaWYgKGQzX3RyYW5zaXRpb25Jbmhlcml0SWQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmVhY2goXCJzdGFydC5icnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSBleHRlbnQwLmk7XG4gICAgICAgICAgICB5RXh0ZW50RG9tYWluID0gZXh0ZW50MC5qO1xuICAgICAgICAgICAgeEV4dGVudCA9IGV4dGVudDAueDtcbiAgICAgICAgICAgIHlFeHRlbnQgPSBleHRlbnQwLnk7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkudHdlZW4oXCJicnVzaDpicnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB4aSA9IGQzX2ludGVycG9sYXRlQXJyYXkoeEV4dGVudCwgZXh0ZW50MS54KSwgeWkgPSBkM19pbnRlcnBvbGF0ZUFycmF5KHlFeHRlbnQsIGV4dGVudDEueSk7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0geUV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICB4RXh0ZW50ID0gZXh0ZW50MS54ID0geGkodCk7XG4gICAgICAgICAgICAgIHlFeHRlbnQgPSBleHRlbnQxLnkgPSB5aSh0KTtcbiAgICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSkuZWFjaChcImVuZC5icnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHhFeHRlbnREb21haW4gPSBleHRlbnQxLmk7XG4gICAgICAgICAgICB5RXh0ZW50RG9tYWluID0gZXh0ZW50MS5qO1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaGVuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVkcmF3KGcpIHtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgeEV4dGVudFsrL2UkLy50ZXN0KGQpXSArIFwiLFwiICsgeUV4dGVudFsrL15zLy50ZXN0KGQpXSArIFwiKVwiO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZHJhd1goZykge1xuICAgICAgZy5zZWxlY3QoXCIuZXh0ZW50XCIpLmF0dHIoXCJ4XCIsIHhFeHRlbnRbMF0pO1xuICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50LC5uPnJlY3QsLnM+cmVjdFwiKS5hdHRyKFwid2lkdGhcIiwgeEV4dGVudFsxXSAtIHhFeHRlbnRbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWRyYXdZKGcpIHtcbiAgICAgIGcuc2VsZWN0KFwiLmV4dGVudFwiKS5hdHRyKFwieVwiLCB5RXh0ZW50WzBdKTtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudCwuZT5yZWN0LC53PnJlY3RcIikuYXR0cihcImhlaWdodFwiLCB5RXh0ZW50WzFdIC0geUV4dGVudFswXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJydXNoc3RhcnQoKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcywgZXZlbnRUYXJnZXQgPSBkMy5zZWxlY3QoZDMuZXZlbnQudGFyZ2V0KSwgZXZlbnRfID0gZXZlbnQub2YodGFyZ2V0LCBhcmd1bWVudHMpLCBnID0gZDMuc2VsZWN0KHRhcmdldCksIHJlc2l6aW5nID0gZXZlbnRUYXJnZXQuZGF0dW0oKSwgcmVzaXppbmdYID0gIS9eKG58cykkLy50ZXN0KHJlc2l6aW5nKSAmJiB4LCByZXNpemluZ1kgPSAhL14oZXx3KSQvLnRlc3QocmVzaXppbmcpICYmIHksIGRyYWdnaW5nID0gZXZlbnRUYXJnZXQuY2xhc3NlZChcImV4dGVudFwiKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGFyZ2V0KSwgY2VudGVyLCBvcmlnaW4gPSBkMy5tb3VzZSh0YXJnZXQpLCBvZmZzZXQ7XG4gICAgICB2YXIgdyA9IGQzLnNlbGVjdChkM193aW5kb3codGFyZ2V0KSkub24oXCJrZXlkb3duLmJydXNoXCIsIGtleWRvd24pLm9uKFwia2V5dXAuYnJ1c2hcIiwga2V5dXApO1xuICAgICAgaWYgKGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgIHcub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgYnJ1c2htb3ZlKS5vbihcInRvdWNoZW5kLmJydXNoXCIsIGJydXNoZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgYnJ1c2htb3ZlKS5vbihcIm1vdXNldXAuYnJ1c2hcIiwgYnJ1c2hlbmQpO1xuICAgICAgfVxuICAgICAgZy5pbnRlcnJ1cHQoKS5zZWxlY3RBbGwoXCIqXCIpLmludGVycnVwdCgpO1xuICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbMF0gLSBvcmlnaW5bMF07XG4gICAgICAgIG9yaWdpblsxXSA9IHlFeHRlbnRbMF0gLSBvcmlnaW5bMV07XG4gICAgICB9IGVsc2UgaWYgKHJlc2l6aW5nKSB7XG4gICAgICAgIHZhciBleCA9ICsvdyQvLnRlc3QocmVzaXppbmcpLCBleSA9ICsvXm4vLnRlc3QocmVzaXppbmcpO1xuICAgICAgICBvZmZzZXQgPSBbIHhFeHRlbnRbMSAtIGV4XSAtIG9yaWdpblswXSwgeUV4dGVudFsxIC0gZXldIC0gb3JpZ2luWzFdIF07XG4gICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbZXhdO1xuICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50W2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoZDMuZXZlbnQuYWx0S2V5KSBjZW50ZXIgPSBvcmlnaW4uc2xpY2UoKTtcbiAgICAgIGcuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIikuc2VsZWN0QWxsKFwiLnJlc2l6ZVwiKS5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XG4gICAgICBkMy5zZWxlY3QoXCJib2R5XCIpLnN0eWxlKFwiY3Vyc29yXCIsIGV2ZW50VGFyZ2V0LnN0eWxlKFwiY3Vyc29yXCIpKTtcbiAgICAgIGV2ZW50Xyh7XG4gICAgICAgIHR5cGU6IFwiYnJ1c2hzdGFydFwiXG4gICAgICB9KTtcbiAgICAgIGJydXNobW92ZSgpO1xuICAgICAgZnVuY3Rpb24ga2V5ZG93bigpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgICBpZiAoIWRyYWdnaW5nKSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgb3JpZ2luWzBdIC09IHhFeHRlbnRbMV07XG4gICAgICAgICAgICBvcmlnaW5bMV0gLT0geUV4dGVudFsxXTtcbiAgICAgICAgICAgIGRyYWdnaW5nID0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBrZXl1cCgpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LmtleUNvZGUgPT0gMzIgJiYgZHJhZ2dpbmcgPT0gMikge1xuICAgICAgICAgIG9yaWdpblswXSArPSB4RXh0ZW50WzFdO1xuICAgICAgICAgIG9yaWdpblsxXSArPSB5RXh0ZW50WzFdO1xuICAgICAgICAgIGRyYWdnaW5nID0gMDtcbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJydXNobW92ZSgpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gZDMubW91c2UodGFyZ2V0KSwgbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIHBvaW50WzBdICs9IG9mZnNldFswXTtcbiAgICAgICAgICBwb2ludFsxXSArPSBvZmZzZXRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgIGlmIChkMy5ldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIGlmICghY2VudGVyKSBjZW50ZXIgPSBbICh4RXh0ZW50WzBdICsgeEV4dGVudFsxXSkgLyAyLCAoeUV4dGVudFswXSArIHlFeHRlbnRbMV0pIC8gMiBdO1xuICAgICAgICAgICAgb3JpZ2luWzBdID0geEV4dGVudFsrKHBvaW50WzBdIDwgY2VudGVyWzBdKV07XG4gICAgICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50WysocG9pbnRbMV0gPCBjZW50ZXJbMV0pXTtcbiAgICAgICAgICB9IGVsc2UgY2VudGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzaXppbmdYICYmIG1vdmUxKHBvaW50LCB4LCAwKSkge1xuICAgICAgICAgIHJlZHJhd1goZyk7XG4gICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNpemluZ1kgJiYgbW92ZTEocG9pbnQsIHksIDEpKSB7XG4gICAgICAgICAgcmVkcmF3WShnKTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgICAgcmVkcmF3KGcpO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICBtb2RlOiBkcmFnZ2luZyA/IFwibW92ZVwiIDogXCJyZXNpemVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3ZlMShwb2ludCwgc2NhbGUsIGkpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gZDNfc2NhbGVSYW5nZShzY2FsZSksIHIwID0gcmFuZ2VbMF0sIHIxID0gcmFuZ2VbMV0sIHBvc2l0aW9uID0gb3JpZ2luW2ldLCBleHRlbnQgPSBpID8geUV4dGVudCA6IHhFeHRlbnQsIHNpemUgPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIG1pbiwgbWF4O1xuICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICByMCAtPSBwb3NpdGlvbjtcbiAgICAgICAgICByMSAtPSBzaXplICsgcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gKGkgPyB5Q2xhbXAgOiB4Q2xhbXApID8gTWF0aC5tYXgocjAsIE1hdGgubWluKHIxLCBwb2ludFtpXSkpIDogcG9pbnRbaV07XG4gICAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICAgIG1heCA9IChtaW4gKz0gcG9zaXRpb24pICsgc2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2VudGVyKSBwb3NpdGlvbiA9IE1hdGgubWF4KHIwLCBNYXRoLm1pbihyMSwgMiAqIGNlbnRlcltpXSAtIG1pbikpO1xuICAgICAgICAgIGlmIChwb3NpdGlvbiA8IG1pbikge1xuICAgICAgICAgICAgbWF4ID0gbWluO1xuICAgICAgICAgICAgbWluID0gcG9zaXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heCA9IHBvc2l0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZW50WzBdICE9IG1pbiB8fCBleHRlbnRbMV0gIT0gbWF4KSB7XG4gICAgICAgICAgaWYgKGkpIHlFeHRlbnREb21haW4gPSBudWxsOyBlbHNlIHhFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgICAgIGV4dGVudFswXSA9IG1pbjtcbiAgICAgICAgICBleHRlbnRbMV0gPSBtYXg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJydXNoZW5kKCkge1xuICAgICAgICBicnVzaG1vdmUoKTtcbiAgICAgICAgZy5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpLnNlbGVjdEFsbChcIi5yZXNpemVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIGJydXNoLmVtcHR5KCkgPyBcIm5vbmVcIiA6IG51bGwpO1xuICAgICAgICBkMy5zZWxlY3QoXCJib2R5XCIpLnN0eWxlKFwiY3Vyc29yXCIsIG51bGwpO1xuICAgICAgICB3Lm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIG51bGwpLm9uKFwibW91c2V1cC5icnVzaFwiLCBudWxsKS5vbihcInRvdWNobW92ZS5icnVzaFwiLCBudWxsKS5vbihcInRvdWNoZW5kLmJydXNoXCIsIG51bGwpLm9uKFwia2V5ZG93bi5icnVzaFwiLCBudWxsKS5vbihcImtleXVwLmJydXNoXCIsIG51bGwpO1xuICAgICAgICBkcmFnUmVzdG9yZSgpO1xuICAgICAgICBldmVudF8oe1xuICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnJ1c2gueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gejtcbiAgICAgIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWyF4IDw8IDEgfCAheV07XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC55ID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geTtcbiAgICAgIHkgPSB6O1xuICAgICAgcmVzaXplcyA9IGQzX3N2Z19icnVzaFJlc2l6ZXNbIXggPDwgMSB8ICF5XTtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmNsYW1wID0gZnVuY3Rpb24oeikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geCAmJiB5ID8gWyB4Q2xhbXAsIHlDbGFtcCBdIDogeCA/IHhDbGFtcCA6IHkgPyB5Q2xhbXAgOiBudWxsO1xuICAgICAgaWYgKHggJiYgeSkgeENsYW1wID0gISF6WzBdLCB5Q2xhbXAgPSAhIXpbMV07IGVsc2UgaWYgKHgpIHhDbGFtcCA9ICEhejsgZWxzZSBpZiAoeSkgeUNsYW1wID0gISF6O1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guZXh0ZW50ID0gZnVuY3Rpb24oeikge1xuICAgICAgdmFyIHgwLCB4MSwgeTAsIHkxLCB0O1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgaWYgKHhFeHRlbnREb21haW4pIHtcbiAgICAgICAgICAgIHgwID0geEV4dGVudERvbWFpblswXSwgeDEgPSB4RXh0ZW50RG9tYWluWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4MCA9IHhFeHRlbnRbMF0sIHgxID0geEV4dGVudFsxXTtcbiAgICAgICAgICAgIGlmICh4LmludmVydCkgeDAgPSB4LmludmVydCh4MCksIHgxID0geC5pbnZlcnQoeDEpO1xuICAgICAgICAgICAgaWYgKHgxIDwgeDApIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeSkge1xuICAgICAgICAgIGlmICh5RXh0ZW50RG9tYWluKSB7XG4gICAgICAgICAgICB5MCA9IHlFeHRlbnREb21haW5bMF0sIHkxID0geUV4dGVudERvbWFpblsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeTAgPSB5RXh0ZW50WzBdLCB5MSA9IHlFeHRlbnRbMV07XG4gICAgICAgICAgICBpZiAoeS5pbnZlcnQpIHkwID0geS5pbnZlcnQoeTApLCB5MSA9IHkuaW52ZXJ0KHkxKTtcbiAgICAgICAgICAgIGlmICh5MSA8IHkwKSB0ID0geTAsIHkwID0geTEsIHkxID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggJiYgeSA/IFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdIDogeCA/IFsgeDAsIHgxIF0gOiB5ICYmIFsgeTAsIHkxIF07XG4gICAgICB9XG4gICAgICBpZiAoeCkge1xuICAgICAgICB4MCA9IHpbMF0sIHgxID0gelsxXTtcbiAgICAgICAgaWYgKHkpIHgwID0geDBbMF0sIHgxID0geDFbMF07XG4gICAgICAgIHhFeHRlbnREb21haW4gPSBbIHgwLCB4MSBdO1xuICAgICAgICBpZiAoeC5pbnZlcnQpIHgwID0geCh4MCksIHgxID0geCh4MSk7XG4gICAgICAgIGlmICh4MSA8IHgwKSB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgICAgICAgaWYgKHgwICE9IHhFeHRlbnRbMF0gfHwgeDEgIT0geEV4dGVudFsxXSkgeEV4dGVudCA9IFsgeDAsIHgxIF07XG4gICAgICB9XG4gICAgICBpZiAoeSkge1xuICAgICAgICB5MCA9IHpbMF0sIHkxID0gelsxXTtcbiAgICAgICAgaWYgKHgpIHkwID0geTBbMV0sIHkxID0geTFbMV07XG4gICAgICAgIHlFeHRlbnREb21haW4gPSBbIHkwLCB5MSBdO1xuICAgICAgICBpZiAoeS5pbnZlcnQpIHkwID0geSh5MCksIHkxID0geSh5MSk7XG4gICAgICAgIGlmICh5MSA8IHkwKSB0ID0geTAsIHkwID0geTEsIHkxID0gdDtcbiAgICAgICAgaWYgKHkwICE9IHlFeHRlbnRbMF0gfHwgeTEgIT0geUV4dGVudFsxXSkgeUV4dGVudCA9IFsgeTAsIHkxIF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgIHhFeHRlbnQgPSBbIDAsIDAgXSwgeUV4dGVudCA9IFsgMCwgMCBdO1xuICAgICAgICB4RXh0ZW50RG9tYWluID0geUV4dGVudERvbWFpbiA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEheCAmJiB4RXh0ZW50WzBdID09IHhFeHRlbnRbMV0gfHwgISF5ICYmIHlFeHRlbnRbMF0gPT0geUV4dGVudFsxXTtcbiAgICB9O1xuICAgIHJldHVybiBkMy5yZWJpbmQoYnJ1c2gsIGV2ZW50LCBcIm9uXCIpO1xuICB9O1xuICB2YXIgZDNfc3ZnX2JydXNoQ3Vyc29yID0ge1xuICAgIG46IFwibnMtcmVzaXplXCIsXG4gICAgZTogXCJldy1yZXNpemVcIixcbiAgICBzOiBcIm5zLXJlc2l6ZVwiLFxuICAgIHc6IFwiZXctcmVzaXplXCIsXG4gICAgbnc6IFwibndzZS1yZXNpemVcIixcbiAgICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxuICAgIHNlOiBcIm53c2UtcmVzaXplXCIsXG4gICAgc3c6IFwibmVzdy1yZXNpemVcIlxuICB9O1xuICB2YXIgZDNfc3ZnX2JydXNoUmVzaXplcyA9IFsgWyBcIm5cIiwgXCJlXCIsIFwic1wiLCBcIndcIiwgXCJud1wiLCBcIm5lXCIsIFwic2VcIiwgXCJzd1wiIF0sIFsgXCJlXCIsIFwid1wiIF0sIFsgXCJuXCIsIFwic1wiIF0sIFtdIF07XG4gIHZhciBkM190aW1lX2Zvcm1hdCA9IGQzX3RpbWUuZm9ybWF0ID0gZDNfbG9jYWxlX2VuVVMudGltZUZvcm1hdDtcbiAgdmFyIGQzX3RpbWVfZm9ybWF0VXRjID0gZDNfdGltZV9mb3JtYXQudXRjO1xuICB2YXIgZDNfdGltZV9mb3JtYXRJc28gPSBkM190aW1lX2Zvcm1hdFV0YyhcIiVZLSVtLSVkVCVIOiVNOiVTLiVMWlwiKTtcbiAgZDNfdGltZV9mb3JtYXQuaXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgJiYgK25ldyBEYXRlKFwiMjAwMC0wMS0wMVQwMDowMDowMC4wMDBaXCIpID8gZDNfdGltZV9mb3JtYXRJc29OYXRpdmUgOiBkM190aW1lX2Zvcm1hdElzbztcbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gIH1cbiAgZDNfdGltZV9mb3JtYXRJc29OYXRpdmUucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG4gIH07XG4gIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlLnRvU3RyaW5nID0gZDNfdGltZV9mb3JtYXRJc28udG9TdHJpbmc7XG4gIGQzX3RpbWUuc2Vjb25kID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKE1hdGguZmxvb3IoZGF0ZSAvIDFlMykgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiAxZTMpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0U2Vjb25kcygpO1xuICB9KTtcbiAgZDNfdGltZS5zZWNvbmRzID0gZDNfdGltZS5zZWNvbmQucmFuZ2U7XG4gIGQzX3RpbWUuc2Vjb25kcy51dGMgPSBkM190aW1lLnNlY29uZC51dGMucmFuZ2U7XG4gIGQzX3RpbWUubWludXRlID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIG5ldyBkM19kYXRlKE1hdGguZmxvb3IoZGF0ZSAvIDZlNCkgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiA2ZTQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TWludXRlcygpO1xuICB9KTtcbiAgZDNfdGltZS5taW51dGVzID0gZDNfdGltZS5taW51dGUucmFuZ2U7XG4gIGQzX3RpbWUubWludXRlcy51dGMgPSBkM190aW1lLm1pbnV0ZS51dGMucmFuZ2U7XG4gIGQzX3RpbWUuaG91ciA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciB0aW1lem9uZSA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDYwO1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZSgoTWF0aC5mbG9vcihkYXRlIC8gMzZlNSAtIHRpbWV6b25lKSArIHRpbWV6b25lKSAqIDM2ZTUpO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKG9mZnNldCkgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldEhvdXJzKCk7XG4gIH0pO1xuICBkM190aW1lLmhvdXJzID0gZDNfdGltZS5ob3VyLnJhbmdlO1xuICBkM190aW1lLmhvdXJzLnV0YyA9IGQzX3RpbWUuaG91ci51dGMucmFuZ2U7XG4gIGQzX3RpbWUubW9udGggPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSk7XG4gICAgZGF0ZS5zZXREYXRlKDEpO1xuICAgIHJldHVybiBkYXRlO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldE1vbnRoKGRhdGUuZ2V0TW9udGgoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICB9KTtcbiAgZDNfdGltZS5tb250aHMgPSBkM190aW1lLm1vbnRoLnJhbmdlO1xuICBkM190aW1lLm1vbnRocy51dGMgPSBkM190aW1lLm1vbnRoLnV0Yy5yYW5nZTtcbiAgZnVuY3Rpb24gZDNfdGltZV9zY2FsZShsaW5lYXIsIG1ldGhvZHMsIGZvcm1hdCkge1xuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIoeCk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3NjYWxlRGF0ZShsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxpbmVhci5kb21haW4oKS5tYXAoZDNfdGltZV9zY2FsZURhdGUpO1xuICAgICAgbGluZWFyLmRvbWFpbih4KTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRpY2tNZXRob2QoZXh0ZW50LCBjb3VudCkge1xuICAgICAgdmFyIHNwYW4gPSBleHRlbnRbMV0gLSBleHRlbnRbMF0sIHRhcmdldCA9IHNwYW4gLyBjb3VudCwgaSA9IGQzLmJpc2VjdChkM190aW1lX3NjYWxlU3RlcHMsIHRhcmdldCk7XG4gICAgICByZXR1cm4gaSA9PSBkM190aW1lX3NjYWxlU3RlcHMubGVuZ3RoID8gWyBtZXRob2RzLnllYXIsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShleHRlbnQubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgLyAzMTUzNmU2O1xuICAgICAgfSksIGNvdW50KVsyXSBdIDogIWkgPyBbIGQzX3RpbWVfc2NhbGVNaWxsaXNlY29uZHMsIGQzX3NjYWxlX2xpbmVhclRpY2tSYW5nZShleHRlbnQsIGNvdW50KVsyXSBdIDogbWV0aG9kc1t0YXJnZXQgLyBkM190aW1lX3NjYWxlU3RlcHNbaSAtIDFdIDwgZDNfdGltZV9zY2FsZVN0ZXBzW2ldIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICB9XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKGludGVydmFsLCBza2lwKSB7XG4gICAgICB2YXIgZG9tYWluID0gc2NhbGUuZG9tYWluKCksIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIG1ldGhvZCA9IGludGVydmFsID09IG51bGwgPyB0aWNrTWV0aG9kKGV4dGVudCwgMTApIDogdHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiICYmIHRpY2tNZXRob2QoZXh0ZW50LCBpbnRlcnZhbCk7XG4gICAgICBpZiAobWV0aG9kKSBpbnRlcnZhbCA9IG1ldGhvZFswXSwgc2tpcCA9IG1ldGhvZFsxXTtcbiAgICAgIGZ1bmN0aW9uIHNraXBwZWQoZGF0ZSkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGRhdGUpICYmICFpbnRlcnZhbC5yYW5nZShkYXRlLCBkM190aW1lX3NjYWxlRGF0ZSgrZGF0ZSArIDEpLCBza2lwKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhbGUuZG9tYWluKGQzX3NjYWxlX25pY2UoZG9tYWluLCBza2lwID4gMSA/IHtcbiAgICAgICAgZmxvb3I6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB3aGlsZSAoc2tpcHBlZChkYXRlID0gaW50ZXJ2YWwuZmxvb3IoZGF0ZSkpKSBkYXRlID0gZDNfdGltZV9zY2FsZURhdGUoZGF0ZSAtIDEpO1xuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9LFxuICAgICAgICBjZWlsOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKHNraXBwZWQoZGF0ZSA9IGludGVydmFsLmNlaWwoZGF0ZSkpKSBkYXRlID0gZDNfdGltZV9zY2FsZURhdGUoK2RhdGUgKyAxKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSA6IGludGVydmFsKSk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGludGVydmFsLCBza2lwKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoc2NhbGUuZG9tYWluKCkpLCBtZXRob2QgPSBpbnRlcnZhbCA9PSBudWxsID8gdGlja01ldGhvZChleHRlbnQsIDEwKSA6IHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIiA/IHRpY2tNZXRob2QoZXh0ZW50LCBpbnRlcnZhbCkgOiAhaW50ZXJ2YWwucmFuZ2UgJiYgWyB7XG4gICAgICAgIHJhbmdlOiBpbnRlcnZhbFxuICAgICAgfSwgc2tpcCBdO1xuICAgICAgaWYgKG1ldGhvZCkgaW50ZXJ2YWwgPSBtZXRob2RbMF0sIHNraXAgPSBtZXRob2RbMV07XG4gICAgICByZXR1cm4gaW50ZXJ2YWwucmFuZ2UoZXh0ZW50WzBdLCBkM190aW1lX3NjYWxlRGF0ZSgrZXh0ZW50WzFdICsgMSksIHNraXAgPCAxID8gMSA6IHNraXApO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3NjYWxlKGxpbmVhci5jb3B5KCksIG1ldGhvZHMsIGZvcm1hdCk7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfc2NhbGVEYXRlKHQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodCk7XG4gIH1cbiAgdmFyIGQzX3RpbWVfc2NhbGVTdGVwcyA9IFsgMWUzLCA1ZTMsIDE1ZTMsIDNlNCwgNmU0LCAzZTUsIDllNSwgMThlNSwgMzZlNSwgMTA4ZTUsIDIxNmU1LCA0MzJlNSwgODY0ZTUsIDE3MjhlNSwgNjA0OGU1LCAyNTkyZTYsIDc3NzZlNiwgMzE1MzZlNiBdO1xuICB2YXIgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcyA9IFsgWyBkM190aW1lLnNlY29uZCwgMSBdLCBbIGQzX3RpbWUuc2Vjb25kLCA1IF0sIFsgZDNfdGltZS5zZWNvbmQsIDE1IF0sIFsgZDNfdGltZS5zZWNvbmQsIDMwIF0sIFsgZDNfdGltZS5taW51dGUsIDEgXSwgWyBkM190aW1lLm1pbnV0ZSwgNSBdLCBbIGQzX3RpbWUubWludXRlLCAxNSBdLCBbIGQzX3RpbWUubWludXRlLCAzMCBdLCBbIGQzX3RpbWUuaG91ciwgMSBdLCBbIGQzX3RpbWUuaG91ciwgMyBdLCBbIGQzX3RpbWUuaG91ciwgNiBdLCBbIGQzX3RpbWUuaG91ciwgMTIgXSwgWyBkM190aW1lLmRheSwgMSBdLCBbIGQzX3RpbWUuZGF5LCAyIF0sIFsgZDNfdGltZS53ZWVrLCAxIF0sIFsgZDNfdGltZS5tb250aCwgMSBdLCBbIGQzX3RpbWUubW9udGgsIDMgXSwgWyBkM190aW1lLnllYXIsIDEgXSBdO1xuICB2YXIgZDNfdGltZV9zY2FsZUxvY2FsRm9ybWF0ID0gZDNfdGltZV9mb3JtYXQubXVsdGkoWyBbIFwiLiVMXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNaWxsaXNlY29uZHMoKTtcbiAgfSBdLCBbIFwiOiVTXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRTZWNvbmRzKCk7XG4gIH0gXSwgWyBcIiVJOiVNXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRNaW51dGVzKCk7XG4gIH0gXSwgWyBcIiVJICVwXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRIb3VycygpO1xuICB9IF0sIFsgXCIlYSAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0RGF5KCkgJiYgZC5nZXREYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJWIgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldERhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlQlwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TW9udGgoKTtcbiAgfSBdLCBbIFwiJVlcIiwgZDNfdHJ1ZSBdIF0pO1xuICB2YXIgZDNfdGltZV9zY2FsZU1pbGxpc2Vjb25kcyA9IHtcbiAgICByYW5nZTogZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgIHJldHVybiBkMy5yYW5nZShNYXRoLmNlaWwoc3RhcnQgLyBzdGVwKSAqIHN0ZXAsICtzdG9wLCBzdGVwKS5tYXAoZDNfdGltZV9zY2FsZURhdGUpO1xuICAgIH0sXG4gICAgZmxvb3I6IGQzX2lkZW50aXR5LFxuICAgIGNlaWw6IGQzX2lkZW50aXR5XG4gIH07XG4gIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMueWVhciA9IGQzX3RpbWUueWVhcjtcbiAgZDNfdGltZS5zY2FsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM190aW1lX3NjYWxlKGQzLnNjYWxlLmxpbmVhcigpLCBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLCBkM190aW1lX3NjYWxlTG9jYWxGb3JtYXQpO1xuICB9O1xuICB2YXIgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMgPSBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIFsgbVswXS51dGMsIG1bMV0gXTtcbiAgfSk7XG4gIHZhciBkM190aW1lX3NjYWxlVXRjRm9ybWF0ID0gZDNfdGltZV9mb3JtYXRVdGMubXVsdGkoWyBbIFwiLiVMXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgfSBdLCBbIFwiOiVTXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENTZWNvbmRzKCk7XG4gIH0gXSwgWyBcIiVJOiVNXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENNaW51dGVzKCk7XG4gIH0gXSwgWyBcIiVJICVwXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENIb3VycygpO1xuICB9IF0sIFsgXCIlYSAlZFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDRGF5KCkgJiYgZC5nZXRVVENEYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJWIgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RhdGUoKSAhPSAxO1xuICB9IF0sIFsgXCIlQlwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTW9udGgoKTtcbiAgfSBdLCBbIFwiJVlcIiwgZDNfdHJ1ZSBdIF0pO1xuICBkM190aW1lX3NjYWxlVXRjTWV0aG9kcy55ZWFyID0gZDNfdGltZS55ZWFyLnV0YztcbiAgZDNfdGltZS5zY2FsZS51dGMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfdGltZV9zY2FsZShkMy5zY2FsZS5saW5lYXIoKSwgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMsIGQzX3RpbWVfc2NhbGVVdGNGb3JtYXQpO1xuICB9O1xuICBkMy50ZXh0ID0gZDNfeGhyVHlwZShmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9KTtcbiAgZDMuanNvbiA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfeGhyKHVybCwgXCJhcHBsaWNhdGlvbi9qc29uXCIsIGQzX2pzb24sIGNhbGxiYWNrKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfanNvbihyZXF1ZXN0KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICB9XG4gIGQzLmh0bWwgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3hocih1cmwsIFwidGV4dC9odG1sXCIsIGQzX2h0bWwsIGNhbGxiYWNrKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaHRtbChyZXF1ZXN0KSB7XG4gICAgdmFyIHJhbmdlID0gZDNfZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlKGQzX2RvY3VtZW50LmJvZHkpO1xuICAgIHJldHVybiByYW5nZS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICB9XG4gIGQzLnhtbCA9IGQzX3hoclR5cGUoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlWE1MO1xuICB9KTtcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB0aGlzLmQzID0gZDMsIGRlZmluZShkMyk7IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gZDM7IGVsc2UgdGhpcy5kMyA9IGQzO1xufSgpOyIsIi8qIG52ZDMgdmVyc2lvbiAxLjguNSAoaHR0cHM6Ly9naXRodWIuY29tL25vdnVzL252ZDMpIDIwMTYtMTItMDEgKi9cbihmdW5jdGlvbigpe1xuXG4vLyBzZXQgdXAgbWFpbiBudiBvYmplY3RcbnZhciBudiA9IHt9O1xuXG4vLyB0aGUgbWFqb3IgZ2xvYmFsIG9iamVjdHMgdW5kZXIgdGhlIG52IG5hbWVzcGFjZVxubnYuZGV2ID0gZmFsc2U7IC8vc2V0IGZhbHNlIHdoZW4gaW4gcHJvZHVjdGlvblxubnYudG9vbHRpcCA9IG52LnRvb2x0aXAgfHwge307IC8vIEZvciB0aGUgdG9vbHRpcCBzeXN0ZW1cbm52LnV0aWxzID0gbnYudXRpbHMgfHwge307IC8vIFV0aWxpdHkgc3Vic3lzdGVtXG5udi5tb2RlbHMgPSBudi5tb2RlbHMgfHwge307IC8vc3RvcmVzIGFsbCB0aGUgcG9zc2libGUgbW9kZWxzL2NvbXBvbmVudHNcbm52LmNoYXJ0cyA9IHt9OyAvL3N0b3JlcyBhbGwgdGhlIHJlYWR5IHRvIHVzZSBjaGFydHNcbm52LmxvZ3MgPSB7fTsgLy9zdG9yZXMgc29tZSBzdGF0aXN0aWNzIGFuZCBwb3RlbnRpYWwgZXJyb3IgbWVzc2FnZXNcbm52LmRvbSA9IHt9OyAvL0RPTSBtYW5pcHVsYXRpb24gZnVuY3Rpb25zXG5cbi8vIE5vZGUvQ29tbW9uSlMgLSByZXF1aXJlIEQzXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mKGQzKSA9PSAndW5kZWZpbmVkJykge1xuICAgIGQzID0gcmVxdWlyZSgnZDMnKTtcbn1cblxubnYuZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyX3N0YXJ0JywgJ3JlbmRlcl9lbmQnKTtcblxuLy8gRnVuY3Rpb24gYmluZCBwb2x5ZmlsbFxuLy8gTmVlZGVkIE9OTFkgZm9yIHBoYW50b21KUyBhcyBpdCdzIG1pc3NpbmcgdW50aWwgdmVyc2lvbiAyLjAgd2hpY2ggaXMgdW5yZWxlYXNlZCBhcyBvZiB0aGlzIGNvbW1lbnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzEwNTIyXG4vLyBodHRwOi8va2FuZ2F4LmdpdGh1Yi5pby9jb21wYXQtdGFibGUvZXM1LyNGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuLy8gcGhhbnRvbUpTIGlzIHVzZWQgZm9yIHJ1bm5pbmcgdGhlIHRlc3Qgc3VpdGVcbmlmICghRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpIHtcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1IGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXG4gICAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICAgIGZOT1AgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIGZCb3VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCAmJiBvVGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9UaGlzLFxuICAgICAgICAgICAgICAgICAgICBhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcbiAgICAgICAgcmV0dXJuIGZCb3VuZDtcbiAgICB9O1xufVxuXG4vLyAgRGV2ZWxvcG1lbnQgcmVuZGVyIHRpbWVycyAtIGRpc2FibGVkIGlmIGRldiA9IGZhbHNlXG5pZiAobnYuZGV2KSB7XG4gICAgbnYuZGlzcGF0Y2gub24oJ3JlbmRlcl9zdGFydCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbnYubG9ncy5zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICB9KTtcblxuICAgIG52LmRpc3BhdGNoLm9uKCdyZW5kZXJfZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBudi5sb2dzLmVuZFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgbnYubG9ncy50b3RhbFRpbWUgPSBudi5sb2dzLmVuZFRpbWUgLSBudi5sb2dzLnN0YXJ0VGltZTtcbiAgICAgICAgbnYubG9nKCd0b3RhbCcsIG52LmxvZ3MudG90YWxUaW1lKTsgLy8gdXNlZCBmb3IgZGV2ZWxvcG1lbnQsIHRvIGtlZXAgdHJhY2sgb2YgZ3JhcGggZ2VuZXJhdGlvbiB0aW1lc1xuICAgIH0pO1xufVxuXG4vLyBMb2dzIGFsbCBhcmd1bWVudHMsIGFuZCByZXR1cm5zIHRoZSBsYXN0IHNvIHlvdSBjYW4gdGVzdCB0aGluZ3MgaW4gcGxhY2Vcbi8vIE5vdGU6IGluIElFOCBjb25zb2xlLmxvZyBpcyBhbiBvYmplY3Qgbm90IGEgZnVuY3Rpb24sIGFuZCBpZiBtb2Rlcm5penIgaXMgdXNlZFxuLy8gdGhlbiBjYWxsaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHdpdGggd2l0aCBhbnl0aGluZyBvdGhlciB0aGFuIGEgZnVuY3Rpb25cbi8vIGNhdXNlcyBhIFR5cGVFcnJvciB0byBiZSB0aHJvd24uXG5udi5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAobnYuZGV2ICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nICYmIGNvbnNvbGUubG9nLmFwcGx5KVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIGVsc2UgaWYgKG52LmRldiAmJiB3aW5kb3cuY29uc29sZSAmJiB0eXBlb2YgY29uc29sZS5sb2cgPT0gXCJmdW5jdGlvblwiICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kKSB7XG4gICAgICAgIHZhciBsb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgICAgICAgbG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xufTtcblxuLy8gcHJpbnQgY29uc29sZSB3YXJuaW5nLCBzaG91bGQgYmUgdXNlZCBieSBkZXByZWNhdGVkIGZ1bmN0aW9uc1xubnYuZGVwcmVjYXRlZCA9IGZ1bmN0aW9uKG5hbWUsIGluZm8pIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdudmQzIHdhcm5pbmc6IGAnICsgbmFtZSArICdgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuICcsIGluZm8gfHwgJycpO1xuICAgIH1cbn07XG5cbi8vIFRoZSBudi5yZW5kZXIgZnVuY3Rpb24gaXMgdXNlZCB0byBxdWV1ZSB1cCBjaGFydCByZW5kZXJpbmdcbi8vIGluIG5vbi1ibG9ja2luZyBhc3luYyBmdW5jdGlvbnMuXG4vLyBXaGVuIGFsbCBxdWV1ZWQgY2hhcnRzIGFyZSBkb25lIHJlbmRlcmluZywgbnYuZGlzcGF0Y2gucmVuZGVyX2VuZCBpcyBpbnZva2VkLlxubnYucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHN0ZXApIHtcbiAgICAvLyBudW1iZXIgb2YgZ3JhcGhzIHRvIGdlbmVyYXRlIGluIGVhY2ggdGltZW91dCBsb29wXG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIG52LnJlbmRlci5hY3RpdmUgPSB0cnVlO1xuICAgIG52LmRpc3BhdGNoLnJlbmRlcl9zdGFydCgpO1xuXG4gICAgdmFyIHJlbmRlckxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYXJ0LCBncmFwaDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ZXAgJiYgKGdyYXBoID0gbnYucmVuZGVyLnF1ZXVlW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBjaGFydCA9IGdyYXBoLmdlbmVyYXRlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdyYXBoLmNhbGxiYWNrID09IHR5cGVvZihGdW5jdGlvbikpIGdyYXBoLmNhbGxiYWNrKGNoYXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG52LnJlbmRlci5xdWV1ZS5zcGxpY2UoMCwgaSk7XG5cbiAgICAgICAgaWYgKG52LnJlbmRlci5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVuZGVyTG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBudi5kaXNwYXRjaC5yZW5kZXJfZW5kKCk7XG4gICAgICAgICAgICBudi5yZW5kZXIuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0VGltZW91dChyZW5kZXJMb29wKTtcbn07XG5cbm52LnJlbmRlci5hY3RpdmUgPSBmYWxzZTtcbm52LnJlbmRlci5xdWV1ZSA9IFtdO1xuXG4vKlxuQWRkcyBhIGNoYXJ0IHRvIHRoZSBhc3luYyByZW5kZXJpbmcgcXVldWUuIFRoaXMgbWV0aG9kIGNhbiB0YWtlIGFyZ3VtZW50cyBpbiB0d28gZm9ybXM6XG5udi5hZGRHcmFwaCh7XG4gICAgZ2VuZXJhdGU6IDxGdW5jdGlvbj5cbiAgICBjYWxsYmFjazogPEZ1bmN0aW9uPlxufSlcblxub3JcblxubnYuYWRkR3JhcGgoPGdlbmVyYXRlIEZ1bmN0aW9uPiwgPGNhbGxiYWNrIEZ1bmN0aW9uPilcblxuVGhlIGdlbmVyYXRlIGZ1bmN0aW9uIHNob3VsZCBjb250YWluIGNvZGUgdGhhdCBjcmVhdGVzIHRoZSBOVkQzIG1vZGVsLCBzZXRzIG9wdGlvbnNcbm9uIGl0LCBhZGRzIGRhdGEgdG8gYW4gU1ZHIGVsZW1lbnQsIGFuZCBpbnZva2VzIHRoZSBjaGFydCBtb2RlbC4gVGhlIGdlbmVyYXRlIGZ1bmN0aW9uXG5zaG91bGQgcmV0dXJuIHRoZSBjaGFydCBtb2RlbC4gIFNlZSBleGFtcGxlcy9saW5lQ2hhcnQuaHRtbCBmb3IgYSB1c2FnZSBleGFtcGxlLlxuXG5UaGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgb3B0aW9uYWwsIGFuZCBpdCBpcyBjYWxsZWQgd2hlbiB0aGUgZ2VuZXJhdGUgZnVuY3Rpb24gY29tcGxldGVzLlxuKi9cbm52LmFkZEdyYXBoID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IHR5cGVvZihGdW5jdGlvbikpIHtcbiAgICAgICAgb2JqID0ge2dlbmVyYXRlOiBhcmd1bWVudHNbMF0sIGNhbGxiYWNrOiBhcmd1bWVudHNbMV19O1xuICAgIH1cblxuICAgIG52LnJlbmRlci5xdWV1ZS5wdXNoKG9iaik7XG5cbiAgICBpZiAoIW52LnJlbmRlci5hY3RpdmUpIHtcbiAgICAgICAgbnYucmVuZGVyKCk7XG4gICAgfVxufTtcblxuLy8gTm9kZS9Db21tb25KUyBleHBvcnRzXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBudjtcbn1cblxuaWYgKHR5cGVvZih3aW5kb3cpICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cubnYgPSBudjtcbn1cbi8qIEZhY2FkZSBmb3IgcXVldWVpbmcgRE9NIHdyaXRlIG9wZXJhdGlvbnNcclxuICogd2l0aCBGYXN0ZG9tIChodHRwczovL2dpdGh1Yi5jb20vd2lsc29ucGFnZS9mYXN0ZG9tKVxyXG4gKiBpZiBhdmFpbGFibGUuXHJcbiAqIFRoaXMgY291bGQgZWFzaWx5IGJlIGV4dGVuZGVkIHRvIHN1cHBvcnQgYWx0ZXJuYXRlXHJcbiAqIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZnV0dXJlLlxyXG4gKi9cclxubnYuZG9tLndyaXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRpZiAod2luZG93LmZhc3Rkb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIGZhc3Rkb20ubXV0YXRlKGNhbGxiYWNrKTtcclxuXHR9XHJcblx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcbn07XHJcblxyXG4vKiBGYWNhZGUgZm9yIHF1ZXVlaW5nIERPTSByZWFkIG9wZXJhdGlvbnNcclxuICogd2l0aCBGYXN0ZG9tIChodHRwczovL2dpdGh1Yi5jb20vd2lsc29ucGFnZS9mYXN0ZG9tKVxyXG4gKiBpZiBhdmFpbGFibGUuXHJcbiAqIFRoaXMgY291bGQgZWFzaWx5IGJlIGV4dGVuZGVkIHRvIHN1cHBvcnQgYWx0ZXJuYXRlXHJcbiAqIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZnV0dXJlLlxyXG4gKi9cclxubnYuZG9tLnJlYWQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdGlmICh3aW5kb3cuZmFzdGRvbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRyZXR1cm4gZmFzdGRvbS5tZWFzdXJlKGNhbGxiYWNrKTtcclxuXHR9XHJcblx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcbn07XHJcbi8qIFV0aWxpdHkgY2xhc3MgdG8gaGFuZGxlIGNyZWF0aW9uIG9mIGFuIGludGVyYWN0aXZlIGxheWVyLlxuIFRoaXMgcGxhY2VzIGEgcmVjdGFuZ2xlIG9uIHRvcCBvZiB0aGUgY2hhcnQuIFdoZW4geW91IG1vdXNlIG1vdmUgb3ZlciBpdCwgaXQgc2VuZHMgYSBkaXNwYXRjaFxuIGNvbnRhaW5pbmcgdGhlIFgtY29vcmRpbmF0ZS4gSXQgY2FuIGFsc28gcmVuZGVyIGEgdmVydGljYWwgbGluZSB3aGVyZSB0aGUgbW91c2UgaXMgbG9jYXRlZC5cblxuIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUgaXMgdGhlIGltcG9ydGFudCBldmVudCB0byBsYXRjaCBvbnRvLiAgSXQgaXMgZmlyZWQgd2hlbmV2ZXIgdGhlIG1vdXNlIG1vdmVzIG92ZXJcbiB0aGUgcmVjdGFuZ2xlLiBUaGUgZGlzcGF0Y2ggaXMgZ2l2ZW4gb25lIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbW91c2VYL1kgbG9jYXRpb24uXG4gSXQgYWxzbyBoYXMgJ3BvaW50WFZhbHVlJywgd2hpY2ggaXMgdGhlIGNvbnZlcnNpb24gb2YgbW91c2VYIHRvIHRoZSB4LWF4aXMgc2NhbGUuXG4gKi9cbm52LmludGVyYWN0aXZlR3VpZGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgbWFyZ2luID0geyBsZWZ0OiAwLCB0b3A6IDAgfSAvL1Bhc3MgdGhlIGNoYXJ0J3MgdG9wIGFuZCBsZWZ0IG1hZ2lucy4gVXNlZCB0byBjYWxjdWxhdGUgdGhlIG1vdXNlWC9ZLlxuICAgICAgICAsICAgd2lkdGggPSBudWxsXG4gICAgICAgICwgICBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgICB4U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsICAgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudE1vdXNlbW92ZScsICdlbGVtZW50TW91c2VvdXQnLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxjbGljaycsICdlbGVtZW50TW91c2VEb3duJywgJ2VsZW1lbnRNb3VzZVVwJylcbiAgICAgICAgLCAgIHNob3dHdWlkZUxpbmUgPSB0cnVlXG4gICAgICAgICwgICBzdmdDb250YWluZXIgPSBudWxsIC8vIE11c3QgcGFzcyB0aGUgY2hhcnQncyBzdmcsIHdlJ2xsIHVzZSBpdHMgbW91c2Vtb3ZlIGV2ZW50LlxuICAgICAgICAsICAgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKClcbiAgICAgICAgLCAgIGlzTVNJRSA9ICB3aW5kb3cuQWN0aXZlWE9iamVjdC8vIENoZWNrdCBpZiBJRSBieSBsb29raW5nIGZvciBhY3RpdmVYLiAoZXhjbHVkZXMgSUUxMSlcbiAgICA7XG5cbiAgICB0b29sdGlwXG4gICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAuaGlkZURlbGF5KDApXG4gICAgICAgIC5oaWRkZW4oZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gbGF5ZXIoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggfHwgOTYwKSwgYXZhaWxhYmxlSGVpZ2h0ID0gKGhlaWdodCB8fCA0MDApO1xuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKFwiZy5udi13cmFwLm52LWludGVyYWN0aXZlTGluZUxheWVyXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCIgbnYtd3JhcCBudi1pbnRlcmFjdGl2ZUxpbmVMYXllclwiKTtcbiAgICAgICAgICAgIHdyYXBFbnRlci5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLFwibnYtaW50ZXJhY3RpdmVHdWlkZUxpbmVcIik7XG5cbiAgICAgICAgICAgIGlmICghc3ZnQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBtb3VzZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQzbW91c2UgPSBkMy5tb3VzZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgbW91c2VYID0gZDNtb3VzZVswXTtcbiAgICAgICAgICAgICAgICB2YXIgbW91c2VZID0gZDNtb3VzZVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgc3VidHJhY3RNYXJnaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBtb3VzZU91dEFueVJlYXNvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpc01TSUUpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgIEQzLmpzIChvciBtYXliZSBTVkcuZ2V0U2NyZWVuQ1RNKSBoYXMgYSBuYXN0eSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gICAgICAgICAgICAgICAgICAgICBkMy5tb3VzZSgpIHJldHVybnMgaW5jb3JyZWN0IFgsWSBtb3VzZSBjb29yZGluYXRlcyB3aGVuIG1vdXNlIG1vdmluZ1xuICAgICAgICAgICAgICAgICAgICAgb3ZlciBhIHJlY3QgaW4gSUUgMTAuXG4gICAgICAgICAgICAgICAgICAgICBIb3dldmVyLCBkMy5ldmVudC5vZmZzZXRYL1kgYWxzbyByZXR1cm5zIHRoZSBtb3VzZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUgdG8gdGhlIHRyaWdnZXJpbmcgPHJlY3Q+LiBTbyB3ZSB1c2Ugb2Zmc2V0WC9ZIG9uIElFLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbW91c2VYID0gZDMuZXZlbnQub2Zmc2V0WDtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VZID0gZDMuZXZlbnQub2Zmc2V0WTtcblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgT24gSUUsIGlmIHlvdSBhdHRhY2ggYSBtb3VzZSBldmVudCBsaXN0ZW5lciB0byB0aGUgPHN2Zz4gY29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBhY3R1YWxseSB0cmlnZ2VyIGl0IGZvciBhbGwgdGhlIGNoaWxkIGVsZW1lbnRzIChsaWtlIDxwYXRoPiwgPGNpcmNsZT4sIGV0YykuXG4gICAgICAgICAgICAgICAgICAgICBXaGVuIHRoaXMgaGFwcGVucyBvbiBJRSwgdGhlIG9mZnNldFgvWSBpcyBzZXQgdG8gd2hlcmUgZXZlciB0aGUgY2hpbGQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgaXMgbG9jYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgIEFzIGEgcmVzdWx0LCB3ZSBkbyBOT1QgbmVlZCB0byBzdWJ0cmFjdCBtYXJnaW5zIHRvIGZpZ3VyZSBvdXQgdGhlIG1vdXNlIFgvWVxuICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gdW5kZXIgdGhpcyBzY2VuYXJpby4gUmVtb3ZpbmcgdGhlIGxpbmUgYmVsb3cgKndpbGwqIGNhdXNlXG4gICAgICAgICAgICAgICAgICAgICB0aGUgaW50ZXJhY3RpdmUgbGF5ZXIgdG8gbm90IHdvcmsgcmlnaHQgb24gSUUuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZihkMy5ldmVudC50YXJnZXQudGFnTmFtZSAhPT0gXCJzdmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJhY3RNYXJnaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudC50YXJnZXQuY2xhc3NOYW1lLmJhc2VWYWwubWF0Y2goXCJudi1sZWdlbmRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlT3V0QW55UmVhc29uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoc3VidHJhY3RNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VYIC09IG1hcmdpbi5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBtb3VzZVkgLT0gbWFyZ2luLnRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBJZiBtb3VzZVgvWSBpcyBvdXRzaWRlIG9mIHRoZSBjaGFydCdzIGJvdW5kcyxcbiAgICAgICAgICAgICAgICAgdHJpZ2dlciBhIG1vdXNlT3V0IGV2ZW50LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudC50eXBlID09PSAnbW91c2VvdXQnXG4gICAgICAgICAgICAgICAgICAgIHx8IG1vdXNlWCA8IDAgfHwgbW91c2VZIDwgMFxuICAgICAgICAgICAgICAgICAgICB8fCBtb3VzZVggPiBhdmFpbGFibGVXaWR0aCB8fCBtb3VzZVkgPiBhdmFpbGFibGVIZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgfHwgKGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXQgJiYgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5vd25lclNWR0VsZW1lbnQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgfHwgbW91c2VPdXRBbnlSZWFzb25cbiAgICAgICAgICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTVNJRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBkMy5ldmVudC5yZWxhdGVkVGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKGQzLmV2ZW50LnJlbGF0ZWRUYXJnZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgZDMuZXZlbnQucmVsYXRlZFRhcmdldC5jbGFzc05hbWUubWF0Y2godG9vbHRpcC5udlBvaW50ZXJFdmVudHNDbGFzcykpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VZOiBtb3VzZVlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLnJlbmRlckd1aWRlTGluZShudWxsKTsgLy9oaWRlIHRoZSBndWlkZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVJc09yZGluYWwgPSB0eXBlb2YgeFNjYWxlLnJhbmdlQmFuZHMgPT09ICdmdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50WFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgLy8gT3JkaW5hbCBzY2FsZSBoYXMgbm8gaW52ZXJ0IG1ldGhvZFxuICAgICAgICAgICAgICAgIGlmIChzY2FsZUlzT3JkaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudEluZGV4ID0gZDMuYmlzZWN0KHhTY2FsZS5yYW5nZSgpLCBtb3VzZVgpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbW91c2VYIGlzIGluIHRoZSByYW5nZSBiYW5kXG4gICAgICAgICAgICAgICAgICAgIGlmICh4U2NhbGUucmFuZ2UoKVtlbGVtZW50SW5kZXhdICsgeFNjYWxlLnJhbmdlQmFuZCgpID49IG1vdXNlWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRYVmFsdWUgPSB4U2NhbGUuZG9tYWluKClbZDMuYmlzZWN0KHhTY2FsZS5yYW5nZSgpLCBtb3VzZVgpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLnJlbmRlckd1aWRlTGluZShudWxsKTsgLy9oaWRlIHRoZSBndWlkZWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwb2ludFhWYWx1ZSA9IHhTY2FsZS5pbnZlcnQobW91c2VYKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VYOiBtb3VzZVgsXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlWTogbW91c2VZLFxuICAgICAgICAgICAgICAgICAgICBwb2ludFhWYWx1ZTogcG9pbnRYVmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vSWYgdXNlciBkb3VibGUgY2xpY2tzIHRoZSBsYXllciwgZmlyZSBhIGVsZW1lbnREYmxjbGlja1xuICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudC50eXBlID09PSBcImRibGNsaWNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibGNsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VZOiBtb3VzZVksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFhWYWx1ZTogcG9pbnRYVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBzaW5nbGUgY2xpY2tzIHRoZSBsYXllciwgZmlyZSBlbGVtZW50Q2xpY2tcbiAgICAgICAgICAgICAgICBpZiAoZDMuZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VYOiBtb3VzZVgsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZVk6IG1vdXNlWSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50WFZhbHVlOiBwb2ludFhWYWx1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHByZXNzZXMgbW91c2UgZG93biB0aGUgbGF5ZXIsIGZpcmUgZWxlbWVudE1vdXNlRG93blxuICAgICAgICAgICAgICAgIGlmIChkMy5ldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgIFx0ZGlzcGF0Y2guZWxlbWVudE1vdXNlRG93bih7XG4gICAgICAgICAgICAgICAgXHRcdG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgIFx0XHRtb3VzZVk6IG1vdXNlWSxcbiAgICAgICAgICAgICAgICBcdFx0cG9pbnRYVmFsdWU6IHBvaW50WFZhbHVlXG4gICAgICAgICAgICAgICAgXHR9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHByZXNzZXMgbW91c2UgZG93biB0aGUgbGF5ZXIsIGZpcmUgZWxlbWVudE1vdXNlVXBcbiAgICAgICAgICAgICAgICBpZiAoZDMuZXZlbnQudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAgICAgICAgICAgXHRkaXNwYXRjaC5lbGVtZW50TW91c2VVcCh7XG4gICAgICAgICAgICAgICAgXHRcdG1vdXNlWDogbW91c2VYLFxuICAgICAgICAgICAgICAgIFx0XHRtb3VzZVk6IG1vdXNlWSxcbiAgICAgICAgICAgICAgICBcdFx0cG9pbnRYVmFsdWU6IHBvaW50WFZhbHVlXG4gICAgICAgICAgICAgICAgXHR9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN2Z0NvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5vbihcInRvdWNobW92ZVwiLG1vdXNlSGFuZGxlcilcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW1vdmVcIixtb3VzZUhhbmRsZXIsIHRydWUpXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiAsbW91c2VIYW5kbGVyLHRydWUpXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2Vkb3duXCIgLG1vdXNlSGFuZGxlcix0cnVlKVxuICAgICAgICAgICAgICAgIC5vbihcIm1vdXNldXBcIiAsbW91c2VIYW5kbGVyLHRydWUpXG4gICAgICAgICAgICAgICAgLm9uKFwiZGJsY2xpY2tcIiAsbW91c2VIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIsIG1vdXNlSGFuZGxlcilcbiAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgbGF5ZXIuZ3VpZGVMaW5lID0gbnVsbDtcbiAgICAgICAgICAgIC8vRHJhd3MgYSB2ZXJ0aWNhbCBndWlkZWxpbmUgYXQgdGhlIGdpdmVuIFggcG9zdGlvbi5cbiAgICAgICAgICAgIGxheWVyLnJlbmRlckd1aWRlTGluZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNob3dHdWlkZUxpbmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuZ3VpZGVMaW5lICYmIGxheWVyLmd1aWRlTGluZS5hdHRyKFwieDFcIikgPT09IHgpIHJldHVybjtcbiAgICAgICAgICAgICAgICBudi5kb20ud3JpdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaW5lID0gd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVHdWlkZUxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJsaW5lXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YSgoeCAhPSBudWxsKSA/IFtudi51dGlscy5OYU50b1plcm8oeCldIDogW10sIFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJudi1ndWlkZWxpbmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwwKTtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGxheWVyLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgbGF5ZXIudG9vbHRpcCA9IHRvb2x0aXA7XG5cbiAgICBsYXllci5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICAgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgbWFyZ2luLmxlZnQgICA9IHR5cGVvZiBfLmxlZnQgICAhPSAndW5kZWZpbmVkJyA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIud2lkdGggPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHdpZHRoO1xuICAgICAgICB3aWR0aCA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIuaGVpZ2h0ID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIueFNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4U2NhbGU7XG4gICAgICAgIHhTY2FsZSA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIuc2hvd0d1aWRlTGluZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2hvd0d1aWRlTGluZTtcbiAgICAgICAgc2hvd0d1aWRlTGluZSA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgbGF5ZXIuc3ZnQ29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdmdDb250YWluZXI7XG4gICAgICAgIHN2Z0NvbnRhaW5lciA9IF87XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxheWVyO1xufTtcblxuLyogVXRpbGl0eSBjbGFzcyB0aGF0IHVzZXMgZDMuYmlzZWN0IHRvIGZpbmQgdGhlIGluZGV4IGluIGEgZ2l2ZW4gYXJyYXksIHdoZXJlIGEgc2VhcmNoIHZhbHVlIGNhbiBiZSBpbnNlcnRlZC5cbiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIG5vcm1hbCBiaXNlY3RMZWZ0OyB0aGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBuZWFyZXN0IGluZGV4IHRvIGluc2VydCB0aGUgc2VhcmNoIHZhbHVlLlxuXG4gRm9yIGluc3RhbmNlLCBsZXRzIHNheSB5b3VyIGFycmF5IGlzIFsxLDIsMyw1LDEwLDMwXSwgYW5kIHlvdSBzZWFyY2ggZm9yIDI4LlxuIE5vcm1hbCBkMy5iaXNlY3RMZWZ0IHdpbGwgcmV0dXJuIDQsIGJlY2F1c2UgMjggaXMgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIG51bWJlciAxMC4gIEJ1dCBpbnRlcmFjdGl2ZUJpc2VjdCB3aWxsIHJldHVybiA1XG4gYmVjYXVzZSAyOCBpcyBjbG9zZXIgdG8gMzAgdGhhbiAxMC5cblxuIFVuaXQgdGVzdHMgY2FuIGJlIGZvdW5kIGluOiBpbnRlcmFjdGl2ZUJpc2VjdFRlc3QuaHRtbFxuXG4gSGFzIHRoZSBmb2xsb3dpbmcga25vd24gaXNzdWVzOlxuICogV2lsbCBub3Qgd29yayBpZiB0aGUgZGF0YSBwb2ludHMgbW92ZSBiYWNrd2FyZHMgKGllLCAxMCw5LDgsNywgZXRjKSBvciBpZiB0aGUgZGF0YSBwb2ludHMgYXJlIGluIHJhbmRvbSBvcmRlci5cbiAqIFdvbid0IHdvcmsgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZSB4IGNvb3JkaW5hdGUgdmFsdWVzLlxuICovXG5udi5pbnRlcmFjdGl2ZUJpc2VjdCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNlYXJjaFZhbCwgeEFjY2Vzc29yKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKCEgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIF94QWNjZXNzb3I7XG4gICAgaWYgKHR5cGVvZiB4QWNjZXNzb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX3hBY2Nlc3NvciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLng7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBfeEFjY2Vzc29yID0geEFjY2Vzc29yO1xuICAgIH1cbiAgICB2YXIgX2NtcCA9IGZ1bmN0aW9uKGQsIHYpIHtcbiAgICAgICAgLy8gQWNjZXNzb3JzIGFyZSBubyBsb25nZXIgcGFzc2VkIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBhbG9uZyB3aXRoXG4gICAgICAgIC8vIHRoZSBlbGVtZW50IGl0c2VsZiB3aGVuIGludm9rZWQgYnkgZDMuYmlzZWN0b3IuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFN0YXJ0aW5nIGF0IEQzIHYzLjQuNCwgZDMuYmlzZWN0b3IoKSBzdGFydGVkIGluc3BlY3RpbmcgdGhlXG4gICAgICAgIC8vIGZ1bmN0aW9uIHBhc3NlZCB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIGNvbnNpZGVyIGl0IGFuIGFjY2Vzc29yXG4gICAgICAgIC8vIG9yIGEgY29tcGFyYXRvci4gVGhpcyBtZWFudCB0aGF0IGFjY2Vzc29ycyB0aGF0IHRha2UgdHdvIGFyZ3VtZW50c1xuICAgICAgICAvLyAoZXhwZWN0aW5nIGFuIGluZGV4IGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyKSBhcmUgdHJlYXRlZCBhc1xuICAgICAgICAvLyBjb21wYXJhdG9ycyB3aGVyZSB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIHRoZSBzZWFyY2ggdmFsdWUgYWdhaW5zdFxuICAgICAgICAvLyB3aGljaCB0aGUgZmlyc3QgYXJndW1lbnQgaXMgY29tcGFyZWQuXG4gICAgICAgIHJldHVybiBfeEFjY2Vzc29yKGQpIC0gdjtcbiAgICB9O1xuXG4gICAgdmFyIGJpc2VjdCA9IGQzLmJpc2VjdG9yKF9jbXApLmxlZnQ7XG4gICAgdmFyIGluZGV4ID0gZDMubWF4KFswLCBiaXNlY3QodmFsdWVzLHNlYXJjaFZhbCkgLSAxXSk7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IF94QWNjZXNzb3IodmFsdWVzW2luZGV4XSk7XG5cbiAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gc2VhcmNoVmFsKSB7XG4gICAgICAgIHJldHVybiBpbmRleDsgLy9mb3VuZCBleGFjdCBtYXRjaFxuICAgIH1cblxuICAgIHZhciBuZXh0SW5kZXggPSBkMy5taW4oW2luZGV4KzEsIHZhbHVlcy5sZW5ndGggLSAxXSk7XG4gICAgdmFyIG5leHRWYWx1ZSA9IF94QWNjZXNzb3IodmFsdWVzW25leHRJbmRleF0pO1xuXG4gICAgaWYgKHR5cGVvZiBuZXh0VmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5leHRWYWx1ZSA9IG5leHRJbmRleDtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnMobmV4dFZhbHVlIC0gc2VhcmNoVmFsKSA+PSBNYXRoLmFicyhjdXJyZW50VmFsdWUgLSBzZWFyY2hWYWwpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV4dEluZGV4XG4gICAgfVxufTtcblxuLypcbiBSZXR1cm5zIHRoZSBpbmRleCBpbiB0aGUgYXJyYXkgXCJ2YWx1ZXNcIiB0aGF0IGlzIGNsb3Nlc3QgdG8gc2VhcmNoVmFsLlxuIE9ubHkgcmV0dXJucyBhbiBpbmRleCBpZiBzZWFyY2hWYWwgaXMgd2l0aGluIHNvbWUgXCJ0aHJlc2hvbGRcIi5cbiBPdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiAqL1xubnYubmVhcmVzdFZhbHVlSW5kZXggPSBmdW5jdGlvbiAodmFsdWVzLCBzZWFyY2hWYWwsIHRocmVzaG9sZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB5RGlzdE1heCA9IEluZmluaXR5LCBpbmRleFRvSGlnaGxpZ2h0ID0gbnVsbDtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2VhcmNoVmFsIC0gZCk7XG4gICAgICAgIGlmICggZCAhPSBudWxsICYmIGRlbHRhIDw9IHlEaXN0TWF4ICYmIGRlbHRhIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICB5RGlzdE1heCA9IGRlbHRhO1xuICAgICAgICAgICAgaW5kZXhUb0hpZ2hsaWdodCA9IGk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5kZXhUb0hpZ2hsaWdodDtcbn07XG5cbi8qIE1vZGVsIHdoaWNoIGNhbiBiZSBpbnN0YW50aWF0ZWQgdG8gaGFuZGxlIHRvb2x0aXAgcmVuZGVyaW5nLlxuIEV4YW1wbGUgdXNhZ2U6XG4gdmFyIHRpcCA9IG52Lm1vZGVscy50b29sdGlwKCkuZ3Jhdml0eSgndycpLmRpc3RhbmNlKDIzKVxuIC5kYXRhKG15RGF0YU9iamVjdCk7XG5cbiB0aXAoKTsgICAgLy9qdXN0IGludm9rZSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdG8gcmVuZGVyIHRvb2x0aXAuXG4gKi9cbm52Lm1vZGVscy50b29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvKlxuICAgIFRvb2x0aXAgZGF0YS4gSWYgZGF0YSBpcyBnaXZlbiBpbiB0aGUgcHJvcGVyIGZvcm1hdCwgYSBjb25zaXN0ZW50IHRvb2x0aXAgaXMgZ2VuZXJhdGVkLlxuICAgIEV4YW1wbGUgRm9ybWF0IG9mIGRhdGE6XG4gICAge1xuICAgICAgICBrZXk6IFwiRGF0ZVwiLFxuICAgICAgICB2YWx1ZTogXCJBdWd1c3QgMjAwOVwiLFxuICAgICAgICBzZXJpZXM6IFtcbiAgICAgICAgICAgIHtrZXk6IFwiU2VyaWVzIDFcIiwgdmFsdWU6IFwiVmFsdWUgMVwiLCBjb2xvcjogXCIjMDAwXCJ9LFxuICAgICAgICAgICAge2tleTogXCJTZXJpZXMgMlwiLCB2YWx1ZTogXCJWYWx1ZSAyXCIsIGNvbG9yOiBcIiMwMGZcIn1cbiAgICAgICAgXVxuICAgIH1cbiAgICAqL1xuICAgIHZhciBpZCA9IFwibnZ0b29sdGlwLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKSAvLyBHZW5lcmF0ZXMgYSB1bmlxdWUgaWQgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IHRvb2x0aXAoKSBvYmplY3QuXG4gICAgICAgICwgICBkYXRhID0gbnVsbFxuICAgICAgICAsICAgZ3Jhdml0eSA9ICd3JyAgIC8vIENhbiBiZSAnbicsJ3MnLCdlJywndycuIERldGVybWluZXMgaG93IHRvb2x0aXAgaXMgcG9zaXRpb25lZC5cbiAgICAgICAgLCAgIGRpc3RhbmNlID0gMjUgLy8gRGlzdGFuY2UgdG8gb2Zmc2V0IHRvb2x0aXAgZnJvbSB0aGUgbW91c2UgbG9jYXRpb24uXG4gICAgICAgICwgICBzbmFwRGlzdGFuY2UgPSAwICAgLy8gVG9sZXJhbmNlIGFsbG93ZWQgYmVmb3JlIHRvb2x0aXAgaXMgbW92ZWQgZnJvbSBpdHMgY3VycmVudCBwb3NpdGlvbiAoY3JlYXRlcyAnc25hcHBpbmcnIGVmZmVjdClcbiAgICAgICAgLCAgIGNsYXNzZXMgPSBudWxsICAvLyBBdHRhY2hlcyBhZGRpdGlvbmFsIENTUyBjbGFzc2VzIHRvIHRoZSB0b29sdGlwIERJViB0aGF0IGlzIGNyZWF0ZWQuXG4gICAgICAgICwgICBoaWRkZW4gPSB0cnVlICAvLyBTdGFydCBvZmYgaGlkZGVuLCB0b2dnbGUgd2l0aCBoaWRlL3Nob3cgZnVuY3Rpb25zIGJlbG93LlxuICAgICAgICAsICAgaGlkZURlbGF5ID0gMjAwICAvLyBEZWxheSAoaW4gbXMpIGJlZm9yZSB0aGUgdG9vbHRpcCBoaWRlcyBhZnRlciBjYWxsaW5nIGhpZGUoKS5cbiAgICAgICAgLCAgIHRvb2x0aXAgPSBudWxsIC8vIGQzIHNlbGVjdCBvZiB0aGUgdG9vbHRpcCBkaXYuXG4gICAgICAgICwgICBsYXN0UG9zaXRpb24gPSB7IGxlZnQ6IG51bGwsIHRvcDogbnVsbCB9IC8vIExhc3QgcG9zaXRpb24gdGhlIHRvb2x0aXAgd2FzIGluLlxuICAgICAgICAsICAgZW5hYmxlZCA9IHRydWUgIC8vIFRydWUgLT4gdG9vbHRpcHMgYXJlIHJlbmRlcmVkLiBGYWxzZSAtPiBkb24ndCByZW5kZXIgdG9vbHRpcHMuXG4gICAgICAgICwgICBkdXJhdGlvbiA9IDEwMCAvLyBUb29sdGlwIG1vdmVtZW50IGR1cmF0aW9uLCBpbiBtcy5cbiAgICAgICAgLCAgIGhlYWRlckVuYWJsZWQgPSB0cnVlIC8vIElmIGlzIHRvIHNob3cgdGhlIHRvb2x0aXAgaGVhZGVyLlxuICAgICAgICAsICAgbnZQb2ludGVyRXZlbnRzQ2xhc3MgPSBcIm52LXBvaW50ZXItZXZlbnRzLW5vbmVcIiAvLyBDU1MgY2xhc3MgdG8gc3BlY2lmeSB3aGV0aGVyIGVsZW1lbnQgc2hvdWxkIG5vdCBoYXZlIG1vdXNlIGV2ZW50cy5cbiAgICA7XG5cbiAgICAvLyBGb3JtYXQgZnVuY3Rpb24gZm9yIHRoZSB0b29sdGlwIHZhbHVlcyBjb2x1bW4uXG4gICAgdmFyIHZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9O1xuXG4gICAgLy8gRm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgdG9vbHRpcCBoZWFkZXIgdmFsdWUuXG4gICAgdmFyIGhlYWRlckZvcm1hdHRlciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfTtcblxuICAgIHZhciBrZXlGb3JtYXR0ZXIgPSBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH07XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBtb2RlbCByZW5kZXJzIGEgYmVhdXRpZnVsIHRhYmxlIGluc2lkZSBhIERJVi5cbiAgICAvLyBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaWYgYSBjdXN0b20gdG9vbHRpcCBpcyBkZXNpcmVkLlxuICAgIHZhciBjb250ZW50R2VuZXJhdG9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhYmxlID0gZDMuc2VsZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKSk7XG4gICAgICAgIGlmIChoZWFkZXJFbmFibGVkKSB7XG4gICAgICAgICAgICB2YXIgdGhlYWRFbnRlciA9IHRhYmxlLnNlbGVjdEFsbChcInRoZWFkXCIpXG4gICAgICAgICAgICAgICAgLmRhdGEoW2RdKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcInRoZWFkXCIpO1xuXG4gICAgICAgICAgICB0aGVhZEVudGVyLmFwcGVuZChcInRyXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJjb2xzcGFuXCIsIDMpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcInN0cm9uZ1wiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwieC12YWx1ZVwiLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5odG1sKGhlYWRlckZvcm1hdHRlcihkLnZhbHVlKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGJvZHlFbnRlciA9IHRhYmxlLnNlbGVjdEFsbChcInRib2R5XCIpXG4gICAgICAgICAgICAuZGF0YShbZF0pXG4gICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuICAgICAgICB2YXIgdHJvd0VudGVyID0gdGJvZHlFbnRlci5zZWxlY3RBbGwoXCJ0clwiKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuc2VyaWVzfSlcbiAgICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKFwiaGlnaGxpZ2h0XCIsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuaGlnaGxpZ2h0fSk7XG5cbiAgICAgICAgdHJvd0VudGVyLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcImxlZ2VuZC1jb2xvci1ndWlkZVwiLHRydWUpXG4gICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAuc3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuY29sb3J9KTtcblxuICAgICAgICB0cm93RW50ZXIuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwia2V5XCIsdHJ1ZSlcbiAgICAgICAgICAgIC5jbGFzc2VkKFwidG90YWxcIixmdW5jdGlvbihwKSB7IHJldHVybiAhIXAudG90YWx9KVxuICAgICAgICAgICAgLmh0bWwoZnVuY3Rpb24ocCwgaSkgeyByZXR1cm4ga2V5Rm9ybWF0dGVyKHAua2V5LCBpKX0pO1xuXG4gICAgICAgIHRyb3dFbnRlci5hcHBlbmQoXCJ0ZFwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJ2YWx1ZVwiLHRydWUpXG4gICAgICAgICAgICAuaHRtbChmdW5jdGlvbihwLCBpKSB7IHJldHVybiB2YWx1ZUZvcm1hdHRlcihwLnZhbHVlLCBpKSB9KTtcblxuICAgICAgICB0cm93RW50ZXIuZmlsdGVyKGZ1bmN0aW9uIChwLGkpIHsgcmV0dXJuIHAucGVyY2VudCAhPT0gdW5kZWZpbmVkIH0pLmFwcGVuZChcInRkXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcInBlcmNlbnRcIiwgdHJ1ZSlcbiAgICAgICAgICAgIC5odG1sKGZ1bmN0aW9uKHAsIGkpIHsgcmV0dXJuIFwiKFwiICsgZDMuZm9ybWF0KCclJykocC5wZXJjZW50KSArIFwiKVwiIH0pO1xuXG4gICAgICAgIHRyb3dFbnRlci5zZWxlY3RBbGwoXCJ0ZFwiKS5lYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIGlmIChwLmhpZ2hsaWdodCkge1xuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oWzAsMV0pLnJhbmdlKFtcIiNmZmZcIixwLmNvbG9yXSk7XG4gICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAwLjY7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImJvcmRlci1ib3R0b20tY29sb3JcIiwgb3BhY2l0eVNjYWxlKG9wYWNpdHkpKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJib3JkZXItdG9wLWNvbG9yXCIsIG9wYWNpdHlTY2FsZShvcGFjaXR5KSlcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBodG1sID0gdGFibGUubm9kZSgpLm91dGVySFRNTDtcbiAgICAgICAgaWYgKGQuZm9vdGVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBodG1sICs9IFwiPGRpdiBjbGFzcz0nZm9vdGVyJz5cIiArIGQuZm9vdGVyICsgXCI8L2Rpdj5cIjtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG5cbiAgICB9O1xuXG4gICAgLypcbiAgICAgRnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwb3NpdGlvbiAocmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0L2RvY3VtZW50LmJvZHkpXG4gICAgIHRoZSB0b29sdGlwIHNob3VsZCBiZSBwbGFjZWQgaW4uXG4gICAgIFNob3VsZCByZXR1cm46IHtcbiAgICAgICAgbGVmdDogPGxlZnRQb3M+LFxuICAgICAgICB0b3A6IDx0b3BQb3M+XG4gICAgIH1cbiAgICAgKi9cbiAgICB2YXIgcG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGQzLmV2ZW50ICE9PSBudWxsID8gZDMuZXZlbnQuY2xpZW50WCA6IDAsXG4gICAgICAgICAgICB0b3A6IGQzLmV2ZW50ICE9PSBudWxsID8gZDMuZXZlbnQuY2xpZW50WSA6IDBcbiAgICAgICAgfTtcblxuICAgICAgICBpZihnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLnRyYW5zZm9ybSAhPSAnbm9uZScpIHtcbiAgICAgICAgICAgIC8vIFRha2UgdGhlIG9mZnNldCBpbnRvIGFjY291bnQsIGFzIG5vdyB0aGUgdG9vbHRpcCBpcyByZWxhdGl2ZVxuICAgICAgICAgICAgLy8gdG8gZG9jdW1lbnQuYm9keS5cbiAgICAgICAgICAgIHZhciBjbGllbnQgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcG9zLmxlZnQgLT0gY2xpZW50LmxlZnQ7XG4gICAgICAgICAgICBwb3MudG9wIC09IGNsaWVudC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG5cbiAgICB2YXIgZGF0YVNlcmllc0V4aXN0cyA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaWYgKGQgJiYgZC5zZXJpZXMpIHtcbiAgICAgICAgICAgIGlmIChudi51dGlscy5pc0FycmF5KGQuc2VyaWVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgb2JqZWN0LCBpdCdzIG9rYXkganVzdCBjb252ZXJ0IHRvIGFycmF5IG9mIHRoZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChudi51dGlscy5pc09iamVjdChkLnNlcmllcykpIHtcbiAgICAgICAgICAgICAgICBkLnNlcmllcyA9IFtkLnNlcmllc107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBDYWxjdWxhdGVzIHRoZSBncmF2aXR5IG9mZnNldCBvZiB0aGUgdG9vbHRpcC4gUGFyYW1ldGVyIGlzIHBvc2l0aW9uIG9mIHRvb2x0aXBcbiAgICAvLyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXG4gICAgdmFyIGNhbGNHcmF2aXR5T2Zmc2V0ID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0b29sdGlwLm5vZGUoKS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICB3aWR0aCA9IHRvb2x0aXAubm9kZSgpLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgY2xpZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIC8vIERvbid0IHdhbnQgc2Nyb2xsYmFycy5cbiAgICAgICAgICAgIGNsaWVudEhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIC8vIERvbid0IHdhbnQgc2Nyb2xsYmFycy5cbiAgICAgICAgICAgIGxlZnQsIHRvcCwgdG1wO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiBncmF2aXR5XG4gICAgICAgIHN3aXRjaCAoZ3Jhdml0eSkge1xuICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgbGVmdCA9IC0gd2lkdGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICB0b3AgPSAtIChoZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICBpZihwb3MubGVmdCArIGxlZnQgPCAwKSBsZWZ0ID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYoKHRtcCA9IHBvcy50b3AgKyB0b3ApIDwgMCkgdG9wIC09IHRtcDtcbiAgICAgICAgICAgICAgICBpZigodG1wID0gcG9zLnRvcCArIHRvcCArIGhlaWdodCkgPiBjbGllbnRIZWlnaHQpIHRvcCAtPSB0bXAgLSBjbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgdG9wID0gLSAoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5sZWZ0ICsgbGVmdCArIHdpZHRoID4gY2xpZW50V2lkdGgpIGxlZnQgPSAtIHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKCh0bXAgPSBwb3MudG9wICsgdG9wKSA8IDApIHRvcCAtPSB0bXA7XG4gICAgICAgICAgICAgICAgaWYgKCh0bXAgPSBwb3MudG9wICsgdG9wICsgaGVpZ2h0KSA+IGNsaWVudEhlaWdodCkgdG9wIC09IHRtcCAtIGNsaWVudEhlaWdodDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgIGxlZnQgPSAtICh3aWR0aCAvIDIpIC0gNTsgLy8gLSA1IGlzIGFuIGFwcHJveGltYXRpb24gb2YgdGhlIG1vdXNlJ3MgaGVpZ2h0LlxuICAgICAgICAgICAgICAgIHRvcCA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3MudG9wICsgdG9wICsgaGVpZ2h0ID4gY2xpZW50SGVpZ2h0KSB0b3AgPSAtIGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmICgodG1wID0gcG9zLmxlZnQgKyBsZWZ0KSA8IDApIGxlZnQgLT0gdG1wO1xuICAgICAgICAgICAgICAgIGlmICgodG1wID0gcG9zLmxlZnQgKyBsZWZ0ICsgd2lkdGgpID4gY2xpZW50V2lkdGgpIGxlZnQgLT0gdG1wIC0gY2xpZW50V2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICBsZWZ0ID0gLSAod2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB0b3AgPSAtIGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3MudG9wICsgdG9wIDwgMCkgdG9wID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgaWYgKCh0bXAgPSBwb3MubGVmdCArIGxlZnQpIDwgMCkgbGVmdCAtPSB0bXA7XG4gICAgICAgICAgICAgICAgaWYgKCh0bXAgPSBwb3MubGVmdCArIGxlZnQgKyB3aWR0aCkgPiBjbGllbnRXaWR0aCkgbGVmdCAtPSB0bXAgLSBjbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgbGVmdCA9IC0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgdG9wID0gLSAoaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICAgICAgICAgIHRvcCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyAnbGVmdCc6IGxlZnQsICd0b3AnOiB0b3AgfTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgUG9zaXRpb25zIHRoZSB0b29sdGlwIGluIHRoZSBjb3JyZWN0IHBsYWNlLCBhcyBnaXZlbiBieSB0aGUgcG9zaXRpb24oKSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgcG9zaXRpb25Ub29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG52LmRvbS5yZWFkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uKCksXG4gICAgICAgICAgICAgICAgZ3Jhdml0eU9mZnNldCA9IGNhbGNHcmF2aXR5T2Zmc2V0KHBvcyksXG4gICAgICAgICAgICAgICAgbGVmdCA9IHBvcy5sZWZ0ICsgZ3Jhdml0eU9mZnNldC5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcCA9IHBvcy50b3AgKyBncmF2aXR5T2Zmc2V0LnRvcDtcblxuICAgICAgICAgICAgLy8gZGVsYXkgaGlkaW5nIGEgYml0IHRvIGF2b2lkIGZsaWNrZXJpbmdcbiAgICAgICAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kZWxheShoaWRlRGVsYXkpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXNpbmcgdG9vbHRpcC5zdHlsZSgndHJhbnNmb3JtJykgcmV0dXJucyB2YWx1ZXMgdW4tdXNhYmxlIGZvciB0d2VlblxuICAgICAgICAgICAgICAgIHZhciBvbGRfdHJhbnNsYXRlID0gJ3RyYW5zbGF0ZSgnICsgbGFzdFBvc2l0aW9uLmxlZnQgKyAncHgsICcgKyBsYXN0UG9zaXRpb24udG9wICsgJ3B4KSc7XG4gICAgICAgICAgICAgICAgdmFyIG5ld190cmFuc2xhdGUgPSAndHJhbnNsYXRlKCcgKyBNYXRoLnJvdW5kKGxlZnQpICsgJ3B4LCAnICsgTWF0aC5yb3VuZCh0b3ApICsgJ3B4KSc7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZUludGVycG9sYXRvciA9IGQzLmludGVycG9sYXRlU3RyaW5nKG9sZF90cmFuc2xhdGUsIG5ld190cmFuc2xhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBpc19oaWRkZW4gPSB0b29sdGlwLnN0eWxlKCdvcGFjaXR5JykgPCAwLjE7XG5cbiAgICAgICAgICAgICAgICB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnJ1cHQoKSAvLyBjYW5jZWwgcnVubmluZyB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihpc19oaWRkZW4gPyAwIDogZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIHR3ZWVuIHNpbmNlIHNvbWUgdmVyc2lvbnMgb2YgZDMgY2FuJ3QgYXV0by10d2VlbiBhIHRyYW5zbGF0ZSBvbiBhIGRpdlxuICAgICAgICAgICAgICAgICAgICAuc3R5bGVUd2VlbigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVJbnRlcnBvbGF0b3I7XG4gICAgICAgICAgICAgICAgICAgIH0sICdpbXBvcnRhbnQnKVxuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaGFzIGl0cyBvd24gYC13ZWJraXQtdHJhbnNmb3JtYCBhbmQgZG9lcyBub3Qgc3VwcG9ydCBgdHJhbnNmb3JtYFxuICAgICAgICAgICAgICAgICAgICAuc3R5bGVUd2VlbignLXdlYmtpdC10cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZUludGVycG9sYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCctbXMtdHJhbnNmb3JtJywgbmV3X3RyYW5zbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RQb3NpdGlvbi5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIGxhc3RQb3NpdGlvbi50b3AgPSB0b3A7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGVzIG5ldyB0b29sdGlwIGNvbnRhaW5lciwgb3IgdXNlcyBleGlzdGluZyBvbmUgb24gRE9NLlxuICAgIGZ1bmN0aW9uIGluaXRUb29sdGlwKCkge1xuICAgICAgICBpZiAoIXRvb2x0aXAgfHwgIXRvb2x0aXAubm9kZSgpKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbmV3IHRvb2x0aXAgZGl2IGlmIGl0IGRvZXNuJ3QgZXhpc3Qgb24gRE9NLlxuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IFsxXTtcbiAgICAgICAgICAgIHRvb2x0aXAgPSBkMy5zZWxlY3QoZG9jdW1lbnQuYm9keSkuc2VsZWN0KCcjJytpZCkuZGF0YShkYXRhKTtcblxuICAgICAgICAgICAgdG9vbHRpcC5lbnRlcigpLmFwcGVuZCgnZGl2JylcbiAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibnZ0b29sdGlwIFwiICsgKGNsYXNzZXMgPyBjbGFzc2VzIDogXCJ4eS10b29sdGlwXCIpKVxuICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgaWQpXG4gICAgICAgICAgICAgICAgICAgLnN0eWxlKFwidG9wXCIsIDApLnN0eWxlKFwibGVmdFwiLCAwKVxuICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXG4gICAgICAgICAgICAgICAgICAgLnN0eWxlKCdwb3NpdGlvbicsICdmaXhlZCcpXG4gICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcImRpdiwgdGFibGUsIHRkLCB0clwiKS5jbGFzc2VkKG52UG9pbnRlckV2ZW50c0NsYXNzLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKG52UG9pbnRlckV2ZW50c0NsYXNzLCB0cnVlKTtcblxuICAgICAgICAgICAgdG9vbHRpcC5leGl0KCkucmVtb3ZlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIHRvb2x0aXAgb250byB0aGUgRE9NLlxuICAgIGZ1bmN0aW9uIG52dG9vbHRpcCgpIHtcbiAgICAgICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgICAgIGlmICghZGF0YVNlcmllc0V4aXN0cyhkYXRhKSkgcmV0dXJuO1xuXG4gICAgICAgIG52LmRvbS53cml0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbml0VG9vbHRpcCgpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgZGF0YSBhbmQgc2V0IGl0IGludG8gdG9vbHRpcC5cbiAgICAgICAgICAgIC8vIEJvbnVzIC0gSWYgeW91IG92ZXJyaWRlIGNvbnRlbnRHZW5lcmF0b3IgYW5kIHJldHVybiBmYWxzZXkgeW91IGNhbiB1c2Ugc29tZXRoaW5nIGxpa2VcbiAgICAgICAgICAgIC8vICAgICAgICAgUmVhY3Qgb3IgS25vY2tvdXQgdG8gYmluZCB0aGUgZGF0YSBmb3IgeW91ciB0b29sdGlwLlxuICAgICAgICAgICAgdmFyIG5ld0NvbnRlbnQgPSBjb250ZW50R2VuZXJhdG9yKGRhdGEpO1xuICAgICAgICAgICAgaWYgKG5ld0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0b29sdGlwLm5vZGUoKS5pbm5lckhUTUwgPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG52dG9vbHRpcDtcbiAgICB9XG5cbiAgICBudnRvb2x0aXAubnZQb2ludGVyRXZlbnRzQ2xhc3MgPSBudlBvaW50ZXJFdmVudHNDbGFzcztcbiAgICBudnRvb2x0aXAub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQobnZ0b29sdGlwKTtcblxuICAgIG52dG9vbHRpcC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIHJlYWQvd3JpdGUgb3B0aW9uc1xuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtkdXJhdGlvbj1fO319LFxuICAgICAgICBncmF2aXR5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBncmF2aXR5O30sIHNldDogZnVuY3Rpb24oXyl7Z3Jhdml0eT1fO319LFxuICAgICAgICBkaXN0YW5jZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGlzdGFuY2U7fSwgc2V0OiBmdW5jdGlvbihfKXtkaXN0YW5jZT1fO319LFxuICAgICAgICBzbmFwRGlzdGFuY2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNuYXBEaXN0YW5jZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3NuYXBEaXN0YW5jZT1fO319LFxuICAgICAgICBjbGFzc2VzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGFzc2VzO30sIHNldDogZnVuY3Rpb24oXyl7Y2xhc3Nlcz1fO319LFxuICAgICAgICBlbmFibGVkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBlbmFibGVkO30sIHNldDogZnVuY3Rpb24oXyl7ZW5hYmxlZD1fO319LFxuICAgICAgICBoaWRlRGVsYXk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhpZGVEZWxheTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hpZGVEZWxheT1fO319LFxuICAgICAgICBjb250ZW50R2VuZXJhdG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb250ZW50R2VuZXJhdG9yO30sIHNldDogZnVuY3Rpb24oXyl7Y29udGVudEdlbmVyYXRvcj1fO319LFxuICAgICAgICB2YWx1ZUZvcm1hdHRlcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdmFsdWVGb3JtYXR0ZXI7fSwgc2V0OiBmdW5jdGlvbihfKXt2YWx1ZUZvcm1hdHRlcj1fO319LFxuICAgICAgICBoZWFkZXJGb3JtYXR0ZXI6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlYWRlckZvcm1hdHRlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlYWRlckZvcm1hdHRlcj1fO319LFxuICAgICAgICBrZXlGb3JtYXR0ZXI6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGtleUZvcm1hdHRlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2tleUZvcm1hdHRlcj1fO319LFxuICAgICAgICBoZWFkZXJFbmFibGVkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWFkZXJFbmFibGVkO30sIHNldDogZnVuY3Rpb24oXyl7aGVhZGVyRW5hYmxlZD1fO319LFxuICAgICAgICBwb3NpdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcG9zaXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtwb3NpdGlvbj1fO319LFxuXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgb3B0aW9uc1xuICAgICAgICBjaGFydENvbnRhaW5lcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCBhZnRlciAxLjguM1xuICAgICAgICAgICAgbnYuZGVwcmVjYXRlZCgnY2hhcnRDb250YWluZXInLCAnZmVhdHVyZSByZW1vdmVkIGFmdGVyIDEuOC4zJyk7XG4gICAgICAgIH19LFxuICAgICAgICBmaXhlZFRvcDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbnVsbDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCBhZnRlciAxLjguMVxuICAgICAgICAgICAgbnYuZGVwcmVjYXRlZCgnZml4ZWRUb3AnLCAnZmVhdHVyZSByZW1vdmVkIGFmdGVyIDEuOC4xJyk7XG4gICAgICAgIH19LFxuICAgICAgICBvZmZzZXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHtsZWZ0OiAwLCB0b3A6IDB9O30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkIGFmdGVyIDEuOC4xXG4gICAgICAgICAgICBudi5kZXByZWNhdGVkKCdvZmZzZXQnLCAndXNlIGNoYXJ0LnRvb2x0aXAuZGlzdGFuY2UoKSBpbnN0ZWFkJyk7XG4gICAgICAgIH19LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgd2l0aCBleHRyYSBsb2dpY1xuICAgICAgICBoaWRkZW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhpZGRlbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKGhpZGRlbiAhPSBfKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gISFfO1xuICAgICAgICAgICAgICAgIG52dG9vbHRpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fSxcbiAgICAgICAgZGF0YToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgLy8gaWYgc2hvd2luZyBhIHNpbmdsZSBkYXRhIHBvaW50LCBhZGp1c3QgZGF0YSBmb3JtYXQgd2l0aCB0aGF0XG4gICAgICAgICAgICBpZiAoXy5wb2ludCkge1xuICAgICAgICAgICAgICAgIF8udmFsdWUgPSBfLnBvaW50Lng7XG4gICAgICAgICAgICAgICAgXy5zZXJpZXMgPSBfLnNlcmllcyB8fCB7fTtcbiAgICAgICAgICAgICAgICBfLnNlcmllcy52YWx1ZSA9IF8ucG9pbnQueTtcbiAgICAgICAgICAgICAgICBfLnNlcmllcy5jb2xvciA9IF8ucG9pbnQuY29sb3IgfHwgXy5zZXJpZXMuY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gXztcbiAgICAgICAgfX0sXG5cbiAgICAgICAgLy8gcmVhZCBvbmx5IHByb3BlcnRpZXNcbiAgICAgICAgbm9kZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdG9vbHRpcC5ub2RlKCk7fSwgc2V0OiBmdW5jdGlvbihfKXt9fSxcbiAgICAgICAgaWQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7fX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKG52dG9vbHRpcCk7XG4gICAgcmV0dXJuIG52dG9vbHRpcDtcbn07XG5cblxuLypcbkdldHMgdGhlIGJyb3dzZXIgd2luZG93IHNpemVcblxuUmV0dXJucyBvYmplY3Qgd2l0aCBoZWlnaHQgYW5kIHdpZHRoIHByb3BlcnRpZXNcbiAqL1xubnYudXRpbHMud2luZG93U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNhbmUgZGVmYXVsdHNcbiAgICB2YXIgc2l6ZSA9IHt3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MH07XG5cbiAgICAvLyBNb3N0IHJlY2VudCBicm93c2VycyB1c2VcbiAgICBpZiAod2luZG93LmlubmVyV2lkdGggJiYgd2luZG93LmlubmVySGVpZ2h0KSB7XG4gICAgICAgIHNpemUud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIHJldHVybiAoc2l6ZSk7XG4gICAgfVxuXG4gICAgLy8gSUUgY2FuIHVzZSBkZXBlbmRpbmcgb24gbW9kZSBpdCBpcyBpblxuICAgIGlmIChkb2N1bWVudC5jb21wYXRNb2RlPT0nQ1NTMUNvbXBhdCcgJiZcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCApIHtcblxuICAgICAgICBzaXplLndpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBzaXplLmhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHJldHVybiAoc2l6ZSk7XG4gICAgfVxuXG4gICAgLy8gRWFybGllciBJRSB1c2VzIERvYy5ib2R5XG4gICAgaWYgKGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aCkge1xuICAgICAgICBzaXplLndpZHRoID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcbiAgICAgICAgc2l6ZS5oZWlnaHQgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbiAgICAgICAgcmV0dXJuIChzaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHNpemUpO1xufTtcblxuXG4vKiBoYW5kbGUgZHVtYiBicm93c2VyIHF1aXJrcy4uLiAgaXNpbnN0YW5jZSBicmVha3MgaWYgeW91IHVzZSBmcmFtZXNcbnR5cGVvZiByZXR1cm5zICdvYmplY3QnIGZvciBudWxsLCBOYU4gaXMgYSBudW1iZXIsIGV0Yy5cbiAqL1xubnYudXRpbHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5udi51dGlscy5pc09iamVjdCA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gYSAhPT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCc7XG59O1xubnYudXRpbHMuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59O1xubnYudXRpbHMuaXNEYXRlID0gZnVuY3Rpb24oYSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKGEpID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xubnYudXRpbHMuaXNOdW1iZXIgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuICFpc05hTihhKSAmJiB0eXBlb2YgYSA9PT0gJ251bWJlcic7XG59O1xuXG5cbi8qXG5CaW5kcyBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB3aW5kb3cgaXMgcmVzaXplZFxuICovXG5udi51dGlscy53aW5kb3dSZXNpemUgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBudi5sb2coXCJFUlJPUjogRmFpbGVkIHRvIGJpbmQgdG8gd2luZG93LnJlc2l6ZSB3aXRoOiBcIiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHJldHVybiBvYmplY3Qgd2l0aCBjbGVhciBmdW5jdGlvbiB0byByZW1vdmUgdGhlIHNpbmdsZSBhZGRlZCBjYWxsYmFjay5cbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxsYmFjazogaGFuZGxlcixcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vKlxuQmFja3dhcmRzIGNvbXBhdGlibGUgd2F5IHRvIGltcGxlbWVudCBtb3JlIGQzLWxpa2UgY29sb3Jpbmcgb2YgZ3JhcGhzLlxuQ2FuIHRha2UgaW4gbm90aGluZywgYW4gYXJyYXksIG9yIGEgZnVuY3Rpb24vc2NhbGVcblRvIHVzZSBhIG5vcm1hbCBzY2FsZSwgZ2V0IHRoZSByYW5nZSBhbmQgcGFzcyB0aGF0IGJlY2F1c2Ugd2UgbXVzdCBiZSBhYmxlXG50byB0YWtlIHR3byBhcmd1bWVudHMgYW5kIHVzZSB0aGUgaW5kZXggdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4qL1xubnYudXRpbHMuZ2V0Q29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIC8vaWYgeW91IHBhc3MgaW4gbm90aGluZywgZ2V0IGRlZmF1bHQgY29sb3JzIGJhY2tcbiAgICBpZiAoY29sb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbnYudXRpbHMuZGVmYXVsdENvbG9yKCk7XG5cbiAgICAvL2lmIHBhc3NlZCBhbiBhcnJheSwgdHVybiBpdCBpbnRvIGEgY29sb3Igc2NhbGVcbiAgICB9IGVsc2UgaWYobnYudXRpbHMuaXNBcnJheShjb2xvcikpIHtcbiAgICAgICAgdmFyIGNvbG9yX3NjYWxlID0gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBpID09PSB1bmRlZmluZWQgPyBkIDogaTtcbiAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yX3NjYWxlKGtleSk7XG4gICAgICAgIH07XG5cbiAgICAvL2lmIHBhc3NlZCBhIGZ1bmN0aW9uIG9yIHNjYWxlLCByZXR1cm4gaXQsIG9yIHdoYXRldmVyIGl0IG1heSBiZVxuICAgIC8vZXh0ZXJuYWwgbGlicywgc3VjaCBhcyBhbmd1bGFyanMtbnZkMy1kaXJlY3RpdmVzIHVzZSB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9jYW4ndCByZWFsbHkgaGVscCBpdCBpZiBzb21lb25lIHBhc3NlcyBydWJiaXNoIGFzIGNvbG9yXG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG59O1xuXG5cbi8qXG5EZWZhdWx0IGNvbG9yIGNob29zZXIgdXNlcyBhIGNvbG9yIHNjYWxlIG9mIDIwIGNvbG9ycyBmcm9tIEQzXG4gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvT3JkaW5hbC1TY2FsZXMjY2F0ZWdvcmljYWwtY29sb3JzXG4gKi9cbm52LnV0aWxzLmRlZmF1bHRDb2xvciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGdldCByYW5nZSBvZiB0aGUgc2NhbGUgc28gd2UnbGwgdHVybiBpdCBpbnRvIG91ciBvd24gZnVuY3Rpb24uXG4gICAgcmV0dXJuIG52LnV0aWxzLmdldENvbG9yKGQzLnNjYWxlLmNhdGVnb3J5MjAoKS5yYW5nZSgpKTtcbn07XG5cblxuLypcblJldHVybnMgYSBjb2xvciBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSByZXN1bHQgb2YgJ2dldEtleScgZm9yIGVhY2ggc2VyaWVzIGFuZFxubG9va3MgZm9yIGEgY29ycmVzcG9uZGluZyBjb2xvciBmcm9tIHRoZSBkaWN0aW9uYXJ5XG4qL1xubnYudXRpbHMuY3VzdG9tVGhlbWUgPSBmdW5jdGlvbihkaWN0aW9uYXJ5LCBnZXRLZXksIGRlZmF1bHRDb2xvcnMpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBzZXJpZXMua2V5IGlmIGdldEtleSBpcyB1bmRlZmluZWRcbiAgICBnZXRLZXkgPSBnZXRLZXkgfHwgZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMua2V5IH07XG4gICAgZGVmYXVsdENvbG9ycyA9IGRlZmF1bHRDb2xvcnMgfHwgZDMuc2NhbGUuY2F0ZWdvcnkyMCgpLnJhbmdlKCk7XG5cbiAgICAvLyBzdGFydCBhdCBlbmQgb2YgZGVmYXVsdCBjb2xvciBsaXN0IGFuZCB3YWxrIGJhY2sgdG8gaW5kZXggMFxuICAgIHZhciBkZWZJbmRleCA9IGRlZmF1bHRDb2xvcnMubGVuZ3RoO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllcywgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGdldEtleShzZXJpZXMpO1xuICAgICAgICBpZiAobnYudXRpbHMuaXNGdW5jdGlvbihkaWN0aW9uYXJ5W2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGljdGlvbmFyeVtrZXldKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGljdGlvbmFyeVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBkaWN0aW9uYXJ5W2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBtYXRjaCBpbiBkaWN0aW9uYXJ5LCB1c2UgYSBkZWZhdWx0IGNvbG9yXG4gICAgICAgICAgICBpZiAoIWRlZkluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlZCBhbGwgdGhlIGRlZmF1bHQgY29sb3JzLCBzdGFydCBvdmVyXG4gICAgICAgICAgICAgICAgZGVmSW5kZXggPSBkZWZhdWx0Q29sb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZkluZGV4ID0gZGVmSW5kZXggLSAxO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb2xvcnNbZGVmSW5kZXhdO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cblxuLypcbkZyb20gdGhlIFBKQVggZXhhbXBsZSBvbiBkM2pzLm9yZywgd2hpbGUgdGhpcyBpcyBub3QgcmVhbGx5IGRpcmVjdGx5IG5lZWRlZFxuaXQncyBhIHZlcnkgY29vbCBtZXRob2QgZm9yIGRvaW5nIHBqYXgsIEkgbWF5IGV4cGFuZCB1cG9uIGl0IGEgbGl0dGxlIGJpdCxcbm9wZW4gdG8gc3VnZ2VzdGlvbnMgb24gYW55dGhpbmcgdGhhdCBtYXkgYmUgdXNlZnVsXG4qL1xubnYudXRpbHMucGpheCA9IGZ1bmN0aW9uKGxpbmtzLCBjb250ZW50KSB7XG5cbiAgICB2YXIgbG9hZCA9IGZ1bmN0aW9uKGhyZWYpIHtcbiAgICAgICAgZDMuaHRtbChocmVmLCBmdW5jdGlvbihmcmFnbWVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGQzLnNlbGVjdChjb250ZW50KS5ub2RlKCk7XG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KGZyYWdtZW50KS5zZWxlY3QoY29udGVudCkubm9kZSgpLFxuICAgICAgICAgICAgICAgIHRhcmdldCk7XG4gICAgICAgICAgICBudi51dGlscy5wamF4KGxpbmtzLCBjb250ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGQzLnNlbGVjdEFsbChsaW5rcykub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUodGhpcy5ocmVmLCB0aGlzLnRleHRDb250ZW50LCB0aGlzLmhyZWYpO1xuICAgICAgICBsb2FkKHRoaXMuaHJlZik7XG4gICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBkMy5zZWxlY3Qod2luZG93KS5vbihcInBvcHN0YXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQuc3RhdGUpIHtcbiAgICAgICAgICAgIGxvYWQoZDMuZXZlbnQuc3RhdGUpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5cbi8qXG5Gb3Igd2hlbiB3ZSB3YW50IHRvIGFwcHJveGltYXRlIHRoZSB3aWR0aCBpbiBwaXhlbHMgZm9yIGFuIFNWRzp0ZXh0IGVsZW1lbnQuXG5Nb3N0IGNvbW1vbiBpbnN0YW5jZSBpcyB3aGVuIHRoZSBlbGVtZW50IGlzIGluIGEgZGlzcGxheTpub25lOyBjb250YWluZXIuXG5Gb3J1bWxhIGlzIDogdGV4dC5sZW5ndGggKiBmb250LXNpemUgKiBjb25zdGFudF9mYWN0b3JcbiovXG5udi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoID0gZnVuY3Rpb24gKHN2Z1RleHRFbGVtKSB7XG4gICAgaWYgKG52LnV0aWxzLmlzRnVuY3Rpb24oc3ZnVGV4dEVsZW0uc3R5bGUpICYmIG52LnV0aWxzLmlzRnVuY3Rpb24oc3ZnVGV4dEVsZW0udGV4dCkpIHtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyc2VJbnQoc3ZnVGV4dEVsZW0uc3R5bGUoXCJmb250LXNpemVcIikucmVwbGFjZShcInB4XCIsXCJcIiksIDEwKTtcbiAgICAgICAgdmFyIHRleHRMZW5ndGggPSBzdmdUZXh0RWxlbS50ZXh0KCkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHRleHRMZW5ndGggKiBmb250U2l6ZSAqIDAuNSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuXG4vKlxuTnVtYmVycyB0aGF0IGFyZSB1bmRlZmluZWQsIG51bGwgb3IgTmFOLCBjb252ZXJ0IHRoZW0gdG8gemVyb3MuXG4qL1xubnYudXRpbHMuTmFOdG9aZXJvID0gZnVuY3Rpb24obikge1xuICAgIGlmICghbnYudXRpbHMuaXNOdW1iZXIobilcbiAgICAgICAgfHwgaXNOYU4obilcbiAgICAgICAgfHwgbiA9PT0gbnVsbFxuICAgICAgICB8fCBuID09PSBJbmZpbml0eVxuICAgICAgICB8fCBuID09PSAtSW5maW5pdHkpIHtcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuXG4vKlxuQWRkIGEgd2F5IHRvIHdhdGNoIGZvciBkMyB0cmFuc2l0aW9uIGVuZHMgdG8gZDNcbiovXG5kMy5zZWxlY3Rpb24ucHJvdG90eXBlLndhdGNoVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKHJlbmRlcldhdGNoKXtcbiAgICB2YXIgYXJncyA9IFt0aGlzXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICByZXR1cm4gcmVuZGVyV2F0Y2gudHJhbnNpdGlvbi5hcHBseShyZW5kZXJXYXRjaCwgYXJncyk7XG59O1xuXG5cbi8qXG5IZWxwZXIgb2JqZWN0IHRvIHdhdGNoIHdoZW4gZDMgaGFzIHJlbmRlcmVkIHNvbWV0aGluZ1xuKi9cbm52LnV0aWxzLnJlbmRlcldhdGNoID0gZnVuY3Rpb24oZGlzcGF0Y2gsIGR1cmF0aW9uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIG52LnV0aWxzLnJlbmRlcldhdGNoKSkge1xuICAgICAgICByZXR1cm4gbmV3IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIF9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBkdXJhdGlvbiA6IDI1MDtcbiAgICB2YXIgcmVuZGVyU3RhY2sgPSBbXTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLm1vZGVscyA9IGZ1bmN0aW9uKG1vZGVscykge1xuICAgICAgICBtb2RlbHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIG1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uKG1vZGVsKXtcbiAgICAgICAgICAgIG1vZGVsLl9fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIChmdW5jdGlvbihtKXtcbiAgICAgICAgICAgICAgICBtLmRpc3BhdGNoLm9uKCdyZW5kZXJFbmQnLCBmdW5jdGlvbihhcmcpe1xuICAgICAgICAgICAgICAgICAgICBtLl9fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnJlbmRlckVuZCgnbW9kZWwnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKG1vZGVsKTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YWNrLmluZGV4T2YobW9kZWwpIDwgMCkge1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YWNrLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChkdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJTdGFjayA9IFtdO1xuICAgIH07XG5cbiAgICB0aGlzLnRyYW5zaXRpb24gPSBmdW5jdGlvbihzZWxlY3Rpb24sIGFyZ3MsIGR1cmF0aW9uKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gYXJncy5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gX2R1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBfZHVyYXRpb24gOiAyNTA7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLl9fcmVuZGVyZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAocmVuZGVyU3RhY2suaW5kZXhPZihzZWxlY3Rpb24pIDwgMCkge1xuICAgICAgICAgICAgcmVuZGVyU3RhY2sucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uX19yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZGVsYXkgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgICAgICAgICBzZWxlY3Rpb24uZHVyYXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX19yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbi5ldmVyeSggZnVuY3Rpb24oZCl7IHJldHVybiAhZC5sZW5ndGg7IH0gKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9fcmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oKXsgKytuOyB9KVxuICAgICAgICAgICAgICAgIC5lYWNoKCdlbmQnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVuZGVyRW5kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZW5kZXJFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlbmRlclN0YWNrLmV2ZXJ5KCBmdW5jdGlvbihkKXsgcmV0dXJuIGQuX19yZW5kZXJlZDsgfSApKSB7XG4gICAgICAgICAgICByZW5kZXJTdGFjay5mb3JFYWNoKCBmdW5jdGlvbihkKXsgZC5fX3JlbmRlcmVkID0gZmFsc2U7IH0pO1xuICAgICAgICAgICAgZGlzcGF0Y2gucmVuZGVyRW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cblxuLypcblRha2VzIG11bHRpcGxlIG9iamVjdHMgYW5kIGNvbWJpbmVzIHRoZW0gaW50byB0aGUgZmlyc3Qgb25lIChkc3QpXG5leGFtcGxlOiAgbnYudXRpbHMuZGVlcEV4dGVuZCh7YTogMX0sIHthOiAyLCBiOiAzfSwge2M6IDR9KTtcbmdpdmVzOiAge2E6IDIsIGI6IDMsIGM6IDR9XG4qL1xubnYudXRpbHMuZGVlcEV4dGVuZCA9IGZ1bmN0aW9uKGRzdCl7XG4gICAgdmFyIHNvdXJjZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSBudi51dGlscy5pc0FycmF5KGRzdFtrZXldKTtcbiAgICAgICAgICAgIHZhciBpc09iamVjdCA9IG52LnV0aWxzLmlzT2JqZWN0KGRzdFtrZXldKTtcbiAgICAgICAgICAgIHZhciBzcmNPYmogPSBudi51dGlscy5pc09iamVjdChzb3VyY2Vba2V5XSk7XG5cbiAgICAgICAgICAgIGlmIChpc09iamVjdCAmJiAhaXNBcnJheSAmJiBzcmNPYmopIHtcbiAgICAgICAgICAgICAgICBudi51dGlscy5kZWVwRXh0ZW5kKGRzdFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuLypcbnN0YXRlIHV0aWxpdHkgb2JqZWN0LCB1c2VkIHRvIHRyYWNrIGQzIHN0YXRlcyBpbiB0aGUgbW9kZWxzXG4qL1xubnYudXRpbHMuc3RhdGUgPSBmdW5jdGlvbigpe1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBudi51dGlscy5zdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBudi51dGlscy5zdGF0ZSgpO1xuICAgIH1cbiAgICB2YXIgc3RhdGUgPSB7fTtcbiAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgIHZhciBfc2V0U3RhdGUgPSBmdW5jdGlvbigpe307XG4gICAgdmFyIF9nZXRTdGF0ZSA9IGZ1bmN0aW9uKCl7IHJldHVybiB7fTsgfTtcbiAgICB2YXIgaW5pdCA9IG51bGw7XG4gICAgdmFyIGNoYW5nZWQgPSBudWxsO1xuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFuZ2UnLCAnc2V0Jyk7XG5cbiAgICB0aGlzLmRpc3BhdGNoLm9uKCdzZXQnLCBmdW5jdGlvbihzdGF0ZSl7XG4gICAgICAgIF9zZXRTdGF0ZShzdGF0ZSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uKGZuKXtcbiAgICAgICAgX2dldFN0YXRlID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICB0aGlzLnNldHRlciA9IGZ1bmN0aW9uKGZuLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCl7fTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgdXBkYXRlKXtcbiAgICAgICAgICAgIGZuKHN0YXRlKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oc3RhdGUpe1xuICAgICAgICBpbml0ID0gaW5pdCB8fCB7fTtcbiAgICAgICAgbnYudXRpbHMuZGVlcEV4dGVuZChpbml0LCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHZhciBfc2V0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gX2dldFN0YXRlKCk7XG5cbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSA9PT0gSlNPTi5zdHJpbmdpZnkoc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gc2V0dGluZ3Nba2V5XTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICBfc2V0U3RhdGUoaW5pdCwgZmFsc2UpO1xuICAgICAgICAgICAgaW5pdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9zZXQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaC5jaGFuZ2Uoc3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcblxufTtcblxuXG4vKlxuU25pcHBldCBvZiBjb2RlIHlvdSBjYW4gaW5zZXJ0IGludG8gZWFjaCBudi5tb2RlbHMuKiB0byBnaXZlIHlvdSB0aGUgYWJpbGl0eSB0b1xuZG8gdGhpbmdzIGxpa2U6XG5jaGFydC5vcHRpb25zKHtcbiAgc2hvd1hBeGlzOiB0cnVlLFxuICB0b29sdGlwczogdHJ1ZVxufSk7XG5cblRvIGVuYWJsZSBpbiB0aGUgY2hhcnQ6XG5jaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG4qL1xubnYudXRpbHMub3B0aW9uc0Z1bmMgPSBmdW5jdGlvbihhcmdzKSB7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZDMubWFwKGFyZ3MpLmZvckVhY2goKGZ1bmN0aW9uKGtleSx2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG52LnV0aWxzLmlzRnVuY3Rpb24odGhpc1trZXldKSkge1xuICAgICAgICAgICAgICAgIHRoaXNba2V5XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLypcbm51bVRpY2tzOiAgcmVxdWVzdGVkIG51bWJlciBvZiB0aWNrc1xuZGF0YTogIHRoZSBjaGFydCBkYXRhXG5cbnJldHVybnMgdGhlIG51bWJlciBvZiB0aWNrcyB0byBhY3R1YWxseSB1c2Ugb24gWCBheGlzLCBiYXNlZCBvbiBjaGFydCBkYXRhXG50byBhdm9pZCBkdXBsaWNhdGUgdGlja3Mgd2l0aCB0aGUgc2FtZSB2YWx1ZVxuKi9cbm52LnV0aWxzLmNhbGNUaWNrc1ggPSBmdW5jdGlvbihudW1UaWNrcywgZGF0YSkge1xuICAgIC8vIGZpbmQgbWF4IG51bWJlciBvZiB2YWx1ZXMgZnJvbSBhbGwgZGF0YSBzdHJlYW1zXG4gICAgdmFyIG51bVZhbHVlcyA9IDE7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoaTsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0cmVhbV9sZW4gPSBkYXRhW2ldICYmIGRhdGFbaV0udmFsdWVzID8gZGF0YVtpXS52YWx1ZXMubGVuZ3RoIDogMDtcbiAgICAgICAgbnVtVmFsdWVzID0gc3RyZWFtX2xlbiA+IG51bVZhbHVlcyA/IHN0cmVhbV9sZW4gOiBudW1WYWx1ZXM7XG4gICAgfVxuICAgIG52LmxvZyhcIlJlcXVlc3RlZCBudW1iZXIgb2YgdGlja3M6IFwiLCBudW1UaWNrcyk7XG4gICAgbnYubG9nKFwiQ2FsY3VsYXRlZCBtYXggdmFsdWVzIHRvIGJlOiBcIiwgbnVtVmFsdWVzKTtcbiAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBtb3JlIHRpY2tzIHRoYW4gdmFsdWVzIHRvIGF2b2lkIGR1cGxpY2F0ZXNcbiAgICBudW1UaWNrcyA9IG51bVRpY2tzID4gbnVtVmFsdWVzID8gbnVtVGlja3MgPSBudW1WYWx1ZXMgLSAxIDogbnVtVGlja3M7XG4gICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHRpY2tcbiAgICBudW1UaWNrcyA9IG51bVRpY2tzIDwgMSA/IDEgOiBudW1UaWNrcztcbiAgICAvLyBtYWtlIHN1cmUgaXQncyBhbiBpbnRlZ2VyXG4gICAgbnVtVGlja3MgPSBNYXRoLmZsb29yKG51bVRpY2tzKTtcbiAgICBudi5sb2coXCJDYWxjdWxhdGluZyB0aWNrIGNvdW50IGFzOiBcIiwgbnVtVGlja3MpO1xuICAgIHJldHVybiBudW1UaWNrcztcbn07XG5cblxuLypcbnJldHVybnMgbnVtYmVyIG9mIHRpY2tzIHRvIGFjdHVhbGx5IHVzZSBvbiBZIGF4aXMsIGJhc2VkIG9uIGNoYXJ0IGRhdGFcbiovXG5udi51dGlscy5jYWxjVGlja3NZID0gZnVuY3Rpb24obnVtVGlja3MsIGRhdGEpIHtcbiAgICAvLyBjdXJyZW50bHkgdXNlcyB0aGUgc2FtZSBsb2dpYyBidXQgd2UgY2FuIGFkanVzdCBoZXJlIGlmIG5lZWRlZCBsYXRlclxuICAgIHJldHVybiBudi51dGlscy5jYWxjVGlja3NYKG51bVRpY2tzLCBkYXRhKTtcbn07XG5cblxuLypcbkFkZCBhIHBhcnRpY3VsYXIgb3B0aW9uIGZyb20gYW4gb3B0aW9ucyBvYmplY3Qgb250byBjaGFydFxuT3B0aW9ucyBleHBvc2VkIG9uIGEgY2hhcnQgYXJlIGEgZ2V0dGVyL3NldHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgY2hhcnRcbm9uIHNldCB0byBtaW1pYyB0eXBpY2FsIGQzIG9wdGlvbiBjaGFpbmluZywgZS5nLiBzdmcub3B0aW9uMSgnYScpLm9wdGlvbjIoJ2InKTtcblxub3B0aW9uIG9iamVjdHMgc2hvdWxkIGJlIGdlbmVyYXRlZCB2aWEgT2JqZWN0LmNyZWF0ZSgpIHRvIHByb3ZpZGVcbnRoZSBvcHRpb24gb2YgbWFuaXB1bGF0aW5nIGRhdGEgdmlhIGdldC9zZXQgZnVuY3Rpb25zLlxuKi9cbm52LnV0aWxzLmluaXRPcHRpb24gPSBmdW5jdGlvbihjaGFydCwgbmFtZSkge1xuICAgIC8vIGlmIGl0J3MgYSBjYWxsIG9wdGlvbiwganVzdCBjYWxsIGl0IGRpcmVjdGx5LCBvdGhlcndpc2UgZG8gZ2V0L3NldFxuICAgIGlmIChjaGFydC5fY2FsbHMgJiYgY2hhcnQuX2NhbGxzW25hbWVdKSB7XG4gICAgICAgIGNoYXJ0W25hbWVdID0gY2hhcnQuX2NhbGxzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXJ0W25hbWVdID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNoYXJ0Ll9vcHRpb25zW25hbWVdO1xuICAgICAgICAgICAgY2hhcnQuX292ZXJyaWRlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBjaGFydC5fb3B0aW9uc1tuYW1lXSA9IF87XG4gICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhbGxpbmcgdGhlIG9wdGlvbiBhcyBfb3B0aW9uIHdpbGwgaWdub3JlIGlmIHNldCBieSBvcHRpb24gYWxyZWFkeVxuICAgICAgICAvLyBzbyBudmQzIGNhbiBzZXQgb3B0aW9ucyBpbnRlcm5hbGx5IGJ1dCB0aGUgc3RvcCBpZiBzZXQgbWFudWFsbHlcbiAgICAgICAgY2hhcnRbJ18nICsgbmFtZV0gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGFydC5fb3B0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghY2hhcnQuX292ZXJyaWRlc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGNoYXJ0Ll9vcHRpb25zW25hbWVdID0gXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLypcbkFkZCBhbGwgb3B0aW9ucyBpbiBhbiBvcHRpb25zIG9iamVjdCB0byB0aGUgY2hhcnRcbiovXG5udi51dGlscy5pbml0T3B0aW9ucyA9IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnQuX292ZXJyaWRlcyA9IGNoYXJ0Ll9vdmVycmlkZXMgfHwge307XG4gICAgdmFyIG9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYXJ0Ll9vcHRpb25zIHx8IHt9KTtcbiAgICB2YXIgY2FsbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFydC5fY2FsbHMgfHwge30pO1xuICAgIG9wcyA9IG9wcy5jb25jYXQoY2FsbHMpO1xuICAgIGZvciAodmFyIGkgaW4gb3BzKSB7XG4gICAgICAgIG52LnV0aWxzLmluaXRPcHRpb24oY2hhcnQsIG9wc1tpXSk7XG4gICAgfVxufTtcblxuXG4vKlxuSW5oZXJpdCBvcHRpb25zIGZyb20gYSBEMyBvYmplY3RcbmQzLnJlYmluZCBtYWtlcyBjYWxsaW5nIHRoZSBmdW5jdGlvbiBvbiB0YXJnZXQgYWN0dWFsbHkgY2FsbCBpdCBvbiBzb3VyY2VcbkFsc28gdXNlIF9kM29wdGlvbnMgc28gd2UgY2FuIHRyYWNrIHdoYXQgd2UgaW5oZXJpdCBmb3IgZG9jdW1lbnRhdGlvbiBhbmQgY2hhaW5lZCBpbmhlcml0YW5jZVxuKi9cbm52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMgPSBmdW5jdGlvbih0YXJnZXQsIGQzX3NvdXJjZSwgb3BsaXN0KSB7XG4gICAgdGFyZ2V0Ll9kM29wdGlvbnMgPSBvcGxpc3QuY29uY2F0KHRhcmdldC5fZDNvcHRpb25zIHx8IFtdKTtcbiAgICBvcGxpc3QudW5zaGlmdChkM19zb3VyY2UpO1xuICAgIG9wbGlzdC51bnNoaWZ0KHRhcmdldCk7XG4gICAgZDMucmViaW5kLmFwcGx5KHRoaXMsIG9wbGlzdCk7XG59O1xuXG5cbi8qXG5SZW1vdmUgZHVwbGljYXRlcyBmcm9tIGFuIGFycmF5XG4qL1xubnYudXRpbHMuYXJyYXlVbmlxdWUgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGEuc29ydCgpLmZpbHRlcihmdW5jdGlvbihpdGVtLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuICFwb3MgfHwgaXRlbSAhPSBhW3BvcyAtIDFdO1xuICAgIH0pO1xufTtcblxuXG4vKlxuS2VlcHMgYSBsaXN0IG9mIGN1c3RvbSBzeW1ib2xzIHRvIGRyYXcgZnJvbSBpbiBhZGRpdGlvbiB0byBkMy5zdmcuc3ltYm9sXG5OZWNlc3Nhcnkgc2luY2UgZDMgZG9lc24ndCBsZXQgeW91IGV4dGVuZCBpdHMgbGlzdCAtXy1cbkFkZCBuZXcgc3ltYm9scyBieSBkb2luZyBudi51dGlscy5zeW1ib2xzLnNldCgnbmFtZScsIGZ1bmN0aW9uKHNpemUpey4uLn0pO1xuKi9cbm52LnV0aWxzLnN5bWJvbE1hcCA9IGQzLm1hcCgpO1xuXG5cbi8qXG5SZXBsYWNlcyBkMy5zdmcuc3ltYm9sIHNvIHRoYXQgd2UgY2FuIGxvb2sgYm90aCB0aGVyZSBhbmQgb3VyIG93biBtYXBcbiAqL1xubnYudXRpbHMuc3ltYm9sID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUsXG4gICAgICAgIHNpemUgPSA2NDtcbiAgICBmdW5jdGlvbiBzeW1ib2woZCxpKSB7XG4gICAgICAgIHZhciB0ID0gdHlwZS5jYWxsKHRoaXMsZCxpKTtcbiAgICAgICAgdmFyIHMgPSBzaXplLmNhbGwodGhpcyxkLGkpO1xuICAgICAgICBpZiAoZDMuc3ZnLnN5bWJvbFR5cGVzLmluZGV4T2YodCkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZDMuc3ZnLnN5bWJvbCgpLnR5cGUodCkuc2l6ZShzKSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG52LnV0aWxzLnN5bWJvbE1hcC5nZXQodCkocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3ltYm9sLnR5cGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHR5cGU7XG4gICAgICAgIHR5cGUgPSBkMy5mdW5jdG9yKF8pO1xuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICAgIHNpemUgPSBkMy5mdW5jdG9yKF8pO1xuICAgICAgICByZXR1cm4gc3ltYm9sO1xuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbDtcbn07XG5cblxuLypcbkluaGVyaXQgb3B0aW9uIGdldHRlci9zZXR0ZXIgZnVuY3Rpb25zIGZyb20gc291cmNlIHRvIHRhcmdldFxuZDMucmViaW5kIG1ha2VzIGNhbGxpbmcgdGhlIGZ1bmN0aW9uIG9uIHRhcmdldCBhY3R1YWxseSBjYWxsIGl0IG9uIHNvdXJjZVxuQWxzbyB0cmFjayB2aWEgX2luaGVyaXRlZCBhbmQgX2Qzb3B0aW9ucyBzbyB3ZSBjYW4gdHJhY2sgd2hhdCB3ZSBpbmhlcml0XG5mb3IgZG9jdW1lbnRhdGlvbiBnZW5lcmF0aW9uIHB1cnBvc2VzIGFuZCBjaGFpbmVkIGluaGVyaXRhbmNlXG4qL1xubnYudXRpbHMuaW5oZXJpdE9wdGlvbnMgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIC8vIGluaGVyaXQgYWxsIHRoZSB0aGluZ3NcbiAgICB2YXIgb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlLl9vcHRpb25zIHx8IHt9KTtcbiAgICB2YXIgY2FsbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UuX2NhbGxzIHx8IHt9KTtcbiAgICB2YXIgaW5oZXJpdGVkID0gc291cmNlLl9pbmhlcml0ZWQgfHwgW107XG4gICAgdmFyIGQzb3BzID0gc291cmNlLl9kM29wdGlvbnMgfHwgW107XG4gICAgdmFyIGFyZ3MgPSBvcHMuY29uY2F0KGNhbGxzKS5jb25jYXQoaW5oZXJpdGVkKS5jb25jYXQoZDNvcHMpO1xuICAgIGFyZ3MudW5zaGlmdChzb3VyY2UpO1xuICAgIGFyZ3MudW5zaGlmdCh0YXJnZXQpO1xuICAgIGQzLnJlYmluZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAvLyBwYXNzIGFsb25nIHRoZSBsaXN0cyB0byBrZWVwIHRyYWNrIG9mIHRoZW0sIGRvbid0IGFsbG93IGR1cGxpY2F0ZXNcbiAgICB0YXJnZXQuX2luaGVyaXRlZCA9IG52LnV0aWxzLmFycmF5VW5pcXVlKG9wcy5jb25jYXQoY2FsbHMpLmNvbmNhdChpbmhlcml0ZWQpLmNvbmNhdChvcHMpLmNvbmNhdCh0YXJnZXQuX2luaGVyaXRlZCB8fCBbXSkpO1xuICAgIHRhcmdldC5fZDNvcHRpb25zID0gbnYudXRpbHMuYXJyYXlVbmlxdWUoZDNvcHMuY29uY2F0KHRhcmdldC5fZDNvcHRpb25zIHx8IFtdKSk7XG59O1xuXG5cbi8qXG5SdW5zIGNvbW1vbiBpbml0aWFsaXplIGNvZGUgb24gdGhlIHN2ZyBiZWZvcmUgdGhlIGNoYXJ0IGJ1aWxkc1xuKi9cbm52LnV0aWxzLmluaXRTVkcgPSBmdW5jdGlvbihzdmcpIHtcbiAgICBzdmcuY2xhc3NlZCh7J252ZDMtc3ZnJzp0cnVlfSk7XG59O1xuXG5cbi8qXG5TYW5pdGl6ZSBhbmQgcHJvdmlkZSBkZWZhdWx0IGZvciB0aGUgY29udGFpbmVyIGhlaWdodC5cbiovXG5udi51dGlscy5zYW5pdGl6ZUhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSwgMTApIHx8IDQwMCk7XG59O1xuXG5cbi8qXG5TYW5pdGl6ZSBhbmQgcHJvdmlkZSBkZWZhdWx0IGZvciB0aGUgY29udGFpbmVyIHdpZHRoLlxuKi9cbm52LnV0aWxzLnNhbml0aXplV2lkdGggPSBmdW5jdGlvbih3aWR0aCwgY29udGFpbmVyKSB7XG4gICAgcmV0dXJuICh3aWR0aCB8fCBwYXJzZUludChjb250YWluZXIuc3R5bGUoJ3dpZHRoJyksIDEwKSB8fCA5NjApO1xufTtcblxuXG4vKlxuQ2FsY3VsYXRlIHRoZSBhdmFpbGFibGUgaGVpZ2h0IGZvciBhIGNoYXJ0LlxuKi9cbm52LnV0aWxzLmF2YWlsYWJsZUhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCxudi51dGlscy5zYW5pdGl6ZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lcikgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSk7XG59O1xuXG4vKlxuQ2FsY3VsYXRlIHRoZSBhdmFpbGFibGUgd2lkdGggZm9yIGEgY2hhcnQuXG4qL1xubnYudXRpbHMuYXZhaWxhYmxlV2lkdGggPSBmdW5jdGlvbih3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCxudi51dGlscy5zYW5pdGl6ZVdpZHRoKHdpZHRoLCBjb250YWluZXIpIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQpO1xufTtcblxuLypcbkNsZWFyIGFueSByZW5kZXJlZCBjaGFydCBjb21wb25lbnRzIGFuZCBkaXNwbGF5IGEgY2hhcnQncyAnbm9EYXRhJyBtZXNzYWdlXG4qL1xubnYudXRpbHMubm9EYXRhID0gZnVuY3Rpb24oY2hhcnQsIGNvbnRhaW5lcikge1xuICAgIHZhciBvcHQgPSBjaGFydC5vcHRpb25zKCksXG4gICAgICAgIG1hcmdpbiA9IG9wdC5tYXJnaW4oKSxcbiAgICAgICAgbm9EYXRhID0gb3B0Lm5vRGF0YSgpLFxuICAgICAgICBkYXRhID0gKG5vRGF0YSA9PSBudWxsKSA/IFtcIk5vIERhdGEgQXZhaWxhYmxlLlwiXSA6IFtub0RhdGFdLFxuICAgICAgICBoZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQobnVsbCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICB3aWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKG51bGwsIGNvbnRhaW5lciwgbWFyZ2luKSxcbiAgICAgICAgeCA9IG1hcmdpbi5sZWZ0ICsgd2lkdGgvMixcbiAgICAgICAgeSA9IG1hcmdpbi50b3AgKyBoZWlnaHQvMjtcblxuICAgIC8vUmVtb3ZlIGFueSBwcmV2aW91c2x5IGNyZWF0ZWQgY2hhcnQgY29tcG9uZW50c1xuICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cnKS5yZW1vdmUoKTtcblxuICAgIHZhciBub0RhdGFUZXh0ID0gY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLmRhdGEoZGF0YSk7XG5cbiAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgIG5vRGF0YVRleHRcbiAgICAgICAgLmF0dHIoJ3gnLCB4KVxuICAgICAgICAuYXR0cigneScsIHkpXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uKHQpeyByZXR1cm4gdDsgfSk7XG59O1xuXG4vKlxuIFdyYXAgbG9uZyBsYWJlbHMuXG4gKi9cbm52LnV0aWxzLndyYXBUaWNrcyA9IGZ1bmN0aW9uICh0ZXh0LCB3aWR0aCkge1xuICAgIHRleHQuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRleHQgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICB3b3JkcyA9IHRleHQudGV4dCgpLnNwbGl0KC9cXHMrLykucmV2ZXJzZSgpLFxuICAgICAgICAgICAgd29yZCxcbiAgICAgICAgICAgIGxpbmUgPSBbXSxcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAwLFxuICAgICAgICAgICAgbGluZUhlaWdodCA9IDEuMSxcbiAgICAgICAgICAgIHkgPSB0ZXh0LmF0dHIoXCJ5XCIpLFxuICAgICAgICAgICAgZHkgPSBwYXJzZUZsb2F0KHRleHQuYXR0cihcImR5XCIpKSxcbiAgICAgICAgICAgIHRzcGFuID0gdGV4dC50ZXh0KG51bGwpLmFwcGVuZChcInRzcGFuXCIpLmF0dHIoXCJ4XCIsIDApLmF0dHIoXCJ5XCIsIHkpLmF0dHIoXCJkeVwiLCBkeSArIFwiZW1cIik7XG4gICAgICAgIHdoaWxlICh3b3JkID0gd29yZHMucG9wKCkpIHtcbiAgICAgICAgICAgIGxpbmUucHVzaCh3b3JkKTtcbiAgICAgICAgICAgIHRzcGFuLnRleHQobGluZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICBpZiAodHNwYW4ubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRzcGFuLnRleHQobGluZS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgICAgICAgbGluZSA9IFt3b3JkXTtcbiAgICAgICAgICAgICAgICB0c3BhbiA9IHRleHQuYXBwZW5kKFwidHNwYW5cIikuYXR0cihcInhcIiwgMCkuYXR0cihcInlcIiwgeSkuYXR0cihcImR5XCIsICsrbGluZU51bWJlciAqIGxpbmVIZWlnaHQgKyBkeSArIFwiZW1cIikudGV4dCh3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLypcbkNoZWNrIGVxdWFsaXR5IG9mIDIgYXJyYXlcbiovXG5udi51dGlscy5hcnJheUVxdWFscyA9IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5Mikge1xuICAgIGlmIChhcnJheTEgPT09IGFycmF5MilcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBpZiAoIWFycmF5MSB8fCAhYXJyYXkyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBjb21wYXJlIGxlbmd0aHMgLSBjYW4gc2F2ZSBhIGxvdCBvZiB0aW1lXG4gICAgaWYgKGFycmF5MS5sZW5ndGggIT0gYXJyYXkyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsXG4gICAgICAgIGwgPSBhcnJheTEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgbmVzdGVkIGFycmF5c1xuICAgICAgICBpZiAoYXJyYXkxW2ldIGluc3RhbmNlb2YgQXJyYXkgJiYgYXJyYXkyW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byB0aGUgbmVzdGVkIGFycmF5c1xuICAgICAgICAgICAgaWYgKCFudi5hcnJheUVxdWFscyhhcnJheTFbaV0sIGFycmF5MltpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGFycmF5MVtpXSAhPSBhcnJheTJbaV0pIHtcbiAgICAgICAgICAgIC8vIFdhcm5pbmcgLSB0d28gZGlmZmVyZW50IG9iamVjdCBpbnN0YW5jZXMgd2lsbCBuZXZlciBiZSBlcXVhbDoge3g6MjB9ICE9IHt4OjIwfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbm52Lm1vZGVscy5heGlzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBheGlzID0gZDMuc3ZnLmF4aXMoKTtcbiAgICB2YXIgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKTtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gNzUgLy9vbmx5IHVzZWQgZm9yIHRpY2tMYWJlbCBjdXJyZW50bHlcbiAgICAgICAgLCBoZWlnaHQgPSA2MCAvL29ubHkgdXNlZCBmb3IgdGlja0xhYmVsIGN1cnJlbnRseVxuICAgICAgICAsIGF4aXNMYWJlbFRleHQgPSBudWxsXG4gICAgICAgICwgc2hvd01heE1pbiA9IHRydWUgLy9UT0RPOiBzaG93TWF4TWluIHNob3VsZCBiZSBkaXNhYmxlZCBvbiBhbGwgb3JkaW5hbCBzY2FsZWQgYXhlc1xuICAgICAgICAsIHJvdGF0ZUxhYmVscyA9IDBcbiAgICAgICAgLCByb3RhdGVZTGFiZWwgPSB0cnVlXG4gICAgICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXG4gICAgICAgICwgaXNPcmRpbmFsID0gZmFsc2VcbiAgICAgICAgLCB0aWNrcyA9IG51bGxcbiAgICAgICAgLCBheGlzTGFiZWxEaXN0YW5jZSA9IDBcbiAgICAgICAgLCBmb250U2l6ZSA9IHVuZGVmaW5lZFxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyRW5kJylcbiAgICAgICAgO1xuICAgIGF4aXNcbiAgICAgICAgLnNjYWxlKHNjYWxlKVxuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja0Zvcm1hdChmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pXG4gICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2NhbGUwO1xuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWF4aXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1heGlzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBpZiAodGlja3MgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgYXhpcy50aWNrcyh0aWNrcyk7XG4gICAgICAgICAgICBlbHNlIGlmIChheGlzLm9yaWVudCgpID09ICd0b3AnIHx8IGF4aXMub3JpZW50KCkgPT0gJ2JvdHRvbScpXG4gICAgICAgICAgICAgICAgYXhpcy50aWNrcyhNYXRoLmFicyhzY2FsZS5yYW5nZSgpWzFdIC0gc2NhbGUucmFuZ2UoKVswXSkgLyAxMDApO1xuXG4gICAgICAgICAgICAvL1RPRE86IGNvbnNpZGVyIGNhbGN1bGF0aW5nIHdpZHRoL2hlaWdodCBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBsYWJlbCBpcyBhZGRlZCwgZm9yIHJlZmVyZW5jZSBpbiBjaGFydHMgdXNpbmcgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIGcud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnYXhpcycpLmNhbGwoYXhpcyk7XG5cbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMCB8fCBheGlzLnNjYWxlKCk7XG5cbiAgICAgICAgICAgIHZhciBmbXQgPSBheGlzLnRpY2tGb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChmbXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZtdCA9IHNjYWxlMC50aWNrRm9ybWF0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBheGlzTGFiZWwgPSBnLnNlbGVjdEFsbCgndGV4dC5udi1heGlzbGFiZWwnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtheGlzTGFiZWxUZXh0IHx8IG51bGxdKTtcbiAgICAgICAgICAgIGF4aXNMYWJlbC5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vb25seSBza2lwIHdoZW4gZm9udFNpemUgaXMgdW5kZWZpbmVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIHdpdGggYSBudWxsIG9yIGJsYW5rIHN0cmluZ1xuICAgICAgICAgICAgaWYgKGZvbnRTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdEFsbCgnZycpLnNlbGVjdChcInRleHRcIikuc3R5bGUoJ2ZvbnQtc2l6ZScsIGZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHhMYWJlbE1hcmdpbjtcbiAgICAgICAgICAgIHZhciBheGlzTWF4TWluO1xuICAgICAgICAgICAgdmFyIHc7XG4gICAgICAgICAgICBzd2l0Y2ggKGF4aXMub3JpZW50KCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgIHcgPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlLnJhbmdlKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBpc09yZGluYWwgPyBzY2FsZS5yYW5nZSgpWzBdICogMiArIHNjYWxlLnJhbmdlQmFuZCgpIDogMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NhbGUucmFuZ2UoKS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdyA9IGlzT3JkaW5hbCA/IHNjYWxlLnJhbmdlKClbMF0gKyBzY2FsZS5yYW5nZSgpWzFdICsgc2NhbGUucmFuZ2VCYW5kKCkgOiBzY2FsZS5yYW5nZSgpWzFdO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggc2NhbGUucmFuZ2UoKS5sZW5ndGggPiAyKXtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNjYWxlLnJhbmdlKClbc2NhbGUucmFuZ2UoKS5sZW5ndGgtMV0rKHNjYWxlLnJhbmdlKClbMV0tc2NhbGUucmFuZ2UoKVswXSk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB3LzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbiA9IHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnbnYtYXhpc01heE1pbicsJ252LWF4aXNNYXhNaW4teCcsKGkgPT0gMCA/ICdudi1heGlzTWluLXgnOidudi1heGlzTWF4LXgnKV0uam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmQoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZShkKSkgKyAnLDApJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0wLjVlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHYpLm1hdGNoKCdOYU4nKSA/ICcnIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4ud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbWluLW1heCB0b3AnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZS5yYW5nZSgpW2ldKSArICcsMCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgICAgeExhYmVsTWFyZ2luID0gYXhpc0xhYmVsRGlzdGFuY2UgKyAzNjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFRleHRXaWR0aCA9IDMwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4VGlja3MgPSBnLnNlbGVjdEFsbCgnZycpLnNlbGVjdChcInRleHRcIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVMYWJlbHNSdWxlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGVMYWJlbHMlMzYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1Jlc2V0IHRyYW5zZm9ybSBvbiB0aWNrcyBzbyB0ZXh0SGVpZ2h0IGNhbiBiZSBjYWxjdWxhdGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgeFRpY2tzLmF0dHIoJ3RyYW5zZm9ybScsICcnKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NhbGN1bGF0ZSB0aGUgbG9uZ2VzdCB4VGljayB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgeFRpY2tzLmVhY2goZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm94ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBib3gud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEhlaWdodCA9IGJveC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod2lkdGggPiBtYXhUZXh0V2lkdGgpIG1heFRleHRXaWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVMYWJlbHNSdWxlID0gJ3JvdGF0ZSgnICsgcm90YXRlTGFiZWxzICsgJyAwLCcgKyAodGV4dEhlaWdodC8yICsgYXhpcy50aWNrUGFkZGluZygpKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQ29udmVydCB0byByYWRpYW5zIGJlZm9yZSBjYWxjdWxhdGluZyBzaW4uIEFkZCAzMCB0byBtYXJnaW4gZm9yIGhlYWx0aHkgcGFkZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3RhdGVMYWJlbHMqTWF0aC5QSS8xODApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMYWJlbE1hcmdpbiA9IChzaW4gPyBzaW4qbWF4VGV4dFdpZHRoIDogbWF4VGV4dFdpZHRoKSszMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vUm90YXRlIGFsbCB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCByb3RhdGVMYWJlbHNSdWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMlMzYwID4gMCA/ICdzdGFydCcgOiAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyAoaSAlIDIgPT0gMCA/ICcwJyA6ICcxMicpICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4VGlja3MuYXR0cigndHJhbnNmb3JtJywgXCJ0cmFuc2xhdGUoMCwwKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2FsZS5yYW5nZSgpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdyA9IGlzT3JkaW5hbCA/IHNjYWxlLnJhbmdlKClbMF0gKiAyICsgc2NhbGUucmFuZ2VCYW5kKCkgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjYWxlLnJhbmdlKCkubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gaXNPcmRpbmFsID8gc2NhbGUucmFuZ2UoKVswXSArIHNjYWxlLnJhbmdlKClbMV0gKyBzY2FsZS5yYW5nZUJhbmQoKSA6IHNjYWxlLnJhbmdlKClbMV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIHNjYWxlLnJhbmdlKCkubGVuZ3RoID4gMil7XG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gc2NhbGUucmFuZ2UoKVtzY2FsZS5yYW5nZSgpLmxlbmd0aC0xXSsoc2NhbGUucmFuZ2UoKVsxXS1zY2FsZS5yYW5nZSgpWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeExhYmVsTWFyZ2luKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB3LzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiAoc2hvd01heE1pbiAmJiAhaXNPcmRpbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluID0gd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8uZGF0YShzY2FsZS5kb21haW4oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShbc2NhbGUuZG9tYWluKClbMF0sIHNjYWxlLmRvbWFpbigpW3NjYWxlLmRvbWFpbigpLmxlbmd0aCAtIDFdXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ252LWF4aXNNYXhNaW4nLCdudi1heGlzTWF4TWluLXgnLChpID09IDAgPyAnbnYtYXhpc01pbi14JzonbnYtYXhpc01heC14JyldLmpvaW4oJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuYXBwZW5kKCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBudi51dGlscy5OYU50b1plcm8oKHNjYWxlKGQpICsgKGlzT3JkaW5hbCA/IHNjYWxlLnJhbmdlQmFuZCgpIC8gMiA6IDApKSkgKyAnLDApJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy43MWVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIGF4aXMudGlja1BhZGRpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgcm90YXRlTGFiZWxzUnVsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlTGFiZWxzID8gKHJvdGF0ZUxhYmVscyUzNjAgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKSA6ICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHYpLm1hdGNoKCdOYU4nKSA/ICcnIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4ud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbWluLW1heCBib3R0b20nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIG52LnV0aWxzLk5hTnRvWmVybygoc2NhbGUoZCkgKyAoaXNPcmRpbmFsID8gc2NhbGUucmFuZ2VCYW5kKCkgLyAyIDogMCkpKSArICcsMCknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbC5lbnRlcigpLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LWF4aXNsYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVZTGFiZWwgPyAnbWlkZGxlJyA6ICdiZWdpbicpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgcm90YXRlWUxhYmVsID8gJ3JvdGF0ZSg5MCknIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHJvdGF0ZVlMYWJlbCA/ICgtTWF0aC5tYXgobWFyZ2luLnJpZ2h0LCB3aWR0aCkgKyAxMiAtIChheGlzTGFiZWxEaXN0YW5jZSB8fCAwKSkgOiAtMTApIC8vVE9ETzogY29uc2lkZXIgY2FsY3VsYXRpbmcgdGhpcyBiYXNlZCBvbiBsYXJnZXN0IHRpY2sgd2lkdGguLi4gT1IgYXQgbGVhc3QgZXhwb3NlIHRoaXMgb24gY2hhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgcm90YXRlWUxhYmVsID8gKGQzLm1heChzY2FsZS5yYW5nZSgpKSAvIDIpIDogYXhpcy50aWNrUGFkZGluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dNYXhNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4gPSB3cmFwLnNlbGVjdEFsbCgnZy5udi1heGlzTWF4TWluJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShzY2FsZS5kb21haW4oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgIFx0YXhpc01heE1pbi5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJyxmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydudi1heGlzTWF4TWluJywnbnYtYXhpc01heE1pbi15JywoaSA9PSAwID8gJ252LWF4aXNNaW4teSc6J252LWF4aXNNYXgteScpXS5qb2luKCcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsJyArIG52LnV0aWxzLk5hTnRvWmVybyhzY2FsZShkKSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMzJlbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCAnc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBmbXQoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoJycgKyB2KS5tYXRjaCgnTmFOJykgPyAnJyA6IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ21pbi1tYXggcmlnaHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgbnYudXRpbHMuTmFOdG9aZXJvKHNjYWxlLnJhbmdlKClbaV0pICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgIC8vRm9yIGR5bmFtaWNhbGx5IHBsYWNpbmcgdGhlIGxhYmVsLiBDYW4gYmUgdXNlZCB3aXRoIGR5bmFtaWNhbGx5LXNpemVkIGNoYXJ0IGF4aXMgbWFyZ2luc1xuICAgICAgICAgICAgICAgICAgICAgdmFyIHlUaWNrcyA9IGcuc2VsZWN0QWxsKCdnJykuc2VsZWN0KFwidGV4dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgIHlUaWNrcy5lYWNoKGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxQYWRkaW5nID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIGF4aXMudGlja1BhZGRpbmcoKSArIDE2O1xuICAgICAgICAgICAgICAgICAgICAgaWYobGFiZWxQYWRkaW5nID4gd2lkdGgpIHdpZHRoID0gbGFiZWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWwuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi1heGlzbGFiZWwnKTtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xhYmVsXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgcm90YXRlWUxhYmVsID8gJ21pZGRsZScgOiAnZW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCByb3RhdGVZTGFiZWwgPyAncm90YXRlKC05MCknIDogJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHJvdGF0ZVlMYWJlbCA/ICgtTWF0aC5tYXgobWFyZ2luLmxlZnQsIHdpZHRoKSArIDI1IC0gKGF4aXNMYWJlbERpc3RhbmNlIHx8IDApKSA6IC0xMClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4Jywgcm90YXRlWUxhYmVsID8gKC1kMy5tYXgoc2NhbGUucmFuZ2UoKSkgLyAyKSA6IC1heGlzLnRpY2tQYWRkaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01heE1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbiA9IHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKHNjYWxlLmRvbWFpbigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4uZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsnbnYtYXhpc01heE1pbicsJ252LWF4aXNNYXhNaW4teScsKGkgPT0gMCA/ICdudi1heGlzTWluLXknOidudi1heGlzTWF4LXknKV0uam9pbignICcpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhpc01heE1pbi5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTWF4TWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyBudi51dGlscy5OYU50b1plcm8oc2NhbGUwKGQpKSArICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtYXhpcy50aWNrUGFkZGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdlbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGZtdChkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHYpLm1hdGNoKCdOYU4nKSA/ICcnIDogdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNNYXhNaW4ud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbWluLW1heCByaWdodCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgwLCcgKyBudi51dGlscy5OYU50b1plcm8oc2NhbGUucmFuZ2UoKVtpXSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXhpc0xhYmVsLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgaWYgKHNob3dNYXhNaW4gJiYgKGF4aXMub3JpZW50KCkgPT09ICdsZWZ0JyB8fCBheGlzLm9yaWVudCgpID09PSAncmlnaHQnKSkge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgbWF4IGFuZCBtaW4gb3ZlcmxhcCBvdGhlciB2YWx1ZXMsIGlmIHNvLCBoaWRlIHRoZSB2YWx1ZXMgdGhhdCBvdmVybGFwXG4gICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJ2cnKSAvLyB0aGUgZydzIHdyYXBwaW5nIGVhY2ggdGlja1xuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5hdHRyKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NhbGUoZCkgPCBzY2FsZS5yYW5nZSgpWzFdICsgMTAgfHwgc2NhbGUoZCkgPiBzY2FsZS5yYW5nZSgpWzBdIC0gMTApIHsgLy8gMTAgaXMgYXNzdW1pbmcgdGV4dCBoZWlnaHQgaXMgMTYuLi4gaWYgZCBpcyAwLCBsZWF2ZSBpdCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA+IDFlLTEwIHx8IGQgPCAtMWUtMTApIC8vIGFjY291bnRzIGZvciBtaW5vciBmbG9hdGluZyBwb2ludCBlcnJvcnMuLi4gdGhvdWdoIGNvdWxkIGJlIHByb2JsZW1hdGljIGlmIHRoZSBzY2FsZSBpcyBFWFRSRU1FTFkgU01BTExcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ29wYWNpdHknLCAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5hdHRyKCdvcGFjaXR5JywgMCk7IC8vIERvbid0IHJlbW92ZSB0aGUgWkVSTyBsaW5lISFcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIE1heCBhbmQgTWluID0gMCBvbmx5IHNob3cgbWluLCBJc3N1ZSAjMjgxXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlLmRvbWFpbigpWzBdID09IHNjYWxlLmRvbWFpbigpWzFdICYmIHNjYWxlLmRvbWFpbigpWzBdID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbicpLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaSA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dNYXhNaW4gJiYgKGF4aXMub3JpZW50KCkgPT09ICd0b3AnIHx8IGF4aXMub3JpZW50KCkgPT09ICdib3R0b20nKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXhNaW5SYW5nZSA9IFtdO1xuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0QWxsKCdnLm52LWF4aXNNYXhNaW4nKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIC8vIGk9PSAxLCBtYXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWluUmFuZ2UucHVzaChzY2FsZShkKSAtIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSA0KTsgIC8vYXNzdW1pbmcgdGhlIG1heCBhbmQgbWluIGxhYmVscyBhcmUgYXMgd2lkZSBhcyB0aGUgbmV4dCB0aWNrICh3aXRoIGFuIGV4dHJhIDQgcGl4ZWxzIGp1c3QgaW4gY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIGk9PTAsIG1pbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhNaW5SYW5nZS5wdXNoKHNjYWxlKGQpICsgdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9Y2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpKSAvLyBpPT0gMSwgbWF4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heE1pblJhbmdlLnB1c2goc2NhbGUoZCkgLSA0KTsgIC8vYXNzdW1pbmcgdGhlIG1heCBhbmQgbWluIGxhYmVscyBhcmUgYXMgd2lkZSBhcyB0aGUgbmV4dCB0aWNrICh3aXRoIGFuIGV4dHJhIDQgcGl4ZWxzIGp1c3QgaW4gY2FzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIC8vIGk9PTAsIG1pbiBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhNaW5SYW5nZS5wdXNoKHNjYWxlKGQpICsgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBnJ3Mgd3JhcHBpbmcgZWFjaCB0aWNrXG4gICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJ2cnKS5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxlKGQpIDwgbWF4TWluUmFuZ2VbMF0gfHwgc2NhbGUoZCkgPiBtYXhNaW5SYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPiAxZS0xMCB8fCBkIDwgLTFlLTEwKSAvLyBhY2NvdW50cyBmb3IgbWlub3IgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLi4uIHRob3VnaCBjb3VsZCBiZSBwcm9ibGVtYXRpYyBpZiB0aGUgc2NhbGUgaXMgRVhUUkVNRUxZIFNNQUxMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5yZW1vdmUoKTsgLy8gRG9uJ3QgcmVtb3ZlIHRoZSBaRVJPIGxpbmUhIVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vSGlnaGxpZ2h0IHplcm8gdGljayBsaW5lXG4gICAgICAgICAgICBnLnNlbGVjdEFsbCgnLnRpY2snKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgVGhlIGZpbHRlciBuZWVkcyB0byByZXR1cm4gb25seSB0aWNrcyBhdCBvciBuZWFyIHplcm8uXG4gICAgICAgICAgICAgICAgICAgIE51bWJlcnMgbGlrZSAwLjAwMDAxIG5lZWQgdG8gY291bnQgYXMgemVybyBhcyB3ZWxsLFxuICAgICAgICAgICAgICAgICAgICBhbmQgdGhlIGFyaXRobWV0aWMgdHJpY2sgYmVsb3cgc29sdmVzIHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhcGFyc2VGbG9hdChNYXRoLnJvdW5kKGQgKiAxMDAwMDApIC8gMTAwMDAwMCkgJiYgKGQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB9KSBcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnemVybycsIHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlLmNvcHkoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2F4aXMgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuYXhpcyA9IGF4aXM7XG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICBheGlzTGFiZWxEaXN0YW5jZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYXhpc0xhYmVsRGlzdGFuY2U7fSwgc2V0OiBmdW5jdGlvbihfKXtheGlzTGFiZWxEaXN0YW5jZT1fO319LFxuICAgICAgICBzdGFnZ2VyTGFiZWxzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhZ2dlckxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWdnZXJMYWJlbHM9Xzt9fSxcbiAgICAgICAgcm90YXRlTGFiZWxzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJvdGF0ZUxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JvdGF0ZUxhYmVscz1fO319LFxuICAgICAgICByb3RhdGVZTGFiZWw6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcm90YXRlWUxhYmVsO30sIHNldDogZnVuY3Rpb24oXyl7cm90YXRlWUxhYmVsPV87fX0sXG4gICAgICAgIHNob3dNYXhNaW46ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TWF4TWluO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd01heE1pbj1fO319LFxuICAgICAgICBheGlzTGFiZWw6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYXhpc0xhYmVsVGV4dDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2F4aXNMYWJlbFRleHQ9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB0aWNrczogICAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdGlja3M7fSwgc2V0OiBmdW5jdGlvbihfKXt0aWNrcz1fO319LFxuICAgICAgICB3aWR0aDogICAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBmb250U2l6ZTogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9udFNpemU7fSwgc2V0OiBmdW5jdGlvbihfKXtmb250U2l6ZT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAhPT0gdW5kZWZpbmVkICAgID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgIT09IHVuZGVmaW5lZCAgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAhPT0gdW5kZWZpbmVkICAgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbj1fO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgc2NhbGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNjYWxlO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBzY2FsZSA9IF87XG4gICAgICAgICAgICBheGlzLnNjYWxlKHNjYWxlKTtcbiAgICAgICAgICAgIGlzT3JkaW5hbCA9IHR5cGVvZiBzY2FsZS5yYW5nZUJhbmRzID09PSAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnNEMyhjaGFydCwgc2NhbGUsIFsnZG9tYWluJywgJ3JhbmdlJywgJ3JhbmdlQmFuZCcsICdyYW5nZUJhbmRzJ10pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMoY2hhcnQsIGF4aXMsIFsnb3JpZW50JywgJ3RpY2tWYWx1ZXMnLCAndGlja1N1YmRpdmlkZScsICd0aWNrU2l6ZScsICd0aWNrUGFkZGluZycsICd0aWNrRm9ybWF0J10pO1xuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zRDMoY2hhcnQsIHNjYWxlLCBbJ2RvbWFpbicsICdyYW5nZScsICdyYW5nZUJhbmQnLCAncmFuZ2VCYW5kcyddKTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMuYm94UGxvdCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH0sXG4gICAgICAgIHdpZHRoID0gOTYwLFxuICAgICAgICBoZWlnaHQgPSA1MDAsXG4gICAgICAgIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLCAvLyBDcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICB4U2NhbGUgPSBkMy5zY2FsZS5vcmRpbmFsKCksXG4gICAgICAgIHlTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLFxuICAgICAgICBnZXRYICA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubGFiZWwgfSwgLy8gRGVmYXVsdCBkYXRhIG1vZGVsIHNlbGVjdG9ycy5cbiAgICAgICAgZ2V0UTEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5RMSB9LFxuICAgICAgICBnZXRRMiA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLlEyIH0sXG4gICAgICAgIGdldFEzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMuUTMgfSxcbiAgICAgICAgZ2V0V2wgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy53aGlza2VyX2xvdyB9LFxuICAgICAgICBnZXRXaCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLndoaXNrZXJfaGlnaCB9LFxuICAgICAgICBnZXRDb2xvciA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuY29sb3IgfSxcbiAgICAgICAgZ2V0T2xJdGVtcyAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5vdXRsaWVycyB9LFxuICAgICAgICBnZXRPbFZhbHVlID0gZnVuY3Rpb24oZCwgaSwgaikgeyByZXR1cm4gZCB9LFxuICAgICAgICBnZXRPbExhYmVsID0gZnVuY3Rpb24oZCwgaSwgaikgeyByZXR1cm4gZCB9LFxuICAgICAgICBnZXRPbENvbG9yID0gZnVuY3Rpb24oZCwgaSwgaikgeyByZXR1cm4gdW5kZWZpbmVkIH0sXG4gICAgICAgIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKCksXG4gICAgICAgIGNvbnRhaW5lciA9IG51bGwsXG4gICAgICAgIHhEb21haW4sIHhSYW5nZSxcbiAgICAgICAgeURvbWFpbiwgeVJhbmdlLFxuICAgICAgICBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdlbGVtZW50TW91c2Vtb3ZlJywgJ3JlbmRlckVuZCcpLFxuICAgICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgICAgbWF4Qm94V2lkdGggPSBudWxsO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgeFNjYWxlMCwgeVNjYWxlMDtcbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4U2NhbGUuZG9tYWluKHhEb21haW4gfHwgZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRYKGQsaSk7IH0pKVxuICAgICAgICAgICAgICAgIC5yYW5nZUJhbmRzKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdLCAwLjEpO1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBrbm93IHlEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICB2YXIgeURhdGEgPSBbXVxuICAgICAgICAgICAgaWYgKCF5RG9tYWluKSB7XG4gICAgICAgICAgICAgICAgLy8gKHktcmFuZ2UgaXMgYmFzZWQgb24gcXVhcnRpbGVzLCB3aGlza2VycyBhbmQgb3V0bGllcnMpXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdLCB5TWluLCB5TWF4O1xuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcTEgPSBnZXRRMShkKSwgcTMgPSBnZXRRMyhkKSwgd2wgPSBnZXRXbChkKSwgd2ggPSBnZXRXaChkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sSXRlbXMgPSBnZXRPbEl0ZW1zKGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZ2V0T2xWYWx1ZShlLCBpLCB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh3bCkgeyB2YWx1ZXMucHVzaCh3bCkgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocTEpIHsgdmFsdWVzLnB1c2gocTEpIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHEzKSB7IHZhbHVlcy5wdXNoKHEzKSB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aCkgeyB2YWx1ZXMucHVzaCh3aCkgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHlNaW4gPSBkMy5taW4odmFsdWVzKTtcbiAgICAgICAgICAgICAgICB5TWF4ID0gZDMubWF4KHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgeURhdGEgPSBbIHlNaW4sIHlNYXggXSA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHlTY2FsZS5kb21haW4oeURvbWFpbiB8fCB5RGF0YSk7XG4gICAgICAgICAgICB5U2NhbGUucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgICAgIHhTY2FsZTAgPSB4U2NhbGUwIHx8IHhTY2FsZTtcbiAgICAgICAgICAgIHlTY2FsZTAgPSB5U2NhbGUwIHx8IHlTY2FsZS5jb3B5KCkucmFuZ2UoW3lTY2FsZSgwKSx5U2NhbGUoMCldKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAnKTtcbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIGJveHBsb3RzID0gd3JhcC5zZWxlY3RBbGwoJy5udi1ib3hwbG90JykuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0pO1xuICAgICAgICAgICAgdmFyIGJveEVudGVyID0gYm94cGxvdHMuZW50ZXIoKS5hcHBlbmQoJ2cnKS5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KS5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG4gICAgICAgICAgICBib3hwbG90c1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1ib3hwbG90JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4U2NhbGUoZ2V0WChkLGkpKSArIHhTY2FsZS5yYW5nZUJhbmQoKSAqIDAuMDUpICsgJywgMCknOyB9KVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSk7XG4gICAgICAgICAgICBib3hwbG90c1xuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdudi1ib3hwbG90OiBib3hwbG90cycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwLjc1KVxuICAgICAgICAgICAgICAgIC5kZWxheShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgKiBkdXJhdGlvbiAvIGRhdGEubGVuZ3RoIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgKHhTY2FsZShnZXRYKGQsaSkpICsgeFNjYWxlLnJhbmdlQmFuZCgpICogMC4wNSkgKyAnLCAwKSc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBib3hwbG90cy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIC8vIC0tLS0tIGFkZCB0aGUgU1ZHIGVsZW1lbnRzIGZvciBlYWNoIGJveFBsb3QgLS0tLS1cblxuICAgICAgICAgICAgLy8gY29uZGl0aW9uYWxseSBhcHBlbmQgd2hpc2tlciBsaW5lc1xuICAgICAgICAgICAgYm94RW50ZXIuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm94ID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIFtnZXRXbCwgZ2V0V2hdLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYoZCkgIT09IHVuZGVmaW5lZCAmJiBmKGQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gKGYgPT09IGdldFdsKSA/ICdsb3cnIDogJ2hpZ2gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94LmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWJveHBsb3Qtd2hpc2tlciBudi1ib3hwbG90LScgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm94LmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWJveHBsb3QtdGljayBudi1ib3hwbG90LScgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGJveF93aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKG1heEJveFdpZHRoID09PSBudWxsID8geFNjYWxlLnJhbmdlQmFuZCgpICogMC45IDogTWF0aC5taW4oNzUsIHhTY2FsZS5yYW5nZUJhbmQoKSAqIDAuOSkpOyB9O1xuICAgICAgICAgICAgdmFyIGJveF9sZWZ0ICA9IGZ1bmN0aW9uKCkgeyByZXR1cm4geFNjYWxlLnJhbmdlQmFuZCgpICogMC40NSAtIGJveF93aWR0aCgpLzI7IH07XG4gICAgICAgICAgICB2YXIgYm94X3JpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB4U2NhbGUucmFuZ2VCYW5kKCkgKiAwLjQ1ICsgYm94X3dpZHRoKCkvMjsgfTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHdoaXNrZXIgbGluZXMgYW5kIHRpY2tzXG4gICAgICAgICAgICBbZ2V0V2wsIGdldFdoXS5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IChmID09PSBnZXRXbCkgPyAnbG93JyA6ICdoaWdoJztcbiAgICAgICAgICAgICAgICB2YXIgZW5kcG9pbnQgPSAoZiA9PT0gZ2V0V2wpID8gZ2V0UTEgOiBnZXRRMztcbiAgICAgICAgICAgICAgICBib3hwbG90cy5zZWxlY3QoJ2xpbmUubnYtYm94cGxvdC13aGlza2VyLm52LWJveHBsb3QtJyArIGtleSlcbiAgICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdudi1ib3hwbG90OiBib3hwbG90cycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIHhTY2FsZS5yYW5nZUJhbmQoKSAqIDAuNDUgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHlTY2FsZShmKGQpKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeFNjYWxlLnJhbmdlQmFuZCgpICogMC40NSApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geVNjYWxlKGVuZHBvaW50KGQpKTsgfSk7XG4gICAgICAgICAgICAgICAgYm94cGxvdHMuc2VsZWN0KCdsaW5lLm52LWJveHBsb3QtdGljay5udi1ib3hwbG90LScgKyBrZXkpXG4gICAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbnYtYm94cGxvdDogYm94cGxvdHMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBib3hfbGVmdCApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geVNjYWxlKGYoZCkpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBib3hfcmlnaHQgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHlTY2FsZShmKGQpKTsgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgW2dldFdsLCBnZXRXaF0uZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSAoZiA9PT0gZ2V0V2wpID8gJ2xvdycgOiAnaGlnaCc7XG4gICAgICAgICAgICAgICAgYm94RW50ZXIuc2VsZWN0QWxsKCcubnYtYm94cGxvdC0nICsga2V5KVxuICAgICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHsga2V5OiBmKGQpLCBjb2xvcjogZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxqKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHsga2V5OiBmKGQpLCBjb2xvcjogZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxqKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlbW92ZSh7ZTogZDMuZXZlbnR9KTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGJveGVzXG4gICAgICAgICAgICBib3hFbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1ib3hwbG90LWJveCcpXG4gICAgICAgICAgICAgICAgLy8gdG9vbHRpcCBldmVudHNcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGdldFgoZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0WChkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAnUTMnLCB2YWx1ZTogZ2V0UTMoZCksIGNvbG9yOiBnZXRDb2xvcihkKSB8fCBjb2xvcihkLGkpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdRMicsIHZhbHVlOiBnZXRRMihkKSwgY29sb3I6IGdldENvbG9yKGQpIHx8IGNvbG9yKGQsaSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogJ1ExJywgdmFsdWU6IGdldFExKGQpLCBjb2xvcjogZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxpKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZ2V0WChkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRYKGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBrZXk6ICdRMycsIHZhbHVlOiBnZXRRMyhkKSwgY29sb3I6IGdldENvbG9yKGQpIHx8IGNvbG9yKGQsaSkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogJ1EyJywgdmFsdWU6IGdldFEyKGQpLCBjb2xvcjogZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxpKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiAnUTEnLCB2YWx1ZTogZ2V0UTEoZCksIGNvbG9yOiBnZXRDb2xvcihkKSB8fCBjb2xvcihkLGkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe2U6IGQzLmV2ZW50fSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGJveCB0cmFuc2l0aW9uc1xuICAgICAgICAgICAgYm94cGxvdHMuc2VsZWN0KCdyZWN0Lm52LWJveHBsb3QtYm94JylcbiAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ252LWJveHBsb3Q6IGJveGVzJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geVNjYWxlKGdldFEzKGQpKTsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBib3hfd2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBib3hfbGVmdCApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gTWF0aC5hYnMoeVNjYWxlKGdldFEzKGQpKSAtIHlTY2FsZShnZXRRMShkKSkpIHx8IDEgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldENvbG9yKGQpIHx8IGNvbG9yKGQsaSkgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0Q29sb3IoZCkgfHwgY29sb3IoZCxpKSB9KTtcblxuICAgICAgICAgICAgLy8gbWVkaWFuIGxpbmVcbiAgICAgICAgICAgIGJveEVudGVyLmFwcGVuZCgnbGluZScpLmF0dHIoJ2NsYXNzJywgJ252LWJveHBsb3QtbWVkaWFuJyk7XG5cbiAgICAgICAgICAgIGJveHBsb3RzLnNlbGVjdCgnbGluZS5udi1ib3hwbG90LW1lZGlhbicpXG4gICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdudi1ib3hwbG90OiBib3hwbG90cyBsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCBib3hfbGVmdClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHlTY2FsZShnZXRRMihkKSk7IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgYm94X3JpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geVNjYWxlKGdldFEyKGQpKTsgfSk7XG5cbiAgICAgICAgICAgIC8vIG91dGxpZXJzXG4gICAgICAgICAgICB2YXIgb3V0bGllcnMgPSBib3hwbG90cy5zZWxlY3RBbGwoJy5udi1ib3hwbG90LW91dGxpZXInKS5kYXRhKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0T2xJdGVtcyhkKSB8fCBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3V0bGllcnMuZW50ZXIoKS5hcHBlbmQoJ2NpcmNsZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIGdldE9sQ29sb3IoZCxpLGopIHx8IGNvbG9yKGQsaikgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBnZXRPbENvbG9yKGQsaSxqKSB8fCBjb2xvcihkLGopIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd6LWluZGV4JywgOTAwMClcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogeyBrZXk6IGdldE9sTGFiZWwoZCxpLGopLCBjb2xvcjogZ2V0T2xDb2xvcihkLGksaikgfHwgY29sb3IoZCxqKSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZTogZDMuZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiB7IGtleTogZ2V0T2xMYWJlbChkLGksaiksIGNvbG9yOiBnZXRPbENvbG9yKGQsaSxqKSB8fCBjb2xvcihkLGopIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlOiBkMy5ldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe2U6IGQzLmV2ZW50fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvdXRsaWVycy5hdHRyKCdjbGFzcycsICdudi1ib3hwbG90LW91dGxpZXInKTtcbiAgICAgICAgICAgIG91dGxpZXJzXG4gICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdudi1ib3hwbG90OiBudi1ib3hwbG90LW91dGxpZXInKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeCcsIHhTY2FsZS5yYW5nZUJhbmQoKSAqIDAuNDUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N5JywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIHlTY2FsZShnZXRPbFZhbHVlKGQsaSxqKSk7IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3InLCAnMycpO1xuICAgICAgICAgICAgb3V0bGllcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHhTY2FsZTAgPSB4U2NhbGUuY29weSgpO1xuICAgICAgICAgICAgeVNjYWxlMCA9IHlTY2FsZS5jb3B5KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbnYtYm94cGxvdCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIG1heEJveFdpZHRoOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXhCb3hXaWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21heEJveFdpZHRoPV87fX0sXG4gICAgICAgIHg6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICBxMToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0UTE7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRRMT1fO319LFxuICAgICAgICBxMjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0UTI7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRRMj1fO319LFxuICAgICAgICBxMzoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0UTM7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRRMz1fO319LFxuICAgICAgICB3bDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0V2w7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRXbD1fO319LFxuICAgICAgICB3aDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0V2g7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRXaD1fO319LFxuICAgICAgICBpdGVtQ29sb3I6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldENvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0Q29sb3I9Xzt9fSxcbiAgICAgICAgb3V0bGllcnM6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRPbEl0ZW1zO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0T2xJdGVtcz1fO319LFxuICAgICAgICBvdXRsaWVyVmFsdWU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldE9sVmFsdWU7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRPbFZhbHVlPV87fX0sXG4gICAgICAgIG91dGxpZXJMYWJlbDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0T2xMYWJlbDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldE9sTGFiZWw9Xzt9fSxcbiAgICAgICAgb3V0bGllckNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRPbENvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0T2xDb2xvcj1fO319LFxuICAgICAgICB4U2NhbGU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4U2NhbGU7fSwgc2V0OiBmdW5jdGlvbihfKXt4U2NhbGU9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVNjYWxlO30sIHNldDogZnVuY3Rpb24oXyl7eVNjYWxlPV87fX0sXG4gICAgICAgIHhEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgLy8gcmVjdENsYXNzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByZWN0Q2xhc3M7fSwgc2V0OiBmdW5jdGlvbihfKXtyZWN0Q2xhc3M9Xzt9fSxcbiAgICAgICAgeToge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0JveFBsb3QgXFwneVxcJyBjaGFydCBvcHRpb24gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb2RlbCBvdmVycmlkZXMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdCb3hQbG90IFxcJ3lcXCcgY2hhcnQgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9kZWwgb3ZlcnJpZGVzIGluc3RlYWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcbm52Lm1vZGVscy5ib3hQbG90Q2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGJveHBsb3QgPSBudi5tb2RlbHMuYm94UGxvdCgpLFxuICAgICAgICB4QXhpcyA9IG52Lm1vZGVscy5heGlzKCksXG4gICAgICAgIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKTtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAxNSwgcmlnaHQ6IDEwLCBib3R0b206IDUwLCBsZWZ0OiA2MH0sXG4gICAgICAgIHdpZHRoID0gbnVsbCxcbiAgICAgICAgaGVpZ2h0ID0gbnVsbCxcbiAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcigpLFxuICAgICAgICBzaG93WEF4aXMgPSB0cnVlLFxuICAgICAgICBzaG93WUF4aXMgPSB0cnVlLFxuICAgICAgICByaWdodEFsaWduWUF4aXMgPSBmYWxzZSxcbiAgICAgICAgc3RhZ2dlckxhYmVscyA9IGZhbHNlLFxuICAgICAgICB0b29sdGlwID0gbnYubW9kZWxzLnRvb2x0aXAoKSxcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9EYXRhID0gJ05vIERhdGEgQXZhaWxhYmxlLicsXG4gICAgICAgIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2JlZm9yZVVwZGF0ZScsICdyZW5kZXJFbmQnKSxcbiAgICAgICAgZHVyYXRpb24gPSAyNTA7XG5cbiAgICB4QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAgICAgLnRpY2tGb3JtYXQoZDMuZm9ybWF0KCcsLjFmJykpXG4gICAgO1xuXG4gICAgdG9vbHRpcC5kdXJhdGlvbigwKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoYm94cGxvdCk7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSwgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSAod2lkdGggIHx8IHBhcnNlSW50KGNvbnRhaW5lci5zdHlsZSgnd2lkdGgnKSkgfHwgOTYwKSAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IChoZWlnaHQgfHwgcGFyc2VJbnQoY29udGFpbmVyLnN0eWxlKCdoZWlnaHQnKSkgfHwgNDAwKSAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5iZWZvcmVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBUT0RPIHN0aWxsIG5lZWQgdG8gZmluZCBhIHdheSB0byB2YWxpZGF0ZSBxdWFydGlsZSBkYXRhIHByZXNlbmNlIHVzaW5nIGJveFBsb3QgY2FsbGJhY2tzLlxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuIChxdWFydGlsZXMgcmVxdWlyZWQgYXQgbWluaW11bSkuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vRGF0YVRleHQgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykuZGF0YShbbm9EYXRhXSk7XG5cbiAgICAgICAgICAgICAgICBub0RhdGFUZXh0LmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbm9EYXRhJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy0uN2VtJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKTtcblxuICAgICAgICAgICAgICAgIG5vRGF0YVRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBtYXJnaW4ubGVmdCArIGF2YWlsYWJsZVdpZHRoIC8gMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBtYXJnaW4udG9wICsgYXZhaWxhYmxlSGVpZ2h0IC8gMilcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBib3hwbG90LnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IGJveHBsb3QueVNjYWxlKCkuY2xhbXAodHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1ib3hQbG90V2l0aEF4ZXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1ib3hQbG90V2l0aEF4ZXMnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi16ZXJvTGluZScpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcbiAgICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGF2YWlsYWJsZVdpZHRoICsgJywwKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgYm94cGxvdC53aWR0aChhdmFpbGFibGVXaWR0aCkuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSlcblxuICAgICAgICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwoYm94cGxvdCk7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYteC1sYWJlbC1jbGlwLScgKyBib3hwbG90LmlkKCkpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnI252LXgtbGFiZWwtY2xpcC0nICsgYm94cGxvdC5pZCgpICsgJyByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpICogKHN0YWdnZXJMYWJlbHMgPyAyIDogMSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE2KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLXgucmFuZ2VCYW5kKCkgLyAoc3RhZ2dlckxhYmVscyA/IDEgOiAyICkpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5jYWxsKHhBeGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciB4VGlja3MgPSBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpLnNlbGVjdEFsbCgnZycpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFnZ2VyTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuICd0cmFuc2xhdGUoMCwnICsgKGogJSAyID09PSAwID8gJzUnIDogJzE3JykgKyAnKScgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tzKCBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodC8zNikgKSAvLyBjYW4ndCB1c2UgbnYudXRpbHMuY2FsY1RpY2tzWSB3aXRoIE9iamVjdCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJykuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFplcm8gbGluZVxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi16ZXJvTGluZSBsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJyxhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCB5KDApKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MicsIHkoMCkpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbnYtYm94cGxvdCBjaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBib3hwbG90LmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdG9vbHRpcC5kYXRhKGV2dCkuaGlkZGVuKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGJveHBsb3QuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuZGF0YShldnQpLmhpZGRlbih0cnVlKTtcbiAgICB9KTtcblxuICAgIGJveHBsb3QuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuYm94cGxvdCA9IGJveHBsb3Q7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgc3RhZ2dlckxhYmVsczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhZ2dlckxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWdnZXJMYWJlbHM9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgdG9vbHRpcENvbnRlbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvb2x0aXA7fSwgc2V0OiBmdW5jdGlvbihfKXt0b29sdGlwPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGJveHBsb3QuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeEF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICAgICAgeUF4aXMuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGJveHBsb3QuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGJveHBsb3QpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn1cblxuLy8gQ2hhcnQgZGVzaWduIGJhc2VkIG9uIHRoZSByZWNvbW1lbmRhdGlvbnMgb2YgU3RlcGhlbiBGZXcuIEltcGxlbWVudGF0aW9uXG4vLyBiYXNlZCBvbiB0aGUgd29yayBvZiBDbGludCBJdnksIEphbWllIExvdmUsIGFuZCBKYXNvbiBEYXZpZXMuXG4vLyBodHRwOi8vcHJvamVjdHMuaW5zdGFudGNvZ25pdGlvbi5jb20vcHJvdG92aXMvYnVsbGV0Y2hhcnQvXG5cbm52Lm1vZGVscy5idWxsZXQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgb3JpZW50ID0gJ2xlZnQnIC8vIFRPRE8gdG9wICYgYm90dG9tXG4gICAgICAgICwgcmV2ZXJzZSA9IGZhbHNlXG4gICAgICAgICwgcmFuZ2VzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5yYW5nZXMgfVxuICAgICAgICAsIG1hcmtlcnMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1hcmtlcnMgPyBkLm1hcmtlcnMgOiBbXSB9XG4gICAgICAgICwgbWFya2VyTGluZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1hcmtlckxpbmVzID8gZC5tYXJrZXJMaW5lcyA6IFswXSB9XG4gICAgICAgICwgbWVhc3VyZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1lYXN1cmVzIH1cbiAgICAgICAgLCByYW5nZUxhYmVscyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmFuZ2VMYWJlbHMgPyBkLnJhbmdlTGFiZWxzIDogW10gfVxuICAgICAgICAsIG1hcmtlckxhYmVscyA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQubWFya2VyTGFiZWxzID8gZC5tYXJrZXJMYWJlbHMgOiBbXSAgfVxuICAgICAgICAsIG1hcmtlckxpbmVMYWJlbHMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1hcmtlckxpbmVMYWJlbHMgPyBkLm1hcmtlckxpbmVMYWJlbHMgOiBbXSAgfVxuICAgICAgICAsIG1lYXN1cmVMYWJlbHMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1lYXN1cmVMYWJlbHMgPyBkLm1lYXN1cmVMYWJlbHMgOiBbXSAgfVxuICAgICAgICAsIGZvcmNlWCA9IFswXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgWCBzY2FsZSAoaWUuIDAsIG9yIGEgbWF4IC8gbWluLCBldGMuKVxuICAgICAgICAsIHdpZHRoID0gMzgwXG4gICAgICAgICwgaGVpZ2h0ID0gMzBcbiAgICAgICAgLCBjb250YWluZXIgPSBudWxsXG4gICAgICAgICwgdGlja0Zvcm1hdCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKFsnIzFmNzdiNCddKVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ2VsZW1lbnRNb3VzZW1vdmUnKVxuICAgICAgICAsIGRlZmF1bHRSYW5nZUxhYmVscyA9IFtcIk1heGltdW1cIiwgXCJNZWFuXCIsIFwiTWluaW11bVwiXVxuICAgICAgICAsIGxlZ2FjeVJhbmdlQ2xhc3NOYW1lcyA9IFtcIk1heFwiLCBcIkF2Z1wiLCBcIk1pblwiXVxuICAgICAgICAsIGR1cmF0aW9uID0gMTAwMFxuICAgICAgICA7XG5cbiAgICBmdW5jdGlvbiBzb3J0TGFiZWxzKGxhYmVscywgdmFsdWVzKXtcbiAgICAgICAgdmFyIGx6ID0gbGFiZWxzLnNsaWNlKCk7XG4gICAgICAgIGxhYmVscy5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICAgICAgdmFyIGlBID0gbHouaW5kZXhPZihhKTtcbiAgICAgICAgICAgIHZhciBpQiA9IGx6LmluZGV4T2YoYik7XG4gICAgICAgICAgICByZXR1cm4gZDMuZGVzY2VuZGluZyh2YWx1ZXNbaUFdLCB2YWx1ZXNbaUJdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciByYW5nZXogPSByYW5nZXMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLFxuICAgICAgICAgICAgICAgIG1hcmtlcnogPSBtYXJrZXJzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICBtYXJrZXJMaW5leiA9IG1hcmtlckxpbmVzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICBtZWFzdXJleiA9IG1lYXN1cmVzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICByYW5nZUxhYmVseiA9IHJhbmdlTGFiZWxzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICBtYXJrZXJMYWJlbHogPSBtYXJrZXJMYWJlbHMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLFxuICAgICAgICAgICAgICAgIG1hcmtlckxpbmVMYWJlbHogPSBtYXJrZXJMaW5lTGFiZWxzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlTGFiZWx6ID0gbWVhc3VyZUxhYmVscy5jYWxsKHRoaXMsIGQsIGkpLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgbGFiZWxzIGFjY29yZGluZyB0byB0aGVpciBzb3J0ZWQgdmFsdWVzXG4gICAgICAgICAgICBzb3J0TGFiZWxzKHJhbmdlTGFiZWx6LCByYW5nZXopO1xuICAgICAgICAgICAgc29ydExhYmVscyhtYXJrZXJMYWJlbHosIG1hcmtlcnopO1xuICAgICAgICAgICAgc29ydExhYmVscyhtYXJrZXJMaW5lTGFiZWx6LCBtYXJrZXJMaW5leik7XG4gICAgICAgICAgICBzb3J0TGFiZWxzKG1lYXN1cmVMYWJlbHosIG1lYXN1cmV6KTtcblxuICAgICAgICAgICAgLy8gc29ydCB2YWx1ZXMgZGVzY2VuZGluZ1xuICAgICAgICAgICAgcmFuZ2V6LnNvcnQoZDMuZGVzY2VuZGluZyk7XG4gICAgICAgICAgICBtYXJrZXJ6LnNvcnQoZDMuZGVzY2VuZGluZyk7XG4gICAgICAgICAgICBtYXJrZXJMaW5lei5zb3J0KGQzLmRlc2NlbmRpbmcpO1xuICAgICAgICAgICAgbWVhc3VyZXouc29ydChkMy5kZXNjZW5kaW5nKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBuZXcgeC1zY2FsZS5cbiAgICAgICAgICAgIHZhciB4MSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbiggZDMuZXh0ZW50KGQzLm1lcmdlKFtmb3JjZVgsIHJhbmdlel0pKSApXG4gICAgICAgICAgICAgICAgLnJhbmdlKHJldmVyc2UgPyBbYXZhaWxhYmxlV2lkdGgsIDBdIDogWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSBvbGQgeC1zY2FsZSwgaWYgdGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAgICAgICAgIC5kb21haW4oWzAsIEluZmluaXR5XSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoeDEucmFuZ2UoKSk7XG5cbiAgICAgICAgICAgIC8vIFN0YXNoIHRoZSBuZXcgc2NhbGUuXG4gICAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHgxO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2VNaW4gPSBkMy5taW4ocmFuZ2V6KSwgLy9yYW5nZXpbMl1cbiAgICAgICAgICAgICAgICByYW5nZU1heCA9IGQzLm1heChyYW5nZXopLCAvL3JhbmdlelswXVxuICAgICAgICAgICAgICAgIHJhbmdlQXZnID0gcmFuZ2V6WzFdO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtYnVsbGV0JykuZGF0YShbZF0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtYnVsbGV0Jyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBmb3IodmFyIGk9MCxpbD1yYW5nZXoubGVuZ3RoOyBpPGlsOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciByYW5nZUNsYXNzTmFtZXMgPSAnbnYtcmFuZ2UgbnYtcmFuZ2UnK2k7XG4gICAgICAgICAgICAgICAgaWYoaSA8PSAyKXtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VDbGFzc05hbWVzID0gcmFuZ2VDbGFzc05hbWVzICsgJyBudi1yYW5nZScrbGVnYWN5UmFuZ2VDbGFzc05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCByYW5nZUNsYXNzTmFtZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtbWVhc3VyZScpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHZhciB3MCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgwKGQpIC0geDAoMCkpIH0sIC8vIFRPRE86IGNvdWxkIG9wdGltaXplIGJ5IHByZWNhbGN1bGF0aW5nIHgwKDApIGFuZCB4MSgwKVxuICAgICAgICAgICAgICAgIHcxID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gTWF0aC5hYnMoeDEoZCkgLSB4MSgwKSkgfTtcbiAgICAgICAgICAgIHZhciB4cDAgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkIDwgMCA/IHgwKGQpIDogeDAoMCkgfSxcbiAgICAgICAgICAgICAgICB4cDEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkIDwgMCA/IHgxKGQpIDogeDEoMCkgfTtcblxuICAgICAgICAgICAgZm9yKHZhciBpPTAsaWw9cmFuZ2V6Lmxlbmd0aDsgaTxpbDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZXpbaV07XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJ3JlY3QubnYtcmFuZ2UnK2kpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShyYW5nZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHcxKHJhbmdlKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4cDEocmFuZ2UpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnLnNlbGVjdCgncmVjdC5udi1tZWFzdXJlJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjb2xvcilcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0IC8gMylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGF2YWlsYWJsZUhlaWdodCAvIDMpXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWVhc3VyZXpbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbWVhc3VyZUxhYmVselswXSB8fCAnQ3VycmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbWVhc3VyZXpbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbWVhc3VyZUxhYmVselswXSB8fCAnQ3VycmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1lYXN1cmV6WzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IG1lYXN1cmVMYWJlbHpbMF0gfHwgJ0N1cnJlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgbWVhc3VyZXogPCAwID9cbiAgICAgICAgICAgICAgICAgICAgeDEoMCkgLSB4MShtZWFzdXJlelswXSlcbiAgICAgICAgICAgICAgICAgICAgOiB4MShtZWFzdXJlelswXSkgLSB4MSgwKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIHhwMShtZWFzdXJleikpO1xuXG4gICAgICAgICAgICB2YXIgaDMgPSAgYXZhaWxhYmxlSGVpZ2h0IC8gNjtcblxuICAgICAgICAgICAgdmFyIG1hcmtlckRhdGEgPSBtYXJrZXJ6Lm1hcCggZnVuY3Rpb24obWFya2VyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IG1hcmtlciwgbGFiZWw6IG1hcmtlckxhYmVseltpbmRleF19XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdFbnRlclxuICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwicGF0aC5udi1tYXJrZXJUcmlhbmdsZVwiKVxuICAgICAgICAgICAgICAuZGF0YShtYXJrZXJEYXRhKVxuICAgICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgICAuYXBwZW5kKCdwYXRoJylcbiAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LW1hcmtlclRyaWFuZ2xlJylcbiAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTAsJyArIGgzICsgJ0wnICsgaDMgKyAnLCcgKyAoLWgzKSArICcgJyArICgtaDMpICsgJywnICsgKC1oMykgKyAnWicpXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGQudmFsdWUsXG4gICAgICAgICAgICAgICAgICBsYWJlbDogZC5sYWJlbCB8fCAnUHJldmlvdXMnLFxuICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIiksXG4gICAgICAgICAgICAgICAgICBwb3M6IFt4MShkLnZhbHVlKSwgYXZhaWxhYmxlSGVpZ2h0LzJdXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkLmxhYmVsIHx8ICdQcmV2aW91cycsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkLmxhYmVsIHx8ICdQcmV2aW91cycsXG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBnLnNlbGVjdEFsbChcInBhdGgubnYtbWFya2VyVHJpYW5nbGVcIilcbiAgICAgICAgICAgICAgLmRhdGEobWFya2VyRGF0YSlcbiAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MShkLnZhbHVlKSArICcsJyArIChhdmFpbGFibGVIZWlnaHQgLyAyKSArICcpJyB9KTtcblxuICAgICAgICAgICAgdmFyIG1hcmtlckxpbmVzRGF0YSA9IG1hcmtlckxpbmV6Lm1hcCggZnVuY3Rpb24obWFya2VyLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IG1hcmtlciwgbGFiZWw6IG1hcmtlckxpbmVMYWJlbHpbaW5kZXhdfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnRW50ZXJcbiAgICAgICAgICAgICAgLnNlbGVjdEFsbChcImxpbmUubnYtbWFya2VyTGluZVwiKVxuICAgICAgICAgICAgICAuZGF0YShtYXJrZXJMaW5lc0RhdGEpXG4gICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAuYXR0cignY3Vyc29yJywgJycpXG4gICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1tYXJrZXJMaW5lJylcbiAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24oZCkgeyByZXR1cm4geDEoZC52YWx1ZSkgfSlcbiAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgJzInKVxuICAgICAgICAgICAgICAuYXR0cigneDInLCBmdW5jdGlvbihkKSB7IHJldHVybiB4MShkLnZhbHVlKSB9KVxuICAgICAgICAgICAgICAuYXR0cigneTInLCBhdmFpbGFibGVIZWlnaHQgLSAyKVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IGQubGFiZWwgfHwgJ1ByZXZpb3VzJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpLFxuICAgICAgICAgICAgICAgICAgcG9zOiBbeDEoZC52YWx1ZSksIGF2YWlsYWJsZUhlaWdodC8yXVxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZC5sYWJlbCB8fCAnUHJldmlvdXMnLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZC5sYWJlbCB8fCAnUHJldmlvdXMnLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZy5zZWxlY3RBbGwoXCJsaW5lLm52LW1hcmtlckxpbmVcIilcbiAgICAgICAgICAgICAgLmRhdGEobWFya2VyTGluZXNEYXRhKVxuICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24oZCkgeyByZXR1cm4geDEoZC52YWx1ZSkgfSlcbiAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4geDEoZC52YWx1ZSkgfSk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0QWxsKCcubnYtcmFuZ2UnKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHJhbmdlTGFiZWx6W2ldIHx8IGRlZmF1bHRSYW5nZUxhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZWFzdXJlelswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBtZWFzdXJlTGFiZWx6WzBdIHx8ICdQcmV2aW91cycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSByYW5nZUxhYmVseltpXSB8fCBkZWZhdWx0UmFuZ2VMYWJlbHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgcmFuZ2VzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJhbmdlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Jhbmdlcz1fO319LCAvLyByYW5nZXMgKGJhZCwgc2F0aXNmYWN0b3J5LCBnb29kKVxuICAgICAgICBtYXJrZXJzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFya2Vyczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21hcmtlcnM9Xzt9fSwgLy8gbWFya2VycyAocHJldmlvdXMsIGdvYWwpXG4gICAgICAgIG1lYXN1cmVzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtZWFzdXJlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21lYXN1cmVzPV87fX0sIC8vIG1lYXN1cmVzIChhY3R1YWwsIGZvcmVjYXN0KVxuICAgICAgICBmb3JjZVg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VYO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VYPV87fX0sXG4gICAgICAgIHdpZHRoOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHRpY2tGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt0aWNrRm9ybWF0PV87fX0sXG4gICAgICAgIGR1cmF0aW9uOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2R1cmF0aW9uPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBvcmllbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG9yaWVudDt9LCBzZXQ6IGZ1bmN0aW9uKF8peyAvLyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b21cbiAgICAgICAgICAgIG9yaWVudCA9IF87XG4gICAgICAgICAgICByZXZlcnNlID0gb3JpZW50ID09ICdyaWdodCcgfHwgb3JpZW50ID09ICdib3R0b20nO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5cblxuLy8gQ2hhcnQgZGVzaWduIGJhc2VkIG9uIHRoZSByZWNvbW1lbmRhdGlvbnMgb2YgU3RlcGhlbiBGZXcuIEltcGxlbWVudGF0aW9uXG4vLyBiYXNlZCBvbiB0aGUgd29yayBvZiBDbGludCBJdnksIEphbWllIExvdmUsIGFuZCBKYXNvbiBEYXZpZXMuXG4vLyBodHRwOi8vcHJvamVjdHMuaW5zdGFudGNvZ25pdGlvbi5jb20vcHJvdG92aXMvYnVsbGV0Y2hhcnQvXG5udi5tb2RlbHMuYnVsbGV0Q2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGJ1bGxldCA9IG52Lm1vZGVscy5idWxsZXQoKTtcbiAgICB2YXIgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKCk7XG5cbiAgICB2YXIgb3JpZW50ID0gJ2xlZnQnIC8vIFRPRE8gdG9wICYgYm90dG9tXG4gICAgICAgICwgcmV2ZXJzZSA9IGZhbHNlXG4gICAgICAgICwgbWFyZ2luID0ge3RvcDogNSwgcmlnaHQ6IDQwLCBib3R0b206IDIwLCBsZWZ0OiAxMjB9XG4gICAgICAgICwgcmFuZ2VzID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5yYW5nZXMgfVxuICAgICAgICAsIG1hcmtlcnMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1hcmtlcnMgPyBkLm1hcmtlcnMgOiBbXSB9XG4gICAgICAgICwgbWVhc3VyZXMgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm1lYXN1cmVzIH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSA1NVxuICAgICAgICAsIHRpY2tGb3JtYXQgPSBudWxsXG4gICAgICAgICwgdGlja3MgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gbnVsbFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goKVxuICAgICAgICA7XG5cbiAgICB0b29sdGlwXG4gICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAuaGVhZGVyRW5hYmxlZChmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNoYXJ0KHNlbGVjdGlvbikgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkIHx8ICFyYW5nZXMuY2FsbCh0aGlzLCBkLCBpKSkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmFuZ2V6ID0gcmFuZ2VzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgICAgICAgIG1hcmtlcnogPSBtYXJrZXJzLmNhbGwodGhpcywgZCwgaSkuc2xpY2UoKS5zb3J0KGQzLmRlc2NlbmRpbmcpLFxuICAgICAgICAgICAgICAgIG1lYXN1cmV6ID0gbWVhc3VyZXMuY2FsbCh0aGlzLCBkLCBpKS5zbGljZSgpLnNvcnQoZDMuZGVzY2VuZGluZyk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1idWxsZXRDaGFydCcpLmRhdGEoW2RdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWJ1bGxldENoYXJ0Jyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYnVsbGV0V3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXRpdGxlcycpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG5ldyB4LXNjYWxlLlxuICAgICAgICAgICAgdmFyIHgxID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAgICAgICAuZG9tYWluKFswLCBNYXRoLm1heChyYW5nZXpbMF0sIChtYXJrZXJ6WzBdIHx8IDApLCBtZWFzdXJlelswXSldKSAgLy8gVE9ETzogbmVlZCB0byBhbGxvdyBmb3JjZVggYW5kIGZvcmNlWSwgYW5kIHhEb21haW4sIHlEb21haW5cbiAgICAgICAgICAgICAgICAucmFuZ2UocmV2ZXJzZSA/IFthdmFpbGFibGVXaWR0aCwgMF0gOiBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIG9sZCB4LXNjYWxlLCBpZiB0aGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAgICAgICAgIHZhciB4MCA9IHRoaXMuX19jaGFydF9fIHx8IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgLmRvbWFpbihbMCwgSW5maW5pdHldKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh4MS5yYW5nZSgpKTtcblxuICAgICAgICAgICAgLy8gU3Rhc2ggdGhlIG5ldyBzY2FsZS5cbiAgICAgICAgICAgIHRoaXMuX19jaGFydF9fID0geDE7XG5cbiAgICAgICAgICAgIHZhciB3MCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGguYWJzKHgwKGQpIC0geDAoMCkpIH0sIC8vIFRPRE86IGNvdWxkIG9wdGltaXplIGJ5IHByZWNhbGN1bGF0aW5nIHgwKDApIGFuZCB4MSgwKVxuICAgICAgICAgICAgICAgIHcxID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gTWF0aC5hYnMoeDEoZCkgLSB4MSgwKSkgfTtcblxuICAgICAgICAgICAgdmFyIHRpdGxlID0gZ0VudGVyLnNlbGVjdCgnLm52LXRpdGxlcycpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLTYsJyArIChoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbSkgLyAyICsgJyknKTtcbiAgICAgICAgICAgIHRpdGxlLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXRpdGxlJylcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkLnRpdGxlOyB9KTtcblxuICAgICAgICAgICAgdGl0bGUuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtc3VidGl0bGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxZW0nKVxuICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3VidGl0bGU7IH0pO1xuXG4gICAgICAgICAgICBidWxsZXRcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgYnVsbGV0V3JhcCA9IGcuc2VsZWN0KCcubnYtYnVsbGV0V3JhcCcpO1xuICAgICAgICAgICAgZDMudHJhbnNpdGlvbihidWxsZXRXcmFwKS5jYWxsKGJ1bGxldCk7XG5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIHRpY2sgZm9ybWF0LlxuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHRpY2tGb3JtYXQgfHwgeDEudGlja0Zvcm1hdCggYXZhaWxhYmxlV2lkdGggLyAxMDAgKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0aWNrIGdyb3Vwcy5cbiAgICAgICAgICAgIHZhciB0aWNrID0gZy5zZWxlY3RBbGwoJ2cubnYtdGljaycpXG4gICAgICAgICAgICAgICAgLmRhdGEoeDEudGlja3MoIHRpY2tzID8gdGlja3MgOiAoYXZhaWxhYmxlV2lkdGggLyA1MCkgKSwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0Q29udGVudCB8fCBmb3JtYXQoZCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHRpY2tzIHdpdGggdGhlIG9sZCBzY2FsZSwgeDAuXG4gICAgICAgICAgICB2YXIgdGlja0VudGVyID0gdGljay5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LXRpY2snKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MChkKSArICcsMCknIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMWUtNik7XG5cbiAgICAgICAgICAgIHRpY2tFbnRlci5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBhdmFpbGFibGVIZWlnaHQgKiA3IC8gNik7XG5cbiAgICAgICAgICAgIHRpY2tFbnRlci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcxZW0nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpXG4gICAgICAgICAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0aGUgdXBkYXRpbmcgdGlja3MgdG8gdGhlIG5ldyBzY2FsZSwgeDEuXG4gICAgICAgICAgICB2YXIgdGlja1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24odGljaylcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKGJ1bGxldC5kdXJhdGlvbigpKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4MShkKSArICcsMCknIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG5cbiAgICAgICAgICAgIHRpY2tVcGRhdGUuc2VsZWN0KCdsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgYXZhaWxhYmxlSGVpZ2h0ICogNyAvIDYpO1xuXG4gICAgICAgICAgICB0aWNrVXBkYXRlLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBhdmFpbGFibGVIZWlnaHQgKiA3IC8gNik7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zaXRpb24gdGhlIGV4aXRpbmcgdGlja3MgdG8gdGhlIG5ldyBzY2FsZSwgeDEuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKHRpY2suZXhpdCgpKVxuICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAuZHVyYXRpb24oYnVsbGV0LmR1cmF0aW9uKCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgxKGQpICsgJywwKScgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZDMudGltZXIuZmx1c2goKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBidWxsZXQuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBldnRbJ3NlcmllcyddID0ge1xuICAgICAgICAgICAga2V5OiBldnQubGFiZWwsXG4gICAgICAgICAgICB2YWx1ZTogZXZ0LnZhbHVlLFxuICAgICAgICAgICAgY29sb3I6IGV2dC5jb2xvclxuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgYnVsbGV0LmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwLmhpZGRlbih0cnVlKTtcbiAgICB9KTtcblxuICAgIGJ1bGxldC5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZS50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuYnVsbGV0ID0gYnVsbGV0O1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQudG9vbHRpcCA9IHRvb2x0aXA7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICByYW5nZXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmFuZ2VzO30sIHNldDogZnVuY3Rpb24oXyl7cmFuZ2VzPV87fX0sIC8vIHJhbmdlcyAoYmFkLCBzYXRpc2ZhY3RvcnksIGdvb2QpXG4gICAgICAgIG1hcmtlcnM6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJrZXJzO30sIHNldDogZnVuY3Rpb24oXyl7bWFya2Vycz1fO319LCAvLyBtYXJrZXJzIChwcmV2aW91cywgZ29hbClcbiAgICAgICAgbWVhc3VyZXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1lYXN1cmVzO30sIHNldDogZnVuY3Rpb24oXyl7bWVhc3VyZXM9Xzt9fSwgLy8gbWVhc3VyZXMgKGFjdHVhbCwgZm9yZWNhc3QpXG4gICAgICAgIHdpZHRoOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHRpY2tGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt0aWNrRm9ybWF0PV87fX0sXG4gICAgICAgIHRpY2tzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0aWNrczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3RpY2tzPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBvcmllbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG9yaWVudDt9LCBzZXQ6IGZ1bmN0aW9uKF8peyAvLyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b21cbiAgICAgICAgICAgIG9yaWVudCA9IF87XG4gICAgICAgICAgICByZXZlcnNlID0gb3JpZW50ID09ICdyaWdodCcgfHwgb3JpZW50ID09ICdib3R0b20nO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGJ1bGxldCk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxuXG5cbm52Lm1vZGVscy5jYW5kbGVzdGlja0JhciA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIGNvbnRhaW5lclxuICAgICAgICAsIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGdldE9wZW4gPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9wZW4gfVxuICAgICAgICAsIGdldENsb3NlID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jbG9zZSB9XG4gICAgICAgICwgZ2V0SGlnaCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaGlnaCB9XG4gICAgICAgICwgZ2V0TG93ID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5sb3cgfVxuICAgICAgICAsIGZvcmNlWCA9IFtdXG4gICAgICAgICwgZm9yY2VZID0gW11cbiAgICAgICAgLCBwYWREYXRhICAgICA9IGZhbHNlIC8vIElmIHRydWUsIGFkZHMgaGFsZiBhIGRhdGEgcG9pbnRzIHdpZHRoIHRvIGZyb250IGFuZCBiYWNrLCBmb3IgbGluaW5nIHVwIGEgbGluZSBjaGFydCB3aXRoIGEgYmFyIGNoYXJ0XG4gICAgICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIGludGVyYWN0aXZlID0gZmFsc2VcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywgJ3JlbmRlckVuZCcsICdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAnZWxlbWVudE1vdXNlbW92ZScpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFdpZHRoIG9mIHRoZSBjYW5kbGVzdGljayBiYXJzLlxuICAgICAgICAgICAgdmFyIGJhcldpZHRoID0gKGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAqIC40NTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4LmRvbWFpbih4RG9tYWluIHx8IGQzLmV4dGVudChkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0WCkuY29uY2F0KGZvcmNlWCkgKSk7XG5cbiAgICAgICAgICAgIGlmIChwYWREYXRhKVxuICAgICAgICAgICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFthdmFpbGFibGVXaWR0aCAqIC41IC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoLCBhdmFpbGFibGVXaWR0aCAqIChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAuNSkgIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoIF0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFs1ICsgYmFyV2lkdGggLyAyLCBhdmFpbGFibGVXaWR0aCAtIGJhcldpZHRoIC8gMiAtIDVdKTtcblxuICAgICAgICAgICAgeS5kb21haW4oeURvbWFpbiB8fCBbXG4gICAgICAgICAgICAgICAgICAgIGQzLm1pbihkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0TG93KS5jb25jYXQoZm9yY2VZKSksXG4gICAgICAgICAgICAgICAgICAgIGQzLm1heChkYXRhWzBdLnZhbHVlcy5tYXAoZ2V0SGlnaCkuY29uY2F0KGZvcmNlWSkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKS5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHguZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSAtIHguZG9tYWluKClbMF0gKiAwLjAxLCB4LmRvbWFpbigpWzFdICsgeC5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHguZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIGlmICh5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHkuZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSArIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdIC0geS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHkuZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1jYW5kbGVzdGlja0JhcicpLmRhdGEoW2RhdGFbMF0udmFsdWVzXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1jYW5kbGVzdGlja0JhcicpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi10aWNrcycpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guY2hhcnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpO1xuXG4gICAgICAgICAgICB3cmFwLnNlbGVjdCgnI252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQgKyAnIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBnICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZCArICcpJyA6ICcnKTtcblxuICAgICAgICAgICAgdmFyIHRpY2tzID0gd3JhcC5zZWxlY3QoJy5udi10aWNrcycpLnNlbGVjdEFsbCgnLm52LXRpY2snKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG4gICAgICAgICAgICB0aWNrcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciB0aWNrR3JvdXBzID0gdGlja3MuZW50ZXIoKS5hcHBlbmQoJ2cnKTtcblxuICAgICAgICAgICAgLy8gVGhlIGNvbG9ycyBhcmUgY3VycmVudGx5IGNvbnRyb2xsZWQgYnkgQ1NTLlxuICAgICAgICAgICAgdGlja3NcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLCBpLCBqKSB7IHJldHVybiAoZ2V0T3BlbihkLCBpKSA+IGdldENsb3NlKGQsIGkpID8gJ252LXRpY2sgbmVnYXRpdmUnIDogJ252LXRpY2sgcG9zaXRpdmUnKSArICcgbnYtdGljay0nICsgaiArICctJyArIGl9KTtcblxuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGlja0dyb3Vwcy5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1jYW5kbGVzdGljay1saW5lcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLCBpKSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIHkoZ2V0SGlnaChkLCBpKSk7IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiB5KGdldExvdyhkLCBpKSk7IH0pO1xuXG4gICAgICAgICAgICB2YXIgcmVjdHMgPSB0aWNrR3JvdXBzLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWNhbmRsZXN0aWNrLXJlY3RzIG52LWJhcnMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoeChnZXRYKGQsIGkpKSAtIGJhcldpZHRoLzIpICsgJywnXG4gICAgICAgICAgICAgICAgICAgICsgKHkoZ2V0WShkLCBpKSkgLSAoZ2V0T3BlbihkLCBpKSA+IGdldENsb3NlKGQsIGkpID8gKHkoZ2V0Q2xvc2UoZCwgaSkpIC0geShnZXRPcGVuKGQsIGkpKSkgOiAwKSlcbiAgICAgICAgICAgICAgICAgICAgKyAnKSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGJhcldpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVuID0gZ2V0T3BlbihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlID0gZ2V0Q2xvc2UoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVuID4gY2xvc2UgPyB5KGNsb3NlKSAtIHkob3BlbikgOiB5KG9wZW4pIC0geShjbG9zZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRpY2tzLnNlbGVjdCgnLm52LWNhbmRsZXN0aWNrLWxpbmVzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLCBpKSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIHkoZ2V0SGlnaChkLCBpKSk7IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiB5KGdldExvdyhkLCBpKSk7IH0pO1xuXG4gICAgICAgICAgICB0aWNrcy5zZWxlY3QoJy5udi1jYW5kbGVzdGljay1yZWN0cycpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoeChnZXRYKGQsIGkpKSAtIGJhcldpZHRoLzIpICsgJywnXG4gICAgICAgICAgICAgICAgICAgICsgKHkoZ2V0WShkLCBpKSkgLSAoZ2V0T3BlbihkLCBpKSA+IGdldENsb3NlKGQsIGkpID8gKHkoZ2V0Q2xvc2UoZCwgaSkpIC0geShnZXRPcGVuKGQsIGkpKSkgOiAwKSlcbiAgICAgICAgICAgICAgICAgICAgKyAnKSc7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGJhcldpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcGVuID0gZ2V0T3BlbihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlID0gZ2V0Q2xvc2UoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcGVuID4gY2xvc2UgPyB5KGNsb3NlKSAtIHkob3BlbikgOiB5KG9wZW4pIC0geShjbG9zZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cblxuICAgIC8vQ3JlYXRlIG1ldGhvZHMgdG8gYWxsb3cgb3V0c2lkZSBmdW5jdGlvbnMgdG8gaGlnaGxpZ2h0IGEgc3BlY2lmaWMgYmFyLlxuICAgIGNoYXJ0LmhpZ2hsaWdodFBvaW50ID0gZnVuY3Rpb24ocG9pbnRJbmRleCwgaXNIb3Zlck92ZXIpIHtcbiAgICAgICAgY2hhcnQuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3QoXCIubnYtY2FuZGxlc3RpY2tCYXIgLm52LXRpY2stMC1cIiArIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGlzSG92ZXJPdmVyKVxuICAgICAgICA7XG4gICAgfTtcblxuICAgIGNoYXJ0LmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250YWluZXIuc2VsZWN0KFwiLm52LWNhbmRsZXN0aWNrQmFyIC5udi10aWNrLmhvdmVyXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGZhbHNlKVxuICAgICAgICA7XG4gICAgfTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHhTY2FsZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgeERvbWFpbjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eURvbWFpbj1fO319LFxuICAgICAgICB4UmFuZ2U6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgZm9yY2VYOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWD1fO319LFxuICAgICAgICBmb3JjZVk6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VZPV87fX0sXG4gICAgICAgIHBhZERhdGE6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwYWREYXRhO30sIHNldDogZnVuY3Rpb24oXyl7cGFkRGF0YT1fO319LFxuICAgICAgICBjbGlwRWRnZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuICAgICAgICBpZDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICBpbnRlcmFjdGl2ZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaW50ZXJhY3RpdmU7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcmFjdGl2ZT1fO319LFxuXG4gICAgICAgIHg6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1fO319LFxuICAgICAgICB5OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFk9Xzt9fSxcbiAgICAgICAgb3BlbjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldE9wZW4oKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldE9wZW49Xzt9fSxcbiAgICAgICAgY2xvc2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldENsb3NlKCk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRDbG9zZT1fO319LFxuICAgICAgICBoaWdoOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0SGlnaDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldEhpZ2g9Xzt9fSxcbiAgICAgICAgbG93OiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldExvdzt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldExvdz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5jdW11bGF0aXZlTGluZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBsaW5lcyA9IG52Lm1vZGVscy5saW5lKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBjb250cm9scyA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGludGVyYWN0aXZlTGF5ZXIgPSBudi5pbnRlcmFjdGl2ZUd1aWRlbGluZSgpXG4gICAgICAgICwgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMzAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIG1hcmdpblRvcCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHNob3dDb250cm9scyA9IHRydWVcbiAgICAgICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgICAgICwgcmVzY2FsZVkgPSB0cnVlXG4gICAgICAgICwgeCAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueFNjYWxlKClcbiAgICAgICAgLCB5IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC55U2NhbGUoKVxuICAgICAgICAsIGlkID0gbGluZXMuaWQoKVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBub0RhdGEgPSBudWxsXG4gICAgICAgICwgYXZlcmFnZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuYXZlcmFnZSB9XG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgLCB0cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIG5vRXJyb3JDaGVjayA9IGZhbHNlICAvL2lmIHNldCB0byBUUlVFLCB3aWxsIGJ5cGFzcyBhbiBlcnJvciBjaGVjayBpbiB0aGUgaW5kZXhpZnkgZnVuY3Rpb24uXG4gICAgICAgIDtcblxuICAgIHN0YXRlLmluZGV4ID0gMDtcbiAgICBzdGF0ZS5yZXNjYWxlWSA9IHJlc2NhbGVZO1xuXG4gICAgeEF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg3KTtcbiAgICB5QXhpcy5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKTtcblxuICAgIHRvb2x0aXAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4geUF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgIH0pLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB4QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgfSk7XG5cbiAgICBjb250cm9scy51cGRhdGVTdGF0ZShmYWxzZSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBkeCA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICwgaW5kZXggPSB7aTogMCwgeDogMH1cbiAgICAgICAgLCByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbilcbiAgICAgICAgO1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXguaSxcbiAgICAgICAgICAgICAgICByZXNjYWxlWTogcmVzY2FsZVlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5pbmRleCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGluZGV4LmkgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZXNjYWxlWSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJlc2NhbGVZID0gc3RhdGUucmVzY2FsZVk7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhsaW5lcyk7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NlZCgnbnYtY2hhcnQtJyArIGlkLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChjaGFydClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5kZXhEcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpXG4gICAgICAgICAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpXG4gICAgICAgICAgICAgICAgLm9uKCdkcmFnJywgZHJhZ01vdmUpXG4gICAgICAgICAgICAgICAgLm9uKCdkcmFnZW5kJywgZHJhZ0VuZCk7XG5cblxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhZ1N0YXJ0KGQsaSkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdChjaGFydC5jb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnY3Vyc29yJywgJ2V3LXJlc2l6ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFnTW92ZShkLGkpIHtcbiAgICAgICAgICAgICAgICBpbmRleC54ID0gZDMuZXZlbnQueDtcbiAgICAgICAgICAgICAgICBpbmRleC5pID0gTWF0aC5yb3VuZChkeC5pbnZlcnQoaW5kZXgueCkpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVplcm8oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gZHJhZ0VuZChkLGkpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QoY2hhcnQuY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2N1cnNvcicsICdhdXRvJyk7XG5cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc3RhdGUgYW5kIHNlbmQgc3RhdGVDaGFuZ2Ugd2l0aCBuZXcgaW5kZXhcbiAgICAgICAgICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4Lmk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IE5vIERhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBudi51dGlscy5ub0RhdGEoY2hhcnQsIGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgICAgICB5ID0gbGluZXMueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIGlmICghcmVzY2FsZVkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzRG9tYWlucyA9IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRpYWxEb21haW4gPSBkMy5leHRlbnQoc2VyaWVzLnZhbHVlcywgbGluZXMueSgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hY2NvdW50IGZvciBzZXJpZXMgYmVpbmcgZGlzYWJsZWQgd2hlbiBsb3NpbmcgOTUlIG9yIG1vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbml0aWFsRG9tYWluWzBdIDwgLS45NSkgaW5pdGlhbERvbWFpblswXSA9IC0uOTU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsRG9tYWluWzBdIC0gaW5pdGlhbERvbWFpblsxXSkgLyAoMSArIGluaXRpYWxEb21haW5bMV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbERvbWFpblsxXSAtIGluaXRpYWxEb21haW5bMF0pIC8gKDEgKyBpbml0aWFsRG9tYWluWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVEb21haW4gPSBbXG4gICAgICAgICAgICAgICAgICAgIGQzLm1pbihzZXJpZXNEb21haW5zLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdIH0pLFxuICAgICAgICAgICAgICAgICAgICBkMy5tYXgoc2VyaWVzRG9tYWlucywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZFsxXSB9KVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBsaW5lcy55RG9tYWluKGNvbXBsZXRlRG9tYWluKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZXMueURvbWFpbihudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHguZG9tYWluKFswLCBkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAxXSkgLy9Bc3N1bWVzIGFsbCBzZXJpZXMgaGF2ZSBzYW1lIGxlbmd0aFxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlV2lkdGhdKVxuICAgICAgICAgICAgICAgIC5jbGFtcCh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBpbmRleGlmeShpbmRleC5pLCBkYXRhKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGl2ZVBvaW50ZXJFdmVudHMgPSAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpID8gXCJub25lXCIgOiBcImFsbFwiO1xuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtY3VtdWxhdGl2ZUxpbmUnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1jdW11bGF0aXZlTGluZScpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaW50ZXJhY3RpdmUnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsaW50ZXJhY3RpdmVQb2ludGVyRXZlbnRzKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1hdmdMaW5lc1dyYXAnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoIXNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKS5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChsZWdlbmQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXJnaW5Ub3AgJiYgbGVnZW5kLmhlaWdodCgpICE9PSBtYXJnaW4udG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2xzXG4gICAgICAgICAgICBpZiAoIXNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICB7IGtleTogJ1JlLXNjYWxlIHktYXhpcycsIGRpc2FibGVkOiAhcmVzY2FsZVkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9sc1xuICAgICAgICAgICAgICAgICAgICAud2lkdGgoMTQwKVxuICAgICAgICAgICAgICAgICAgICAuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKVxuICAgICAgICAgICAgICAgICAgICAucmlnaHRBbGlnbihmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcmdpbih7dG9wOiA1LCByaWdodDogMCwgYm90dG9tOiA1LCBsZWZ0OiAyMH0pXG4gICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250cm9sc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oY29udHJvbHNEYXRhKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoLW1hcmdpbi50b3ApICsnKScpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2hvdyBlcnJvciBpZiBzZXJpZXMgZ29lcyBiZWxvdyAxMDAlXG4gICAgICAgICAgICB2YXIgdGVtcERpc2FibGVkID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50ZW1wRGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcudGVtcERpc2FibGVkJykucmVtb3ZlKCk7IC8vY2xlYW4tdXAgYW5kIHByZXZlbnQgZHVwbGljYXRlc1xuICAgICAgICAgICAgaWYgKHRlbXBEaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cmFwLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ3RlbXBEaXNhYmxlZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsICctLjcxZW0nKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHRlbXBEaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSkuam9pbignLCAnKSArICcgdmFsdWVzIGNhbm5vdCBiZSBjYWxjdWxhdGVkIGZvciB0aGlzIHRpbWUgcGVyaW9kLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LHRvcDptYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLnN2Z0NvbnRhaW5lcihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC54U2NhbGUoeCk7XG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVcIikuY2FsbChpbnRlcmFjdGl2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ0VudGVyLnNlbGVjdCgnLm52LWJhY2tncm91bmQnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBsaW5lc1xuICAgICAgICAgICAgICAgIC8vLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pXG4gICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5kaXNwbGF5LnkgfSlcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiAhZGF0YVtpXS50ZW1wRGlzYWJsZWQ7IH0pKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gICFkLmRpc2FibGVkICYmICFkLnRlbXBEaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIGxpbmVzV3JhcC5jYWxsKGxpbmVzKTtcblxuICAgICAgICAgICAgLy9TdG9yZSBhIHNlcmllcyBpbmRleCBudW1iZXIgaW4gdGhlIGRhdGEgYXJyYXkuXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZC5zZXJpZXNJbmRleCA9IGk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGF2Z0xpbmVEYXRhID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhZC5kaXNhYmxlZCAmJiAhIWF2ZXJhZ2UoZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGF2Z0xpbmVzID0gZy5zZWxlY3QoXCIubnYtYXZnTGluZXNXcmFwXCIpLnNlbGVjdEFsbChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuZGF0YShhdmdMaW5lRGF0YSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXk7IH0pO1xuXG4gICAgICAgICAgICB2YXIgZ2V0QXZnTGluZVkgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy9JZiBhdmVyYWdlIGxpbmVzIGdvIG9mZiB0aGUgc3ZnIGVsZW1lbnQsIGNsYW1wIHRoZW0gdG8gdGhlIHN2ZyBib3VuZHMuXG4gICAgICAgICAgICAgICAgdmFyIHlWYWwgPSB5KGF2ZXJhZ2UoZCkpO1xuICAgICAgICAgICAgICAgIGlmICh5VmFsIDwgMCkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgaWYgKHlWYWwgPiBhdmFpbGFibGVIZWlnaHQpIHJldHVybiBhdmFpbGFibGVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlWYWw7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhdmdMaW5lcy5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLDIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UtZGFzaGFycmF5JywnMTAsMTAnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJyxmdW5jdGlvbiAoZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy5jb2xvcigpKGQsZC5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJyxhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBnZXRBdmdMaW5lWSlcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBnZXRBdmdMaW5lWSk7XG5cbiAgICAgICAgICAgIGF2Z0xpbmVzXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgIC8vSWYgYXZlcmFnZSBsaW5lcyBnbyBvZmZzY3JlZW4sIG1ha2UgdGhlbSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbCA9IHkoYXZlcmFnZShkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5VmFsIDwgMCB8fCB5VmFsID4gYXZhaWxhYmxlSGVpZ2h0KSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJyxhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cigneTEnLCBnZXRBdmdMaW5lWSlcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBnZXRBdmdMaW5lWSk7XG5cbiAgICAgICAgICAgIGF2Z0xpbmVzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy9DcmVhdGUgaW5kZXggbGluZVxuICAgICAgICAgICAgdmFyIGluZGV4TGluZSA9IGxpbmVzV3JhcC5zZWxlY3RBbGwoJy5udi1pbmRleExpbmUnKVxuICAgICAgICAgICAgICAgIC5kYXRhKFtpbmRleF0pO1xuICAgICAgICAgICAgaW5kZXhMaW5lLmVudGVyKCkuYXBwZW5kKCdyZWN0JykuYXR0cignY2xhc3MnLCAnbnYtaW5kZXhMaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAncmVkJylcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgLjUpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixcImFsbFwiKVxuICAgICAgICAgICAgICAgIC5jYWxsKGluZGV4RHJhZyk7XG5cbiAgICAgICAgICAgIGluZGV4TGluZVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyBkeChkLmkpICsgJywwKScgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzcwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlWmVybygpIHtcbiAgICAgICAgICAgICAgICBpbmRleExpbmVcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG5cbiAgICAgICAgICAgICAgICAvL1doZW4gZHJhZ2dpbmcgdGhlIGluZGV4IGxpbmUsIHR1cm4gb2ZmIGxpbmUgdHJhbnNpdGlvbnMuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiB0dXJuIHRoZW0gYmFjayBvbiB3aGVuIGRvbmUgZHJhZ2dpbmcuXG4gICAgICAgICAgICAgICAgdmFyIG9sZER1cmF0aW9uID0gY2hhcnQuZHVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBjaGFydC5kdXJhdGlvbigwKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBjaGFydC5kdXJhdGlvbihvbGREdXJhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtYmFja2dyb3VuZCByZWN0JylcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LnggPSBkMy5tb3VzZSh0aGlzKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXguaSA9IE1hdGgucm91bmQoZHguaW52ZXJ0KGluZGV4LngpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgc3RhdGUgYW5kIHNlbmQgc3RhdGVDaGFuZ2Ugd2l0aCBuZXcgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleC5pO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlWmVybygpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudENsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGluZGV4LmkgPSBlLnBvaW50SW5kZXg7XG4gICAgICAgICAgICAgICAgaW5kZXgueCA9IGR4KGluZGV4LmkpO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXRlIGFuZCBzZW5kIHN0YXRlQ2hhbmdlIHdpdGggbmV3IGluZGV4XG4gICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleC5pO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVplcm8oKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb250cm9scy5kaXNwYXRjaC5vbignbGVnZW5kQ2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgcmVzY2FsZVkgPSAhZC5kaXNhYmxlZDtcblxuICAgICAgICAgICAgICAgIHN0YXRlLnJlc2NhbGVZID0gcmVzY2FsZVk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgbGluZXMuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVBvaW50LCBwb2ludEluZGV4LCBwb2ludFhMb2NhdGlvbiwgYWxsRGF0YSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5oaWdobGlnaHRQb2ludChpLCBwb2ludEluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaW5nbGVQb2ludCA9PT0gJ3VuZGVmaW5lZCcpIHNpbmdsZVBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBvaW50WExvY2F0aW9uID09PSAndW5kZWZpbmVkJykgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yKHNlcmllcyxzZXJpZXMuc2VyaWVzSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvL0hpZ2hsaWdodCB0aGUgdG9vbHRpcCBlbnRyeSBiYXNlZCBvbiB3aGljaCBwb2ludCB0aGUgbW91c2UgaXMgY2xvc2VzdCB0by5cbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5VmFsdWUgPSBjaGFydC55U2NhbGUoKS5pbnZlcnQoZS5tb3VzZVkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluRXh0ZW50ID0gTWF0aC5hYnMoY2hhcnQueVNjYWxlKCkuZG9tYWluKClbMF0gLSBjaGFydC55U2NhbGUoKS5kb21haW4oKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAzICogZG9tYWluRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhUb0hpZ2hsaWdodCA9IG52Lm5lYXJlc3RWYWx1ZUluZGV4KGFsbERhdGEubWFwKGZ1bmN0aW9uKGQpe3JldHVybiBkLnZhbHVlfSkseVZhbHVlLHRocmVzaG9sZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleFRvSGlnaGxpZ2h0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YVtpbmRleFRvSGlnaGxpZ2h0XS5oaWdobGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSB4QXhpcy50aWNrRm9ybWF0KCkoY2hhcnQueCgpKHNpbmdsZVBvaW50LHBvaW50SW5kZXgpLCBwb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB4VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICkoKTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuaW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LmkgPSBlLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpbmRleC54ID0gZHgoaW5kZXguaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5kZXggPSBlLmluZGV4O1xuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4TGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnJlc2NhbGVZICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXNjYWxlWSA9IGUucmVzY2FsZVk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2N1bXVsYXRpdmVMaW5lQ2hhcnQgaW1tZWRpYXRlJyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBsaW5lcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICAgIHg6IGNoYXJ0LngoKShldnQucG9pbnQpLFxuICAgICAgICAgICAgeTogY2hhcnQueSgpKGV2dC5wb2ludCksXG4gICAgICAgICAgICBjb2xvcjogZXZ0LnBvaW50LmNvbG9yXG4gICAgICAgIH07XG4gICAgICAgIGV2dC5wb2ludCA9IHBvaW50O1xuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEZ1bmN0aW9uc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgaW5kZXhpZnlZR2V0dGVyID0gbnVsbDtcbiAgICAvKiBOb3JtYWxpemUgdGhlIGRhdGEgYWNjb3JkaW5nIHRvIGFuIGluZGV4IHBvaW50LiAqL1xuICAgIGZ1bmN0aW9uIGluZGV4aWZ5KGlkeCwgZGF0YSkge1xuICAgICAgICBpZiAoIWluZGV4aWZ5WUdldHRlcikgaW5kZXhpZnlZR2V0dGVyID0gbGluZXMueSgpO1xuICAgICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24obGluZSwgaSkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4VmFsdWUgPSBsaW5lLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGluZGV4VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHYgPSBpbmRleGlmeVlHZXR0ZXIoaW5kZXhWYWx1ZSwgaWR4KTtcblxuICAgICAgICAgICAgLy9UT0RPOiBpbXBsZW1lbnQgY2hlY2sgYmVsb3csIGFuZCBkaXNhYmxlIHNlcmllcyBpZiBzZXJpZXMgbG9zZXMgMTAwJSBvciBtb3JlIGNhdXNlIGRpdmlkZSBieSAwIGlzc3VlXG4gICAgICAgICAgICBpZiAodiA8IC0uOTUgJiYgIW5vRXJyb3JDaGVjaykge1xuICAgICAgICAgICAgICAgIC8vaWYgYSBzZXJpZXMgbG9zZXMgbW9yZSB0aGFuIDEwMCUsIGNhbGN1bGF0aW9ucyBmYWlsLi4gYW55dGhpbmcgY2xvc2UgY2FuIGNhdXNlIG1ham9yIGRpc3RvcnRpb24gKGJ1dCBpcyBtYXRoZW1hdGljYWxseSBjb3JyZWN0IHRpbGwgaXQgaGl0cyAxMDApXG5cbiAgICAgICAgICAgICAgICBsaW5lLnRlbXBEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUudGVtcERpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxpbmUudmFsdWVzID0gbGluZS52YWx1ZXMubWFwKGZ1bmN0aW9uKHBvaW50LCBwb2ludEluZGV4KSB7XG4gICAgICAgICAgICAgICAgcG9pbnQuZGlzcGxheSA9IHsneSc6IChpbmRleGlmeVlHZXR0ZXIocG9pbnQsIHBvaW50SW5kZXgpIC0gdikgLyAoMSArIHYpIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LmxpbmVzID0gbGluZXM7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LmludGVyYWN0aXZlTGF5ZXIgPSBpbnRlcmFjdGl2ZUxheWVyO1xuICAgIGNoYXJ0LnN0YXRlID0gc3RhdGU7XG4gICAgY2hhcnQudG9vbHRpcCA9IHRvb2x0aXA7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICByZXNjYWxlWTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJlc2NhbGVZO30sIHNldDogZnVuY3Rpb24oXyl7cmVzY2FsZVk9Xzt9fSxcbiAgICAgICAgc2hvd0NvbnRyb2xzOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0NvbnRyb2xzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0NvbnRyb2xzPV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIGF2ZXJhZ2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGF2ZXJhZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXthdmVyYWdlPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIHNob3dYQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIG5vRXJyb3JDaGVjazogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9FcnJvckNoZWNrO30sIHNldDogZnVuY3Rpb24oXyl7bm9FcnJvckNoZWNrPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gXy50b3A7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gXy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUgPSBfO1xuICAgICAgICAgICAgaWYgKF8gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5pbnRlcmFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXNlVm9yb25vaShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19LFxuICAgICAgICByaWdodEFsaWduWUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ25ZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICAgICAgICAgIHlBeGlzLm9yaWVudCggKF8pID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIGxpbmVzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBsaW5lcyk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcbi8vVE9ETzogY29uc2lkZXIgZGVwcmVjYXRpbmcgYnkgYWRkaW5nIG5lY2Vzc2FyeSBmZWF0dXJlcyB0byBtdWx0aUJhciBtb2RlbFxubnYubW9kZWxzLmRpc2NyZXRlQmFyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIGNvbnRhaW5lclxuICAgICAgICAsIHggPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBmb3JjZVkgPSBbMF0gLy8gMCBpcyBmb3JjZWQgYnkgZGVmYXVsdC4uIHRoaXMgbWFrZXMgc2Vuc2UgZm9yIHRoZSBtYWpvcml0eSBvZiBiYXIgZ3JhcGhzLi4uIHVzZXIgY2FuIGFsd2F5cyBkbyBjaGFydC5mb3JjZVkoW10pIHRvIHJlbW92ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93VmFsdWVzID0gZmFsc2VcbiAgICAgICAgLCB2YWx1ZUZvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAnZWxlbWVudE1vdXNlbW92ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIHJlY3RDbGFzcyA9ICdkaXNjcmV0ZUJhcidcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTA7XG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vYWRkIHNlcmllcyBpbmRleCB0byBlYWNoIGRhdGEgcG9pbnQgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5zZXJpZXMgPSBpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4pID8gW10gOiAvLyBpZiB3ZSBrbm93IHhEb21haW4gYW5kIHlEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSksIHkwOiBkLnkwIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgeCAgIC5kb21haW4oeERvbWFpbiB8fCBkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pKVxuICAgICAgICAgICAgICAgIC5yYW5nZUJhbmRzKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdLCAuMSk7XG4gICAgICAgICAgICB5ICAgLmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0pLmNvbmNhdChmb3JjZVkpKSk7XG5cbiAgICAgICAgICAgIC8vIElmIHNob3dWYWx1ZXMsIHBhZCB0aGUgWSBheGlzIHJhbmdlIHRvIGFjY291bnQgZm9yIGxhYmVsIGhlaWdodFxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMpIHkucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQgLSAoeS5kb21haW4oKVswXSA8IDAgPyAxMiA6IDApLCB5LmRvbWFpbigpWzFdID4gMCA/IDEyIDogMF0pO1xuICAgICAgICAgICAgZWxzZSB5LnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBpZiB0aGV5IGV4aXN0XG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IHkuY29weSgpLnJhbmdlKFt5KDApLHkoMCldKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWRpc2NyZXRlYmFyJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtZGlzY3JldGViYXInKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgLy9UT0RPOiBieSBkZWZpbml0aW9uLCB0aGUgZGlzY3JldGUgYmFyIHNob3VsZCBub3QgaGF2ZSBtdWx0aXBsZSBncm91cHMsIHdpbGwgbW9kaWZ5L3JlbW92ZSBsYXRlclxuICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHdyYXAuc2VsZWN0KCcubnYtZ3JvdXBzJykuc2VsZWN0QWxsKCcubnYtZ3JvdXAnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSk7XG4gICAgICAgICAgICBncm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG4gICAgICAgICAgICBncm91cHMuZXhpdCgpXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2Rpc2NyZXRlQmFyOiBleGl0IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGdyb3Vwc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWdyb3VwIG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSk7XG4gICAgICAgICAgICBncm91cHNcbiAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnZGlzY3JldGVCYXI6IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAuNzUpO1xuXG4gICAgICAgICAgICB2YXIgYmFycyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ2cubnYtYmFyJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcyB9KTtcbiAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB2YXIgYmFyc0VudGVyID0gYmFycy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoeChnZXRYKGQsaSkpICsgeC5yYW5nZUJhbmQoKSAqIC4wNSApICsgJywgJyArIHkoMCkgKyAnKSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7IC8vVE9ETzogZmlndXJlIG91dCB3aHkgaiB3b3JrcyBhYm92ZSwgYnV0IG5vdCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGQzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnREYmxDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIGRhdGEubGVuZ3RoIClcblxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3QoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHZhbHVlRm9ybWF0KGdldFkoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2Rpc2NyZXRlQmFyOiBiYXJzIHRleHQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8geShnZXRZKGQsaSkpIC0geSgwKSArIDEyIDogLTQgfSlcblxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3RBbGwoJ3RleHQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCxpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsaSkgfSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCByZWN0Q2xhc3MpXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2Rpc2NyZXRlQmFyOiBiYXJzIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAuOSAvIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnZGlzY3JldGVCYXI6IGJhcnMnKVxuICAgICAgICAgICAgICAgIC8vLmRlbGF5KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSAqIDEyMDAgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggfSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0geChnZXRYKGQsaSkpICsgeC5yYW5nZUJhbmQoKSAqIC4wNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IGdldFkoZCxpKSA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KDApIC0geShnZXRZKGQsaSkpIDwgMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOiAvL21ha2UgMSBweCBwb3NpdGl2ZSBiYXJzIHNob3cgdXAgYWJvdmUgeT0wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShnZXRZKGQsaSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBsZWZ0ICsgJywgJyArIHRvcCArICcpJ1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIE1hdGgubWF4KE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpLCAxKVxuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIC8vc3RvcmUgb2xkIHNjYWxlcyBmb3IgdXNlIGluIHRyYW5zaXRpb25zIG9uIHVwZGF0ZVxuICAgICAgICAgICAgeDAgPSB4LmNvcHkoKTtcbiAgICAgICAgICAgIHkwID0geS5jb3B5KCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdkaXNjcmV0ZUJhciBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBmb3JjZVk6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgc2hvd1ZhbHVlczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1ZhbHVlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dWYWx1ZXM9Xzt9fSxcbiAgICAgICAgeDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgeTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFk9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgeERvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lSYW5nZT1fO319LFxuICAgICAgICB2YWx1ZUZvcm1hdDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdmFsdWVGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt2YWx1ZUZvcm1hdD1fO319LFxuICAgICAgICBpZDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICByZWN0Q2xhc3M6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJlY3RDbGFzczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JlY3RDbGFzcz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLmRpc2NyZXRlQmFyQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGRpc2NyZXRlYmFyID0gbnYubW9kZWxzLmRpc2NyZXRlQmFyKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcblx0LCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCB0b29sdGlwID0gbnYubW9kZWxzLnRvb2x0aXAoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMTUsIHJpZ2h0OiAxMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgbWFyZ2luVG9wID0gbnVsbFxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKClcblx0LCBzaG93TGVnZW5kID0gZmFsc2VcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgc3RhZ2dlckxhYmVscyA9IGZhbHNlXG4gICAgICAgICwgd3JhcExhYmVscyA9IGZhbHNlXG4gICAgICAgICwgcm90YXRlTGFiZWxzID0gMFxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgbm9EYXRhID0gbnVsbFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2JlZm9yZVVwZGF0ZScsJ3JlbmRlckVuZCcpXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnYm90dG9tJylcbiAgICAgICAgLnNob3dNYXhNaW4oZmFsc2UpXG4gICAgICAgIC50aWNrRm9ybWF0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSlcbiAgICA7XG4gICAgeUF4aXNcbiAgICAgICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgICAgIC50aWNrRm9ybWF0KGQzLmZvcm1hdCgnLC4xZicpKVxuICAgIDtcblxuICAgIHRvb2x0aXBcbiAgICAgICAgLmR1cmF0aW9uKDApXG4gICAgICAgIC5oZWFkZXJFbmFibGVkKGZhbHNlKVxuICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmtleUZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoZGlzY3JldGViYXIpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBudi51dGlscy5hdmFpbGFibGVXaWR0aCh3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYmVmb3JlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikuY2FsbChjaGFydCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbnYudXRpbHMubm9EYXRhKGNoYXJ0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBkaXNjcmV0ZWJhci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBkaXNjcmV0ZWJhci55U2NhbGUoKS5jbGFtcCh0cnVlKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWRpc2NyZXRlQmFyV2l0aEF4ZXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1kaXNjcmV0ZUJhcldpdGhBeGVzJykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gZ0VudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtemVyb0xpbmUnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG5cdCAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuXG4gICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKCFzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJykuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWFyZ2luVG9wICYmIGxlZ2VuZC5oZWlnaHQoKSAhPT0gbWFyZ2luLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcbiAgICAgICAgICAgIGRpc2NyZXRlYmFyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgYmFyc1dyYXAudHJhbnNpdGlvbigpLmNhbGwoZGlzY3JldGViYXIpO1xuXG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYteC1sYWJlbC1jbGlwLScgKyBkaXNjcmV0ZWJhci5pZCgpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJyNudi14LWxhYmVsLWNsaXAtJyArIGRpc2NyZXRlYmFyLmlkKCkgKyAnIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHgucmFuZ2VCYW5kKCkgKiAoc3RhZ2dlckxhYmVscyA/IDIgOiAxKSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTYpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAteC5yYW5nZUJhbmQoKSAvIChzdGFnZ2VyTGFiZWxzID8gMSA6IDIgKSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEF4ZXNcbiAgICAgICAgICAgIGlmIChzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICB4QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoeS5yYW5nZSgpWzBdICsgKChkaXNjcmV0ZWJhci5zaG93VmFsdWVzKCkgJiYgeS5kb21haW4oKVswXSA8IDApID8gMTYgOiAwKSkgKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuY2FsbCh4QXhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5zZWxlY3RBbGwoJ2cnKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xuICAgICAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAndHJhbnNsYXRlKDAsJyArIChqICUgMiA9PSAwID8gJzUnIDogJzE3JykgKyAnKScgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocm90YXRlTGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnLnRpY2sgdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgnICsgcm90YXRlTGFiZWxzICsgJyAwLDApJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByb3RhdGVMYWJlbHMgPiAwID8gJ3N0YXJ0JyA6ICdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAod3JhcExhYmVscykge1xuICAgICAgICAgICAgICAgICAgICBnLnNlbGVjdEFsbCgnLnRpY2sgdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2FsbChudi51dGlscy53cmFwVGlja3MsIGNoYXJ0LnhBeGlzLnJhbmdlQmFuZCgpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBaZXJvIGxpbmVcbiAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXplcm9MaW5lIGxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsMClcbiAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsKHJpZ2h0QWxpZ25ZQXhpcykgPyAtYXZhaWxhYmxlV2lkdGggOiBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIHkoMCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ5MlwiLCB5KDApKVxuICAgICAgICAgICAgO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2Rpc2NyZXRlQmFyIGNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGRpc2NyZXRlYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgZXZ0WydzZXJpZXMnXSA9IHtcbiAgICAgICAgICAgIGtleTogY2hhcnQueCgpKGV2dC5kYXRhKSxcbiAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkoZXZ0LmRhdGEpLFxuICAgICAgICAgICAgY29sb3I6IGV2dC5jb2xvclxuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgZGlzY3JldGViYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpO1xuICAgIH0pO1xuXG4gICAgZGlzY3JldGViYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuZGlzY3JldGViYXIgPSBkaXNjcmV0ZWJhcjtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcblx0c2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgc3RhZ2dlckxhYmVsczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhZ2dlckxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWdnZXJMYWJlbHM9Xzt9fSxcbiAgICAgICAgcm90YXRlTGFiZWxzOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcm90YXRlTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7cm90YXRlTGFiZWxzPV87fX0sXG4gICAgICAgIHdyYXBMYWJlbHM6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3cmFwTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7d3JhcExhYmVscz0hIV87fX0sXG4gICAgICAgIHNob3dYQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gXy50b3A7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gXy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGRpc2NyZXRlYmFyLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBkaXNjcmV0ZWJhci5jb2xvcihjb2xvcik7XG5cdCAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIChfKSA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGRpc2NyZXRlYmFyKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59XG5cbm52Lm1vZGVscy5kaXN0cmlidXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gNDAwIC8vdGVjaG5pY2FsbHkgd2lkdGggb3IgaGVpZ2h0IGRlcGVuZGluZyBvbiB4IG9yIHkuLi4uXG4gICAgICAgICwgc2l6ZSA9IDhcbiAgICAgICAgLCBheGlzID0gJ3gnIC8vICd4JyBvciAneScuLi4gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuICAgICAgICAsIGdldERhdGEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkW2F4aXNdIH0gIC8vIGRlZmF1bHRzIGQueCBvciBkLnlcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGRvbWFpblxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgc2NhbGUwO1xuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUxlbmd0aCA9IHdpZHRoIC0gKGF4aXMgPT09ICd4JyA/IG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0IDogbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20pLFxuICAgICAgICAgICAgICAgIG5heGlzID0gYXhpcyA9PSAneCcgPyAneScgOiAneCcsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG5cbiAgICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMCB8fCBzY2FsZTtcblxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcblxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LWRpc3RyaWJ1dGlvbicpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi1kaXN0cmlidXRpb24nKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKVxuXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgIHZhciBkaXN0V3JhcCA9IGcuc2VsZWN0QWxsKCdnLm52LWRpc3QnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSk7XG5cbiAgICAgICAgICAgIGRpc3RXcmFwLmVudGVyKCkuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICBkaXN0V3JhcFxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWRpc3QgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pO1xuXG4gICAgICAgICAgICB2YXIgZGlzdCA9IGRpc3RXcmFwLnNlbGVjdEFsbCgnbGluZS5udi1kaXN0JyArIGF4aXMpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAgIGRpc3QuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUwKGdldERhdGEoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihheGlzICsgJzInLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIHNjYWxlMChnZXREYXRhKGQsaSkpIH0pXG4gICAgICAgICAgICByZW5kZXJXYXRjaC50cmFuc2l0aW9uKGRpc3RXcmFwLmV4aXQoKS5zZWxlY3RBbGwoJ2xpbmUubnYtZGlzdCcgKyBheGlzKSwgJ2Rpc3QgZXhpdCcpXG4gICAgICAgICAgICAgICAgLy8gLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKGF4aXMgKyAnMicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gc2NhbGUoZ2V0RGF0YShkLGkpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGRpc3RcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICdudi1kaXN0JyArIGF4aXMgKyAnIG52LWRpc3QnICsgYXhpcyArICctJyArIGkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cihuYXhpcyArICcxJywgMClcbiAgICAgICAgICAgICAgICAuYXR0cihuYXhpcyArICcyJywgc2l6ZSk7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC50cmFuc2l0aW9uKGRpc3QsICdkaXN0JylcbiAgICAgICAgICAgICAgICAvLyAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgLmF0dHIoYXhpcyArICcxJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBzY2FsZShnZXREYXRhKGQsaSkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoYXhpcyArICcyJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBzY2FsZShnZXREYXRhKGQsaSkpIH0pXG5cblxuICAgICAgICAgICAgc2NhbGUwID0gc2NhbGUuY29weSgpO1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2Rpc3RyaWJ1dGlvbiBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG5cbiAgICBjaGFydC5tYXJnaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hcmdpbjtcbiAgICAgICAgbWFyZ2luLnRvcCAgICA9IHR5cGVvZiBfLnRvcCAgICAhPSAndW5kZWZpbmVkJyA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICBtYXJnaW4uYm90dG9tID0gdHlwZW9mIF8uYm90dG9tICE9ICd1bmRlZmluZWQnID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICBtYXJnaW4ubGVmdCAgID0gdHlwZW9mIF8ubGVmdCAgICE9ICd1bmRlZmluZWQnID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC53aWR0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gd2lkdGg7XG4gICAgICAgIHdpZHRoID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5heGlzID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBheGlzO1xuICAgICAgICBheGlzID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgICBzaXplID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5nZXREYXRhID0gZnVuY3Rpb24oXykge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBnZXREYXRhO1xuICAgICAgICBnZXREYXRhID0gZDMuZnVuY3RvcihfKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgICAgIHNjYWxlID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5jb2xvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY29sb3I7XG4gICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9O1xuXG4gICAgY2hhcnQuZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGR1cmF0aW9uO1xuICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gICAgcmV0dXJuIGNoYXJ0O1xufVxubnYubW9kZWxzLmZvY3VzID0gZnVuY3Rpb24oY29udGVudCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgY29udGVudCA9IGNvbnRlbnQgfHwgbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGJydXNoID0gZDMuc3ZnLmJydXNoKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDEwLCByaWdodDogMCwgYm90dG9tOiAzMCwgbGVmdDogMH1cbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gNzBcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gZmFsc2VcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHRpY2tzID0gbnVsbFxuICAgICAgICAsIHhcbiAgICAgICAgLCB5XG4gICAgICAgICwgYnJ1c2hFeHRlbnQgPSBudWxsXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdicnVzaCcsICdvbkJydXNoJywgJ3JlbmRlckVuZCcpXG4gICAgICAgICwgc3luY0JydXNoaW5nID0gdHJ1ZVxuICAgICAgICA7XG5cbiAgICBjb250ZW50LmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICBjb250ZW50LnBvaW50QWN0aXZlKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoY29udGVudCk7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICBpZiggZHVyYXRpb24gPT09IDAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKCBjaGFydCApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBjb250ZW50LnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IGNvbnRlbnQueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtZm9jdXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtZm9jdXMnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFja2dyb3VuZCcpLmFwcGVuZCgncmVjdCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWNvbnRlbnRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYnJ1c2hCYWNrZ3JvdW5kJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1icnVzaCcpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY29udGVudFxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkOyB9KSk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZW50V3JhcCA9IGcuc2VsZWN0KCcubnYtY29udGVudFdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZDsgfSkpO1xuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGNvbnRlbnRXcmFwKS5jYWxsKGNvbnRlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTZXR1cCBCcnVzaFxuICAgICAgICAgICAgYnJ1c2hcbiAgICAgICAgICAgICAgICAueCh4KVxuICAgICAgICAgICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25CcnVzaChzeW5jQnJ1c2hpbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicnVzaC5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzeW5jQnJ1c2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gub25CcnVzaChicnVzaC5lbXB0eSgpID8geC5kb21haW4oKSA6IGJydXNoLmV4dGVudCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGJydXNoRXh0ZW50KSBicnVzaC5leHRlbnQoYnJ1c2hFeHRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgYnJ1c2hCRyA9IGcuc2VsZWN0KCcubnYtYnJ1c2hCYWNrZ3JvdW5kJykuc2VsZWN0QWxsKCdnJylcbiAgICAgICAgICAgICAgICAuZGF0YShbYnJ1c2hFeHRlbnQgfHwgYnJ1c2guZXh0ZW50KCldKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBicnVzaEJHZW50ZXIgPSBicnVzaEJHLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJyk7XG5cbiAgICAgICAgICAgIGJydXNoQkdlbnRlci5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWZ0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBicnVzaEJHZW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncmlnaHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBnQnJ1c2ggPSBnLnNlbGVjdCgnLm52LXgubnYtYnJ1c2gnKVxuICAgICAgICAgICAgICAgIC5jYWxsKGJydXNoKTtcbiAgICAgICAgICAgIGdCcnVzaC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICAgICAgZ0JydXNoLnNlbGVjdEFsbCgnLnJlc2l6ZScpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCByZXNpemVQYXRoKTtcblxuICAgICAgICAgICAgb25CcnVzaCh0cnVlKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1iYWNrZ3JvdW5kIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXMuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQsIDApO1xuICBcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZDMudHJhbnNpdGlvbihnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZDMudHJhbnNpdGlvbihnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB5LnJhbmdlKClbMF0gKyAnKScpO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRnVuY3Rpb25zXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFxuICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBjcm9zc2ZpbHRlciAoaHR0cDovL3NxdWFyZS5naXRodWIuY29tL2Nyb3NzZmlsdGVyLylcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2l6ZVBhdGgoZCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gKyhkID09ICdlJyksXG4gICAgICAgICAgICAgICAgICAgIHggPSBlID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICB5ID0gYXZhaWxhYmxlSGVpZ2h0IC8gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gJ00nICsgKDAuNSAqIHgpICsgJywnICsgeVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICg2LjUgKiB4KSArICcsJyArICh5ICsgNilcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA2KVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICgwLjUgKiB4KSArICcsJyArICgyICogeSlcbiAgICAgICAgICAgICAgICAgICAgKyAnWidcbiAgICAgICAgICAgICAgICAgICAgKyAnTScgKyAoMi41ICogeCkgKyAnLCcgKyAoeSArIDgpXG4gICAgICAgICAgICAgICAgICAgICsgJ1YnICsgKDIgKiB5IC0gOClcbiAgICAgICAgICAgICAgICAgICAgKyAnTScgKyAoNC41ICogeCkgKyAnLCcgKyAoeSArIDgpXG4gICAgICAgICAgICAgICAgICAgICsgJ1YnICsgKDIgKiB5IC0gOCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVCcnVzaEJHKCkge1xuICAgICAgICAgICAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcbiAgICAgICAgICAgICAgICBicnVzaEJHXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFticnVzaC5lbXB0eSgpID8geC5kb21haW4oKSA6IGJydXNoRXh0ZW50XSlcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdFdpZHRoID0geChkWzBdKSAtIHgucmFuZ2UoKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFdpZHRoID0gYXZhaWxhYmxlV2lkdGggLSB4KGRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLmxlZnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICBsZWZ0V2lkdGggPCAwID8gMCA6IGxlZnRXaWR0aCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCcucmlnaHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgeChkWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCByaWdodFdpZHRoIDwgMCA/IDAgOiByaWdodFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25CcnVzaChzaG91bGREaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGJydXNoRXh0ZW50ID0gYnJ1c2guZW1wdHkoKSA/IG51bGwgOiBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZW1wdHkoKSA/IHguZG9tYWluKCkgOiBicnVzaC5leHRlbnQoKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5icnVzaCh7ZXh0ZW50OiBleHRlbnQsIGJydXNoOiBicnVzaH0pO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUJydXNoQkcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkRGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gub25CcnVzaChleHRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdmb2N1cyBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LmNvbnRlbnQgPSBjb250ZW50O1xuICAgIGNoYXJ0LmJydXNoID0gYnJ1c2g7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dYQXhpczogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgYnJ1c2hFeHRlbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGJydXNoRXh0ZW50O30sIHNldDogZnVuY3Rpb24oXyl7YnJ1c2hFeHRlbnQ9Xzt9fSxcbiAgICAgICAgc3luY0JydXNoaW5nOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzeW5jQnJ1c2hpbmc7fSwgc2V0OiBmdW5jdGlvbihfKXtzeW5jQnJ1c2hpbmc9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgY29udGVudC5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgY29udGVudC5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICBpbnRlcnBvbGF0ZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udGVudC5pbnRlcnBvbGF0ZSgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb250ZW50LmludGVycG9sYXRlKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeFRpY2tGb3JtYXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgeEF4aXMudGlja0Zvcm1hdChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHlUaWNrRm9ybWF0OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5QXhpcy50aWNrRm9ybWF0KCk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHlBeGlzLnRpY2tGb3JtYXQoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb250ZW50LngoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29udGVudC54KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udGVudC55KCk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbnRlbnQueShfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCByaWdodEFsaWduWUF4aXMgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBjb250ZW50KTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLmZvcmNlRGlyZWN0ZWRHcmFwaCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDIsIHJpZ2h0OiAwLCBib3R0b206IDIsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA0MDBcbiAgICAgICAgLCBoZWlnaHQgPSAzMlxuICAgICAgICAsIGNvbnRhaW5lciA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdyZW5kZXJFbmQnKVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoWycjMDAwJ10pXG4gICAgICAgICwgdG9vbHRpcCAgICAgID0gbnYubW9kZWxzLnRvb2x0aXAoKVxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLy8gRm9yY2UgZGlyZWN0ZWQgZ3JhcGggc3BlY2lmaWMgcGFyYW1ldGVycyBbZGVmYXVsdCB2YWx1ZXNdXG4gICAgICAgICwgbGlua1N0cmVuZ3RoID0gMC4xXG4gICAgICAgICwgZnJpY3Rpb24gPSAwLjlcbiAgICAgICAgLCBsaW5rRGlzdCA9IDMwXG4gICAgICAgICwgY2hhcmdlID0gLTEyMFxuICAgICAgICAsIGdyYXZpdHkgPSAwLjFcbiAgICAgICAgLCB0aGV0YSA9IDAuOFxuICAgICAgICAsIGFscGhhID0gMC4xXG4gICAgICAgICwgcmFkaXVzID0gNVxuICAgICAgICAvLyBUaGVzZSBmdW5jdGlvbnMgYWxsb3cgdG8gYWRkIGV4dHJhIGF0dHJpYnV0ZXMgdG8gbmRlcyBhbmQgbGlua3NcbiAgICAgICAgLG5vZGVFeHRyYXMgPSBmdW5jdGlvbihub2RlcykgeyAvKiBEbyBub3RoaW5nICovIH1cbiAgICAgICAgLGxpbmtFeHRyYXMgPSBmdW5jdGlvbihsaW5rcykgeyAvKiBEbyBub3RoaW5nICovIH1cbiAgICAgICAgO1xuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKSxcbiAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5saW5rcyB8fCAhZGF0YS5ub2Rlcykge1xuICAgICAgICAgICAgICBudi51dGlscy5ub0RhdGEoY2hhcnQsIGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgLy8gQ29sbGVjdCBuYW1lcyBvZiBhbGwgZmllbGRzIGluIHRoZSBub2Rlc1xuICAgICAgICAgIHZhciBub2RlRmllbGRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgZGF0YS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZSk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgIG5vZGVGaWVsZFNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGZvcmNlID0gZDMubGF5b3V0LmZvcmNlKClcbiAgICAgICAgICAgICAgICAubm9kZXMoZGF0YS5ub2RlcylcbiAgICAgICAgICAgICAgICAubGlua3MoZGF0YS5saW5rcylcbiAgICAgICAgICAgICAgICAuc2l6ZShbYXZhaWxhYmxlV2lkdGgsIGF2YWlsYWJsZUhlaWdodF0pXG4gICAgICAgICAgICAgICAgLmxpbmtTdHJlbmd0aChsaW5rU3RyZW5ndGgpXG4gICAgICAgICAgICAgICAgLmZyaWN0aW9uKGZyaWN0aW9uKVxuICAgICAgICAgICAgICAgIC5saW5rRGlzdGFuY2UobGlua0Rpc3QpXG4gICAgICAgICAgICAgICAgLmNoYXJnZShjaGFyZ2UpXG4gICAgICAgICAgICAgICAgLmdyYXZpdHkoZ3Jhdml0eSlcbiAgICAgICAgICAgICAgICAudGhldGEodGhldGEpXG4gICAgICAgICAgICAgICAgLmFscGhhKGFscGhhKVxuICAgICAgICAgICAgICAgIC5zdGFydCgpO1xuXG4gICAgICAgICAgdmFyIGxpbmsgPSBjb250YWluZXIuc2VsZWN0QWxsKFwiLmxpbmtcIilcbiAgICAgICAgICAgICAgICAuZGF0YShkYXRhLmxpbmtzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcImxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibnYtZm9yY2UtbGlua1wiKVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSk7IH0pO1xuXG4gICAgICAgICAgdmFyIG5vZGUgPSBjb250YWluZXIuc2VsZWN0QWxsKFwiLm5vZGVcIilcbiAgICAgICAgICAgICAgICAuZGF0YShkYXRhLm5vZGVzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibnYtZm9yY2Utbm9kZVwiKVxuICAgICAgICAgICAgICAgIC5jYWxsKGZvcmNlLmRyYWcpO1xuXG4gICAgICAgICAgbm9kZVxuICAgICAgICAgICAgLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAgICAgLmF0dHIoXCJyXCIsIHJhZGl1cylcbiAgICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY29sb3IoZCkgfSApXG4gICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3QoJy5udi1zZXJpZXMtJyArIGV2dC5zZXJpZXNJbmRleCArICcgLm52LWRpc3R4LScgKyBldnQucG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGV2dC5weSk7XG4gICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3QoJy5udi1zZXJpZXMtJyArIGV2dC5zZXJpZXNJbmRleCArICcgLm52LWRpc3R5LScgKyBldnQucG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsIGV2dC5weCk7XG5cbiAgICAgICAgICAgICAgLy8gQWRkICdzZXJpZXMnIG9iamVjdCB0b1xuICAgICAgICAgICAgICB2YXIgbm9kZUNvbG9yID0gY29sb3IoZXZ0KTtcbiAgICAgICAgICAgICAgZXZ0LnNlcmllcyA9IFtdO1xuICAgICAgICAgICAgICBub2RlRmllbGRTZXQuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgICAgICAgIGV2dC5zZXJpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBjb2xvcjogbm9kZUNvbG9yLFxuICAgICAgICAgICAgICAgICAga2V5OiAgIGZpZWxkLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IGV2dFtmaWVsZF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRvb2x0aXAuZGF0YShldnQpLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwibW91c2VvdXRcIiwgIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRvb2x0aXAuaGVhZGVyRm9ybWF0dGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gXCJOb2RlXCI7fSk7XG5cbiAgICAgICAgICAvLyBBcHBseSBleHRyYSBhdHRyaWJ1dGVzIHRvIG5vZGVzIGFuZCBsaW5rcyAoaWYgYW55KVxuICAgICAgICAgIGxpbmtFeHRyYXMobGluayk7XG4gICAgICAgICAgbm9kZUV4dHJhcyhub2RlKTtcblxuICAgICAgICAgIGZvcmNlLm9uKFwidGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgbGluay5hdHRyKFwieDFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2UueDsgfSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zb3VyY2UueTsgfSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwieDJcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50YXJnZXQueDsgfSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwieTJcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50YXJnZXQueTsgfSk7XG5cbiAgICAgICAgICAgICAgbm9kZS5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBkLnggKyBcIiwgXCIgKyBkLnkgKyBcIilcIjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG5cbiAgICAgICAgLy8gRm9yY2UgZGlyZWN0ZWQgZ3JhcGggc3BlY2lmaWMgcGFyYW1ldGVyc1xuICAgICAgICBsaW5rU3RyZW5ndGg6e2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGlua1N0cmVuZ3RoO30sIHNldDogZnVuY3Rpb24oXyl7bGlua1N0cmVuZ3RoPV87fX0sXG4gICAgICAgIGZyaWN0aW9uOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmcmljdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZyaWN0aW9uPV87fX0sXG4gICAgICAgIGxpbmtEaXN0OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5rRGlzdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xpbmtEaXN0PV87fX0sXG4gICAgICAgIGNoYXJnZTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjaGFyZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjaGFyZ2U9Xzt9fSxcbiAgICAgICAgZ3Jhdml0eTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdyYXZpdHk7fSwgc2V0OiBmdW5jdGlvbihfKXtncmF2aXR5PV87fX0sXG4gICAgICAgIHRoZXRhOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB0aGV0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3RoZXRhPV87fX0sXG4gICAgICAgIGFscGhhOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBhbHBoYTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2FscGhhPV87fX0sXG4gICAgICAgIHJhZGl1czogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByYWRpdXM7fSwgc2V0OiBmdW5jdGlvbihfKXtyYWRpdXM9Xzt9fSxcblxuICAgICAgICAvL2Z1bmN0b3Igb3B0aW9uc1xuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1kMy5mdW5jdG9yKF8pO319LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1kMy5mdW5jdG9yKF8pO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIG5vZGVFeHRyYXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vZGVFeHRyYXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG5vZGVFeHRyYXMgPSBfO1xuICAgICAgICB9fSxcbiAgICAgICAgbGlua0V4dHJhczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGlua0V4dHJhczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbGlua0V4dHJhcyA9IF87XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLmZ1cmlvdXNMZWdlbmQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDUsIHJpZ2h0OiAwLCBib3R0b206IDUsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA0MDBcbiAgICAgICAgLCBoZWlnaHQgPSAyMFxuICAgICAgICAsIGdldEtleSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5IH1cbiAgICAgICAgLCBrZXlGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZCB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcigpXG4gICAgICAgICwgbWF4S2V5TGVuZ3RoID0gMjAgLy9kZWZhdWx0IHZhbHVlIGZvciBrZXkgbGVuZ3Roc1xuICAgICAgICAsIGFsaWduID0gdHJ1ZVxuICAgICAgICAsIHBhZGRpbmcgPSAyOCAvL2RlZmluZSBob3cgbXVjaCBzcGFjZSBiZXR3ZWVuIGxlZ2VuZCBpdGVtcy4gLSByZWNvbW1lbmQgMzIgZm9yIGZ1cmlvdXMgdmVyc2lvblxuICAgICAgICAsIHJpZ2h0QWxpZ24gPSB0cnVlXG4gICAgICAgICwgdXBkYXRlU3RhdGUgPSB0cnVlICAgLy9JZiB0cnVlLCBsZWdlbmQgd2lsbCB1cGRhdGUgZGF0YS5kaXNhYmxlZCBhbmQgdHJpZ2dlciBhICdzdGF0ZUNoYW5nZScgZGlzcGF0Y2guXG4gICAgICAgICwgcmFkaW9CdXR0b25Nb2RlID0gZmFsc2UgICAvL0lmIHRydWUsIGNsaWNraW5nIGxlZ2VuZCBpdGVtcyB3aWxsIGNhdXNlIGl0IHRvIGJlaGF2ZSBsaWtlIGEgcmFkaW8gYnV0dG9uLiAob25seSBvbmUgY2FuIGJlIHNlbGVjdGVkIGF0IGEgdGltZSlcbiAgICAgICAgLCBleHBhbmRlZCA9IGZhbHNlXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnbGVnZW5kQ2xpY2snLCAnbGVnZW5kRGJsY2xpY2snLCAnbGVnZW5kTW91c2VvdmVyJywgJ2xlZ2VuZE1vdXNlb3V0JywgJ3N0YXRlQ2hhbmdlJylcbiAgICAgICAgLCB2ZXJzID0gJ2NsYXNzaWMnIC8vT3B0aW9ucyBhcmUgXCJjbGFzc2ljXCIgYW5kIFwiZnVyaW91c1wiXG4gICAgICAgIDtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi1sZWdlbmQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtbGVnZW5kJykuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIHNlcmllcyA9IGcuc2VsZWN0QWxsKCcubnYtc2VyaWVzJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHZlcnMgIT0gJ2Z1cmlvdXMnKSByZXR1cm4gZDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZGVkID8gdHJ1ZSA6ICFuLmRpc2VuZ2FnZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNlcmllc0VudGVyID0gc2VyaWVzLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2VyaWVzJylcblxuICAgICAgICAgICAgdmFyIHNlcmllc1NoYXBlO1xuXG4gICAgICAgICAgICBpZih2ZXJzID09ICdjbGFzc2ljJykge1xuICAgICAgICAgICAgICAgIHNlcmllc0VudGVyLmFwcGVuZCgnY2lyY2xlJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCdudi1sZWdlbmQtc3ltYm9sJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCA1KTtcblxuICAgICAgICAgICAgICAgIHNlcmllc1NoYXBlID0gc2VyaWVzLnNlbGVjdCgnY2lyY2xlJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZlcnMgPT0gJ2Z1cmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzRW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCAyKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCdudi1sZWdlbmQtc3ltYm9sJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgMylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J5JywgMyk7XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNTaGFwZSA9IHNlcmllcy5zZWxlY3QoJ3JlY3QnKTtcblxuICAgICAgICAgICAgICAgIHNlcmllc0VudGVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1jaGVjay1ib3gnKVxuICAgICAgICAgICAgICAgICAgICAucHJvcGVydHkoJ2lubmVySFRNTCcsJzxwYXRoIGQ9XCJNMC41LDUgTDIyLjUsNSBMMjIuNSwyNi41IEwwLjUsMjYuNSBMMC41LDUgWlwiIGNsYXNzPVwibnYtYm94XCI+PC9wYXRoPjxwYXRoIGQ9XCJNNS41LDEyLjg2MTg0NjcgTDExLjkxODUwODksMTkuMjgwMzU1NiBMMzEsMC4xOTg4NjQ1MTFcIiBjbGFzcz1cIm52LWNoZWNrXCI+PC9wYXRoPicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC0xMCwtOClzY2FsZSgwLjUpJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzQ2hlY2tib3ggPSBzZXJpZXMuc2VsZWN0KCcubnYtY2hlY2stYm94Jyk7XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNDaGVja2JveC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBzZXRUZXh0Q29sb3IoZCxpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlcmllc0VudGVyLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCdudi1sZWdlbmQtdGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAnOCcpO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzVGV4dCA9IHNlcmllcy5zZWxlY3QoJ3RleHQubnYtbGVnZW5kLXRleHQnKTtcblxuICAgICAgICAgICAgc2VyaWVzXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kTW91c2VvdmVyKGQsaSk7ICAvL1RPRE86IE1ha2UgY29uc2lzdGVudCB3aXRoIG90aGVyIGV2ZW50IG9iamVjdHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kTW91c2VvdXQoZCxpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kQ2xpY2soZCxpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJlLWdldCBkYXRhIGluIGNhc2UgaXQgd2FzIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJzID09J2NsYXNzaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvQnV0dG9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1JhZGlvIGJ1dHRvbiBtb2RlOiBzZXQgZXZlcnkgc2VyaWVzIHRvIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgYW5kIGVuYWJsZSB0aGUgY2xpY2tlZCBzZXJpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHsgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmV2ZXJ5KGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgTlZEMyBsZWdlbmRzIGlzLCBpZiBldmVyeSBzaW5nbGUgc2VyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBkaXNhYmxlZCwgdHVybiBhbGwgc2VyaWVzJyBiYWNrIG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcykgeyBzZXJpZXMuZGlzYWJsZWQgPSBmYWxzZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHZlcnMgPT0gJ2Z1cmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNlbmdhZ2VkID0gIWQuZGlzZW5nYWdlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC51c2VyRGlzYWJsZWQgPSBkLnVzZXJEaXNhYmxlZCA9PSB1bmRlZmluZWQgPyAhIWQuZGlzYWJsZWQgOiBkLnVzZXJEaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGQuZGlzZW5nYWdlZCB8fCBkLnVzZXJEaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQudXNlckRpc2FibGVkID0gZC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZ2FnZWQgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNlbmdhZ2VkOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2FnZWQuZXZlcnkoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMudXNlckRpc2FibGVkIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcyBpcywgaWYgZXZlcnkgc2luZ2xlIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZGlzYWJsZWQsIHR1cm4gYWxsIHNlcmllcycgYmFjayBvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBzZXJpZXMudXNlckRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2VuZ2FnZWQ6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNlbmdhZ2VkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHZlcnMgPT0gJ2Z1cmlvdXMnICYmIGV4cGFuZGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZERibGNsaWNrKGQsaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJlLWdldCBkYXRhIGluIGNhc2UgaXQgd2FzIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllcy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcywgd2hlbiBkb3VibGUgY2xpY2tpbmcgb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdG8gc2V0IGFsbCBvdGhlciBzZXJpZXMnIHRvIGZhbHNlLCBhbmQgbWFrZSB0aGUgZG91YmxlIGNsaWNrZWQgc2VyaWVzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJzID09ICdmdXJpb3VzJykgc2VyaWVzLnVzZXJEaXNhYmxlZCA9IHNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmVycyA9PSAnZnVyaW91cycpIGQudXNlckRpc2FibGVkID0gZC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXJpZXMuY2xhc3NlZCgnbnYtZGlzYWJsZWQnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnVzZXJEaXNhYmxlZCB9KTtcbiAgICAgICAgICAgIHNlcmllcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHNlcmllc1RleHRcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIHNldFRleHRDb2xvcilcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgeyByZXR1cm4ga2V5Rm9ybWF0dGVyKGdldEtleShkKSkgfSk7XG5cbiAgICAgICAgICAgIC8vVE9ETzogaW1wbGVtZW50IGZpeGVkLXdpZHRoIGFuZCBtYXgtd2lkdGggb3B0aW9ucyAobWF4LXdpZHRoIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdpdGggdGhlIGFsaWduIG9wdGlvbilcbiAgICAgICAgICAgIC8vIE5FVyBBTElHTklORyBDT0RFLCBUT0RPOiBjbGVhbiB1cFxuXG4gICAgICAgICAgICB2YXIgdmVyc1BhZGRpbmc7XG4gICAgICAgICAgICBzd2l0Y2godmVycykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1cmlvdXMnIDpcbiAgICAgICAgICAgICAgICAgICAgdmVyc1BhZGRpbmcgPSAyMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhc3NpYycgOlxuICAgICAgICAgICAgICAgICAgICB2ZXJzUGFkZGluZyA9IDIwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxpZ24pIHtcblxuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNXaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICBzZXJpZXMuZWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXlGb3JtYXR0ZXIoZ2V0S2V5KGQpKSAmJiBrZXlGb3JtYXR0ZXIoZ2V0S2V5KGQpKS5sZW5ndGggPiBtYXhLZXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cmltbWVkS2V5ID0ga2V5Rm9ybWF0dGVyKGdldEtleShkKSkuc3Vic3RyaW5nKDAsIG1heEtleUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmRUZXh0ID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgndGV4dCcpLnRleHQodHJpbW1lZEtleSArIFwiLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmFwcGVuZChcInN2Zzp0aXRsZVwiKS50ZXh0KGtleUZvcm1hdHRlcihnZXRLZXkoZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZFRleHQgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGVUZXh0TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRleHRMZW5ndGggPSBsZWdlbmRUZXh0Lm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsZWdlbmRUZXh0IGlzIGRpc3BsYXk6bm9uZSdkIChub2RlVGV4dExlbmd0aCA9PSAwKSwgc2ltdWxhdGUgYW4gZXJyb3Igc28gd2UgYXBwcm94aW1hdGUsIGluc3RlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGVUZXh0TGVuZ3RoIDw9IDApIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVRleHRMZW5ndGggPSBudi51dGlscy5jYWxjQXBwcm94VGV4dFdpZHRoKGxlZ2VuZFRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzV2lkdGhzLnB1c2gobm9kZVRleHRMZW5ndGggKyBwYWRkaW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBzZXJpZXNQZXJSb3cgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbldpZHRocyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBsZWdlbmRXaWR0aCA8IGF2YWlsYWJsZVdpZHRoICYmIHNlcmllc1BlclJvdyA8IHNlcmllc1dpZHRocy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uV2lkdGhzW3Nlcmllc1BlclJvd10gPSBzZXJpZXNXaWR0aHNbc2VyaWVzUGVyUm93XTtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kV2lkdGggKz0gc2VyaWVzV2lkdGhzW3Nlcmllc1BlclJvdysrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcmllc1BlclJvdyA9PT0gMCkgc2VyaWVzUGVyUm93ID0gMTsgLy9taW5pbXVtIG9mIG9uZSBzZXJpZXMgcGVyIHJvd1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKCBsZWdlbmRXaWR0aCA+IGF2YWlsYWJsZVdpZHRoICYmIHNlcmllc1BlclJvdyA+IDEgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXNQZXJSb3ctLTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlcmllc1dpZHRocy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllc1dpZHRoc1trXSA+IChjb2x1bW5XaWR0aHNbayAlIHNlcmllc1BlclJvd10gfHwgMCkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoc1trICUgc2VyaWVzUGVyUm93XSA9IHNlcmllc1dpZHRoc1trXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gY29sdW1uV2lkdGhzLnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIsIGluZGV4LCBhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgKyBjdXI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB4UG9zaXRpb25zID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGN1clggPSAwOyBpIDwgc2VyaWVzUGVyUm93OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgeFBvc2l0aW9uc1tpXSA9IGN1clg7XG4gICAgICAgICAgICAgICAgICAgIGN1clggKz0gY29sdW1uV2lkdGhzW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhQb3NpdGlvbnNbaSAlIHNlcmllc1BlclJvd10gKyAnLCcgKyAoNSArIE1hdGguZmxvb3IoaSAvIHNlcmllc1BlclJvdykgKiB2ZXJzUGFkZGluZykgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9wb3NpdGlvbiBsZWdlbmQgYXMgZmFyIHJpZ2h0IGFzIHBvc3NpYmxlIHdpdGhpbiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBbGlnbikge1xuICAgICAgICAgICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh3aWR0aCAtIG1hcmdpbi5yaWdodCAtIGxlZ2VuZFdpZHRoKSArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAnICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20gKyAoTWF0aC5jZWlsKHNlcmllc1dpZHRocy5sZW5ndGggLyBzZXJpZXNQZXJSb3cpICogdmVyc1BhZGRpbmcpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIHlwb3MgPSA1LFxuICAgICAgICAgICAgICAgICAgICBuZXd4cG9zID0gNSxcbiAgICAgICAgICAgICAgICAgICAgbWF4d2lkdGggPSAwLFxuICAgICAgICAgICAgICAgICAgICB4cG9zO1xuICAgICAgICAgICAgICAgIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKS5ub2RlKCkuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgeHBvcyA9IG5ld3hwb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aCA8IG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0ICsgeHBvcyArIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3hwb3MgPSB4cG9zID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5cG9zICs9IHZlcnNQYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXd4cG9zICs9IGxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXd4cG9zID4gbWF4d2lkdGgpIG1heHdpZHRoID0gbmV3eHBvcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhwb3MgKyAnLCcgKyB5cG9zICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vcG9zaXRpb24gbGVnZW5kIGFzIGZhciByaWdodCBhcyBwb3NzaWJsZSB3aXRoaW4gdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAod2lkdGggLSBtYXJnaW4ucmlnaHQgLSBtYXh3aWR0aCkgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgICAgIGhlaWdodCA9IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgeXBvcyArIDE1O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih2ZXJzID09ICdmdXJpb3VzJykge1xuICAgICAgICAgICAgICAgIC8vIFNpemUgcmVjdGFuZ2xlcyBhZnRlciB0ZXh0IGlzIHBsYWNlZFxuICAgICAgICAgICAgICAgIHNlcmllc1NoYXBlXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllc1RleHRbMF1baV0uZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgKyAyNztcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDE4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIC05KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIC0xNSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VyaWVzU2hhcGVcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBzZXRCR0NvbG9yKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRUZXh0Q29sb3IoZCxpKSB7XG4gICAgICAgICAgICBpZih2ZXJzICE9ICdmdXJpb3VzJykgcmV0dXJuICcjMDAwJztcbiAgICAgICAgICAgIGlmKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuZGlzZW5nYWdlZCA/IGNvbG9yKGQsaSkgOiAnI2ZmZic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWQuZGlzYWJsZWQgPyBjb2xvcihkLGkpIDogJyNmZmYnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0QkdDb2xvcihkLGkpIHtcbiAgICAgICAgICAgIGlmKGV4cGFuZGVkICYmIHZlcnMgPT0gJ2Z1cmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQuZGlzZW5nYWdlZCA/ICcjZmZmJyA6IGNvbG9yKGQsaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWQuZGlzYWJsZWQgPyAnI2ZmZicgOiBjb2xvcihkLGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGtleTogICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRLZXk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRLZXk9Xzt9fSxcbiAgICAgICAga2V5Rm9ybWF0dGVyOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGtleUZvcm1hdHRlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2tleUZvcm1hdHRlcj1fO319LFxuICAgICAgICBhbGlnbjogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYWxpZ247fSwgc2V0OiBmdW5jdGlvbihfKXthbGlnbj1fO319LFxuICAgICAgICByaWdodEFsaWduOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JpZ2h0QWxpZ249Xzt9fSxcbiAgICAgICAgbWF4S2V5TGVuZ3RoOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1heEtleUxlbmd0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe21heEtleUxlbmd0aD1fO319LFxuICAgICAgICBwYWRkaW5nOiAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcGFkZGluZzt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZGRpbmc9Xzt9fSxcbiAgICAgICAgdXBkYXRlU3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVwZGF0ZVN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7dXBkYXRlU3RhdGU9Xzt9fSxcbiAgICAgICAgcmFkaW9CdXR0b25Nb2RlOntnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJhZGlvQnV0dG9uTW9kZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3JhZGlvQnV0dG9uTW9kZT1fO319LFxuICAgICAgICBleHBhbmRlZDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZXhwYW5kZWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtleHBhbmRlZD1fO319LFxuICAgICAgICB2ZXJzOiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdmVyczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3ZlcnM9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuLy9UT0RPOiBjb25zaWRlciBkZXByZWNhdGluZyBhbmQgdXNpbmcgbXVsdGliYXIgd2l0aCBzaW5nbGUgc2VyaWVzIGZvciB0aGlzXG5udi5tb2RlbHMuaGlzdG9yaWNhbEJhciA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgLy9DcmVhdGUgc2VtaS11bmlxdWUgSUQgaW4gY2FzZSB1c2VyIGRvZXNuJ3Qgc2VsZWN0IG9uZVxuICAgICAgICAsIGNvbnRhaW5lciA9IG51bGxcbiAgICAgICAgLCB4ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBmb3JjZVggPSBbXVxuICAgICAgICAsIGZvcmNlWSA9IFswXVxuICAgICAgICAsIHBhZERhdGEgPSBmYWxzZVxuICAgICAgICAsIGNsaXBFZGdlID0gdHJ1ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdlbGVtZW50TW91c2Vtb3ZlJywgJ3JlbmRlckVuZCcpXG4gICAgICAgICwgaW50ZXJhY3RpdmUgPSB0cnVlXG4gICAgICAgIDtcblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCAwKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuXG4gICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBudi51dGlscy5hdmFpbGFibGVXaWR0aCh3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHguZG9tYWluKHhEb21haW4gfHwgZDMuZXh0ZW50KGRhdGFbMF0udmFsdWVzLm1hcChnZXRYKS5jb25jYXQoZm9yY2VYKSApKTtcblxuICAgICAgICAgICAgaWYgKHBhZERhdGEpXG4gICAgICAgICAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgW2F2YWlsYWJsZVdpZHRoICogLjUgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgsIGF2YWlsYWJsZVdpZHRoICogKGRhdGFbMF0udmFsdWVzLmxlbmd0aCAtIC41KSAgLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGggXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgeC5yYW5nZSh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGRhdGFbMF0udmFsdWVzLm1hcChnZXRZKS5jb25jYXQoZm9yY2VZKSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIGlmICh4LmRvbWFpbigpWzBdID09PSB4LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHguZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB4LmRvbWFpbihbeC5kb21haW4oKVswXSAtIHguZG9tYWluKClbMF0gKiAwLjAxLCB4LmRvbWFpbigpWzFdICsgeC5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHguZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIGlmICh5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdKVxuICAgICAgICAgICAgICAgIHkuZG9tYWluKClbMF0gP1xuICAgICAgICAgICAgICAgICAgICB5LmRvbWFpbihbeS5kb21haW4oKVswXSArIHkuZG9tYWluKClbMF0gKiAwLjAxLCB5LmRvbWFpbigpWzFdIC0geS5kb21haW4oKVsxXSAqIDAuMDFdKVxuICAgICAgICAgICAgICAgICAgICA6IHkuZG9tYWluKFstMSwxXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1oaXN0b3JpY2FsQmFyLScgKyBpZCkuZGF0YShbZGF0YVswXS52YWx1ZXNdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWhpc3RvcmljYWxCYXItJyArIGlkKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFycycpO1xuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBjb250YWluZXJcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmNoYXJ0Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJyNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgZy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWNoYXJ0LWNsaXAtcGF0aC0nICsgaWQgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzID0gd3JhcC5zZWxlY3QoJy5udi1iYXJzJykuc2VsZWN0QWxsKCcubnYtYmFyJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQsaSkge3JldHVybiBnZXRYKGQsaSl9KTtcbiAgICAgICAgICAgIGJhcnMuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBiYXJzLmVudGVyKCkuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIDAgKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7ICByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHkoTWF0aC5tYXgoMCwgZ2V0WShkLGkpKSkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4KGdldFgoZCxpKSkgLSBhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAqIC40NSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnRlcmFjdGl2ZSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZScpICsgJyBudi1iYXItJyArIGogKyAnLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2JhcnMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArICh4KGdldFgoZCxpKSkgLSBhdmFpbGFibGVXaWR0aCAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCAqIC40NSkgKyAnLDApJzsgfSlcbiAgICAgICAgICAgICAgICAvL1RPRE86IGJldHRlciB3aWR0aCBjYWxjdWxhdGlvbnMgdGhhdCBkb24ndCBhc3N1bWUgYWx3YXlzIHVuaWZvcm0gZGF0YSBzcGFjaW5nO3dcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAoYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICogLjkgKTtcblxuICAgICAgICAgICAgYmFycy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdiYXJzJylcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnZhbCA9IGdldFkoZCxpKSA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIHkoZ2V0WShkLGkpKSA8IDEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSAtIDEgOlxuICAgICAgICAgICAgICAgICAgICAgICAgeShnZXRZKGQsaSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHJ2YWwpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKE1hdGgubWF4KE1hdGguYWJzKHkoZ2V0WShkLGkpKSAtIHkoMCkpLDEpKSB9KTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hpc3RvcmljYWxCYXIgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvL0NyZWF0ZSBtZXRob2RzIHRvIGFsbG93IG91dHNpZGUgZnVuY3Rpb25zIHRvIGhpZ2hsaWdodCBhIHNwZWNpZmljIGJhci5cbiAgICBjaGFydC5oaWdobGlnaHRQb2ludCA9IGZ1bmN0aW9uKHBvaW50SW5kZXgsIGlzSG92ZXJPdmVyKSB7XG4gICAgICAgIGNvbnRhaW5lclxuICAgICAgICAgICAgLnNlbGVjdChcIi5udi1iYXJzIC5udi1iYXItMC1cIiArIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGlzSG92ZXJPdmVyKVxuICAgICAgICA7XG4gICAgfTtcblxuICAgIGNoYXJ0LmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250YWluZXJcbiAgICAgICAgICAgIC5zZWxlY3QoXCIubnYtYmFycyAubnYtYmFyLmhvdmVyXCIpXG4gICAgICAgICAgICAuY2xhc3NlZChcImhvdmVyXCIsIGZhbHNlKVxuICAgICAgICA7XG4gICAgfTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBmb3JjZVg6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVg7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVg9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VZPV87fX0sXG4gICAgICAgIHBhZERhdGE6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZERhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtwYWREYXRhPV87fX0sXG4gICAgICAgIHg6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPV87fX0sXG4gICAgICAgIHk6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPV87fX0sXG4gICAgICAgIHhTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHg7fSwgc2V0OiBmdW5jdGlvbihfKXt4PV87fX0sXG4gICAgICAgIHlTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHhEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgY2xpcEVkZ2U6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBFZGdlO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcEVkZ2U9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGludGVyYWN0aXZlO30sIHNldDogZnVuY3Rpb24oXyl7aW50ZXJhY3RpdmU9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuaGlzdG9yaWNhbEJhckNoYXJ0ID0gZnVuY3Rpb24oYmFyX21vZGVsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBiYXJzID0gYmFyX21vZGVsIHx8IG52Lm1vZGVscy5oaXN0b3JpY2FsQmFyKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBpbnRlcmFjdGl2ZUxheWVyID0gbnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUoKVxuICAgICAgICAsIHRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpXG4gICAgICAgIDtcblxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogOTAsIGJvdHRvbTogNTAsIGxlZnQ6IDkwfVxuICAgICAgICAsIG1hcmdpblRvcCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIHNob3dMZWdlbmQgPSBmYWxzZVxuICAgICAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAgICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgICAgICwgeFxuICAgICAgICAsIHlcbiAgICAgICAgLCBzdGF0ZSA9IHt9XG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIHRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MFxuICAgICAgICA7XG5cbiAgICB4QXhpcy5vcmllbnQoJ2JvdHRvbScpLnRpY2tQYWRkaW5nKDcpO1xuICAgIHlBeGlzLm9yaWVudCggKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICB0b29sdGlwXG4gICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAuaGVhZGVyRW5hYmxlZChmYWxzZSlcbiAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5oZWFkZXJGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSk7XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIDApO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoYmFycyk7XG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHsgY29udGFpbmVyLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pLmNhbGwoY2hhcnQpIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvL3NldCBzdGF0ZS5kaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBiYXJzLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IGJhcnMueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1oaXN0b3JpY2FsQmFyQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1oaXN0b3JpY2FsQmFyQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKCFzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJykuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWFyZ2luVG9wICYmIGxlZ2VuZC5oZWlnaHQoKSAhPT0gbWFyZ2luLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9TZXQgdXAgaW50ZXJhY3RpdmUgbGF5ZXJcbiAgICAgICAgICAgIGlmICh1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSkge1xuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLm1hcmdpbih7bGVmdDptYXJnaW4ubGVmdCwgdG9wOm1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuc3ZnQ29udGFpbmVyKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnhTY2FsZSh4KTtcbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdChcIi5udi1pbnRlcmFjdGl2ZVwiKS5jYWxsKGludGVyYWN0aXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNXcmFwID0gZy5zZWxlY3QoJy5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKTtcbiAgICAgICAgICAgIGJhcnNXcmFwLnRyYW5zaXRpb24oKS5jYWxsKGJhcnMpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC5fdGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgeUF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC5fdGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgYmFycy5jbGVhckhpZ2hsaWdodHMoKTtcblxuICAgICAgICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4ID0gbnYuaW50ZXJhY3RpdmVCaXNlY3Qoc2VyaWVzLnZhbHVlcywgZS5wb2ludFhWYWx1ZSwgY2hhcnQueCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcnMuaGlnaGxpZ2h0UG9pbnQocG9pbnRJbmRleCx0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZVBvaW50ID09PSB1bmRlZmluZWQpIHNpbmdsZVBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRYTG9jYXRpb24gPT09IHVuZGVmaW5lZCkgcG9pbnRYTG9jYXRpb24gPSBjaGFydC54U2NhbGUoKShjaGFydC54KCkocG9pbnQscG9pbnRJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yKHNlcmllcyxzZXJpZXMuc2VyaWVzSW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciB4VmFsdWUgPSB4QXhpcy50aWNrRm9ybWF0KCkoY2hhcnQueCgpKHNpbmdsZVBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBwb2ludEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBhbGxEYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnJlbmRlckd1aWRlTGluZShwb2ludFhMb2NhdGlvbik7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKFwiZWxlbWVudE1vdXNlb3V0XCIsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnRvb2x0aXBIaWRlKCk7XG4gICAgICAgICAgICAgICAgYmFycy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9ICFkLmRpc2FibGVkO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3RBbGwoJy5udi1zZXJpZXMnKS5jbGFzc2VkKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignbGVnZW5kRGJsY2xpY2snLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgLy9Eb3VibGUgY2xpY2tpbmcgc2hvdWxkIGFsd2F5cyBlbmFibGUgY3VycmVudCBzZXJpZXMsIGFuZCBkaXNhYmxlZCBhbGwgb3RoZXJzLlxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2hpc3RvcmljYWxCYXJDaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgZXZ0WydzZXJpZXMnXSA9IHtcbiAgICAgICAgICAgIGtleTogY2hhcnQueCgpKGV2dC5kYXRhKSxcbiAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkoZXZ0LmRhdGEpLFxuICAgICAgICAgICAgY29sb3I6IGV2dC5jb2xvclxuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgYmFycy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2Vtb3ZlLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdG9vbHRpcCgpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuYmFycyA9IGJhcnM7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyID0gaW50ZXJhY3RpdmVMYXllcjtcbiAgICBjaGFydC50b29sdGlwID0gdG9vbHRpcDtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHNob3dYQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gXy50b3A7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gXy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIGJhcnMuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uPV87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICAgICAgeUF4aXMuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICByaWdodEFsaWduWUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ25ZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICAgICAgICAgIHlBeGlzLm9yaWVudCggKF8pID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH19LFxuICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gXztcbiAgICAgICAgICAgIGlmIChfID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2hhcnQuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIGJhcnMpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cblxuLy8gb2hsY0NoYXJ0IGlzIGp1c3QgYSBoaXN0b3JpY2FsIGNoYXJ0IHdpdGggb2hsYyBiYXJzIGFuZCBzb21lIHR3ZWFrc1xubnYubW9kZWxzLm9obGNCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFydCA9IG52Lm1vZGVscy5oaXN0b3JpY2FsQmFyQ2hhcnQobnYubW9kZWxzLm9obGNCYXIoKSk7XG5cbiAgICAvLyBzcGVjaWFsIGRlZmF1bHQgdG9vbHRpcCBzaW5jZSB3ZSBzaG93IG11bHRpcGxlIHZhbHVlcyBwZXIgeFxuICAgIGNoYXJ0LnVzZUludGVyYWN0aXZlR3VpZGVsaW5lKHRydWUpO1xuICAgIGNoYXJ0LmludGVyYWN0aXZlTGF5ZXIudG9vbHRpcC5jb250ZW50R2VuZXJhdG9yKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gd2UgYXNzdW1lIG9ubHkgb25lIHNlcmllcyBleGlzdHMgZm9yIHRoaXMgY2hhcnRcbiAgICAgICAgdmFyIGQgPSBkYXRhLnNlcmllc1swXS5kYXRhO1xuICAgICAgICAvLyBtYXRjaCBsaW5lIGNvbG9ycyBhcyBkZWZpbmVkIGluIG52LmQzLmNzc1xuICAgICAgICB2YXIgY29sb3IgPSBkLm9wZW4gPCBkLmNsb3NlID8gXCIyY2EwMmNcIiA6IFwiZDYyNzI4XCI7XG4gICAgICAgIHJldHVybiAnJyArXG4gICAgICAgICAgICAnPGgzIHN0eWxlPVwiY29sb3I6ICMnICsgY29sb3IgKyAnXCI+JyArIGRhdGEudmFsdWUgKyAnPC9oMz4nICtcbiAgICAgICAgICAgICc8dGFibGU+JyArXG4gICAgICAgICAgICAnPHRyPjx0ZD5vcGVuOjwvdGQ+PHRkPicgKyBjaGFydC55QXhpcy50aWNrRm9ybWF0KCkoZC5vcGVuKSArICc8L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPjx0ZD5jbG9zZTo8L3RkPjx0ZD4nICsgY2hhcnQueUF4aXMudGlja0Zvcm1hdCgpKGQuY2xvc2UpICsgJzwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICc8dHI+PHRkPmhpZ2g8L3RkPjx0ZD4nICsgY2hhcnQueUF4aXMudGlja0Zvcm1hdCgpKGQuaGlnaCkgKyAnPC90ZD48L3RyPicgK1xuICAgICAgICAgICAgJzx0cj48dGQ+bG93OjwvdGQ+PHRkPicgKyBjaGFydC55QXhpcy50aWNrRm9ybWF0KCkoZC5sb3cpICsgJzwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICc8L3RhYmxlPic7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxuLy8gY2FuZGxlc3RpY2tDaGFydCBpcyBqdXN0IGEgaGlzdG9yaWNhbCBjaGFydCB3aXRoIGNhbmRsZXN0aWNrIGJhcnMgYW5kIHNvbWUgdHdlYWtzXG5udi5tb2RlbHMuY2FuZGxlc3RpY2tCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGFydCA9IG52Lm1vZGVscy5oaXN0b3JpY2FsQmFyQ2hhcnQobnYubW9kZWxzLmNhbmRsZXN0aWNrQmFyKCkpO1xuXG4gICAgLy8gc3BlY2lhbCBkZWZhdWx0IHRvb2x0aXAgc2luY2Ugd2Ugc2hvdyBtdWx0aXBsZSB2YWx1ZXMgcGVyIHhcbiAgICBjaGFydC51c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSh0cnVlKTtcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXAuY29udGVudEdlbmVyYXRvcihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFzc3VtZSBvbmx5IG9uZSBzZXJpZXMgZXhpc3RzIGZvciB0aGlzIGNoYXJ0XG4gICAgICAgIHZhciBkID0gZGF0YS5zZXJpZXNbMF0uZGF0YTtcbiAgICAgICAgLy8gbWF0Y2ggbGluZSBjb2xvcnMgYXMgZGVmaW5lZCBpbiBudi5kMy5jc3NcbiAgICAgICAgdmFyIGNvbG9yID0gZC5vcGVuIDwgZC5jbG9zZSA/IFwiMmNhMDJjXCIgOiBcImQ2MjcyOFwiO1xuICAgICAgICByZXR1cm4gJycgK1xuICAgICAgICAgICAgJzxoMyBzdHlsZT1cImNvbG9yOiAjJyArIGNvbG9yICsgJ1wiPicgKyBkYXRhLnZhbHVlICsgJzwvaDM+JyArXG4gICAgICAgICAgICAnPHRhYmxlPicgK1xuICAgICAgICAgICAgJzx0cj48dGQ+b3Blbjo8L3RkPjx0ZD4nICsgY2hhcnQueUF4aXMudGlja0Zvcm1hdCgpKGQub3BlbikgKyAnPC90ZD48L3RyPicgK1xuICAgICAgICAgICAgJzx0cj48dGQ+Y2xvc2U6PC90ZD48dGQ+JyArIGNoYXJ0LnlBeGlzLnRpY2tGb3JtYXQoKShkLmNsb3NlKSArICc8L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAnPHRyPjx0ZD5oaWdoPC90ZD48dGQ+JyArIGNoYXJ0LnlBeGlzLnRpY2tGb3JtYXQoKShkLmhpZ2gpICsgJzwvdGQ+PC90cj4nICtcbiAgICAgICAgICAgICc8dHI+PHRkPmxvdzo8L3RkPjx0ZD4nICsgY2hhcnQueUF4aXMudGlja0Zvcm1hdCgpKGQubG93KSArICc8L3RkPjwvdHI+JyArXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xuICAgIH0pO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubGVnZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiA1LCByaWdodDogMCwgYm90dG9tOiA1LCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gNDAwXG4gICAgICAgICwgaGVpZ2h0ID0gMjBcbiAgICAgICAgLCBnZXRLZXkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9XG4gICAgICAgICwga2V5Rm9ybWF0dGVyID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQgfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoKVxuICAgICAgICAsIG1heEtleUxlbmd0aCA9IDIwIC8vZGVmYXVsdCB2YWx1ZSBmb3Iga2V5IGxlbmd0aHNcbiAgICAgICAgLCBhbGlnbiA9IHRydWVcbiAgICAgICAgLCBwYWRkaW5nID0gMzIgLy9kZWZpbmUgaG93IG11Y2ggc3BhY2UgYmV0d2VlbiBsZWdlbmQgaXRlbXMuIC0gcmVjb21tZW5kIDMyIGZvciBmdXJpb3VzIHZlcnNpb25cbiAgICAgICAgLCByaWdodEFsaWduID0gdHJ1ZVxuICAgICAgICAsIHVwZGF0ZVN0YXRlID0gdHJ1ZSAgIC8vSWYgdHJ1ZSwgbGVnZW5kIHdpbGwgdXBkYXRlIGRhdGEuZGlzYWJsZWQgYW5kIHRyaWdnZXIgYSAnc3RhdGVDaGFuZ2UnIGRpc3BhdGNoLlxuICAgICAgICAsIHJhZGlvQnV0dG9uTW9kZSA9IGZhbHNlICAgLy9JZiB0cnVlLCBjbGlja2luZyBsZWdlbmQgaXRlbXMgd2lsbCBjYXVzZSBpdCB0byBiZWhhdmUgbGlrZSBhIHJhZGlvIGJ1dHRvbi4gKG9ubHkgb25lIGNhbiBiZSBzZWxlY3RlZCBhdCBhIHRpbWUpXG4gICAgICAgICwgZXhwYW5kZWQgPSBmYWxzZVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2xlZ2VuZENsaWNrJywgJ2xlZ2VuZERibGNsaWNrJywgJ2xlZ2VuZE1vdXNlb3ZlcicsICdsZWdlbmRNb3VzZW91dCcsICdzdGF0ZUNoYW5nZScpXG4gICAgICAgICwgdmVycyA9ICdjbGFzc2ljJyAvL09wdGlvbnMgYXJlIFwiY2xhc3NpY1wiIGFuZCBcImZ1cmlvdXNcIlxuICAgICAgICA7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtbGVnZW5kJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LWxlZ2VuZCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbilcbiAgICAgICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICgtIG1hcmdpbi5yaWdodCkgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXMgPSBnLnNlbGVjdEFsbCgnLm52LXNlcmllcycpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICBpZih2ZXJzICE9ICdmdXJpb3VzJykgcmV0dXJuIGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHBhbmRlZCA/IHRydWUgOiAhbi5kaXNlbmdhZ2VkO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHNlcmllc0VudGVyID0gc2VyaWVzLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2VyaWVzJyk7XG4gICAgICAgICAgICB2YXIgc2VyaWVzU2hhcGU7XG5cbiAgICAgICAgICAgIHZhciB2ZXJzUGFkZGluZztcbiAgICAgICAgICAgIHN3aXRjaCh2ZXJzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVyaW91cycgOlxuICAgICAgICAgICAgICAgICAgICB2ZXJzUGFkZGluZyA9IDIzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbGFzc2ljJyA6XG4gICAgICAgICAgICAgICAgICAgIHZlcnNQYWRkaW5nID0gMjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZlcnMgPT0gJ2NsYXNzaWMnKSB7XG4gICAgICAgICAgICAgICAgc2VyaWVzRW50ZXIuYXBwZW5kKCdjaXJjbGUnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIDIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ252LWxlZ2VuZC1zeW1ib2wnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncicsIDUpO1xuXG4gICAgICAgICAgICAgICAgc2VyaWVzU2hhcGUgPSBzZXJpZXMuc2VsZWN0KCcubnYtbGVnZW5kLXN5bWJvbCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2ZXJzID09ICdmdXJpb3VzJykge1xuICAgICAgICAgICAgICAgIHNlcmllc0VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLXdpZHRoJywgMilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywnbnYtbGVnZW5kLXN5bWJvbCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeCcsIDMpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeScsIDMpO1xuICAgICAgICAgICAgICAgIHNlcmllc1NoYXBlID0gc2VyaWVzLnNlbGVjdCgnLm52LWxlZ2VuZC1zeW1ib2wnKTtcblxuICAgICAgICAgICAgICAgIHNlcmllc0VudGVyLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1jaGVjay1ib3gnKVxuICAgICAgICAgICAgICAgICAgICAucHJvcGVydHkoJ2lubmVySFRNTCcsJzxwYXRoIGQ9XCJNMC41LDUgTDIyLjUsNSBMMjIuNSwyNi41IEwwLjUsMjYuNSBMMC41LDUgWlwiIGNsYXNzPVwibnYtYm94XCI+PC9wYXRoPjxwYXRoIGQ9XCJNNS41LDEyLjg2MTg0NjcgTDExLjkxODUwODksMTkuMjgwMzU1NiBMMzEsMC4xOTg4NjQ1MTFcIiBjbGFzcz1cIm52LWNoZWNrXCI+PC9wYXRoPicpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKC0xMCwtOClzY2FsZSgwLjUpJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzQ2hlY2tib3ggPSBzZXJpZXMuc2VsZWN0KCcubnYtY2hlY2stYm94Jyk7XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNDaGVja2JveC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdwYXRoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdHJva2UnLCBzZXRUZXh0Q29sb3IoZCxpKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlcmllc0VudGVyLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCdudi1sZWdlbmQtdGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAuYXR0cignZHgnLCAnOCcpO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzVGV4dCA9IHNlcmllcy5zZWxlY3QoJ3RleHQubnYtbGVnZW5kLXRleHQnKTtcblxuICAgICAgICAgICAgc2VyaWVzXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kTW91c2VvdmVyKGQsaSk7ICAvL1RPRE86IE1ha2UgY29uc2lzdGVudCB3aXRoIG90aGVyIGV2ZW50IG9iamVjdHNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kTW91c2VvdXQoZCxpKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gubGVnZW5kQ2xpY2soZCxpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJlLWdldCBkYXRhIGluIGNhc2UgaXQgd2FzIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2VyaWVzLmRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJzID09J2NsYXNzaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvQnV0dG9uTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1JhZGlvIGJ1dHRvbiBtb2RlOiBzZXQgZXZlcnkgc2VyaWVzIHRvIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgYW5kIGVuYWJsZSB0aGUgY2xpY2tlZCBzZXJpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHsgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmV2ZXJ5KGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgTlZEMyBsZWdlbmRzIGlzLCBpZiBldmVyeSBzaW5nbGUgc2VyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBkaXNhYmxlZCwgdHVybiBhbGwgc2VyaWVzJyBiYWNrIG9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcykgeyBzZXJpZXMuZGlzYWJsZWQgPSBmYWxzZX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHZlcnMgPT0gJ2Z1cmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNlbmdhZ2VkID0gIWQuZGlzZW5nYWdlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC51c2VyRGlzYWJsZWQgPSBkLnVzZXJEaXNhYmxlZCA9PSB1bmRlZmluZWQgPyAhIWQuZGlzYWJsZWQgOiBkLnVzZXJEaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGQuZGlzZW5nYWdlZCB8fCBkLnVzZXJEaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gIWQuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQudXNlckRpc2FibGVkID0gZC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZ2FnZWQgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNlbmdhZ2VkOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZ2FnZWQuZXZlcnkoZnVuY3Rpb24oc2VyaWVzKSB7IHJldHVybiBzZXJpZXMudXNlckRpc2FibGVkIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcyBpcywgaWYgZXZlcnkgc2luZ2xlIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZGlzYWJsZWQsIHR1cm4gYWxsIHNlcmllcycgYmFjayBvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBzZXJpZXMudXNlckRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2VuZ2FnZWQ6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNlbmdhZ2VkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHZlcnMgPT0gJ2Z1cmlvdXMnICYmIGV4cGFuZGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmxlZ2VuZERibGNsaWNrKGQsaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHJlLWdldCBkYXRhIGluIGNhc2UgaXQgd2FzIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHNlcmllcy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIE5WRDMgbGVnZW5kcywgd2hlbiBkb3VibGUgY2xpY2tpbmcgb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdG8gc2V0IGFsbCBvdGhlciBzZXJpZXMnIHRvIGZhbHNlLCBhbmQgbWFrZSB0aGUgZG91YmxlIGNsaWNrZWQgc2VyaWVzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih2ZXJzID09ICdmdXJpb3VzJykgc2VyaWVzLnVzZXJEaXNhYmxlZCA9IHNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodmVycyA9PSAnZnVyaW91cycpIGQudXNlckRpc2FibGVkID0gZC5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzZXJpZXMuY2xhc3NlZCgnbnYtZGlzYWJsZWQnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnVzZXJEaXNhYmxlZCB9KTtcbiAgICAgICAgICAgIHNlcmllcy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHNlcmllc1RleHRcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIHNldFRleHRDb2xvcilcbiAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkgeyByZXR1cm4ga2V5Rm9ybWF0dGVyKGdldEtleShkKSkgfSk7XG5cbiAgICAgICAgICAgIC8vVE9ETzogaW1wbGVtZW50IGZpeGVkLXdpZHRoIGFuZCBtYXgtd2lkdGggb3B0aW9ucyAobWF4LXdpZHRoIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdpdGggdGhlIGFsaWduIG9wdGlvbilcbiAgICAgICAgICAgIC8vIE5FVyBBTElHTklORyBDT0RFLCBUT0RPOiBjbGVhbiB1cFxuICAgICAgICAgICAgdmFyIGxlZ2VuZFdpZHRoID0gMDtcbiAgICAgICAgICAgIGlmIChhbGlnbikge1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc1dpZHRocyA9IFtdO1xuICAgICAgICAgICAgICAgIHNlcmllcy5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVnZW5kVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleUZvcm1hdHRlcihnZXRLZXkoZCkpICYmIGtleUZvcm1hdHRlcihnZXRLZXkoZCkpLmxlbmd0aCA+IG1heEtleUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyaW1tZWRLZXkgPSBrZXlGb3JtYXR0ZXIoZ2V0S2V5KGQpKS5zdWJzdHJpbmcoMCwgbWF4S2V5TGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZFRleHQgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0JykudGV4dCh0cmltbWVkS2V5ICsgXCIuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXBwZW5kKFwic3ZnOnRpdGxlXCIpLnRleHQoa2V5Rm9ybWF0dGVyKGdldEtleShkKSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kVGV4dCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZVRleHRMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVGV4dExlbmd0aCA9IGxlZ2VuZFRleHQubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxlZ2VuZFRleHQgaXMgZGlzcGxheTpub25lJ2QgKG5vZGVUZXh0TGVuZ3RoID09IDApLCBzaW11bGF0ZSBhbiBlcnJvciBzbyB3ZSBhcHByb3hpbWF0ZSwgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobm9kZVRleHRMZW5ndGggPD0gMCkgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVGV4dExlbmd0aCA9IG52LnV0aWxzLmNhbGNBcHByb3hUZXh0V2lkdGgobGVnZW5kVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNXaWR0aHMucHVzaChub2RlVGV4dExlbmd0aCArIHBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlcmllc1BlclJvdyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbldpZHRocyA9IFtdO1xuICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoID0gMDtcblxuICAgICAgICAgICAgICAgIHdoaWxlICggbGVnZW5kV2lkdGggPCBhdmFpbGFibGVXaWR0aCAmJiBzZXJpZXNQZXJSb3cgPCBzZXJpZXNXaWR0aHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbldpZHRoc1tzZXJpZXNQZXJSb3ddID0gc2VyaWVzV2lkdGhzW3Nlcmllc1BlclJvd107XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZFdpZHRoICs9IHNlcmllc1dpZHRoc1tzZXJpZXNQZXJSb3crK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXJpZXNQZXJSb3cgPT09IDApIHNlcmllc1BlclJvdyA9IDE7IC8vbWluaW11bSBvZiBvbmUgc2VyaWVzIHBlciByb3dcblxuICAgICAgICAgICAgICAgIHdoaWxlICggbGVnZW5kV2lkdGggPiBhdmFpbGFibGVXaWR0aCAmJiBzZXJpZXNQZXJSb3cgPiAxICkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzUGVyUm93LS07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzZXJpZXNXaWR0aHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXJpZXNXaWR0aHNba10gPiAoY29sdW1uV2lkdGhzW2sgJSBzZXJpZXNQZXJSb3ddIHx8IDApIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5XaWR0aHNbayAlIHNlcmllc1BlclJvd10gPSBzZXJpZXNXaWR0aHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZWdlbmRXaWR0aCA9IGNvbHVtbldpZHRocy5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyLCBpbmRleCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ICsgY3VyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgeFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjdXJYID0gMDsgaSA8IHNlcmllc1BlclJvdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHhQb3NpdGlvbnNbaV0gPSBjdXJYO1xuICAgICAgICAgICAgICAgICAgICBjdXJYICs9IGNvbHVtbldpZHRoc1tpXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4UG9zaXRpb25zW2kgJSBzZXJpZXNQZXJSb3ddICsgJywnICsgKDUgKyBNYXRoLmZsb29yKGkgLyBzZXJpZXNQZXJSb3cpICogdmVyc1BhZGRpbmcpICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vcG9zaXRpb24gbGVnZW5kIGFzIGZhciByaWdodCBhcyBwb3NzaWJsZSB3aXRoaW4gdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZy5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAod2lkdGggLSBtYXJnaW4ucmlnaHQgLSBsZWdlbmRXaWR0aCkgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwJyArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGhlaWdodCA9IG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tICsgKE1hdGguY2VpbChzZXJpZXNXaWR0aHMubGVuZ3RoIC8gc2VyaWVzUGVyUm93KSAqIHZlcnNQYWRkaW5nKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciB5cG9zID0gNSxcbiAgICAgICAgICAgICAgICAgICAgbmV3eHBvcyA9IDUsXG4gICAgICAgICAgICAgICAgICAgIG1heHdpZHRoID0gMCxcbiAgICAgICAgICAgICAgICAgICAgeHBvcztcbiAgICAgICAgICAgICAgICBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0KCd0ZXh0Jykubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHhwb3MgPSBuZXd4cG9zO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGggPCBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCArIHhwb3MgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd4cG9zID0geHBvcyA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeXBvcyArPSB2ZXJzUGFkZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3eHBvcyArPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3eHBvcyA+IG1heHdpZHRoKSBtYXh3aWR0aCA9IG5ld3hwb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxlZ2VuZFdpZHRoIDwgeHBvcyArIG1heHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kV2lkdGggPSB4cG9zICsgbWF4d2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHBvcyArICcsJyArIHlwb3MgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9wb3NpdGlvbiBsZWdlbmQgYXMgZmFyIHJpZ2h0IGFzIHBvc3NpYmxlIHdpdGhpbiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICh3aWR0aCAtIG1hcmdpbi5yaWdodCAtIG1heHdpZHRoKSArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b20gKyB5cG9zICsgMTU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZlcnMgPT0gJ2Z1cmlvdXMnKSB7XG4gICAgICAgICAgICAgICAgLy8gU2l6ZSByZWN0YW5nbGVzIGFmdGVyIHRleHQgaXMgcGxhY2VkXG4gICAgICAgICAgICAgICAgc2VyaWVzU2hhcGVcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzVGV4dFswXVtpXS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSArIDI3O1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgLTkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTE1KTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBiYWNrZ3JvdW5kIGZvciB0aGUgZXhwYW5kZWQgbGVnZW5kIChVSSlcbiAgICAgICAgICAgICAgICBnRW50ZXIuaW5zZXJ0KCdyZWN0JywnOmZpcnN0LWNoaWxkJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZC1iZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyNlZWUnKVxuICAgICAgICAgICAgICAgICAgICAvLyAuYXR0cignc3Ryb2tlJywgJyM0NDQnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsMCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VyaWVzQkcgPSBnLnNlbGVjdCgnLm52LWxlZ2VuZC1iZycpO1xuXG4gICAgICAgICAgICAgICAgc2VyaWVzQkdcbiAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDMwMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtdmVyc1BhZGRpbmcgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBsZWdlbmRXaWR0aCArIHZlcnNQYWRkaW5nIC0gMTIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQgKyAxMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtbWFyZ2luLnRvcCAtIDEwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsIGV4cGFuZGVkID8gMSA6IDApO1xuXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VyaWVzU2hhcGVcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBzZXRCR0NvbG9yKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5Jywgc2V0QkdPcGFjaXR5KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgc2V0QkdDb2xvcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldFRleHRDb2xvcihkLGkpIHtcbiAgICAgICAgICAgIGlmKHZlcnMgIT0gJ2Z1cmlvdXMnKSByZXR1cm4gJyMwMDAnO1xuICAgICAgICAgICAgaWYoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5kaXNlbmdhZ2VkID8gJyMwMDAnIDogJyNmZmYnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICBpZighZC5jb2xvcikgZC5jb2xvciA9IGNvbG9yKGQsaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhZC5kaXNhYmxlZCA/IGQuY29sb3IgOiAnI2ZmZic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRCR0NvbG9yKGQsaSkge1xuICAgICAgICAgICAgaWYoZXhwYW5kZWQgJiYgdmVycyA9PSAnZnVyaW91cycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5kaXNlbmdhZ2VkID8gJyNlZWUnIDogZC5jb2xvciB8fCBjb2xvcihkLGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiBzZXRCR09wYWNpdHkoZCxpKSB7XG4gICAgICAgICAgICBpZihleHBhbmRlZCAmJiB2ZXJzID09ICdmdXJpb3VzJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFkLmRpc2FibGVkID8gMCA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAga2V5OiAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldEtleTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldEtleT1fO319LFxuICAgICAgICBrZXlGb3JtYXR0ZXI6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4ga2V5Rm9ybWF0dGVyO30sIHNldDogZnVuY3Rpb24oXyl7a2V5Rm9ybWF0dGVyPV87fX0sXG4gICAgICAgIGFsaWduOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBhbGlnbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2FsaWduPV87fX0sXG4gICAgICAgIG1heEtleUxlbmd0aDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXhLZXlMZW5ndGg7fSwgc2V0OiBmdW5jdGlvbihfKXttYXhLZXlMZW5ndGg9Xzt9fSxcbiAgICAgICAgcmlnaHRBbGlnbjogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ247fSwgc2V0OiBmdW5jdGlvbihfKXtyaWdodEFsaWduPV87fX0sXG4gICAgICAgIHBhZGRpbmc6ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBwYWRkaW5nO30sIHNldDogZnVuY3Rpb24oXyl7cGFkZGluZz1fO319LFxuICAgICAgICB1cGRhdGVTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXBkYXRlU3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXt1cGRhdGVTdGF0ZT1fO319LFxuICAgICAgICByYWRpb0J1dHRvbk1vZGU6e2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmFkaW9CdXR0b25Nb2RlO30sIHNldDogZnVuY3Rpb24oXyl7cmFkaW9CdXR0b25Nb2RlPV87fX0sXG4gICAgICAgIGV4cGFuZGVkOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBleHBhbmRlZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2V4cGFuZGVkPV87fX0sXG4gICAgICAgIHZlcnM6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB2ZXJzO30sIHNldDogZnVuY3Rpb24oXyl7dmVycz1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgIHNjYXR0ZXIgPSBudi5tb2RlbHMuc2NhdHRlcigpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gOTYwXG4gICAgICAgICwgaGVpZ2h0ID0gNTAwXG4gICAgICAgICwgY29udGFpbmVyID0gbnVsbFxuICAgICAgICAsIHN0cm9rZVdpZHRoID0gMS41XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSAvLyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNvbG9yXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeCB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSAvLyBhY2Nlc3NvciB0byBnZXQgdGhlIHkgdmFsdWUgZnJvbSBhIGRhdGEgcG9pbnRcbiAgICAgICAgLCBkZWZpbmVkID0gZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhaXNOYU4oZ2V0WShkLGkpKSAmJiBnZXRZKGQsaSkgIT09IG51bGwgfSAvLyBhbGxvd3MgYSBsaW5lIHRvIGJlIG5vdCBjb250aW51b3VzIHdoZW4gaXQgaXMgbm90IGRlZmluZWRcbiAgICAgICAgLCBpc0FyZWEgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLmFyZWEgfSAvLyBkZWNpZGVzIGlmIGEgbGluZSBpcyBhbiBhcmVhIG9yIGp1c3QgYSBsaW5lXG4gICAgICAgICwgY2xpcEVkZ2UgPSBmYWxzZSAvLyBpZiB0cnVlLCBtYXNrcyBsaW5lcyB3aXRoaW4geCBhbmQgeSBzY2FsZVxuICAgICAgICAsIHggLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnhTY2FsZSgpXG4gICAgICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAgICAgLCBpbnRlcnBvbGF0ZSA9IFwibGluZWFyXCIgLy8gY29udHJvbHMgdGhlIGxpbmUgaW50ZXJwb2xhdGlvblxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIHNjYXR0ZXJcbiAgICAgICAgLnBvaW50U2l6ZSgxNikgLy8gZGVmYXVsdCBzaXplXG4gICAgICAgIC5wb2ludERvbWFpbihbMTYsMjU2XSkgLy9zZXQgdG8gc3BlZWQgdXAgY2FsY3VsYXRpb24sIG5lZWRzIHRvIGJlIHVuc2V0IGlmIHRoZXJlIGlzIGEgY3VzdG9tIHNpemUgYWNjZXNzb3JcbiAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFByaXZhdGUgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciB4MCwgeTAgLy91c2VkIHRvIHN0b3JlIHByZXZpb3VzIHNjYWxlc1xuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKVxuICAgICAgICA7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHNjYXR0ZXIpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBudi51dGlscy5hdmFpbGFibGVXaWR0aCh3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc2NhdHRlci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzY2F0dGVyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IHk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1saW5lJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtbGluZScpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zY2F0dGVyV3JhcCcpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHNjYXR0ZXJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICB2YXIgc2NhdHRlcldyYXAgPSB3cmFwLnNlbGVjdCgnLm52LXNjYXR0ZXJXcmFwJyk7XG4gICAgICAgICAgICBzY2F0dGVyV3JhcC5jYWxsKHNjYXR0ZXIpO1xuXG4gICAgICAgICAgICBkZWZzRW50ZXIuYXBwZW5kKCdjbGlwUGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgJ252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJyNudi1lZGdlLWNsaXAtJyArIHNjYXR0ZXIuaWQoKSArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIChhdmFpbGFibGVIZWlnaHQgPiAwKSA/IGF2YWlsYWJsZUhlaWdodCA6IDApO1xuXG4gICAgICAgICAgICBnICAgLmF0dHIoJ2NsaXAtcGF0aCcsIGNsaXBFZGdlID8gJ3VybCgjbnYtZWRnZS1jbGlwLScgKyBzY2F0dGVyLmlkKCkgKyAnKScgOiAnJyk7XG4gICAgICAgICAgICBzY2F0dGVyV3JhcFxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmtleSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utd2lkdGgnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnN0cm9rZVdpZHRoIHx8IHN0cm9rZVdpZHRoIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcblxuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC5jbGFzc2VkIHx8ICcnKSArICcgbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpfSk7XG4gICAgICAgICAgICBncm91cHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbGluZTogZ3JvdXBzJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZmlsbE9wYWNpdHkgfHwgLjV9KTtcblxuICAgICAgICAgICAgdmFyIGFyZWFQYXRocyA9IGdyb3Vwcy5zZWxlY3RBbGwoJ3BhdGgubnYtYXJlYScpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gaXNBcmVhKGQpID8gW2RdIDogW10gfSk7IC8vIHRoaXMgaXMgZG9uZSBkaWZmZXJlbnRseSB0aGFuIGxpbmVzIGJlY2F1c2UgSSBuZWVkIHRvIGNoZWNrIGlmIHNlcmllcyBpcyBhbiBhcmVhXG4gICAgICAgICAgICBhcmVhUGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1hcmVhJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4MChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gbnYudXRpbHMuTmFOdG9aZXJvKHkwKGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAueTEoZnVuY3Rpb24oZCxpKSB7IHJldHVybiB5MCggeS5kb21haW4oKVswXSA8PSAwID8geS5kb21haW4oKVsxXSA+PSAwID8gMCA6IHkuZG9tYWluKClbMV0gOiB5LmRvbWFpbigpWzBdICkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geTAoMCkgfSkgLy9hc3N1bWluZyAwIGlzIHdpdGhpbiB5IGRvbWFpbi4uIG1heSBuZWVkIHRvIHR3ZWFrIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseSh0aGlzLCBbZC52YWx1ZXNdKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3BhdGgubnYtYXJlYScpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBhcmVhUGF0aHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbGluZTogYXJlYVBhdGhzJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzLnN2Zy5hcmVhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4KGdldFgoZCxpKSkpIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeShnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geSggeS5kb21haW4oKVswXSA8PSAwID8geS5kb21haW4oKVsxXSA+PSAwID8gMCA6IHkuZG9tYWluKClbMV0gOiB5LmRvbWFpbigpWzBdICkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLnkxKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geTAoMCkgfSkgLy9hc3N1bWluZyAwIGlzIHdpdGhpbiB5IGRvbWFpbi4uIG1heSBuZWVkIHRvIHR3ZWFrIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBseSh0aGlzLCBbZC52YWx1ZXNdKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbGluZVBhdGhzID0gZ3JvdXBzLnNlbGVjdEFsbCgncGF0aC5udi1saW5lJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBbZC52YWx1ZXNdIH0pO1xuXG4gICAgICAgICAgICBsaW5lUGF0aHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1saW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsXG4gICAgICAgICAgICAgICAgICAgIGQzLnN2Zy5saW5lKClcbiAgICAgICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgICAgICAuZGVmaW5lZChkZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh4MChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5MChnZXRZKGQsaSkpKSB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGluZVBhdGhzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ2xpbmU6IGxpbmVQYXRocycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgICAgICAgICBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBudi51dGlscy5OYU50b1plcm8oeChnZXRYKGQsaSkpKSB9KVxuICAgICAgICAgICAgICAgICAgICAueShmdW5jdGlvbihkLGkpIHsgcmV0dXJuIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZCxpKSkpIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdsaW5lIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuc2NhdHRlciA9IHNjYXR0ZXI7XG4gICAgLy8gUGFzcyB0aHJvdWdoIGV2ZW50c1xuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKCl7IGRpc3BhdGNoLmVsZW1lbnRDbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KTtcbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyJywgZnVuY3Rpb24oKXsgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KTtcbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQnLCBmdW5jdGlvbigpeyBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSk7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBkZWZpbmVkOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZpbmVkO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmaW5lZD1fO319LFxuICAgICAgICBpbnRlcnBvbGF0ZTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcnBvbGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVycG9sYXRlPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwRWRnZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBFZGdlPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHNjYXR0ZXIuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgaXNBcmVhOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpc0FyZWE7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGlzQXJlYSA9IGQzLmZ1bmN0b3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRYID0gXztcbiAgICAgICAgICAgIHNjYXR0ZXIueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFkgPSBfO1xuICAgICAgICAgICAgc2NhdHRlci55KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIHNjYXR0ZXIuY29sb3IoY29sb3IpO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHNjYXR0ZXIpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubGluZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBsaW5lcyA9IG52Lm1vZGVscy5saW5lKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBpbnRlcmFjdGl2ZUxheWVyID0gbnYuaW50ZXJhY3RpdmVHdWlkZWxpbmUoKVxuICAgICAgICAsIHRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpXG4gICAgICAgICwgZm9jdXMgPSBudi5tb2RlbHMuZm9jdXMobnYubW9kZWxzLmxpbmUoKSlcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIG1hcmdpblRvcCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgbGVnZW5kUG9zaXRpb24gPSAndG9wJ1xuICAgICAgICAsIHNob3dYQXhpcyA9IHRydWVcbiAgICAgICAgLCBzaG93WUF4aXMgPSB0cnVlXG4gICAgICAgICwgcmlnaHRBbGlnbllBeGlzID0gZmFsc2VcbiAgICAgICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgICAgICwgeFxuICAgICAgICAsIHlcbiAgICAgICAgLCBmb2N1c0VuYWJsZSA9IGZhbHNlXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCd0b29sdGlwU2hvdycsICd0b29sdGlwSGlkZScsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIC8vIHNldCBvcHRpb25zIG9uIHN1Yi1vYmplY3RzIGZvciB0aGlzIGNoYXJ0XG4gICAgeEF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg3KTtcbiAgICB5QXhpcy5vcmllbnQocmlnaHRBbGlnbllBeGlzID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG5cbiAgICBsaW5lcy5jbGlwRWRnZSh0cnVlKS5kdXJhdGlvbigwKTtcblxuICAgIHRvb2x0aXAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4geUF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgIH0pLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB4QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgfSk7XG5cbiAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4geUF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgIH0pLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgIHJldHVybiB4QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgfSk7XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIHZhciBzdGF0ZUdldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQ7IH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKGxpbmVzKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbikgLSAoZm9jdXNFbmFibGUgPyBmb2N1cy5oZWlnaHQoKSA6IDApO1xuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoIGR1cmF0aW9uID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY2FsbCggY2hhcnQgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZDsgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBudi51dGlscy5ub0RhdGEoY2hhcnQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIFVwZGF0ZSBgbWFpbicgZ3JhcGggb24gYnJ1c2ggdXBkYXRlLiAqL1xuICAgICAgICAgICAgZm9jdXMuZGlzcGF0Y2gub24oXCJvbkJydXNoXCIsIGZ1bmN0aW9uKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIG9uQnJ1c2goZXh0ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBsaW5lcy54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBsaW5lcy55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LWxpbmVDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LWxpbmVDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuXG4gICAgICAgICAgICB2YXIgZm9jdXNFbnRlciA9IGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1mb2N1cycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYWNrZ3JvdW5kJykuYXBwZW5kKCdyZWN0Jyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGluZXNXcmFwJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0RW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZm9jdXNXcmFwJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKCFzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJykuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGF2YWlsYWJsZUhlaWdodCArJyknKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZ2VuZFBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbikgLSAoZm9jdXNFbmFibGUgPyBmb2N1cy5oZWlnaHQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1NldCB1cCBpbnRlcmFjdGl2ZSBsYXllclxuICAgICAgICAgICAgaWYgKHVzZUludGVyYWN0aXZlR3VpZGVsaW5lKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LCB0b3A6bWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlXCIpLmNhbGwoaW50ZXJhY3RpdmVMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWJhY2tncm91bmQgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGxpbmVzXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQ7IH0pKTtcblxuICAgICAgICAgICAgdmFyIGxpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQ7IH0pKTtcblxuXG4gICAgICAgICAgICAvLyBTZXR1cCBNYWluIChGb2N1cykgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHlBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVXaWR0aCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBVcGRhdGUgQXhlc1xuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVhBeGlzKCkge1xuICAgICAgICAgICAgICBpZihzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVlBeGlzKCkge1xuICAgICAgICAgICAgICBpZihzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0ICsgJyknKTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBGb2N1c1xuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIGlmKCFmb2N1c0VuYWJsZSkge1xuICAgICAgICAgICAgICAgIGxpbmVzV3JhcC5jYWxsKGxpbmVzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVYQXhpcygpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVlBeGlzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvY3VzLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICggYXZhaWxhYmxlSGVpZ2h0ICsgbWFyZ2luLmJvdHRvbSArIGZvY3VzLm1hcmdpbigpLnRvcCkgKyAnKScpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZDsgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGZvY3VzKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW50ID0gZm9jdXMuYnJ1c2guZW1wdHkoKSA/IGZvY3VzLnhEb21haW4oKSA6IGZvY3VzLmJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIGlmKGV4dGVudCAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIG9uQnJ1c2goZXh0ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzZXJpZXMuZGlzYWJsZWQgJiYgIXNlcmllcy5kaXNhYmxlVG9vbHRpcDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRlbnQgPSBmb2N1c0VuYWJsZSA/IChmb2N1cy5icnVzaC5lbXB0eSgpID8gZm9jdXMueFNjYWxlKCkuZG9tYWluKCkgOiBmb2N1cy5icnVzaC5leHRlbnQoKSkgOiB4LmRvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZXMgPSBzZXJpZXMudmFsdWVzLmZpbHRlcihmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVja3MgaWYgdGhlIHggcG9pbnQgaXMgYmV0d2VlbiB0aGUgZXh0ZW50cywgaGFuZGxpbmcgY2FzZSB3aGVyZSBleHRlbnRbMF0gaXMgZ3JlYXRlciB0aGFuIGV4dGVudFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChlLmcuIHggZG9tYWluIGlzIG1hbnVhbGx5IHNldCB0byByZXZlcnNlIHRoZSB4LWF4aXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZXh0ZW50WzBdIDw9IGV4dGVudFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXMueCgpKGQsaSkgPj0gZXh0ZW50WzBdICYmIGxpbmVzLngoKShkLGkpIDw9IGV4dGVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXMueCgpKGQsaSkgPj0gZXh0ZW50WzFdICYmIGxpbmVzLngoKShkLGkpIDw9IGV4dGVudFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KGN1cnJlbnRWYWx1ZXMsIGUucG9pbnRYVmFsdWUsIGxpbmVzLngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBjdXJyZW50VmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50WVZhbHVlID0gY2hhcnQueSgpKHBvaW50LCBwb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludFlWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzLmhpZ2hsaWdodFBvaW50KGksIHBvaW50SW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVQb2ludCA9PT0gdW5kZWZpbmVkKSBzaW5nbGVQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50WExvY2F0aW9uID09PSB1bmRlZmluZWQpIHBvaW50WExvY2F0aW9uID0gY2hhcnQueFNjYWxlKCkoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwb2ludFlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvL0hpZ2hsaWdodCB0aGUgdG9vbHRpcCBlbnRyeSBiYXNlZCBvbiB3aGljaCBwb2ludCB0aGUgbW91c2UgaXMgY2xvc2VzdCB0by5cbiAgICAgICAgICAgICAgICBpZiAoYWxsRGF0YS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5VmFsdWUgPSBjaGFydC55U2NhbGUoKS5pbnZlcnQoZS5tb3VzZVkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluRXh0ZW50ID0gTWF0aC5hYnMoY2hhcnQueVNjYWxlKCkuZG9tYWluKClbMF0gLSBjaGFydC55U2NhbGUoKS5kb21haW4oKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjAzICogZG9tYWluRXh0ZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhUb0hpZ2hsaWdodCA9IG52Lm5lYXJlc3RWYWx1ZUluZGV4KGFsbERhdGEubWFwKGZ1bmN0aW9uKGQpe3JldHVybiBkLnZhbHVlO30pLHlWYWx1ZSx0aHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhUb0hpZ2hsaWdodCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGFbaW5kZXhUb0hpZ2hsaWdodF0uaGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlRm9ybWF0dGVyID0gZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkID09IG51bGwgPyBcIk4vQVwiIDogeUF4aXMudGlja0Zvcm1hdCgpKGQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcC52YWx1ZUZvcm1hdHRlcigpIHx8IGRlZmF1bHRWYWx1ZUZvcm1hdHRlcilcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LngoKSggc2luZ2xlUG9pbnQscG9pbnRJbmRleCApLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIucmVuZGVyR3VpZGVMaW5lKHBvaW50WExvY2F0aW9uKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcblxuICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNlcmllcy5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHNlcmllcy52YWx1ZXNbcG9pbnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRYTG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSBwb2ludFhMb2NhdGlvbiA9IGNoYXJ0LnhTY2FsZSgpKGNoYXJ0LngoKShwb2ludCxwb2ludEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5UG9zID0gY2hhcnQueVNjYWxlKCkoY2hhcnQueSgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IHBvaW50SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFtwb2ludFhMb2NhdGlvbiwgeVBvc10sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogc2VyaWVzLnNlcmllc0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBsaW5lcy5kaXNwYXRjaC5lbGVtZW50Q2xpY2soYWxsRGF0YSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbihcImVsZW1lbnRNb3VzZW91dFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLmxlbmd0aCA9PT0gZS5kaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBGdW5jdGlvbnNcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIC8vIFRha2VuIGZyb20gY3Jvc3NmaWx0ZXIgKGh0dHA6Ly9zcXVhcmUuZ2l0aHViLmNvbS9jcm9zc2ZpbHRlci8pXG4gICAgICAgICAgICBmdW5jdGlvbiByZXNpemVQYXRoKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9ICsoZCA9PSAnZScpLFxuICAgICAgICAgICAgICAgICAgICB4ID0gZSA/IDEgOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGF2YWlsYWJsZUhlaWdodCAvIDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNJyArICgwLjUgKiB4KSArICcsJyArIHlcbiAgICAgICAgICAgICAgICAgICAgKyAnQTYsNiAwIDAgJyArIGUgKyAnICcgKyAoNi41ICogeCkgKyAnLCcgKyAoeSArIDYpXG4gICAgICAgICAgICAgICAgICAgICsgJ1YnICsgKDIgKiB5IC0gNilcbiAgICAgICAgICAgICAgICAgICAgKyAnQTYsNiAwIDAgJyArIGUgKyAnICcgKyAoMC41ICogeCkgKyAnLCcgKyAoMiAqIHkpXG4gICAgICAgICAgICAgICAgICAgICsgJ1onXG4gICAgICAgICAgICAgICAgICAgICsgJ00nICsgKDIuNSAqIHgpICsgJywnICsgKHkgKyA4KVxuICAgICAgICAgICAgICAgICAgICArICdWJyArICgyICogeSAtIDgpXG4gICAgICAgICAgICAgICAgICAgICsgJ00nICsgKDQuNSAqIHgpICsgJywnICsgKHkgKyA4KVxuICAgICAgICAgICAgICAgICAgICArICdWJyArICgyICogeSAtIDgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBvbkJydXNoKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBNYWluIChGb2N1cylcbiAgICAgICAgICAgICAgICB2YXIgZm9jdXNMaW5lc1dyYXAgPSBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi1saW5lc1dyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBkLmFyZWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZWQ6IGQuY2xhc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXMueCgpKGQsaSkgPj0gZXh0ZW50WzBdICYmIGxpbmVzLngoKShkLGkpIDw9IGV4dGVudFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVUb29sdGlwOiBkLmRpc2FibGVUb29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb2N1c0xpbmVzV3JhcC50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwobGluZXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBBeGVzXG4gICAgICAgICAgICAgICAgdXBkYXRlWEF4aXMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVZQXhpcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ2xpbmVDaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYoIWV2dC5zZXJpZXMuZGlzYWJsZVRvb2x0aXApe1xuICAgICAgICAgICAgdG9vbHRpcC5kYXRhKGV2dCkuaGlkZGVuKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQuZm9jdXMgPSBmb2N1cztcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LngyQXhpcyA9IGZvY3VzLnhBeGlzXG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC55MkF4aXMgPSBmb2N1cy55QXhpc1xuICAgIGNoYXJ0LmludGVyYWN0aXZlTGF5ZXIgPSBpbnRlcmFjdGl2ZUxheWVyO1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIGNoYXJ0LnN0YXRlID0gc3RhdGU7XG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBsZWdlbmRQb3NpdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGVnZW5kUG9zaXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtsZWdlbmRQb3NpdGlvbj1fO319LFxuICAgICAgICBzaG93WEF4aXM6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1lBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1lBeGlzPV87fX0sXG4gICAgICAgIGRlZmF1bHRTdGF0ZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGVmYXVsdFN0YXRlO30sIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIC8vIEZvY3VzIG9wdGlvbnMsIG1vc3RseSBwYXNzZWQgb250byBmb2N1cyBtb2RlbC5cbiAgICAgICAgZm9jdXNFbmFibGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvY3VzRW5hYmxlO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXNFbmFibGU9Xzt9fSxcbiAgICAgICAgZm9jdXNIZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb2N1cy5oZWlnaHQoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvY3VzLmhlaWdodChfKTt9fSxcbiAgICAgICAgZm9jdXNTaG93QXhpc1g6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvY3VzLnNob3dYQXhpcygpO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXMuc2hvd1hBeGlzKF8pO319LFxuICAgICAgICBmb2N1c1Nob3dBeGlzWTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXMuc2hvd1lBeGlzKCk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1cy5zaG93WUF4aXMoXyk7fX0sXG4gICAgICAgIGJydXNoRXh0ZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb2N1cy5icnVzaEV4dGVudCgpO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXMuYnJ1c2hFeHRlbnQoXyk7fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBmb2N1c01hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXMubWFyZ2lufSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGlmIChfLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IF8udG9wO1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IF8udG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9jdXMubWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IGZvY3VzLm1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIGZvY3VzLm1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBmb2N1cy5tYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgZm9jdXMubWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IGZvY3VzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBsaW5lcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICBmb2N1cy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIGxpbmVzLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgIGZvY3VzLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGludGVycG9sYXRlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5lcy5pbnRlcnBvbGF0ZSgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBsaW5lcy5pbnRlcnBvbGF0ZShfKTtcbiAgICAgICAgICAgIGZvY3VzLmludGVycG9sYXRlKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeFRpY2tGb3JtYXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgeEF4aXMudGlja0Zvcm1hdChfKTtcbiAgICAgICAgICAgIGZvY3VzLnhUaWNrRm9ybWF0KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeVRpY2tGb3JtYXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgeUF4aXMudGlja0Zvcm1hdChfKTtcbiAgICAgICAgICAgIGZvY3VzLnlUaWNrRm9ybWF0KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGluZXMueCgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBsaW5lcy54KF8pO1xuICAgICAgICAgICAgZm9jdXMueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxpbmVzLnkoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbGluZXMueShfKTtcbiAgICAgICAgICAgIGZvY3VzLnkoXyk7XG4gICAgICAgIH19LFxuICAgICAgICByaWdodEFsaWduWUF4aXM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHJpZ2h0QWxpZ25ZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgcmlnaHRBbGlnbllBeGlzID0gXztcbiAgICAgICAgICAgIHlBeGlzLm9yaWVudCggcmlnaHRBbGlnbllBeGlzID8gJ3JpZ2h0JyA6ICdsZWZ0Jyk7XG4gICAgICAgIH19LFxuICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gXztcbiAgICAgICAgICAgIGlmICh1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsaW5lcy51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBsaW5lcyk7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLmxpbmVXaXRoRm9jdXNDaGFydCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbnYubW9kZWxzLmxpbmVDaGFydCgpXG4gICAgLm1hcmdpbih7IGJvdHRvbTogMzAgfSlcbiAgICAuZm9jdXNFbmFibGUoIHRydWUgKTtcbn07XG5udi5tb2RlbHMubGluZVBsdXNCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbGluZXMgPSBudi5tb2RlbHMubGluZSgpXG4gICAgICAgICwgbGluZXMyID0gbnYubW9kZWxzLmxpbmUoKVxuICAgICAgICAsIGJhcnMgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgICAgICwgYmFyczIgPSBudi5tb2RlbHMuaGlzdG9yaWNhbEJhcigpXG4gICAgICAgICwgeEF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeDJBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHkxQXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5MkF4aXMgPSBudi5tb2RlbHMuYXhpcygpXG4gICAgICAgICwgeTNBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHk0QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBicnVzaCA9IGQzLnN2Zy5icnVzaCgpXG4gICAgICAgICwgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKClcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMzAsIGJvdHRvbTogMzAsIGxlZnQ6IDYwfVxuICAgICAgICAsIG1hcmdpblRvcCA9IG51bGxcbiAgICAgICAgLCBtYXJnaW4yID0ge3RvcDogMCwgcmlnaHQ6IDMwLCBib3R0b206IDIwLCBsZWZ0OiA2MH1cbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgZ2V0WCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9XG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgZm9jdXNFbmFibGUgPSB0cnVlXG4gICAgICAgICwgZm9jdXNTaG93QXhpc1kgPSBmYWxzZVxuICAgICAgICAsIGZvY3VzU2hvd0F4aXNYID0gdHJ1ZVxuICAgICAgICAsIGZvY3VzSGVpZ2h0ID0gNTBcbiAgICAgICAgLCBleHRlbnRcbiAgICAgICAgLCBicnVzaEV4dGVudCA9IG51bGxcbiAgICAgICAgLCB4XG4gICAgICAgICwgeDJcbiAgICAgICAgLCB5MVxuICAgICAgICAsIHkyXG4gICAgICAgICwgeTNcbiAgICAgICAgLCB5NFxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdicnVzaCcsICdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScpXG4gICAgICAgICwgdHJhbnNpdGlvbkR1cmF0aW9uID0gMFxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBsZWdlbmRMZWZ0QXhpc0hpbnQgPSAnIChsZWZ0IGF4aXMpJ1xuICAgICAgICAsIGxlZ2VuZFJpZ2h0QXhpc0hpbnQgPSAnIChyaWdodCBheGlzKSdcbiAgICAgICAgLCBzd2l0Y2hZQXhpc09yZGVyID0gZmFsc2VcbiAgICAgICAgO1xuXG4gICAgbGluZXMuY2xpcEVkZ2UodHJ1ZSk7XG4gICAgbGluZXMyLmludGVyYWN0aXZlKGZhbHNlKTtcbiAgICAvLyBXZSBkb24ndCB3YW50IGFueSBwb2ludHMgZW1pdHRlZCBmb3IgdGhlIGZvY3VzIGNoYXJ0J3Mgc2NhdHRlciBncmFwaC5cbiAgICBsaW5lczIucG9pbnRBY3RpdmUoZnVuY3Rpb24oZCkgeyByZXR1cm4gZmFsc2UgfSk7XG4gICAgeEF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg1KTtcbiAgICB5MUF4aXMub3JpZW50KCdsZWZ0Jyk7XG4gICAgeTJBeGlzLm9yaWVudCgncmlnaHQnKTtcbiAgICB4MkF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg1KTtcbiAgICB5M0F4aXMub3JpZW50KCdsZWZ0Jyk7XG4gICAgeTRBeGlzLm9yaWVudCgncmlnaHQnKTtcblxuICAgIHRvb2x0aXAuaGVhZGVyRW5hYmxlZCh0cnVlKS5oZWFkZXJGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgZ2V0QmFyc0F4aXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN3aXRjaFlBeGlzT3JkZXJcbiAgICAgICAgICAgID8geyBtYWluOiB5MkF4aXMsIGZvY3VzOiB5NEF4aXMgfVxuICAgICAgICAgICAgOiB7IG1haW46IHkxQXhpcywgZm9jdXM6IHkzQXhpcyB9XG4gICAgfVxuXG4gICAgdmFyIGdldExpbmVzQXhpcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3dpdGNoWUF4aXNPcmRlclxuICAgICAgICAgICAgPyB7IG1haW46IHkxQXhpcywgZm9jdXM6IHkzQXhpcyB9XG4gICAgICAgICAgICA6IHsgbWFpbjogeTJBeGlzLCBmb2N1czogeTRBeGlzIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGFsbERpc2FibGVkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEuZXZlcnkoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXMuZGlzYWJsZWQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MSA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKVxuICAgICAgICAgICAgICAgICAgICAtIChmb2N1c0VuYWJsZSA/IGZvY3VzSGVpZ2h0IDogMCksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0MiA9IGZvY3VzSGVpZ2h0IC0gbWFyZ2luMi50b3AgLSBtYXJnaW4yLmJvdHRvbTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHZhciBkYXRhQmFycyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkICYmIGQuYmFyIH0pO1xuICAgICAgICAgICAgdmFyIGRhdGFMaW5lcyA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmJhciB9KTsgLy8gcmVtb3ZlZCB0aGUgIWQuZGlzYWJsZWQgY2xhdXNlIGhlcmUgdG8gZml4IElzc3VlICMyNDBcblxuICAgICAgICAgICAgaWYgKGRhdGFCYXJzLmxlbmd0aCAmJiAhc3dpdGNoWUF4aXNPcmRlcikge1xuICAgICAgICAgICAgICAgIHggPSBiYXJzLnhTY2FsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHgyID0geDJBeGlzLnNjYWxlKCk7XG5cbiAgICAgICAgICAgIC8vIHNlbGVjdCB0aGUgc2NhbGVzIGFuZCBzZXJpZXMgYmFzZWQgb24gdGhlIHBvc2l0aW9uIG9mIHRoZSB5QXhpc1xuICAgICAgICAgICAgeTEgPSBzd2l0Y2hZQXhpc09yZGVyID8gbGluZXMueVNjYWxlKCkgOiBiYXJzLnlTY2FsZSgpO1xuICAgICAgICAgICAgeTIgPSBzd2l0Y2hZQXhpc09yZGVyID8gYmFycy55U2NhbGUoKSA6IGxpbmVzLnlTY2FsZSgpO1xuICAgICAgICAgICAgeTMgPSBzd2l0Y2hZQXhpc09yZGVyID8gbGluZXMyLnlTY2FsZSgpIDogYmFyczIueVNjYWxlKCk7XG4gICAgICAgICAgICB5NCA9IHN3aXRjaFlBeGlzT3JkZXIgPyBiYXJzMi55U2NhbGUoKSA6IGxpbmVzMi55U2NhbGUoKTtcblxuICAgICAgICAgICAgdmFyIHNlcmllczEgPSBkYXRhXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCAmJiAoc3dpdGNoWUF4aXNPcmRlciA/ICFkLmJhciA6IGQuYmFyKSB9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSkgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2VyaWVzMiA9IGRhdGFcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkICYmIChzd2l0Y2hZQXhpc09yZGVyID8gZC5iYXIgOiAhZC5iYXIpIH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHgucmFuZ2UoWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHgyICAuZG9tYWluKGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMxLmNvbmNhdChzZXJpZXMyKSksIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9ICkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbGluZVBsdXNCYXInKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1saW5lUGx1c0JhcicpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBtYWluIGNoYXJ0XG4gICAgICAgICAgICB2YXIgZm9jdXNFbnRlciA9IGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1mb2N1cycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTEgbnYtYXhpcycpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MiBudi1heGlzJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWJhcnNXcmFwJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxpbmVzV3JhcCcpO1xuXG4gICAgICAgICAgICAvLyBjb250ZXh0IGNoYXJ0IGlzIHdoZXJlIHlvdSBjYW4gZm9jdXMgaW5cbiAgICAgICAgICAgIHZhciBjb250ZXh0RW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udGV4dCcpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXggbnYtYXhpcycpO1xuICAgICAgICAgICAgY29udGV4dEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXkxIG52LWF4aXMnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MiBudi1heGlzJyk7XG4gICAgICAgICAgICBjb250ZXh0RW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1saW5lc1dyYXAnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1icnVzaEJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGNvbnRleHRFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWJydXNoJyk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGlmICghc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSBsZWdlbmQuYWxpZ24oKSA/IGF2YWlsYWJsZVdpZHRoIC8gMiA6IGF2YWlsYWJsZVdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRYUG9zaXRpb24gPSBsZWdlbmQuYWxpZ24oKSA/IGxlZ2VuZFdpZHRoIDogMDtcblxuICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChsZWdlbmRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5tYXAoZnVuY3Rpb24oc2VyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMub3JpZ2luYWxLZXkgPSBzZXJpZXMub3JpZ2luYWxLZXkgPT09IHVuZGVmaW5lZCA/IHNlcmllcy5rZXkgOiBzZXJpZXMub3JpZ2luYWxLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzd2l0Y2hZQXhpc09yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmtleSA9IHNlcmllcy5vcmlnaW5hbEtleSArIChzZXJpZXMuYmFyID8gbGVnZW5kUmlnaHRBeGlzSGludCA6IGxlZ2VuZExlZnRBeGlzSGludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5rZXkgPSBzZXJpZXMub3JpZ2luYWxLZXkgKyAoc2VyaWVzLmJhciA/IGxlZ2VuZExlZnRBeGlzSGludCA6IGxlZ2VuZFJpZ2h0QXhpc0hpbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmllcztcbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IHNob3VsZG4ndCB0aGlzIGJlIFwiLSAoZm9jdXNFbmFibGVkID8gZm9jdXNIZWlnaHQgOiAwKVwiP1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQxID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIC0gZm9jdXNIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGxlZ2VuZFhQb3NpdGlvbiArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIENvbnRleHQgY2hhcnQgKGZvY3VzIGNoYXJ0KSBjb21wb25lbnRzXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAvLyBoaWRlIG9yIHNob3cgdGhlIGZvY3VzIGNvbnRleHQgY2hhcnRcbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCcpLnN0eWxlKCdkaXNwbGF5JywgZm9jdXNFbmFibGUgPyAnaW5pdGlhbCcgOiAnbm9uZScpO1xuXG4gICAgICAgICAgICBiYXJzMlxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDIpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS5iYXJcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsaW5lczJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQyKVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmICFkYXRhW2ldLmJhclxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdmFyIGJhcnMyV3JhcCA9IGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhQmFycy5sZW5ndGggPyBkYXRhQmFycyA6IFtcbiAgICAgICAgICAgICAgICAgICAge3ZhbHVlczogW119XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgbGluZXMyV3JhcCA9IGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYtbGluZXNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oYWxsRGlzYWJsZWQoZGF0YUxpbmVzKSA/XG4gICAgICAgICAgICAgICAgICAgICAgIFt7dmFsdWVzOiBbXX1dIDpcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxpbmVzLmZpbHRlcihmdW5jdGlvbihkYXRhTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZGF0YUxpbmUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyAoIGF2YWlsYWJsZUhlaWdodDEgKyBtYXJnaW4uYm90dG9tICsgbWFyZ2luMi50b3ApICsgJyknKTtcblxuICAgICAgICAgICAgYmFyczJXcmFwLnRyYW5zaXRpb24oKS5jYWxsKGJhcnMyKTtcbiAgICAgICAgICAgIGxpbmVzMldyYXAudHJhbnNpdGlvbigpLmNhbGwobGluZXMyKTtcblxuICAgICAgICAgICAgLy8gY29udGV4dCAoZm9jdXMgY2hhcnQpIGF4aXMgY29udHJvbHNcbiAgICAgICAgICAgIGlmIChmb2N1c1Nob3dBeGlzWCkge1xuICAgICAgICAgICAgICAgIHgyQXhpc1xuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoIC8gMTAwLCBkYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKC1hdmFpbGFibGVIZWlnaHQyLCAwKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkzLnJhbmdlKClbMF0gKyAnKScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHgyQXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb2N1c1Nob3dBeGlzWSkge1xuICAgICAgICAgICAgICAgIHkzQXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeTMpXG4gICAgICAgICAgICAgICAgICAgIC5fdGlja3MoIGF2YWlsYWJsZUhlaWdodDIgLyAzNiApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICB5NEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHk0KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBhdmFpbGFibGVIZWlnaHQyIC8gMzYgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoZGF0YUJhcnMubGVuZ3RoID8gMCA6IC1hdmFpbGFibGVXaWR0aCwgMCk7IC8vIFNob3cgdGhlIHkyIHJ1bGVzIG9ubHkgaWYgeTEgaGFzIG5vbmVcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udGV4dCAubnYteTMubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIGRhdGFCYXJzLmxlbmd0aCA/IDEgOiAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLCcgKyB4Mi5yYW5nZSgpWzBdICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRleHQgLm52LXkyLm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBkYXRhTGluZXMubGVuZ3RoID8gMSA6IDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyB4Mi5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15MS5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHkzQXhpcyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1jb250ZXh0IC5udi15Mi5udi1heGlzJykudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHk0QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIEJydXNoXG4gICAgICAgICAgICBicnVzaC54KHgyKS5vbignYnJ1c2gnLCBvbkJydXNoKTtcblxuICAgICAgICAgICAgaWYgKGJydXNoRXh0ZW50KSBicnVzaC5leHRlbnQoYnJ1c2hFeHRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgYnJ1c2hCRyA9IGcuc2VsZWN0KCcubnYtYnJ1c2hCYWNrZ3JvdW5kJykuc2VsZWN0QWxsKCdnJylcbiAgICAgICAgICAgICAgICAuZGF0YShbYnJ1c2hFeHRlbnQgfHwgYnJ1c2guZXh0ZW50KCldKTtcblxuICAgICAgICAgICAgdmFyIGJydXNoQkdlbnRlciA9IGJydXNoQkcuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2cnKTtcblxuICAgICAgICAgICAgYnJ1c2hCR2VudGVyLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xlZnQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuXG4gICAgICAgICAgICBicnVzaEJHZW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAncmlnaHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIDApXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuXG4gICAgICAgICAgICB2YXIgZ0JydXNoID0gZy5zZWxlY3QoJy5udi14Lm52LWJydXNoJylcbiAgICAgICAgICAgICAgICAuY2FsbChicnVzaCk7XG4gICAgICAgICAgICBnQnJ1c2guc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgICAgICAgICAvLy5hdHRyKCd5JywgLTUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodDIpO1xuICAgICAgICAgICAgZ0JydXNoLnNlbGVjdEFsbCgnLnJlc2l6ZScpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2QnLCByZXNpemVQYXRoKTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGRpc3BhdGNoLm9uKCdjaGFuZ2VTdGF0ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZS5kaXNhYmxlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgLy8gVGFrZW4gZnJvbSBjcm9zc2ZpbHRlciAoaHR0cDovL3NxdWFyZS5naXRodWIuY29tL2Nyb3NzZmlsdGVyLylcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2l6ZVBhdGgoZCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gKyhkID09ICdlJyksXG4gICAgICAgICAgICAgICAgICAgIHggPSBlID8gMSA6IC0xLFxuICAgICAgICAgICAgICAgICAgICB5ID0gYXZhaWxhYmxlSGVpZ2h0MiAvIDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNJyArICguNSAqIHgpICsgJywnICsgeVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICg2LjUgKiB4KSArICcsJyArICh5ICsgNilcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA2KVxuICAgICAgICAgICAgICAgICAgICArICdBNiw2IDAgMCAnICsgZSArICcgJyArICguNSAqIHgpICsgJywnICsgKDIgKiB5KVxuICAgICAgICAgICAgICAgICAgICArICdaJ1xuICAgICAgICAgICAgICAgICAgICArICdNJyArICgyLjUgKiB4KSArICcsJyArICh5ICsgOClcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KVxuICAgICAgICAgICAgICAgICAgICArICdNJyArICg0LjUgKiB4KSArICcsJyArICh5ICsgOClcbiAgICAgICAgICAgICAgICAgICAgKyAnVicgKyAoMiAqIHkgLSA4KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVCcnVzaEJHKCkge1xuICAgICAgICAgICAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkgYnJ1c2guZXh0ZW50KGJydXNoRXh0ZW50KTtcbiAgICAgICAgICAgICAgICBicnVzaEJHXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFticnVzaC5lbXB0eSgpID8geDIuZG9tYWluKCkgOiBicnVzaEV4dGVudF0pXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRXaWR0aCA9IHgyKGRbMF0pIC0geDIucmFuZ2UoKVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodFdpZHRoID0geDIucmFuZ2UoKVsxXSAtIHgyKGRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgnLmxlZnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsICBsZWZ0V2lkdGggPCAwID8gMCA6IGxlZnRXaWR0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoJy5yaWdodCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCB4MihkWzFdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCByaWdodFdpZHRoIDwgMCA/IDAgOiByaWdodFdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uQnJ1c2goKSB7XG4gICAgICAgICAgICAgICAgYnJ1c2hFeHRlbnQgPSBicnVzaC5lbXB0eSgpID8gbnVsbCA6IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIGV4dGVudCA9IGJydXNoLmVtcHR5KCkgPyB4Mi5kb21haW4oKSA6IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmJydXNoKHtleHRlbnQ6IGV4dGVudCwgYnJ1c2g6IGJydXNofSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQnJ1c2hCRygpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSBNYWluIChGb2N1cykgQmFycyBhbmQgTGluZXNcbiAgICAgICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQxKVxuICAgICAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS5iYXIgfSkpO1xuXG4gICAgICAgICAgICAgICAgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodDEpXG4gICAgICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiAhZGF0YVtpXS5iYXIgfSkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvY3VzQmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi1iYXJzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bSghZGF0YUJhcnMubGVuZ3RoID8gW3t2YWx1ZXM6W119XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhQmFyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhcnMueCgpKGQsaSkgPj0gZXh0ZW50WzBdICYmIGJhcnMueCgpKGQsaSkgPD0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHZhciBmb2N1c0xpbmVzV3JhcCA9IGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LWxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShhbGxEaXNhYmxlZChkYXRhTGluZXMpID8gW3t2YWx1ZXM6W119XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZGF0YUxpbmUpIHsgcmV0dXJuICFkYXRhTGluZS5kaXNhYmxlZDsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBkLmFyZWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogZC5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBkLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogZC52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lcy54KCkoZCxpKSA+PSBleHRlbnRbMF0gJiYgbGluZXMueCgpKGQsaSkgPD0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBNYWluIChGb2N1cykgWCBBeGlzXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFCYXJzLmxlbmd0aCAmJiAhc3dpdGNoWUF4aXNPcmRlcikge1xuICAgICAgICAgICAgICAgICAgICB4ID0gYmFycy54U2NhbGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4ID0gbGluZXMueFNjYWxlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAgICAgLnNjYWxlKHgpXG4gICAgICAgICAgICAgICAgICAgIC5fdGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1goYXZhaWxhYmxlV2lkdGgvMTAwLCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0MSwgMCk7XG5cbiAgICAgICAgICAgICAgICB4QXhpcy5kb21haW4oW01hdGguY2VpbChleHRlbnRbMF0pLCBNYXRoLmZsb29yKGV4dGVudFsxXSldKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBCYXJzIGFuZCBMaW5lc1xuICAgICAgICAgICAgICAgIGZvY3VzQmFyc1dyYXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKHRyYW5zaXRpb25EdXJhdGlvbikuY2FsbChiYXJzKTtcbiAgICAgICAgICAgICAgICBmb2N1c0xpbmVzV3JhcC50cmFuc2l0aW9uKCkuZHVyYXRpb24odHJhbnNpdGlvbkR1cmF0aW9uKS5jYWxsKGxpbmVzKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldHVwIGFuZCBVcGRhdGUgTWFpbiAoRm9jdXMpIFkgQXhlc1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZm9jdXMgLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkxLnJhbmdlKClbMF0gKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgeTFBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh5MSlcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQxLzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApO1xuICAgICAgICAgICAgICAgIHkyQXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeTIpXG4gICAgICAgICAgICAgICAgICAgIC5fdGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0MS8zNiwgZGF0YSkgKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHkyIHJ1bGVzIG9ubHkgaWYgeTEgaGFzIG5vbmVcbiAgICAgICAgICAgICAgICBpZighc3dpdGNoWUF4aXNPcmRlcikge1xuICAgICAgICAgICAgICAgICAgICB5MkF4aXMudGlja1NpemUoZGF0YUJhcnMubGVuZ3RoID8gMCA6IC1hdmFpbGFibGVXaWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeTJBeGlzLnRpY2tTaXplKGRhdGFMaW5lcy5sZW5ndGggPyAwIDogLWF2YWlsYWJsZVdpZHRoLCAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgb3BhY2l0eSBvZiB0aGUgYXhpc1xuICAgICAgICAgICAgICAgIHZhciBiYXJzT3BhY2l0eSA9IGRhdGFCYXJzLmxlbmd0aCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lc09wYWNpdHkgPSBkYXRhTGluZXMubGVuZ3RoICYmICFhbGxEaXNhYmxlZChkYXRhTGluZXMpID8gMSA6IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgeTFPcGFjaXR5ID0gc3dpdGNoWUF4aXNPcmRlciA/IGxpbmVzT3BhY2l0eSA6IGJhcnNPcGFjaXR5O1xuICAgICAgICAgICAgICAgIHZhciB5Mk9wYWNpdHkgPSBzd2l0Y2hZQXhpc09yZGVyID8gYmFyc09wYWNpdHkgOiBsaW5lc09wYWNpdHk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15MS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgeTFPcGFjaXR5KTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15Mi5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgeTJPcGFjaXR5KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeC5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteTEubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHkxQXhpcyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteTIubnYtYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbih0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHkyQXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uQnJ1c2goKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGxpbmVzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcbiAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExpbmVzQXhpcygpLm1haW4udGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kYXRhKGV2dClcbiAgICAgICAgICAgIC5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgbGluZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgfSk7XG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgZXZ0LnZhbHVlID0gY2hhcnQueCgpKGV2dC5kYXRhKTtcbiAgICAgICAgZXZ0WydzZXJpZXMnXSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkoZXZ0LmRhdGEpLFxuICAgICAgICAgICAgY29sb3I6IGV2dC5jb2xvclxuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwXG4gICAgICAgICAgICAuZHVyYXRpb24oMClcbiAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEJhcnNBeGlzKCkubWFpbi50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRhdGEoZXZ0KVxuICAgICAgICAgICAgLmhpZGRlbihmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBiYXJzLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwLmhpZGRlbih0cnVlKTtcbiAgICB9KTtcblxuICAgIGJhcnMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQubGluZXMgPSBsaW5lcztcbiAgICBjaGFydC5saW5lczIgPSBsaW5lczI7XG4gICAgY2hhcnQuYmFycyA9IGJhcnM7XG4gICAgY2hhcnQuYmFyczIgPSBiYXJzMjtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LngyQXhpcyA9IHgyQXhpcztcbiAgICBjaGFydC55MUF4aXMgPSB5MUF4aXM7XG4gICAgY2hhcnQueTJBeGlzID0geTJBeGlzO1xuICAgIGNoYXJ0LnkzQXhpcyA9IHkzQXhpcztcbiAgICBjaGFydC55NEF4aXMgPSB5NEF4aXM7XG4gICAgY2hhcnQudG9vbHRpcCA9IHRvb2x0aXA7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICBicnVzaEV4dGVudDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYnJ1c2hFeHRlbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXticnVzaEV4dGVudD1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBmb2N1c0VuYWJsZTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNFbmFibGU7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c0VuYWJsZT1fO319LFxuICAgICAgICBmb2N1c0hlaWdodDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNIZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c0hlaWdodD1fO319LFxuICAgICAgICBmb2N1c1Nob3dBeGlzWDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNTaG93QXhpc1g7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c1Nob3dBeGlzWD1fO319LFxuICAgICAgICBmb2N1c1Nob3dBeGlzWTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXNTaG93QXhpc1k7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1c1Nob3dBeGlzWT1fO319LFxuICAgICAgICBsZWdlbmRMZWZ0QXhpc0hpbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxlZ2VuZExlZnRBeGlzSGludDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xlZ2VuZExlZnRBeGlzSGludD1fO319LFxuICAgICAgICBsZWdlbmRSaWdodEF4aXNIaW50OiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsZWdlbmRSaWdodEF4aXNIaW50O30sIHNldDogZnVuY3Rpb24oXyl7bGVnZW5kUmlnaHRBeGlzSGludD1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGlmIChfLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IF8udG9wO1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IF8udG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZm9jdXNNYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjI7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbjIudG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luMi50b3A7XG4gICAgICAgICAgICBtYXJnaW4yLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbjIucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4yLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbjIuYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luMi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4yLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdHJhbnNpdGlvbkR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSBfO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRYID0gXztcbiAgICAgICAgICAgIGxpbmVzLngoXyk7XG4gICAgICAgICAgICBsaW5lczIueChfKTtcbiAgICAgICAgICAgIGJhcnMueChfKTtcbiAgICAgICAgICAgIGJhcnMyLngoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRZID0gXztcbiAgICAgICAgICAgIGxpbmVzLnkoXyk7XG4gICAgICAgICAgICBsaW5lczIueShfKTtcbiAgICAgICAgICAgIGJhcnMueShfKTtcbiAgICAgICAgICAgIGJhcnMyLnkoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBzd2l0Y2hZQXhpc09yZGVyOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzd2l0Y2hZQXhpc09yZGVyO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICAvLyBTd2l0Y2ggdGhlIHRpY2sgZm9ybWF0IGZvciB0aGUgeUF4aXNcbiAgICAgICAgICAgIGlmKHN3aXRjaFlBeGlzT3JkZXIgIT09IF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgeTEgPSB5MUF4aXM7XG4gICAgICAgICAgICAgICAgeTFBeGlzID0geTJBeGlzO1xuICAgICAgICAgICAgICAgIHkyQXhpcyA9IHkxO1xuXG4gICAgICAgICAgICAgICAgdmFyIHkzID0geTNBeGlzO1xuICAgICAgICAgICAgICAgIHkzQXhpcyA9IHk0QXhpcztcbiAgICAgICAgICAgICAgICB5NEF4aXMgPSB5MztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaFlBeGlzT3JkZXI9XztcblxuICAgICAgICAgICAgeTFBeGlzLm9yaWVudCgnbGVmdCcpO1xuICAgICAgICAgICAgeTJBeGlzLm9yaWVudCgncmlnaHQnKTtcbiAgICAgICAgICAgIHkzQXhpcy5vcmllbnQoJ2xlZnQnKTtcbiAgICAgICAgICAgIHk0QXhpcy5vcmllbnQoJ3JpZ2h0Jyk7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgbGluZXMpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5tdWx0aUJhciA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDk2MFxuICAgICAgICAsIGhlaWdodCA9IDUwMFxuICAgICAgICAsIHggPSBkMy5zY2FsZS5vcmRpbmFsKClcbiAgICAgICAgLCB5ID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgY29udGFpbmVyID0gbnVsbFxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGZvcmNlWSA9IFswXSAvLyAwIGlzIGZvcmNlZCBieSBkZWZhdWx0Li4gdGhpcyBtYWtlcyBzZW5zZSBmb3IgdGhlIG1ham9yaXR5IG9mIGJhciBncmFwaHMuLi4gdXNlciBjYW4gYWx3YXlzIGRvIGNoYXJ0LmZvcmNlWShbXSkgdG8gcmVtb3ZlXG4gICAgICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgICAgICwgc3RhY2tlZCA9IGZhbHNlXG4gICAgICAgICwgc3RhY2tPZmZzZXQgPSAnemVybycgLy8gb3B0aW9ucyBpbmNsdWRlICdzaWxob3VldHRlJywgJ3dpZ2dsZScsICdleHBhbmQnLCAnemVybycsIG9yIGEgY3VzdG9tIGZ1bmN0aW9uXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIGhpZGVhYmxlID0gZmFsc2VcbiAgICAgICAgLCBiYXJDb2xvciA9IG51bGwgLy8gYWRkaW5nIHRoZSBhYmlsaXR5IHRvIHNldCB0aGUgY29sb3IgZm9yIGVhY2ggcmF0aGVyIHRoYW4gdGhlIHdob2xlIGdyb3VwXG4gICAgICAgICwgZGlzYWJsZWQgLy8gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGJhckNvbG9yIHRvIGNvbW11bmljYXRlIGZyb20gbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQgd2hhdCBzZXJpZXMgYXJlIGRpc2FibGVkXG4gICAgICAgICwgZHVyYXRpb24gPSA1MDBcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGdyb3VwU3BhY2luZyA9IDAuMVxuICAgICAgICAsIGZpbGxPcGFjaXR5ID0gMC43NVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ2NoYXJ0Q2xpY2snLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnREYmxDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdlbGVtZW50TW91c2Vtb3ZlJywgJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MCAvL3VzZWQgdG8gc3RvcmUgcHJldmlvdXMgc2NhbGVzXG4gICAgICAgICwgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pXG4gICAgICAgIDtcblxuICAgIHZhciBsYXN0X2RhdGFsZW5ndGggPSAwO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBub25TdGFja2FibGVDb3VudCA9IDA7XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGRlZmluZXMgdGhlIHJlcXVpcmVtZW50cyBmb3IgcmVuZGVyIGNvbXBsZXRlXG4gICAgICAgICAgICB2YXIgZW5kRm4gPSBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQuc2VyaWVzID09PSBkYXRhLmxlbmd0aCAtIDEgJiYgaSA9PT0gZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYoaGlkZWFibGUgJiYgZGF0YS5sZW5ndGgpIGhpZGVhYmxlID0gW3tcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGRhdGFbMF0udmFsdWVzLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMC4wMVxuICAgICAgICAgICAgICAgICAgICAgICAgfTt9XG4gICAgICAgICAgICAgICAgKX1dO1xuXG4gICAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgICAgICAub2Zmc2V0KHN0YWNrT2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICAudmFsdWVzKGZ1bmN0aW9uKGQpeyByZXR1cm4gZC52YWx1ZXMgfSlcbiAgICAgICAgICAgICAgICAgICAgLnkoZ2V0WSlcbiAgICAgICAgICAgICAgICAoIWRhdGEubGVuZ3RoICYmIGhpZGVhYmxlID8gaGlkZWFibGUgOiBkYXRhKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSl7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHNlcmllcyBpcyBub24tc3RhY2thYmxlLCB1c2UgdW4tcGFyc2VkIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllcy5ub25TdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0ubm9uU3RhY2thYmxlU2VyaWVzID0gbm9uU3RhY2thYmxlQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFtpXSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzdGFjayB0aGlzIHNlaXJlcyBvbiB0b3Agb2YgdGhlIG5vblN0YWNrYWJsZSBzZXJpZWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgcGFyc2VkW2kgLSAxXS5ub25TdGFja2FibGUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFtpXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsail7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQueTAgLT0gcGFyc2VkW2kgLSAxXS52YWx1ZXNbal0ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZC55MSA9IGQueTAgKyBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkYXRhID0gcGFyc2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9hZGQgc2VyaWVzIGluZGV4IGFuZCBrZXkgdG8gZWFjaCBkYXRhIHBvaW50IGZvciByZWZlcmVuY2VcbiAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICBzZXJpZXMudmFsdWVzLmZvckVhY2goZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQuc2VyaWVzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQua2V5ID0gc2VyaWVzLmtleTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBIQUNLIGZvciBuZWdhdGl2ZSB2YWx1ZSBzdGFja2luZ1xuICAgICAgICAgICAgaWYgKHN0YWNrZWQgJiYgZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGF0YVswXS52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zQmFzZSA9IDAsIG5lZ0Jhc2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLm1hcChmdW5jdGlvbihkLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtpZHhdLm5vblN0YWNrYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gZC52YWx1ZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnNpemUgPSBNYXRoLmFicyhmLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLnk8MCkgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi55MSA9IG5lZ0Jhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZ0Jhc2UgPSBuZWdCYXNlIC0gZi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi55MSA9IGYuc2l6ZSArIHBvc0Jhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc0Jhc2UgPSBwb3NCYXNlICsgZi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4pID8gW10gOiAvLyBpZiB3ZSBrbm93IHhEb21haW4gYW5kIHlEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCwgaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBnZXRYKGQsaSksIHk6IGdldFkoZCxpKSwgeTA6IGQueTAsIHkxOiBkLnkxLCBpZHg6aWR4IH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgeC5kb21haW4oeERvbWFpbiB8fCBkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0pKVxuICAgICAgICAgICAgICAgIC5yYW5nZUJhbmRzKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdLCBncm91cFNwYWNpbmcpO1xuXG4gICAgICAgICAgICB5LmRvbWFpbih5RG9tYWluIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXNEYXRhKS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIHZhciBkb21haW4gPSBkLnk7XG4gICAgICAgICAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGRvbWFpbiByYW5nZSBpZiB0aGlzIHNlcmllcyBpcyBzdGFja2FibGVcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZCAmJiAhZGF0YVtkLmlkeF0ubm9uU3RhY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkLnkgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9IGQueTFcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbiA9IGQueTEgKyBkLnlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tYWluO1xuICAgICAgICAgICAgfSkuY29uY2F0KGZvcmNlWSkpKVxuICAgICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG5cbiAgICAgICAgICAgIC8vIElmIHNjYWxlJ3MgZG9tYWluIGRvbid0IGhhdmUgYSByYW5nZSwgc2xpZ2h0bHkgYWRqdXN0IHRvIG1ha2Ugb25lLi4uIHNvIGEgY2hhcnQgY2FuIHNob3cgYSBzaW5nbGUgZGF0YSBwb2ludFxuICAgICAgICAgICAgaWYgKHguZG9tYWluKClbMF0gPT09IHguZG9tYWluKClbMV0pXG4gICAgICAgICAgICAgICAgeC5kb21haW4oKVswXSA/XG4gICAgICAgICAgICAgICAgICAgIHguZG9tYWluKFt4LmRvbWFpbigpWzBdIC0geC5kb21haW4oKVswXSAqIDAuMDEsIHguZG9tYWluKClbMV0gKyB4LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgICAgICAgICAgIDogeC5kb21haW4oWy0xLDFdKTtcblxuICAgICAgICAgICAgaWYgKHkuZG9tYWluKClbMF0gPT09IHkuZG9tYWluKClbMV0pXG4gICAgICAgICAgICAgICAgeS5kb21haW4oKVswXSA/XG4gICAgICAgICAgICAgICAgICAgIHkuZG9tYWluKFt5LmRvbWFpbigpWzBdICsgeS5kb21haW4oKVswXSAqIDAuMDEsIHkuZG9tYWluKClbMV0gLSB5LmRvbWFpbigpWzFdICogMC4wMV0pXG4gICAgICAgICAgICAgICAgICAgIDogeS5kb21haW4oWy0xLDFdKTtcblxuICAgICAgICAgICAgeDAgPSB4MCB8fCB4O1xuICAgICAgICAgICAgeTAgPSB5MCB8fCB5O1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGliYXInKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aWJhcicpO1xuICAgICAgICAgICAgdmFyIGRlZnNFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2RlZnMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1lZGdlLWNsaXAtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGcuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1lZGdlLWNsaXAtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgZ3JvdXBzID0gd3JhcC5zZWxlY3QoJy5udi1ncm91cHMnKS5zZWxlY3RBbGwoJy5udi1ncm91cCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9LCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSk7XG4gICAgICAgICAgICBncm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG5cbiAgICAgICAgICAgIHZhciBleGl0VHJhbnNpdGlvbiA9IHJlbmRlcldhdGNoXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3JlY3QubnYtYmFyJyksICdtdWx0aWJhckV4aXQnLCBNYXRoLm1pbigxMDAsIGR1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsIGksIGopIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlWYWwgPSB5MCgwKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbZC5zZXJpZXNdICYmICFkYXRhW2Quc2VyaWVzXS5ub25TdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VmFsID0geTAoZC55MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlWYWw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAoZXhpdFRyYW5zaXRpb24uZGVsYXkpXG4gICAgICAgICAgICAgICAgZXhpdFRyYW5zaXRpb24uZGVsYXkoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxheSA9IGkgKiAoZHVyYXRpb24gLyAobGFzdF9kYXRhbGVuZ3RoICsgMSkpIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGF5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiAnbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2hvdmVyJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5ob3ZlciB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKXsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBmaWxsT3BhY2l0eSk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzID0gZ3JvdXBzLnNlbGVjdEFsbCgncmVjdC5udi1iYXInKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIChoaWRlYWJsZSAmJiAhZGF0YS5sZW5ndGgpID8gaGlkZWFibGUudmFsdWVzIDogZC52YWx1ZXMgfSk7XG4gICAgICAgICAgICBiYXJzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdmFyIGJhcnNFbnRlciA9IGJhcnMuZW50ZXIoKS5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAnbnYtYmFyIG5lZ2F0aXZlJyA6ICdudi1iYXIgcG9zaXRpdmUnfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgJiYgIWRhdGFbal0ubm9uU3RhY2thYmxlID8gMCA6IChqICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoIClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4geTAoc3RhY2tlZCAmJiAhZGF0YVtqXS5ub25TdGFja2FibGUgPyBkLnkwIDogMCkgfHwgMCB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIHgucmFuZ2VCYW5kKCkgLyAoc3RhY2tlZCAmJiAhZGF0YVtqXS5ub25TdGFja2FibGUgPyAxIDogZGF0YS5sZW5ndGgpIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsMCknOyB9KVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIGJhcnNcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGksail7IHJldHVybiBjb2xvcihkLCBqLCBpKTsgIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGksail7IHJldHVybiBjb2xvcihkLCBqLCBpKTsgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGQsaSkgeyAvL1RPRE86IGZpZ3VyZSBvdXQgd2h5IGogd29ya3MgYWJvdmUsIGJ1dCBub3QgaGVyZVxuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdkYmxjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdudi1iYXIgbmVnYXRpdmUnIDogJ252LWJhciBwb3NpdGl2ZSd9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsMCknOyB9KVxuXG4gICAgICAgICAgICBpZiAoYmFyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVkKSBkaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBiYXJzXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBkMy5yZ2IoYmFyQ29sb3IoZCxpKSkuZGFya2VyKCAgZGlzYWJsZWQubWFwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKXsgcmV0dXJuICFkaXNhYmxlZFtpXSAgfSlbal0gICApLnRvU3RyaW5nKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpLGopIHsgcmV0dXJuIGQzLnJnYihiYXJDb2xvcihkLGkpKS5kYXJrZXIoICBkaXNhYmxlZC5tYXAoZnVuY3Rpb24oZCxpKSB7IHJldHVybiBpIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpeyByZXR1cm4gIWRpc2FibGVkW2ldICB9KVtqXSAgICkudG9TdHJpbmcoKTsgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYXJTZWxlY3Rpb24gPVxuICAgICAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXInLCBNYXRoLm1pbigyNTAsIGR1cmF0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgLmRlbGF5KGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKiBkdXJhdGlvbiAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3RhY2tlZCl7XG4gICAgICAgICAgICAgICAgYmFyU2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5VmFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHN0YWNrYWJsZSwgc3RhY2sgaXQgb24gdG9wIG9mIHRoZSBwcmV2aW91cyBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YVtqXS5ub25TdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VmFsID0geShkLnkxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldFkoZCxpKSA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5VmFsID0geSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeSgwKSAtIHkoZ2V0WShkLGkpKSA8IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlWYWwgPSB5KDApIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlWYWwgPSB5KGdldFkoZCwgaSkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geVZhbDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbal0ubm9uU3RhY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGguYWJzKHkoZC55K2QueTApIC0geShkLnkwKSksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnMoeShnZXRZKGQsaSkpIC0geSgwKSksIDApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtqXS5ub25TdGFja2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGQuc2VyaWVzICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gbm9uU3RhY2thYmxlQ291bnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IGRhdGFbal0ubm9uU3RhY2thYmxlU2VyaWVzICogeC5yYW5nZUJhbmQoKS8obm9uU3RhY2thYmxlQ291bnQqMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbihkLGksail7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFbal0ubm9uU3RhY2thYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgucmFuZ2VCYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGFsbCBzZXJpZXMgYXJlIG5vblN0YWNhYmxlLCB0YWtlIHRoZSBmdWxsIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gKHgucmFuZ2VCYW5kKCkgLyBub25TdGFja2FibGVDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBub25TdGFja2FibGUgZ3JhcGggd2lsbCBiZSBvbmx5IHRha2luZyB0aGUgaGFsZi13aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB4IHJhbmdlQmFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gbm9uU3RhY2thYmxlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSB4LnJhbmdlQmFuZCgpLyhub25TdGFja2FibGVDb3VudCoyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhclNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuc2VyaWVzICogeC5yYW5nZUJhbmQoKSAvIGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0WShkLGkpIDwgMCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSgwKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkoMCkgLSB5KGdldFkoZCxpKSkgPCAxID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5KDApIC0gMSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeShnZXRZKGQsaSkpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSwxKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICAgICAgICB4MCA9IHguY29weSgpO1xuICAgICAgICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbGFzdCBkYXRhIHZhbHVlIGxlbmd0aCBmb3IgdHJhbnNpdGlvbiBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYmIGRhdGFbMF0udmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgbGFzdF9kYXRhbGVuZ3RoID0gZGF0YVswXS52YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbXVsdGliYXIgaW1tZWRpYXRlJyk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHg6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFg7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRYPV87fX0sXG4gICAgICAgIHk6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPV87fX0sXG4gICAgICAgIHhTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHg7fSwgc2V0OiBmdW5jdGlvbihfKXt4PV87fX0sXG4gICAgICAgIHlTY2FsZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHhEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9yY2VZO30sIHNldDogZnVuY3Rpb24oXyl7Zm9yY2VZPV87fX0sXG4gICAgICAgIHN0YWNrZWQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YWNrZWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzdGFja2VkPV87fX0sXG4gICAgICAgIHN0YWNrT2Zmc2V0OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFja09mZnNldDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWNrT2Zmc2V0PV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwRWRnZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBFZGdlPV87fX0sXG4gICAgICAgIGRpc2FibGVkOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkaXNhYmxlZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2Rpc2FibGVkPV87fX0sXG4gICAgICAgIGlkOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIGhpZGVhYmxlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoaWRlYWJsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hpZGVhYmxlPV87fX0sXG4gICAgICAgIGdyb3VwU3BhY2luZzp7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBncm91cFNwYWNpbmc7fSwgc2V0OiBmdW5jdGlvbihfKXtncm91cFNwYWNpbmc9Xzt9fSxcbiAgICAgICAgZmlsbE9wYWNpdHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZpbGxPcGFjaXR5O30sIHNldDogZnVuY3Rpb24oXyl7ZmlsbE9wYWNpdHk9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGJhckNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYmFyQ29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGJhckNvbG9yID0gXyA/IG52LnV0aWxzLmdldENvbG9yKF8pIDogbnVsbDtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5udi5tb2RlbHMubXVsdGlCYXJDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbXVsdGliYXIgPSBudi5tb2RlbHMubXVsdGlCYXIoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGludGVyYWN0aXZlTGF5ZXIgPSBudi5pbnRlcmFjdGl2ZUd1aWRlbGluZSgpXG4gICAgICAgICwgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCB0b29sdGlwID0gbnYubW9kZWxzLnRvb2x0aXAoKVxuICAgICAgICA7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiA1MCwgbGVmdDogNjB9XG4gICAgICAgICwgbWFyZ2luVG9wID0gbnVsbFxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgc2hvd0NvbnRyb2xzID0gdHJ1ZVxuICAgICAgICAsIGNvbnRyb2xMYWJlbHMgPSB7fVxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgc2hvd1hBeGlzID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHJlZHVjZVhUaWNrcyA9IHRydWUgLy8gaWYgZmFsc2UgYSB0aWNrIHdpbGwgc2hvdyBmb3IgZXZlcnkgZGF0YSBwb2ludFxuICAgICAgICAsIHN0YWdnZXJMYWJlbHMgPSBmYWxzZVxuICAgICAgICAsIHdyYXBMYWJlbHMgPSBmYWxzZVxuICAgICAgICAsIHJvdGF0ZUxhYmVscyA9IDBcbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIGNvbnRyb2xXaWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc2hvd0NvbnRyb2xzID8gMTgwIDogMCB9XG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IGZhbHNlXG4gICAgICAgIDtcblxuICAgIHN0YXRlLnN0YWNrZWQgPSBmYWxzZSAvLyBERVBSRUNBVEVEIE1haW50YWluZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuICAgIG11bHRpYmFyLnN0YWNrZWQoZmFsc2UpO1xuICAgIHhBeGlzXG4gICAgICAgIC5vcmllbnQoJ2JvdHRvbScpXG4gICAgICAgIC50aWNrUGFkZGluZyg3KVxuICAgICAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KChyaWdodEFsaWduWUF4aXMpID8gJ3JpZ2h0JyA6ICdsZWZ0JylcbiAgICAgICAgLnRpY2tGb3JtYXQoZDMuZm9ybWF0KCcsLjFmJykpXG4gICAgO1xuXG4gICAgdG9vbHRpcFxuICAgICAgICAuZHVyYXRpb24oMClcbiAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5oZWFkZXJGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSk7XG5cbiAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiBkID09IG51bGwgPyBcIk4vQVwiIDogeUF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KVxuICAgICAgICAuaGVhZGVyRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pO1xuXG4gICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQgPT0gbnVsbCA/IFwiTi9BXCIgOiB5QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5oZWFkZXJGb3JtYXR0ZXIoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB4QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pO1xuXG4gICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KTtcblxuICAgIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuICAgIHZhciBzdGFja2VkID0gZmFsc2U7XG5cbiAgICB2YXIgc3RhdGVHZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLFxuICAgICAgICAgICAgICAgIHN0YWNrZWQ6IHN0YWNrZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0YXRlU2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zdGFja2VkICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgc3RhY2tlZCA9IHN0YXRlLnN0YWNrZWQ7XG4gICAgICAgICAgICBpZiAoc3RhdGUuYWN0aXZlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhtdWx0aWJhcik7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZVxuICAgICAgICAgICAgICAgIC5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gREVQUkVDQVRFRCBzZXQgc3RhdGUuZGlzYWJsZWRkaXNhYmxlZFxuICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG5cbiAgICAgICAgICAgIGlmICghZGVmYXVsdFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVba2V5XSBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEaXNwbGF5IG5vRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBtdWx0aWJhci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBtdWx0aWJhci55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LW11bHRpQmFyV2l0aExlZ2VuZCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LW11bHRpQmFyV2l0aExlZ2VuZCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFyc1dyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtY29udHJvbHNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaW50ZXJhY3RpdmUnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoIXNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKS5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoKCkpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjb250cm9sV2lkdGgoKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2xzXG4gICAgICAgICAgICBpZiAoIXNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICB7IGtleTogY29udHJvbExhYmVscy5ncm91cGVkIHx8ICdHcm91cGVkJywgZGlzYWJsZWQ6IG11bHRpYmFyLnN0YWNrZWQoKSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGtleTogY29udHJvbExhYmVscy5zdGFja2VkIHx8ICdTdGFja2VkJywgZGlzYWJsZWQ6ICFtdWx0aWJhci5zdGFja2VkKCkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9scy53aWR0aChjb250cm9sV2lkdGgoKSkuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoY29udHJvbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG4gICAgICAgICAgICBpZiAocmlnaHRBbGlnbllBeGlzKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCIubnYteS5udi1heGlzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgYXZhaWxhYmxlV2lkdGggKyBcIiwwKVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcbiAgICAgICAgICAgIG11bHRpYmFyXG4gICAgICAgICAgICAgICAgLmRpc2FibGVkKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykgeyByZXR1cm4gc2VyaWVzLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcblxuXG4gICAgICAgICAgICB2YXIgYmFyc1dyYXAgPSBnLnNlbGVjdCgnLm52LWJhcnNXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpO1xuXG4gICAgICAgICAgICBiYXJzV3JhcC5jYWxsKG11bHRpYmFyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZUhlaWdodCwgMCk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXgubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIHkucmFuZ2UoKVswXSArICcpJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3QoJy5udi14Lm52LWF4aXMgPiBnJykuc2VsZWN0QWxsKCdnJyk7XG5cbiAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgnbGluZSwgdGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDEpXG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhZ2dlckxhYmVscykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0VHJhbnNsYXRlID0gZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCI7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWdnZXJVcCA9IDUsIHN0YWdnZXJEb3duID0gMTc7ICAvL3BpeGVscyB0byBzdGFnZ2VyIGJ5XG4gICAgICAgICAgICAgICAgICAgIC8vIElzc3VlICMxNDBcbiAgICAgICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKFwidGV4dFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSxqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICBnZXRUcmFuc2xhdGUoMCwgKGogJSAyID09IDAgPyBzdGFnZ2VyVXAgOiBzdGFnZ2VyRG93bikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsSW5CZXR3ZWVuVGlja3MgPSBkMy5zZWxlY3RBbGwoXCIubnYteC5udi1heGlzIC5udi13cmFwIGcgZyB0ZXh0XCIpWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoXCIubnYteC5udi1heGlzIC5udi1heGlzTWF4TWluIHRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2xhdGUoMCwgKGkgPT09IDAgfHwgdG90YWxJbkJldHdlZW5UaWNrcyAlIDIgIT09IDApID8gc3RhZ2dlckRvd24gOiBzdGFnZ2VyVXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHdyYXBMYWJlbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZy5zZWxlY3RBbGwoJy50aWNrIHRleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwobnYudXRpbHMud3JhcFRpY2tzLCBjaGFydC54QXhpcy5yYW5nZUJhbmQoKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlWFRpY2tzKVxuICAgICAgICAgICAgICAgICAgICB4VGlja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgJSBNYXRoLmNlaWwoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC8gKGF2YWlsYWJsZVdpZHRoIC8gMTAwKSkgIT09IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbCgndGV4dCwgbGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKTtcblxuICAgICAgICAgICAgICAgIGlmKHJvdGF0ZUxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgeFRpY2tzXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCcudGljayB0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAncm90YXRlKCcgKyByb3RhdGVMYWJlbHMgKyAnIDAsMCknKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIHJvdGF0ZUxhYmVscyA+IDAgPyAnc3RhcnQnIDogJ2VuZCcpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5zZWxlY3RBbGwoJ2cubnYtYXhpc01heE1pbiB0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vU2V0IHVwIGludGVyYWN0aXZlIGxheWVyXG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXJnaW4oe2xlZnQ6bWFyZ2luLmxlZnQsIHRvcDptYXJnaW4udG9wfSlcbiAgICAgICAgICAgICAgICAgICAgLnN2Z0NvbnRhaW5lcihjb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgIC54U2NhbGUoeCk7XG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoXCIubnYtaW50ZXJhY3RpdmVcIikuY2FsbChpbnRlcmFjdGl2ZUxheWVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkLmRpc2FibGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgY29udHJvbHNEYXRhID0gY29udHJvbHNEYXRhLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICAgIHMuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGQua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0dyb3VwZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnRyb2xMYWJlbHMuZ3JvdXBlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1N0YWNrZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbnRyb2xMYWJlbHMuc3RhY2tlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpYmFyLnN0YWNrZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gbXVsdGliYXIuc3RhY2tlZCgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuc3RhY2tlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVsdGliYXIuc3RhY2tlZChlLnN0YWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkID0gZS5zdGFja2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wb2ludFhWYWx1ZSA9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUG9pbnQsIHBvaW50SW5kZXgsIHBvaW50WExvY2F0aW9uLCB4VmFsdWUsIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuc2VyaWVzSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IHguZG9tYWluKCkuaW5kZXhPZihlLnBvaW50WFZhbHVlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gc2VyaWVzLnZhbHVlc1twb2ludEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeFZhbHVlID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUG9pbnQgPT09IHVuZGVmaW5lZCkgc2luZ2xlUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRYTG9jYXRpb24gPT09IHVuZGVmaW5lZCkgcG9pbnRYTG9jYXRpb24gPSBlLm1vdXNlWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc2VyaWVzLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihzZXJpZXMsc2VyaWVzLnNlcmllc0luZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogc2VyaWVzLnZhbHVlc1twb2ludEluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5yZW5kZXJHdWlkZUxpbmUocG9pbnRYTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbihcImVsZW1lbnRNb3VzZW91dFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci50b29sdGlwLmhpZGRlbih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG11bHRpYmFyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnZhbHVlID0gY2hhcnQueCgpKGV2dC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0WydzZXJpZXMnXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZXZ0LmRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYXJ0LnkoKShldnQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZXZ0LmNvbG9yXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuZGF0YShldnQpLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZS50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdtdWx0aWJhcmNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubXVsdGliYXIgPSBtdWx0aWJhcjtcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQuY29udHJvbHMgPSBjb250cm9scztcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzID0geUF4aXM7XG4gICAgY2hhcnQuc3RhdGUgPSBzdGF0ZTtcbiAgICBjaGFydC50b29sdGlwID0gdG9vbHRpcDtcbiAgICBjaGFydC5pbnRlcmFjdGl2ZUxheWVyID0gaW50ZXJhY3RpdmVMYXllcjtcblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIHNob3dDb250cm9sczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0NvbnRyb2xzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0NvbnRyb2xzPV87fX0sXG4gICAgICAgIGNvbnRyb2xMYWJlbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbnRyb2xMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtjb250cm9sTGFiZWxzPV87fX0sXG4gICAgICAgIHNob3dYQXhpczogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgcmVkdWNlWFRpY2tzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByZWR1Y2VYVGlja3M7fSwgc2V0OiBmdW5jdGlvbihfKXtyZWR1Y2VYVGlja3M9Xzt9fSxcbiAgICAgICAgcm90YXRlTGFiZWxzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByb3RhdGVMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtyb3RhdGVMYWJlbHM9Xzt9fSxcbiAgICAgICAgc3RhZ2dlckxhYmVsczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhZ2dlckxhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWdnZXJMYWJlbHM9Xzt9fSxcbiAgICAgICAgd3JhcExhYmVsczogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3cmFwTGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7d3JhcExhYmVscz0hIV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gXy50b3A7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gXy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIG11bHRpYmFyLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIHJpZ2h0QWxpZ25ZQXhpcyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IF87XG4gICAgICAgIH19LFxuICAgICAgICBiYXJDb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG11bHRpYmFyLmJhckNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtdWx0aWJhci5iYXJDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihmdW5jdGlvbihkLGkpIHtyZXR1cm4gZDMucmdiKCcjY2NjJykuZGFya2VyKGkgKiAxLjUpLnRvU3RyaW5nKCk7fSlcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBtdWx0aWJhcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLm11bHRpQmFySG9yaXpvbnRhbCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDk2MFxuICAgICAgICAsIGhlaWdodCA9IDUwMFxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCBjb250YWluZXIgPSBudWxsXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGdldFllcnIgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnlFcnIgfVxuICAgICAgICAsIGZvcmNlWSA9IFswXSAvLyAwIGlzIGZvcmNlZCBieSBkZWZhdWx0Li4gdGhpcyBtYWtlcyBzZW5zZSBmb3IgdGhlIG1ham9yaXR5IG9mIGJhciBncmFwaHMuLi4gdXNlciBjYW4gYWx3YXlzIGRvIGNoYXJ0LmZvcmNlWShbXSkgdG8gcmVtb3ZlXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIGJhckNvbG9yID0gbnVsbCAvLyBhZGRpbmcgdGhlIGFiaWxpdHkgdG8gc2V0IHRoZSBjb2xvciBmb3IgZWFjaCByYXRoZXIgdGhhbiB0aGUgd2hvbGUgZ3JvdXBcbiAgICAgICAgLCBkaXNhYmxlZCAvLyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYmFyQ29sb3IgdG8gY29tbXVuaWNhdGUgZnJvbSBtdWx0aUJhckhvcml6b250YWxDaGFydCB3aGF0IHNlcmllcyBhcmUgZGlzYWJsZWRcbiAgICAgICAgLCBzdGFja2VkID0gZmFsc2VcbiAgICAgICAgLCBzaG93VmFsdWVzID0gZmFsc2VcbiAgICAgICAgLCBzaG93QmFyTGFiZWxzID0gZmFsc2VcbiAgICAgICAgLCB2YWx1ZVBhZGRpbmcgPSA2MFxuICAgICAgICAsIGdyb3VwU3BhY2luZyA9IDAuMVxuICAgICAgICAsIGZpbGxPcGFjaXR5ID0gMC43NVxuICAgICAgICAsIHZhbHVlRm9ybWF0ID0gZDMuZm9ybWF0KCcsLjJmJylcbiAgICAgICAgLCBkZWxheSA9IDEyMDBcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ2VsZW1lbnRNb3VzZW1vdmUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgeDAsIHkwOyAvL3VzZWQgdG8gc3RvcmUgcHJldmlvdXMgc2NhbGVzXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIG1hcmdpbi5sZWZ0IC0gbWFyZ2luLnJpZ2h0LFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tO1xuXG4gICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChzdGFja2VkKVxuICAgICAgICAgICAgICAgIGRhdGEgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgICAgICAub2Zmc2V0KCd6ZXJvJylcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlcyhmdW5jdGlvbihkKXsgcmV0dXJuIGQudmFsdWVzIH0pXG4gICAgICAgICAgICAgICAgICAgIC55KGdldFkpXG4gICAgICAgICAgICAgICAgKGRhdGEpO1xuXG4gICAgICAgICAgICAvL2FkZCBzZXJpZXMgaW5kZXggYW5kIGtleSB0byBlYWNoIGRhdGEgcG9pbnQgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5zZXJpZXMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5rZXkgPSBzZXJpZXMua2V5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEhBQ0sgZm9yIG5lZ2F0aXZlIHZhbHVlIHN0YWNraW5nXG4gICAgICAgICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgICAgICAgICBkYXRhWzBdLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NCYXNlID0gMCwgbmVnQmFzZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmID0gZC52YWx1ZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgIGYuc2l6ZSA9IE1hdGguYWJzKGYueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi55PDApICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi55MSA9IG5lZ0Jhc2UgLSBmLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVnQmFzZSA9IG5lZ0Jhc2UgLSBmLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLnkxID0gcG9zQmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NCYXNlID0gcG9zQmFzZSArIGYuc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgLy8gcmVtYXAgYW5kIGZsYXR0ZW4gdGhlIGRhdGEgZm9yIHVzZSBpbiBjYWxjdWxhdGluZyB0aGUgc2NhbGVzJyBkb21haW5zXG4gICAgICAgICAgICB2YXIgc2VyaWVzRGF0YSA9ICh4RG9tYWluICYmIHlEb21haW4pID8gW10gOiAvLyBpZiB3ZSBrbm93IHhEb21haW4gYW5kIHlEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgICAgZGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSksIHkwOiBkLnkwLCB5MTogZC55MSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHguZG9tYWluKHhEb21haW4gfHwgZDMubWVyZ2Uoc2VyaWVzRGF0YSkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9KSlcbiAgICAgICAgICAgICAgICAucmFuZ2VCYW5kcyh4UmFuZ2UgfHwgWzAsIGF2YWlsYWJsZUhlaWdodF0sIGdyb3VwU3BhY2luZyk7XG5cbiAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KGQzLm1lcmdlKHNlcmllc0RhdGEpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBzdGFja2VkID8gKGQueSA+IDAgPyBkLnkxICsgZC55IDogZC55MSApIDogZC55IH0pLmNvbmNhdChmb3JjZVkpKSlcblxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMgJiYgIXN0YWNrZWQpXG4gICAgICAgICAgICAgICAgeS5yYW5nZSh5UmFuZ2UgfHwgWyh5LmRvbWFpbigpWzBdIDwgMCA/IHZhbHVlUGFkZGluZyA6IDApLCBhdmFpbGFibGVXaWR0aCAtICh5LmRvbWFpbigpWzFdID4gMCA/IHZhbHVlUGFkZGluZyA6IDApIF0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHkucmFuZ2UoeVJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICB4MCA9IHgwIHx8IHg7XG4gICAgICAgICAgICB5MCA9IHkwIHx8IGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbih5LmRvbWFpbigpKS5yYW5nZShbeSgwKSx5KDApXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1tdWx0aWJhckhvcml6b250YWwnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aWJhckhvcml6b250YWwnKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZ3JvdXBzJyk7XG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHZhciBncm91cHMgPSB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7IHJldHVybiBkIH0sIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy5lbnRlcigpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KTtcbiAgICAgICAgICAgIGdyb3Vwcy5leGl0KCkud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBleGl0IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDFlLTYpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGdyb3Vwc1xuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWdyb3VwIG52LXNlcmllcy0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpeyByZXR1cm4gY29sb3IoZCwgaSkgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBjb2xvcihkLCBpKSB9KTtcbiAgICAgICAgICAgIGdyb3Vwcy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtdWx0aWJhcmhvcml6b250YWw6IGdyb3VwcycpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCBmaWxsT3BhY2l0eSk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzID0gZ3JvdXBzLnNlbGVjdEFsbCgnZy5udi1iYXInKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzIH0pO1xuICAgICAgICAgICAgYmFycy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzRW50ZXIgPSBiYXJzLmVudGVyKCkuYXBwZW5kKCdnJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpLGopIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHkwKHN0YWNrZWQgPyBkLnkwIDogMCkgKyAnLCcgKyAoc3RhY2tlZCA/IDAgOiAoaiAqIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aCApICsgeChnZXRYKGQsaSkpKSArICcpJ1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBiYXJzRW50ZXIuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAwKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB4LnJhbmdlQmFuZCgpIC8gKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpIClcblxuICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7IC8vVE9ETzogZmlndXJlIG91dCB3aHkgaiB3b3JrcyBhYm92ZSwgYnV0IG5vdCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlbW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGdldFllcnIoZGF0YVswXSwwKSkge1xuICAgICAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3BvbHlsaW5lJyk7XG5cbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdCgncG9seWxpbmUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3BvaW50cycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhlcnIgPSBnZXRZZXJyKGQsaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIG1pZCA9IDAuOCAqIHgucmFuZ2VCYW5kKCkgLyAoKHN0YWNrZWQgPyAxIDogZGF0YS5sZW5ndGgpICogMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ZXJyID0geGVyci5sZW5ndGggPyB4ZXJyIDogWy1NYXRoLmFicyh4ZXJyKSwgTWF0aC5hYnMoeGVycildO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGVyciA9IHhlcnIubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIHkoZSkgLSB5KDApOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW1t4ZXJyWzBdLC1taWRdLCBbeGVyclswXSxtaWRdLCBbeGVyclswXSwwXSwgW3hlcnJbMV0sMF0sIFt4ZXJyWzFdLC1taWRdLCBbeGVyclsxXSxtaWRdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5qb2luKCcsJykgfSkuam9pbignICcpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0geC5yYW5nZUJhbmQoKSAvICgoc3RhY2tlZCA/IDEgOiBkYXRhLmxlbmd0aCkgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyAoZ2V0WShkLGkpIDwgMCA/IDAgOiB5KGdldFkoZCxpKSkgLSB5KDApKSArICcsICcgKyBtaWQgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhcnNFbnRlci5hcHBlbmQoJ3RleHQnKTtcblxuICAgICAgICAgICAgaWYgKHNob3dWYWx1ZXMgJiYgIXN0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICBiYXJzLnNlbGVjdCgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gZ2V0WShkLGkpIDwgMCA/ICdlbmQnIDogJ3N0YXJ0JyB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIHgucmFuZ2VCYW5kKCkgLyAoZGF0YS5sZW5ndGggKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy4zMmVtJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IHZhbHVlRm9ybWF0KGdldFkoZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHllcnIgPSBnZXRZZXJyKGQsaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWVyciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF5ZXJyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArICfCsScgKyB2YWx1ZUZvcm1hdChNYXRoLmFicyh5ZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCArICcrJyArIHZhbHVlRm9ybWF0KE1hdGguYWJzKHllcnJbMV0pKSArICctJyArIHZhbHVlRm9ybWF0KE1hdGguYWJzKHllcnJbMF0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmFycy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdtdWx0aWJhcmhvcml6b250YWw6IGJhcnMnKVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0KCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAtNCA6IHkoZ2V0WShkLGkpKSAtIHkoMCkgKyA0IH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhcnMuc2VsZWN0QWxsKCd0ZXh0JykudGV4dCgnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93QmFyTGFiZWxzICYmICFzdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgYmFyc0VudGVyLmFwcGVuZCgndGV4dCcpLmNsYXNzZWQoJ252LWJhci1sYWJlbCcsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3QoJ3RleHQubnYtYmFyLWxhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBnZXRZKGQsaSkgPCAwID8gJ3N0YXJ0JyA6ICdlbmQnIH0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgeC5yYW5nZUJhbmQoKSAvIChkYXRhLmxlbmd0aCAqIDIpKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjMyZW0nKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFgoZCxpKSB9KTtcbiAgICAgICAgICAgICAgICBiYXJzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogYmFycycpXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3RleHQubnYtYmFyLWxhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyB5KDApIC0geShnZXRZKGQsaSkpICsgNCA6IC00IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFycy5zZWxlY3RBbGwoJ3RleHQubnYtYmFyLWxhYmVsJykudGV4dCgnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJhcnNcbiAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGdldFkoZCxpKSA8IDAgPyAnbnYtYmFyIG5lZ2F0aXZlJyA6ICdudi1iYXIgcG9zaXRpdmUnfSlcblxuICAgICAgICAgICAgaWYgKGJhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCkgZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIHRydWUgfSk7XG4gICAgICAgICAgICAgICAgYmFyc1xuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGksaikgeyByZXR1cm4gZDMucmdiKGJhckNvbG9yKGQsaSkpLmRhcmtlciggIGRpc2FibGVkLm1hcChmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGkgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSl7IHJldHVybiAhZGlzYWJsZWRbaV0gIH0pW2pdICAgKS50b1N0cmluZygpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiBkMy5yZ2IoYmFyQ29sb3IoZCxpKSkuZGFya2VyKCAgZGlzYWJsZWQubWFwKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gaSB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKXsgcmV0dXJuICFkaXNhYmxlZFtpXSAgfSlbal0gICApLnRvU3RyaW5nKCk7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhY2tlZClcbiAgICAgICAgICAgICAgICBiYXJzLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ211bHRpYmFyaG9yaXpvbnRhbDogYmFycycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB5KGQueTEpICsgJywnICsgeChnZXRYKGQsaSkpICsgJyknXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3QoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh5KGdldFkoZCxpKSArIGQueTApIC0geShkLnkwKSkgfHwgMFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgeC5yYW5nZUJhbmQoKSApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJhcnMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnbXVsdGliYXJob3Jpem9udGFsOiBiYXJzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBzdGFja2VkIG11c3QgYmUgYWxsIHBvc2l0aXZlIG9yIGFsbCBuZWdhdGl2ZSwgbm90IGJvdGg/XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2V0WShkLGkpIDwgMCA/IHkoZ2V0WShkLGkpKSA6IHkoMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkLnNlcmllcyAqIHgucmFuZ2VCYW5kKCkgLyBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgoZ2V0WChkLGkpKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNlbGVjdCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB4LnJhbmdlQmFuZCgpIC8gZGF0YS5sZW5ndGggKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSwxKSB8fCAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbXVsdGliYXJIb3Jpem9udGFsIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeDogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgeTogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFk9Xzt9fSxcbiAgICAgICAgeUVycjogICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WWVycjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFllcnI9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgeERvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geERvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hEb21haW49Xzt9fSxcbiAgICAgICAgeURvbWFpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geFJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eFJhbmdlPV87fX0sXG4gICAgICAgIHlSYW5nZTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lSYW5nZT1fO319LFxuICAgICAgICBmb3JjZVk6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgc3RhY2tlZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc3RhY2tlZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3N0YWNrZWQ9Xzt9fSxcbiAgICAgICAgc2hvd1ZhbHVlczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1ZhbHVlczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dWYWx1ZXM9Xzt9fSxcbiAgICAgICAgLy8gdGhpcyBzaG93cyB0aGUgZ3JvdXAgbmFtZSwgc2VlbXMgcG9pbnRsZXNzP1xuICAgICAgICAvL3Nob3dCYXJMYWJlbHM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dCYXJMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93QmFyTGFiZWxzPV87fX0sXG4gICAgICAgIGRpc2FibGVkOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZGlzYWJsZWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtkaXNhYmxlZD1fO319LFxuICAgICAgICBpZDogICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgdmFsdWVGb3JtYXQ6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB2YWx1ZUZvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3ZhbHVlRm9ybWF0PV87fX0sXG4gICAgICAgIHZhbHVlUGFkZGluZzoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gdmFsdWVQYWRkaW5nO30sIHNldDogZnVuY3Rpb24oXyl7dmFsdWVQYWRkaW5nPV87fX0sXG4gICAgICAgIGdyb3VwU3BhY2luZzoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ3JvdXBTcGFjaW5nO30sIHNldDogZnVuY3Rpb24oXyl7Z3JvdXBTcGFjaW5nPV87fX0sXG4gICAgICAgIGZpbGxPcGFjaXR5OiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZmlsbE9wYWNpdHk7fSwgc2V0OiBmdW5jdGlvbihfKXtmaWxsT3BhY2l0eT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgYmFyQ29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBiYXJDb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgYmFyQ29sb3IgPSBfID8gbnYudXRpbHMuZ2V0Q29sb3IoXykgOiBudWxsO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcblxubnYubW9kZWxzLm11bHRpQmFySG9yaXpvbnRhbENoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtdWx0aWJhciA9IG52Lm1vZGVscy5tdWx0aUJhckhvcml6b250YWwoKVxuICAgICAgICAsIHhBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKS5oZWlnaHQoMzApXG4gICAgICAgICwgY29udHJvbHMgPSBudi5tb2RlbHMubGVnZW5kKCkuaGVpZ2h0KDMwKVxuICAgICAgICAsIHRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA2MH1cbiAgICAgICAgLCBtYXJnaW5Ub3AgPSBudWxsXG4gICAgICAgICwgd2lkdGggPSBudWxsXG4gICAgICAgICwgaGVpZ2h0ID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzaG93Q29udHJvbHMgPSB0cnVlXG4gICAgICAgICwgY29udHJvbExhYmVscyA9IHt9XG4gICAgICAgICwgc2hvd0xlZ2VuZCA9IHRydWVcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHN0YWNrZWQgPSBmYWxzZVxuICAgICAgICAsIHggLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnhTY2FsZSgpXG4gICAgICAgICwgeSAvL2NhbiBiZSBhY2Nlc3NlZCB2aWEgY2hhcnQueVNjYWxlKClcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gbnVsbFxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywncmVuZGVyRW5kJylcbiAgICAgICAgLCBjb250cm9sV2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNob3dDb250cm9scyA/IDE4MCA6IDAgfVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIHN0YXRlLnN0YWNrZWQgPSBmYWxzZTsgLy8gREVQUkVDQVRFRCBNYWludGFpbmVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICBtdWx0aWJhci5zdGFja2VkKHN0YWNrZWQpO1xuXG4gICAgeEF4aXNcbiAgICAgICAgLm9yaWVudCgnbGVmdCcpXG4gICAgICAgIC50aWNrUGFkZGluZyg1KVxuICAgICAgICAuc2hvd01heE1pbihmYWxzZSlcbiAgICAgICAgLnRpY2tGb3JtYXQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KVxuICAgIDtcbiAgICB5QXhpc1xuICAgICAgICAub3JpZW50KCdib3R0b20nKVxuICAgICAgICAudGlja0Zvcm1hdChkMy5mb3JtYXQoJywuMWYnKSlcbiAgICA7XG5cbiAgICB0b29sdGlwXG4gICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KTtcblxuICAgIGNvbnRyb2xzLnVwZGF0ZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBzdGFja2VkOiBzdGFja2VkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2tlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBzdGF0ZS5zdGFja2VkO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoLCBkdXJhdGlvbik7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKG11bHRpYmFyKTtcbiAgICAgICAgaWYgKHNob3dYQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHhBeGlzKTtcbiAgICAgICAgaWYgKHNob3dZQXhpcykgcmVuZGVyV2F0Y2gubW9kZWxzKHlBeGlzKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG5cbiAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKGNoYXJ0KSB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhY2tlZCA9IG11bHRpYmFyLnN0YWNrZWQoKTtcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkZGlzYWJsZWRcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbnYudXRpbHMubm9EYXRhKGNoYXJ0LCBjb250YWluZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeCA9IG11bHRpYmFyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IG11bHRpYmFyLnlTY2FsZSgpLmNsYW1wKHRydWUpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtbXVsdGlCYXJIb3Jpem9udGFsQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1tdWx0aUJhckhvcml6b250YWxDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJylcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtemVyb0xpbmUnKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ2xpbmUnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1iYXJzV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoIXNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKS5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoKCkpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBjb250cm9sV2lkdGgoKSArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRyb2xzXG4gICAgICAgICAgICBpZiAoIXNob3dDb250cm9scykge1xuICAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHNEYXRhID0gW1xuICAgICAgICAgICAgICAgICAgICB7IGtleTogY29udHJvbExhYmVscy5ncm91cGVkIHx8ICdHcm91cGVkJywgZGlzYWJsZWQ6IG11bHRpYmFyLnN0YWNrZWQoKSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGtleTogY29udHJvbExhYmVscy5zdGFja2VkIHx8ICdTdGFja2VkJywgZGlzYWJsZWQ6ICFtdWx0aWJhci5zdGFja2VkKCkgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9scy53aWR0aChjb250cm9sV2lkdGgoKSkuY29sb3IoWycjNDQ0JywgJyM0NDQnLCAnIzQ0NCddKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJylcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwoY29udHJvbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICBtdWx0aWJhclxuICAgICAgICAgICAgICAgIC5kaXNhYmxlZChkYXRhLm1hcChmdW5jdGlvbihzZXJpZXMpIHsgcmV0dXJuIHNlcmllcy5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIHZhciBiYXJzV3JhcCA9IGcuc2VsZWN0KCcubnYtYmFyc1dyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSk7XG5cbiAgICAgICAgICAgIGJhcnNXcmFwLnRyYW5zaXRpb24oKS5jYWxsKG11bHRpYmFyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8yNCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJykuY2FsbCh4QXhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgeFRpY2tzID0gZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKS5zZWxlY3RBbGwoJ2cnKTtcblxuICAgICAgICAgICAgICAgIHhUaWNrc1xuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdsaW5lLCB0ZXh0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteS5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgYXZhaWxhYmxlSGVpZ2h0ICsgJyknKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LXkubnYtYXhpcycpLmNhbGwoeUF4aXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBaZXJvIGxpbmVcbiAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXplcm9MaW5lIGxpbmVcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcIngxXCIsIHkoMCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ4MlwiLCB5KDApKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwieTFcIiwgMClcbiAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIC1hdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnRyb2xzLmRpc3BhdGNoLm9uKCdsZWdlbmRDbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGlmICghZC5kaXNhYmxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgICBzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZC5kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdHcm91cGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb250cm9sTGFiZWxzLmdyb3VwZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdTdGFja2VkJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBjb250cm9sTGFiZWxzLnN0YWNrZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RhY2tlZCA9IG11bHRpYmFyLnN0YWNrZWQoKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgc3RhY2tlZCA9IG11bHRpYmFyLnN0YWNrZWQoKTtcblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGUuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5zdGFja2VkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aWJhci5zdGFja2VkKGUuc3RhY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrZWQgPSBlLnN0YWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrZWQgPSBlLnN0YWNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnbXVsdGliYXIgaG9yaXpvbnRhbCBjaGFydCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKG91dCBvZiBjaGFydCdzIHNjb3BlKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBtdWx0aWJhci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGV2dC52YWx1ZSA9IGNoYXJ0LngoKShldnQuZGF0YSk7XG4gICAgICAgIGV2dFsnc2VyaWVzJ10gPSB7XG4gICAgICAgICAgICBrZXk6IGV2dC5kYXRhLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiBjaGFydC55KCkoZXZ0LmRhdGEpLFxuICAgICAgICAgICAgY29sb3I6IGV2dC5jb2xvclxuICAgICAgICB9O1xuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpO1xuICAgIH0pO1xuXG4gICAgbXVsdGliYXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5tdWx0aWJhciA9IG11bHRpYmFyO1xuICAgIGNoYXJ0LmxlZ2VuZCA9IGxlZ2VuZDtcbiAgICBjaGFydC5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5zdGF0ZSA9IHN0YXRlO1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgc2hvd0NvbnRyb2xzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93Q29udHJvbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93Q29udHJvbHM9Xzt9fSxcbiAgICAgICAgY29udHJvbExhYmVsczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udHJvbExhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NvbnRyb2xMYWJlbHM9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dYQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dYQXhpcz1fO319LFxuICAgICAgICBzaG93WUF4aXM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBub0RhdGE6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGlmIChfLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IF8udG9wO1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IF8udG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBtdWx0aWJhci5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB4QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB5QXhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGJhckNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbXVsdGliYXIuYmFyQ29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG11bHRpYmFyLmJhckNvbG9yKF8pO1xuICAgICAgICAgICAgbGVnZW5kLmNvbG9yKGZ1bmN0aW9uKGQsaSkge3JldHVybiBkMy5yZ2IoJyNjY2MnKS5kYXJrZXIoaSAqIDEuNSkudG9TdHJpbmcoKTt9KVxuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIG11bHRpYmFyKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLm11bHRpQ2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfSxcbiAgICAgICAgbWFyZ2luVG9wID0gbnVsbCxcbiAgICAgICAgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKSxcbiAgICAgICAgd2lkdGggPSBudWxsLFxuICAgICAgICBoZWlnaHQgPSBudWxsLFxuICAgICAgICBzaG93TGVnZW5kID0gdHJ1ZSxcbiAgICAgICAgbm9EYXRhID0gbnVsbCxcbiAgICAgICAgeURvbWFpbjEsXG4gICAgICAgIHlEb21haW4yLFxuICAgICAgICBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0sXG4gICAgICAgIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnl9LFxuICAgICAgICBpbnRlcnBvbGF0ZSA9ICdsaW5lYXInLFxuICAgICAgICB1c2VWb3Jvbm9pID0gdHJ1ZSxcbiAgICAgICAgaW50ZXJhY3RpdmVMYXllciA9IG52LmludGVyYWN0aXZlR3VpZGVsaW5lKCksXG4gICAgICAgIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gZmFsc2UsXG4gICAgICAgIGxlZ2VuZFJpZ2h0QXhpc0hpbnQgPSAnIChyaWdodCBheGlzKScsXG4gICAgICAgIGR1cmF0aW9uID0gMjUwXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKSxcbiAgICAgICAgeVNjYWxlMSA9IGQzLnNjYWxlLmxpbmVhcigpLFxuICAgICAgICB5U2NhbGUyID0gZDMuc2NhbGUubGluZWFyKCksXG5cbiAgICAgICAgbGluZXMxID0gbnYubW9kZWxzLmxpbmUoKS55U2NhbGUoeVNjYWxlMSkuZHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgICBsaW5lczIgPSBudi5tb2RlbHMubGluZSgpLnlTY2FsZSh5U2NhbGUyKS5kdXJhdGlvbihkdXJhdGlvbiksXG5cbiAgICAgICAgc2NhdHRlcnMxID0gbnYubW9kZWxzLnNjYXR0ZXIoKS55U2NhbGUoeVNjYWxlMSkuZHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgICBzY2F0dGVyczIgPSBudi5tb2RlbHMuc2NhdHRlcigpLnlTY2FsZSh5U2NhbGUyKS5kdXJhdGlvbihkdXJhdGlvbiksXG5cbiAgICAgICAgYmFyczEgPSBudi5tb2RlbHMubXVsdGlCYXIoKS5zdGFja2VkKGZhbHNlKS55U2NhbGUoeVNjYWxlMSkuZHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgICBiYXJzMiA9IG52Lm1vZGVscy5tdWx0aUJhcigpLnN0YWNrZWQoZmFsc2UpLnlTY2FsZSh5U2NhbGUyKS5kdXJhdGlvbihkdXJhdGlvbiksXG5cbiAgICAgICAgc3RhY2sxID0gbnYubW9kZWxzLnN0YWNrZWRBcmVhKCkueVNjYWxlKHlTY2FsZTEpLmR1cmF0aW9uKGR1cmF0aW9uKSxcbiAgICAgICAgc3RhY2syID0gbnYubW9kZWxzLnN0YWNrZWRBcmVhKCkueVNjYWxlKHlTY2FsZTIpLmR1cmF0aW9uKGR1cmF0aW9uKSxcblxuICAgICAgICB4QXhpcyA9IG52Lm1vZGVscy5heGlzKCkuc2NhbGUoeCkub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg1KS5kdXJhdGlvbihkdXJhdGlvbiksXG4gICAgICAgIHlBeGlzMSA9IG52Lm1vZGVscy5heGlzKCkuc2NhbGUoeVNjYWxlMSkub3JpZW50KCdsZWZ0JykuZHVyYXRpb24oZHVyYXRpb24pLFxuICAgICAgICB5QXhpczIgPSBudi5tb2RlbHMuYXhpcygpLnNjYWxlKHlTY2FsZTIpLm9yaWVudCgncmlnaHQnKS5kdXJhdGlvbihkdXJhdGlvbiksXG5cbiAgICAgICAgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpLmhlaWdodCgzMCksXG4gICAgICAgIHRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpLFxuICAgICAgICBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCk7XG5cbiAgICB2YXIgY2hhcnRzID0gW2xpbmVzMSwgbGluZXMyLCBzY2F0dGVyczEsIHNjYXR0ZXJzMiwgYmFyczEsIGJhcnMyLCBzdGFjazEsIHN0YWNrMl07XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuY2FsbChjaGFydCk7IH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBudi51dGlscy5hdmFpbGFibGVXaWR0aCh3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgdmFyIGRhdGFMaW5lczEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnbGluZScgJiYgZC55QXhpcyA9PSAxfSk7XG4gICAgICAgICAgICB2YXIgZGF0YUxpbmVzMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdsaW5lJyAmJiBkLnlBeGlzID09IDJ9KTtcbiAgICAgICAgICAgIHZhciBkYXRhU2NhdHRlcnMxID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnR5cGUgPT0gJ3NjYXR0ZXInICYmIGQueUF4aXMgPT0gMX0pO1xuICAgICAgICAgICAgdmFyIGRhdGFTY2F0dGVyczIgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnc2NhdHRlcicgJiYgZC55QXhpcyA9PSAyfSk7XG4gICAgICAgICAgICB2YXIgZGF0YUJhcnMxID0gIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdiYXInICAmJiBkLnlBeGlzID09IDF9KTtcbiAgICAgICAgICAgIHZhciBkYXRhQmFyczIgPSAgZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnR5cGUgPT0gJ2JhcicgICYmIGQueUF4aXMgPT0gMn0pO1xuICAgICAgICAgICAgdmFyIGRhdGFTdGFjazEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7cmV0dXJuIGQudHlwZSA9PSAnYXJlYScgJiYgZC55QXhpcyA9PSAxfSk7XG4gICAgICAgICAgICB2YXIgZGF0YVN0YWNrMiA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC50eXBlID09ICdhcmVhJyAmJiBkLnlBeGlzID09IDJ9KTtcblxuICAgICAgICAgICAgLy8gRGlzcGxheSBub0RhdGEgbWVzc2FnZSBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2hvdy5cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5sZW5ndGggfHwgIWRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzLmxlbmd0aCB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBudi51dGlscy5ub0RhdGEoY2hhcnQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtbm9EYXRhJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXMxID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnlBeGlzID09IDF9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkKSwgeTogZ2V0WShkKSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBzZXJpZXMyID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiAhZC5kaXNhYmxlZCAmJiBkLnlBeGlzID09IDJ9KVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC52YWx1ZXMubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkKSwgeTogZ2V0WShkKSB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHggICAuZG9tYWluKGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMxLmNvbmNhdChzZXJpZXMyKSksIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueCB9KSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZVdpZHRoXSk7XG5cbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy53cmFwLm11bHRpQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3dyYXAgbnZkMyBtdWx0aUNoYXJ0JykuYXBwZW5kKCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi15MSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteTIgbnYtYXhpcycpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3N0YWNrMVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdzdGFjazJXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYmFyczFXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnYmFyczJXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnc2NhdHRlcnMxV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ3NjYXR0ZXJzMldyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdsaW5lczFXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbGluZXMyV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ2xlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1pbnRlcmFjdGl2ZScpO1xuXG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIHZhciBjb2xvcl9hcnJheSA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2ldLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKCFzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5sZWdlbmRXcmFwJykuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IGxlZ2VuZC5hbGlnbigpID8gYXZhaWxhYmxlV2lkdGggLyAyIDogYXZhaWxhYmxlV2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFhQb3NpdGlvbiA9IGxlZ2VuZC5hbGlnbigpID8gbGVnZW5kV2lkdGggOiAwO1xuXG4gICAgICAgICAgICAgICAgbGVnZW5kLndpZHRoKGxlZ2VuZFdpZHRoKTtcbiAgICAgICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3JfYXJyYXkpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEubWFwKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLm9yaWdpbmFsS2V5ID0gc2VyaWVzLm9yaWdpbmFsS2V5ID09PSB1bmRlZmluZWQgPyBzZXJpZXMua2V5IDogc2VyaWVzLm9yaWdpbmFsS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmtleSA9IHNlcmllcy5vcmlnaW5hbEtleSArIChzZXJpZXMueUF4aXMgPT0gMSA/ICcnIDogbGVnZW5kUmlnaHRBeGlzSGludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWVzO1xuICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmICghbWFyZ2luVG9wICYmIGxlZ2VuZC5oZWlnaHQoKSAhPT0gbWFyZ2luLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGxlZ2VuZFhQb3NpdGlvbiArICcsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmVzMVxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMSAmJiBkYXRhW2ldLnR5cGUgPT0gJ2xpbmUnfSkpO1xuICAgICAgICAgICAgbGluZXMyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5pbnRlcnBvbGF0ZShpbnRlcnBvbGF0ZSlcbiAgICAgICAgICAgICAgICAuY29sb3IoY29sb3JfYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgJiYgZGF0YVtpXS55QXhpcyA9PSAyICYmIGRhdGFbaV0udHlwZSA9PSAnbGluZSd9KSk7XG4gICAgICAgICAgICBzY2F0dGVyczFcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMSAmJiBkYXRhW2ldLnR5cGUgPT0gJ3NjYXR0ZXInfSkpO1xuICAgICAgICAgICAgc2NhdHRlcnMyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDIgJiYgZGF0YVtpXS50eXBlID09ICdzY2F0dGVyJ30pKTtcbiAgICAgICAgICAgIGJhcnMxXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDEgJiYgZGF0YVtpXS50eXBlID09ICdiYXInfSkpO1xuICAgICAgICAgICAgYmFyczJcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMiAmJiBkYXRhW2ldLnR5cGUgPT0gJ2Jhcid9KSk7XG4gICAgICAgICAgICBzdGFjazFcbiAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgLmludGVycG9sYXRlKGludGVycG9sYXRlKVxuICAgICAgICAgICAgICAgIC5jb2xvcihjb2xvcl9hcnJheS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCAmJiBkYXRhW2ldLnlBeGlzID09IDEgJiYgZGF0YVtpXS50eXBlID09ICdhcmVhJ30pKTtcbiAgICAgICAgICAgIHN0YWNrMlxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpXG4gICAgICAgICAgICAgICAgLmNvbG9yKGNvbG9yX2FycmF5LmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkICYmIGRhdGFbaV0ueUF4aXMgPT0gMiAmJiBkYXRhW2ldLnR5cGUgPT0gJ2FyZWEnfSkpO1xuXG4gICAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lczFXcmFwID0gZy5zZWxlY3QoJy5saW5lczFXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YUxpbmVzMS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuICFkLmRpc2FibGVkfSkpO1xuICAgICAgICAgICAgdmFyIHNjYXR0ZXJzMVdyYXAgPSBnLnNlbGVjdCgnLnNjYXR0ZXJzMVdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhU2NhdHRlcnMxLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KSk7XG4gICAgICAgICAgICB2YXIgYmFyczFXcmFwID0gZy5zZWxlY3QoJy5iYXJzMVdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhQmFyczEuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiAhZC5kaXNhYmxlZH0pKTtcbiAgICAgICAgICAgIHZhciBzdGFjazFXcmFwID0gZy5zZWxlY3QoJy5zdGFjazFXcmFwJylcbiAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YVN0YWNrMS5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuICFkLmRpc2FibGVkfSkpO1xuICAgICAgICAgICAgdmFyIGxpbmVzMldyYXAgPSBnLnNlbGVjdCgnLmxpbmVzMldyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhTGluZXMyLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KSk7XG4gICAgICAgICAgICB2YXIgc2NhdHRlcnMyV3JhcCA9IGcuc2VsZWN0KCcuc2NhdHRlcnMyV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGFTY2F0dGVyczIuZmlsdGVyKGZ1bmN0aW9uKGQpe3JldHVybiAhZC5kaXNhYmxlZH0pKTtcbiAgICAgICAgICAgIHZhciBiYXJzMldyYXAgPSBnLnNlbGVjdCgnLmJhcnMyV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGFCYXJzMi5maWx0ZXIoZnVuY3Rpb24oZCl7cmV0dXJuICFkLmRpc2FibGVkfSkpO1xuICAgICAgICAgICAgdmFyIHN0YWNrMldyYXAgPSBnLnNlbGVjdCgnLnN0YWNrMldyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhU3RhY2syLmZpbHRlcihmdW5jdGlvbihkKXtyZXR1cm4gIWQuZGlzYWJsZWR9KSk7XG5cbiAgICAgICAgICAgIHZhciBleHRyYVZhbHVlMSA9IGRhdGFTdGFjazEubGVuZ3RoID8gZGF0YVN0YWNrMS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uKGFWYWwsaSl7cmV0dXJuIHt4OiBhVmFsLngsIHk6IGFWYWwueSArIGJbaV0ueX19KVxuICAgICAgICAgICAgfSkuY29uY2F0KFt7eDowLCB5OjB9XSkgOiBbXTtcbiAgICAgICAgICAgIHZhciBleHRyYVZhbHVlMiA9IGRhdGFTdGFjazIubGVuZ3RoID8gZGF0YVN0YWNrMi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmFsdWVzfSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubWFwKGZ1bmN0aW9uKGFWYWwsaSl7cmV0dXJuIHt4OiBhVmFsLngsIHk6IGFWYWwueSArIGJbaV0ueX19KVxuICAgICAgICAgICAgfSkuY29uY2F0KFt7eDowLCB5OjB9XSkgOiBbXTtcblxuICAgICAgICAgICAgeVNjYWxlMSAuZG9tYWluKHlEb21haW4xIHx8IGQzLmV4dGVudChkMy5tZXJnZShzZXJpZXMxKS5jb25jYXQoZXh0cmFWYWx1ZTEpLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZShbMCwgYXZhaWxhYmxlSGVpZ2h0XSk7XG5cbiAgICAgICAgICAgIHlTY2FsZTIgLmRvbWFpbih5RG9tYWluMiB8fCBkMy5leHRlbnQoZDMubWVyZ2Uoc2VyaWVzMikuY29uY2F0KGV4dHJhVmFsdWUyKSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0gKSlcbiAgICAgICAgICAgICAgICAucmFuZ2UoWzAsIGF2YWlsYWJsZUhlaWdodF0pO1xuXG4gICAgICAgICAgICBsaW5lczEueURvbWFpbih5U2NhbGUxLmRvbWFpbigpKTtcbiAgICAgICAgICAgIHNjYXR0ZXJzMS55RG9tYWluKHlTY2FsZTEuZG9tYWluKCkpO1xuICAgICAgICAgICAgYmFyczEueURvbWFpbih5U2NhbGUxLmRvbWFpbigpKTtcbiAgICAgICAgICAgIHN0YWNrMS55RG9tYWluKHlTY2FsZTEuZG9tYWluKCkpO1xuXG4gICAgICAgICAgICBsaW5lczIueURvbWFpbih5U2NhbGUyLmRvbWFpbigpKTtcbiAgICAgICAgICAgIHNjYXR0ZXJzMi55RG9tYWluKHlTY2FsZTIuZG9tYWluKCkpO1xuICAgICAgICAgICAgYmFyczIueURvbWFpbih5U2NhbGUyLmRvbWFpbigpKTtcbiAgICAgICAgICAgIHN0YWNrMi55RG9tYWluKHlTY2FsZTIuZG9tYWluKCkpO1xuXG4gICAgICAgICAgICBpZihkYXRhU3RhY2sxLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihzdGFjazFXcmFwKS5jYWxsKHN0YWNrMSk7fVxuICAgICAgICAgICAgaWYoZGF0YVN0YWNrMi5sZW5ndGgpe2QzLnRyYW5zaXRpb24oc3RhY2syV3JhcCkuY2FsbChzdGFjazIpO31cblxuICAgICAgICAgICAgaWYoZGF0YUJhcnMxLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihiYXJzMVdyYXApLmNhbGwoYmFyczEpO31cbiAgICAgICAgICAgIGlmKGRhdGFCYXJzMi5sZW5ndGgpe2QzLnRyYW5zaXRpb24oYmFyczJXcmFwKS5jYWxsKGJhcnMyKTt9XG5cbiAgICAgICAgICAgIGlmKGRhdGFMaW5lczEubGVuZ3RoKXtkMy50cmFuc2l0aW9uKGxpbmVzMVdyYXApLmNhbGwobGluZXMxKTt9XG4gICAgICAgICAgICBpZihkYXRhTGluZXMyLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihsaW5lczJXcmFwKS5jYWxsKGxpbmVzMik7fVxuXG4gICAgICAgICAgICBpZihkYXRhU2NhdHRlcnMxLmxlbmd0aCl7ZDMudHJhbnNpdGlvbihzY2F0dGVyczFXcmFwKS5jYWxsKHNjYXR0ZXJzMSk7fVxuICAgICAgICAgICAgaWYoZGF0YVNjYXR0ZXJzMi5sZW5ndGgpe2QzLnRyYW5zaXRpb24oc2NhdHRlcnMyV3JhcCkuY2FsbChzY2F0dGVyczIpO31cblxuICAgICAgICAgICAgeEF4aXNcbiAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi14Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGF2YWlsYWJsZUhlaWdodCArICcpJyk7XG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteC5udi1heGlzJykpXG4gICAgICAgICAgICAgICAgLmNhbGwoeEF4aXMpO1xuXG4gICAgICAgICAgICB5QXhpczFcbiAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSkgKVxuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSggLWF2YWlsYWJsZVdpZHRoLCAwKTtcblxuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteTEubnYtYXhpcycpKVxuICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzMSk7XG5cbiAgICAgICAgICAgIHlBeGlzMlxuICAgICAgICAgICAgICAgIC5fdGlja3MoIG52LnV0aWxzLmNhbGNUaWNrc1koYXZhaWxhYmxlSGVpZ2h0LzM2LCBkYXRhKSApXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICBkMy50cmFuc2l0aW9uKGcuc2VsZWN0KCcubnYteTIubnYtYXhpcycpKVxuICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzMik7XG5cbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteTEubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ252LWRpc2FibGVkJywgc2VyaWVzMS5sZW5ndGggPyBmYWxzZSA6IHRydWUpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHgucmFuZ2UoKVswXSArICcsMCknKTtcblxuICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Mi5udi1heGlzJylcbiAgICAgICAgICAgICAgICAuY2xhc3NlZCgnbnYtZGlzYWJsZWQnLCBzZXJpZXMyLmxlbmd0aCA/IGZhbHNlIDogdHJ1ZSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeC5yYW5nZSgpWzFdICsgJywwKScpO1xuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZih1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSl7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllclxuICAgICAgICAgICAgICAgICAgICAud2lkdGgoYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAubWFyZ2luKHtsZWZ0Om1hcmdpbi5sZWZ0LCB0b3A6bWFyZ2luLnRvcH0pXG4gICAgICAgICAgICAgICAgICAgIC5zdmdDb250YWluZXIoY29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAueFNjYWxlKHgpO1xuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KFwiLm52LWludGVyYWN0aXZlXCIpLmNhbGwoaW50ZXJhY3RpdmVMYXllcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZ1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgZnVuY3Rpb24gbW91c2VvdmVyX2xpbmUoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHlheGlzID0gZGF0YVtldnQuc2VyaWVzSW5kZXhdLnlBeGlzID09PSAyID8geUF4aXMyIDogeUF4aXMxO1xuICAgICAgICAgICAgICAgIGV2dC52YWx1ZSA9IGV2dC5wb2ludC54O1xuICAgICAgICAgICAgICAgIGV2dC5zZXJpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBldnQucG9pbnQueSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGV2dC5wb2ludC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBldnQuc2VyaWVzLmtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMClcbiAgICAgICAgICAgICAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIFx0cmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5YXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGV2dClcbiAgICAgICAgICAgICAgICAgICAgLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdXNlb3Zlcl9zY2F0dGVyKGV2dCkge1xuICAgICAgICAgICAgICAgIHZhciB5YXhpcyA9IGRhdGFbZXZ0LnNlcmllc0luZGV4XS55QXhpcyA9PT0gMiA/IHlBeGlzMiA6IHlBeGlzMTtcbiAgICAgICAgICAgICAgICBldnQudmFsdWUgPSBldnQucG9pbnQueDtcbiAgICAgICAgICAgICAgICBldnQuc2VyaWVzID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXZ0LnBvaW50LnksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBldnQucG9pbnQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIGtleTogZXZ0LnNlcmllcy5rZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDEwMClcbiAgICAgICAgICAgICAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIFx0cmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5YXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGV2dClcbiAgICAgICAgICAgICAgICAgICAgLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdXNlb3Zlcl9zdGFjayhldnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeWF4aXMgPSBkYXRhW2V2dC5zZXJpZXNJbmRleF0ueUF4aXMgPT09IDIgPyB5QXhpczIgOiB5QXhpczE7XG4gICAgICAgICAgICAgICAgZXZ0LnBvaW50Wyd4J10gPSBzdGFjazEueCgpKGV2dC5wb2ludCk7XG4gICAgICAgICAgICAgICAgZXZ0LnBvaW50Wyd5J10gPSBzdGFjazEueSgpKGV2dC5wb2ludCk7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAuZHVyYXRpb24oMClcbiAgICAgICAgICAgICAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIFx0cmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5YXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKGV2dClcbiAgICAgICAgICAgICAgICAgICAgLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1vdXNlb3Zlcl9iYXIoZXZ0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHlheGlzID0gZGF0YVtldnQuZGF0YS5zZXJpZXNdLnlBeGlzID09PSAyID8geUF4aXMyIDogeUF4aXMxO1xuXG4gICAgICAgICAgICAgICAgZXZ0LnZhbHVlID0gYmFyczEueCgpKGV2dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBldnRbJ3NlcmllcyddID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYmFyczEueSgpKGV2dC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGV2dC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBldnQuZGF0YS5rZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDApXG4gICAgICAgICAgICAgICAgICAgIC5oZWFkZXJGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBcdHJldHVybiB4QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC52YWx1ZUZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShldnQpXG4gICAgICAgICAgICAgICAgICAgIC5oaWRkZW4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYXJIaWdobGlnaHRzKCkge1xuICAgICAgICAgICAgICBmb3IodmFyIGk9MCwgaWw9Y2hhcnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspe1xuICAgICAgICAgICAgICAgIHZhciBjaGFydCA9IGNoYXJ0c1tpXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY2hhcnQuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKXt9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gaGlnaGxpZ2h0UG9pbnQoc2VyaWVJbmRleCwgcG9pbnRJbmRleCwgYil7XG4gICAgICAgICAgICAgIGZvcih2YXIgaT0wLCBpbD1jaGFydHMubGVuZ3RoOyBpIDwgaWw7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXJ0ID0gY2hhcnRzW2ldO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjaGFydC5oaWdobGlnaHRQb2ludChzZXJpZUluZGV4LCBwb2ludEluZGV4LCBiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpe31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSl7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5nbGVQb2ludCwgcG9pbnRJbmRleCwgcG9pbnRYTG9jYXRpb24sIGFsbERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVudCA9IHguZG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlcyA9IHNlcmllcy52YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFydC54KCkoZCxpKSA+PSBleHRlbnRbMF0gJiYgY2hhcnQueCgpKGQsaSkgPD0gZXh0ZW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXggPSBudi5pbnRlcmFjdGl2ZUJpc2VjdChjdXJyZW50VmFsdWVzLCBlLnBvaW50WFZhbHVlLCBjaGFydC54KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gY3VycmVudFZhbHVlc1twb2ludEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludFlWYWx1ZSA9IGNoYXJ0LnkoKShwb2ludCwgcG9pbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRZVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRQb2ludChpLCBwb2ludEluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludCA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2luZ2xlUG9pbnQgPT09IHVuZGVmaW5lZCkgc2luZ2xlUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludFhMb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSBwb2ludFhMb2NhdGlvbiA9IHgoY2hhcnQueCgpKHBvaW50LHBvaW50SW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBzZXJpZXMua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwb2ludFlWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM6IHNlcmllcy55QXhpcyA9PSAyID8geUF4aXMyIDogeUF4aXMxXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZUZvcm1hdHRlciA9IGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlBeGlzID0gYWxsRGF0YVtpXS55QXhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkID09IG51bGwgPyBcIk4vQVwiIDogeUF4aXMudGlja0Zvcm1hdCgpKGQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsdWVGb3JtYXR0ZXIoaW50ZXJhY3RpdmVMYXllci50b29sdGlwLnZhbHVlRm9ybWF0dGVyKCkgfHwgZGVmYXVsdFZhbHVlRm9ybWF0dGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFydC54KCkoIHNpbmdsZVBvaW50LHBvaW50SW5kZXggKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogcG9pbnRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGFsbERhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5yZW5kZXJHdWlkZUxpbmUocG9pbnRYTG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbihcImVsZW1lbnRNb3VzZW91dFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgbW91c2VvdmVyX2xpbmUpO1xuICAgICAgICAgICAgICAgIGxpbmVzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgbW91c2VvdmVyX2xpbmUpO1xuICAgICAgICAgICAgICAgIGxpbmVzMS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsaW5lczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzY2F0dGVyczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIG1vdXNlb3Zlcl9zY2F0dGVyKTtcbiAgICAgICAgICAgICAgICBzY2F0dGVyczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIG1vdXNlb3Zlcl9zY2F0dGVyKTtcbiAgICAgICAgICAgICAgICBzY2F0dGVyczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NhdHRlcnMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGRlbih0cnVlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc3RhY2sxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBtb3VzZW92ZXJfc3RhY2spO1xuICAgICAgICAgICAgICAgIHN0YWNrMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgbW91c2VvdmVyX3N0YWNrKTtcbiAgICAgICAgICAgICAgICBzdGFjazEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhY2syLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGRlbih0cnVlKVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYmFyczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIG1vdXNlb3Zlcl9iYXIpO1xuICAgICAgICAgICAgICAgIGJhcnMyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBtb3VzZW92ZXJfYmFyKTtcblxuICAgICAgICAgICAgICAgIGJhcnMxLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmhpZGRlbih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXJzMi5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmFyczEuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmFyczIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEdsb2JhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LmxpbmVzMSA9IGxpbmVzMTtcbiAgICBjaGFydC5saW5lczIgPSBsaW5lczI7XG4gICAgY2hhcnQuc2NhdHRlcnMxID0gc2NhdHRlcnMxO1xuICAgIGNoYXJ0LnNjYXR0ZXJzMiA9IHNjYXR0ZXJzMjtcbiAgICBjaGFydC5iYXJzMSA9IGJhcnMxO1xuICAgIGNoYXJ0LmJhcnMyID0gYmFyczI7XG4gICAgY2hhcnQuc3RhY2sxID0gc3RhY2sxO1xuICAgIGNoYXJ0LnN0YWNrMiA9IHN0YWNrMjtcbiAgICBjaGFydC54QXhpcyA9IHhBeGlzO1xuICAgIGNoYXJ0LnlBeGlzMSA9IHlBeGlzMTtcbiAgICBjaGFydC55QXhpczIgPSB5QXhpczI7XG4gICAgY2hhcnQudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgY2hhcnQuaW50ZXJhY3RpdmVMYXllciA9IGludGVyYWN0aXZlTGF5ZXI7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBzaG93TGVnZW5kOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGVnZW5kO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xlZ2VuZD1fO319LFxuICAgICAgICB5RG9tYWluMTogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluMTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW4xPV87fX0sXG4gICAgICAgIHlEb21haW4yOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5RG9tYWluMjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW4yPV87fX0sXG4gICAgICAgIG5vRGF0YTogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIGludGVycG9sYXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcnBvbGF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVycG9sYXRlPV87fX0sXG4gICAgICAgIGxlZ2VuZFJpZ2h0QXhpc0hpbnQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxlZ2VuZFJpZ2h0QXhpc0hpbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXtsZWdlbmRSaWdodEF4aXNIaW50PV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gXy50b3A7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gXy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgeDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZ2V0WCA9IF87XG4gICAgICAgICAgICBsaW5lczEueChfKTtcbiAgICAgICAgICAgIGxpbmVzMi54KF8pO1xuICAgICAgICAgICAgc2NhdHRlcnMxLngoXyk7XG4gICAgICAgICAgICBzY2F0dGVyczIueChfKTtcbiAgICAgICAgICAgIGJhcnMxLngoXyk7XG4gICAgICAgICAgICBiYXJzMi54KF8pO1xuICAgICAgICAgICAgc3RhY2sxLngoXyk7XG4gICAgICAgICAgICBzdGFjazIueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGdldFkgPSBfO1xuICAgICAgICAgICAgbGluZXMxLnkoXyk7XG4gICAgICAgICAgICBsaW5lczIueShfKTtcbiAgICAgICAgICAgIHNjYXR0ZXJzMS55KF8pO1xuICAgICAgICAgICAgc2NhdHRlcnMyLnkoXyk7XG4gICAgICAgICAgICBzdGFjazEueShfKTtcbiAgICAgICAgICAgIHN0YWNrMi55KF8pO1xuICAgICAgICAgICAgYmFyczEueShfKTtcbiAgICAgICAgICAgIGJhcnMyLnkoXyk7XG4gICAgICAgIH19LFxuICAgICAgICB1c2VWb3Jvbm9pOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1c2VWb3Jvbm9pO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VWb3Jvbm9pPV87XG4gICAgICAgICAgICBsaW5lczEudXNlVm9yb25vaShfKTtcbiAgICAgICAgICAgIGxpbmVzMi51c2VWb3Jvbm9pKF8pO1xuICAgICAgICAgICAgc3RhY2sxLnVzZVZvcm9ub2koXyk7XG4gICAgICAgICAgICBzdGFjazIudXNlVm9yb25vaShfKTtcbiAgICAgICAgfX0sXG5cbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9IF87XG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaW5lczEuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxpbmVzMS51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsaW5lczIuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGxpbmVzMi51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzdGFjazEuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YWNrMS51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzdGFjazIuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YWNrMi51c2VWb3Jvbm9pKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzY2F0dGVyczEuaW50ZXJhY3RpdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNjYXR0ZXJzMi5pbnRlcmFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19LFxuXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIFtsaW5lczEsIGxpbmVzMiwgc3RhY2sxLCBzdGFjazIsIHNjYXR0ZXJzMSwgc2NhdHRlcnMyLCB4QXhpcywgeUF4aXMxLCB5QXhpczJdLmZvckVhY2goZnVuY3Rpb24obW9kZWwpe1xuICAgICAgICAgICAgICBtb2RlbC5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5vaGxjQmFyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgY29udGFpbmVyID0gbnVsbFxuICAgICAgICAsIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGdldE9wZW4gPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9wZW4gfVxuICAgICAgICAsIGdldENsb3NlID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jbG9zZSB9XG4gICAgICAgICwgZ2V0SGlnaCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaGlnaCB9XG4gICAgICAgICwgZ2V0TG93ID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5sb3cgfVxuICAgICAgICAsIGZvcmNlWCA9IFtdXG4gICAgICAgICwgZm9yY2VZID0gW11cbiAgICAgICAgLCBwYWREYXRhICAgICA9IGZhbHNlIC8vIElmIHRydWUsIGFkZHMgaGFsZiBhIGRhdGEgcG9pbnRzIHdpZHRoIHRvIGZyb250IGFuZCBiYWNrLCBmb3IgbGluaW5nIHVwIGEgbGluZSBjaGFydCB3aXRoIGEgYmFyIGNoYXJ0XG4gICAgICAgICwgY2xpcEVkZ2UgPSB0cnVlXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIGludGVyYWN0aXZlID0gZmFsc2VcbiAgICAgICAgLCB4RG9tYWluXG4gICAgICAgICwgeURvbWFpblxuICAgICAgICAsIHhSYW5nZVxuICAgICAgICAsIHlSYW5nZVxuICAgICAgICAsIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goJ3N0YXRlQ2hhbmdlJywgJ2NoYW5nZVN0YXRlJywgJ3JlbmRlckVuZCcsICdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAnZWxlbWVudE1vdXNlbW92ZScpXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vIG9obGMgYmFyIHdpZHRoLlxuICAgICAgICAgICAgdmFyIHcgPSAoYXZhaWxhYmxlV2lkdGggLyBkYXRhWzBdLnZhbHVlcy5sZW5ndGgpICogLjk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeC5kb21haW4oeERvbWFpbiB8fCBkMy5leHRlbnQoZGF0YVswXS52YWx1ZXMubWFwKGdldFgpLmNvbmNhdChmb3JjZVgpICkpO1xuXG4gICAgICAgICAgICBpZiAocGFkRGF0YSlcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbYXZhaWxhYmxlV2lkdGggKiAuNSAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCwgYXZhaWxhYmxlV2lkdGggKiAoZGF0YVswXS52YWx1ZXMubGVuZ3RoIC0gLjUpICAvIGRhdGFbMF0udmFsdWVzLmxlbmd0aCBdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4LnJhbmdlKHhSYW5nZSB8fCBbNSArIHcvMiwgYXZhaWxhYmxlV2lkdGggLSB3LzIgLSA1XSk7XG5cbiAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgW1xuICAgICAgICAgICAgICAgICAgICBkMy5taW4oZGF0YVswXS52YWx1ZXMubWFwKGdldExvdykuY29uY2F0KGZvcmNlWSkpLFxuICAgICAgICAgICAgICAgICAgICBkMy5tYXgoZGF0YVswXS52YWx1ZXMubWFwKGdldEhpZ2gpLmNvbmNhdChmb3JjZVkpKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICkucmFuZ2UoeVJhbmdlIHx8IFthdmFpbGFibGVIZWlnaHQsIDBdKTtcblxuICAgICAgICAgICAgLy8gSWYgc2NhbGUncyBkb21haW4gZG9uJ3QgaGF2ZSBhIHJhbmdlLCBzbGlnaHRseSBhZGp1c3QgdG8gbWFrZSBvbmUuLi4gc28gYSBjaGFydCBjYW4gc2hvdyBhIHNpbmdsZSBkYXRhIHBvaW50XG4gICAgICAgICAgICBpZiAoeC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeC5kb21haW4oW3guZG9tYWluKClbMF0gLSB4LmRvbWFpbigpWzBdICogMC4wMSwgeC5kb21haW4oKVsxXSArIHguZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB5LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0gKyB5LmRvbWFpbigpWzBdICogMC4wMSwgeS5kb21haW4oKVsxXSAtIHkuZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB5LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtb2hsY0JhcicpLmRhdGEoW2RhdGFbMF0udmFsdWVzXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1vaGxjQmFyJyk7XG4gICAgICAgICAgICB2YXIgZGVmc0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZGVmcycpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXRpY2tzJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlZnNFbnRlci5hcHBlbmQoJ2NsaXBQYXRoJylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdyZWN0Jyk7XG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtY2hhcnQtY2xpcC1wYXRoLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIGcgICAuYXR0cignY2xpcC1wYXRoJywgY2xpcEVkZ2UgPyAndXJsKCNudi1jaGFydC1jbGlwLXBhdGgtJyArIGlkICsgJyknIDogJycpO1xuXG4gICAgICAgICAgICB2YXIgdGlja3MgPSB3cmFwLnNlbGVjdCgnLm52LXRpY2tzJykuc2VsZWN0QWxsKCcubnYtdGljaycpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZCB9KTtcbiAgICAgICAgICAgIHRpY2tzLmV4aXQoKS5yZW1vdmUoKTtcblxuICAgICAgICAgICAgdGlja3MuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSxqKSB7IHJldHVybiAoZ2V0T3BlbihkLGkpID4gZ2V0Q2xvc2UoZCxpKSA/ICdudi10aWNrIG5lZ2F0aXZlJyA6ICdudi10aWNrIHBvc2l0aXZlJykgKyAnIG52LXRpY2stJyArIGogKyAnLScgKyBpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdtMCwwbDAsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeShnZXRPcGVuKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB5KGdldEhpZ2goZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoLXcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywwbCdcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKHcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywwbDAsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeShnZXRMb3coZCxpKSkgLSB5KGdldE9wZW4oZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldENsb3NlKGQsaSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLSB5KGdldExvdyhkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh3LzIpXG4gICAgICAgICAgICAgICAgICAgICAgICArICcsMGwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDB6JztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoZ2V0WChkLGkpKSArICcsJyArIHkoZ2V0SGlnaChkLGkpKSArICcpJzsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3JbMF07IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3JbMF07IH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwIClcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQsaSkgeyAgcmV0dXJuIHkoTWF0aC5tYXgoMCwgZ2V0WShkLGkpKSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBNYXRoLmFicyh5KGdldFkoZCxpKSkgLSB5KDApKSB9KTtcblxuICAgICAgICAgICAgLy8gdGhlIGJhciBjb2xvcnMgYXJlIGNvbnRyb2xsZWQgYnkgQ1NTIGN1cnJlbnRseVxuICAgICAgICAgICAgdGlja3MuYXR0cignY2xhc3MnLCBmdW5jdGlvbihkLGksaikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZ2V0T3BlbihkLGkpID4gZ2V0Q2xvc2UoZCxpKSA/ICdudi10aWNrIG5lZ2F0aXZlJyA6ICdudi10aWNrIHBvc2l0aXZlJykgKyAnIG52LXRpY2stJyArIGogKyAnLScgKyBpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24odGlja3MpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeChnZXRYKGQsaSkpICsgJywnICsgeShnZXRIaWdoKGQsaSkpICsgJyknOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3ID0gKGF2YWlsYWJsZVdpZHRoIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoKSAqIC45O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ20wLDBsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldE9wZW4oZCxpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHkoZ2V0SGlnaChkLGkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJ2wnXG4gICAgICAgICAgICAgICAgICAgICAgICArICgtdy8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAody8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsMCwnXG4gICAgICAgICAgICAgICAgICAgICAgICArICh5KGdldExvdyhkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0geShnZXRPcGVuKGQsaSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnbDAsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoeShnZXRDbG9zZShkLGkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0geShnZXRMb3coZCxpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICArICdsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAody8yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAnLDBsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAoLXcvMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJywweic7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cblxuICAgIC8vQ3JlYXRlIG1ldGhvZHMgdG8gYWxsb3cgb3V0c2lkZSBmdW5jdGlvbnMgdG8gaGlnaGxpZ2h0IGEgc3BlY2lmaWMgYmFyLlxuICAgIGNoYXJ0LmhpZ2hsaWdodFBvaW50ID0gZnVuY3Rpb24ocG9pbnRJbmRleCwgaXNIb3Zlck92ZXIpIHtcbiAgICAgICAgY2hhcnQuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3QoXCIubnYtb2hsY0JhciAubnYtdGljay0wLVwiICsgcG9pbnRJbmRleClcbiAgICAgICAgICAgIC5jbGFzc2VkKFwiaG92ZXJcIiwgaXNIb3Zlck92ZXIpXG4gICAgICAgIDtcbiAgICB9O1xuXG4gICAgY2hhcnQuY2xlYXJIaWdobGlnaHRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRhaW5lci5zZWxlY3QoXCIubnYtb2hsY0JhciAubnYtdGljay5ob3ZlclwiKVxuICAgICAgICAgICAgLmNsYXNzZWQoXCJob3ZlclwiLCBmYWxzZSlcbiAgICAgICAgO1xuICAgIH07XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICB4U2NhbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHhEb21haW46ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3lEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVJhbmdlO30sIHNldDogZnVuY3Rpb24oXyl7eVJhbmdlPV87fX0sXG4gICAgICAgIGZvcmNlWDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVg7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVg9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGZvcmNlWTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvcmNlWT1fO319LFxuICAgICAgICBwYWREYXRhOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcGFkRGF0YTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZERhdGE9Xzt9fSxcbiAgICAgICAgY2xpcEVkZ2U6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBFZGdlO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcEVkZ2U9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGlkO30sIHNldDogZnVuY3Rpb24oXyl7aWQ9Xzt9fSxcbiAgICAgICAgaW50ZXJhY3RpdmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGludGVyYWN0aXZlO30sIHNldDogZnVuY3Rpb24oXyl7aW50ZXJhY3RpdmU9Xzt9fSxcblxuICAgICAgICB4OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgeTogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRZPV87fX0sXG4gICAgICAgIG9wZW46ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRPcGVuKCk7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRPcGVuPV87fX0sXG4gICAgICAgIGNsb3NlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRDbG9zZSgpO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0Q2xvc2U9Xzt9fSxcbiAgICAgICAgaGlnaDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldEhpZ2g7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRIaWdoPV87fX0sXG4gICAgICAgIGxvdzogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRMb3c7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRMb3c9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuLy8gQ29kZSBhZGFwdGVkIGZyb20gSmFzb24gRGF2aWVzJyBcIlBhcmFsbGVsIENvb3JkaW5hdGVzXCJcbi8vIGh0dHA6Ly9ibC5vY2tzLm9yZy9qYXNvbmRhdmllcy8xMzQxMjgxXG5udi5tb2RlbHMucGFyYWxsZWxDb29yZGluYXRlcyA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAwLCBib3R0b206IDEwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBhdmFpbGFibGVXaWR0aCA9IG51bGxcbiAgICAgICAgLCBhdmFpbGFibGVIZWlnaHQgPSBudWxsXG4gICAgICAgICwgeCA9IGQzLnNjYWxlLm9yZGluYWwoKVxuICAgICAgICAsIHkgPSB7fVxuICAgICAgICAsIHVuZGVmaW5lZFZhbHVlc0xhYmVsID0gXCJ1bmRlZmluZWQgdmFsdWVzXCJcbiAgICAgICAgLCBkaW1lbnNpb25EYXRhID0gW11cbiAgICAgICAgLCBlbmFibGVkRGltZW5zaW9ucyA9IFtdXG4gICAgICAgICwgZGltZW5zaW9uTmFtZXMgPSBbXVxuICAgICAgICAsIGRpc3BsYXlCcnVzaCA9IHRydWVcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgZmlsdGVycyA9IFtdXG4gICAgICAgICwgYWN0aXZlID0gW11cbiAgICAgICAgLCBkcmFnZ2luZyA9IFtdXG4gICAgICAgICwgYXhpc1dpdGhVbmRlZmluZWRWYWx1ZXMgPSBbXVxuICAgICAgICAsIGxpbmVUZW5zaW9uID0gMVxuICAgICAgICAsIGZvcmVncm91bmRcbiAgICAgICAgLCBiYWNrZ3JvdW5kXG4gICAgICAgICwgZGltZW5zaW9uc1xuICAgICAgICAsIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAgICAgICwgYXhpcyA9IGQzLnN2Zy5heGlzKClcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdicnVzaHN0YXJ0JywgJ2JydXNoJywgJ2JydXNoRW5kJywgJ2RpbWVuc2lvbnNPcmRlcicsIFwic3RhdGVDaGFuZ2VcIiwgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdlbGVtZW50TW91c2Vtb3ZlJywgJ3JlbmRlckVuZCcsICdhY3RpdmVDaGFuZ2VkJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKTtcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgIC8vQ29udmVydCBvbGQgZGF0YSB0byBuZXcgZm9ybWF0IChuYW1lLCB2YWx1ZXMpXG4gICAgICAgICAgICBpZiAoZGF0YVswXS52YWx1ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhID0gW107XG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gT2JqZWN0LmtleXMoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBpZiAoayAhPT0gXCJuYW1lXCIpIHZhbFtrXSA9IGRba10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhLnB1c2goeyBrZXk6IGQubmFtZSwgdmFsdWVzOiB2YWwgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhVmFsdWVzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtyZXR1cm4gZC52YWx1ZXN9KTtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlID0gZGF0YTtcbiAgICAgICAgICAgIH07IC8vc2V0IGFsbCBhY3RpdmUgYmVmb3JlIGZpcnN0IGJydXNoIGNhbGxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXMgPSBkaW1lbnNpb25EYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY3VycmVudFBvc2l0aW9uIC0gYi5jdXJyZW50UG9zaXRpb247IH0pLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5rZXkgfSk7XG4gICAgICAgICAgICBlbmFibGVkRGltZW5zaW9ucyA9IGRpbWVuc2lvbkRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiAhZC5kaXNhYmxlZDsgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgeC5yYW5nZVBvaW50cyhbMCwgYXZhaWxhYmxlV2lkdGhdLCAxKS5kb21haW4oZW5hYmxlZERpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmtleTsgfSkpO1xuXG4gICAgICAgICAgICAvL1NldCBhcyB0cnVlIGlmIGFsbCB2YWx1ZXMgb24gYW4gYXhpcyBhcmUgbWlzc2luZy5cbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIGxpc3Qgb2YgZGltZW5zaW9ucyBhbmQgY3JlYXRlIGEgc2NhbGUgZm9yIGVhY2guXG4gICAgICAgICAgICB2YXIgb2xkRG9tYWluTWF4VmFsdWUgPSB7fTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5TWlzc2luZ1ZhbHVlc2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50VGlja3MgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZGltZW5zaW9uTmFtZXMuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChkYXRhVmFsdWVzLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gK3BbZF07IH0pO1xuICAgICAgICAgICAgICAgIHZhciBtaW4gPSBleHRlbnRbMF07XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IGV4dGVudFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgb25seVVuZGVmaW5lZFZhbHVlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vSWYgdGhlcmUgaXMgbm8gdmFsdWVzIHRvIGRpc3BsYXkgb24gYW4gYXhpcywgc2V0IHRoZSBleHRlbnQgdG8gMFxuICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW4pIHx8IGlzTmFOKG1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25seVVuZGVmaW5lZFZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vU2NhbGUgYXhpcyBpZiB0aGVyZSBpcyBvbmx5IG9uZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBtYXggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZiA9IGZpbHRlcnMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrLmRpbWVuc2lvbiA9PSBkOyB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyBvbmx5IE5hTiB2YWx1ZXMsIGtlZXAgdGhlIGV4aXN0aW5nIGRvbWFpbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlVbmRlZmluZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHlbZF0uZG9tYWluKClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB5W2RdLmRvbWFpbigpWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZSBicnVzaCBleHRlbnQgaXMgPiBtYXggKDwgbWluKSwga2VlcCB0aGUgZXh0ZW50IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghZlswXS5oYXNPbmx5TmFOICYmIGRpc3BsYXlCcnVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gbWluID4gZlswXS5leHRlbnRbMF0gPyBmWzBdLmV4dGVudFswXSA6IG1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IG1heCA8IGZbMF0uZXh0ZW50WzFdID8gZlswXS5leHRlbnRbMV0gOiBtYXg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlcmUgaXMgTmFOIHZhbHVlcyBicnVzaGVkIGJlIHN1cmUgdGhlIGJydXNoIGV4dGVudCBpcyBvbiB0aGUgZG9tYWluLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmWzBdLmhhc05hTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gbWF4IDwgZlswXS5leHRlbnRbMV0gPyBmWzBdLmV4dGVudFsxXSA6IG1heDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZERvbWFpbk1heFZhbHVlW2RdID0geVtkXS5kb21haW4oKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNaXNzaW5nVmFsdWVzbGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9Vc2UgOTAlIG9mIChhdmFpbGFibGVIZWlnaHQgLSAxMikgZm9yIHRoZSBheGlzIHJhbmdlLCAxMiByZXByZW5zZW50aW5nIHRoZSBzcGFjZSBuZWNlc3NhcnkgdG8gZGlzcGxheSBcInVuZGVmaW5lZCB2YWx1ZXNcIiB0ZXh0LlxuICAgICAgICAgICAgICAgIC8vVGhlIHJlbWFpbmluZyAxMCUgYXJlIHVzZWQgdG8gZGlzcGxheSB0aGUgbWlzc2luZ1ZhbHVlIGxpbmUuXG4gICAgICAgICAgICAgICAgeVtkXSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAgIC5kb21haW4oW21pbiwgbWF4XSlcbiAgICAgICAgICAgICAgICAgICAgLnJhbmdlKFsoYXZhaWxhYmxlSGVpZ2h0IC0gMTIpICogMC45LCAwXSk7XG5cbiAgICAgICAgICAgICAgICBheGlzV2l0aFVuZGVmaW5lZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHlbZF0uYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKS55KHlbZF0pLm9uKCdicnVzaHN0YXJ0JywgYnJ1c2hzdGFydCkub24oJ2JydXNoJywgYnJ1c2gpLm9uKCdicnVzaGVuZCcsIGJydXNoZW5kKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtcGFyYWxsZWxDb29yZGluYXRlcycpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXBhcmFsbGVsQ29vcmRpbmF0ZXMnKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1wYXJhbGxlbENvb3JkaW5hdGVzIGJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1wYXJhbGxlbENvb3JkaW5hdGVzIGZvcmVncm91bmQnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1wYXJhbGxlbENvb3JkaW5hdGVzIG1pc3NpbmdWYWx1ZXNsaW5lJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgbGluZS5pbnRlcnBvbGF0ZSgnY2FyZGluYWwnKS50ZW5zaW9uKGxpbmVUZW5zaW9uKTtcbiAgICAgICAgICAgIGF4aXMub3JpZW50KCdsZWZ0Jyk7XG4gICAgICAgICAgICB2YXIgYXhpc0RyYWcgPSBkMy5iZWhhdmlvci5kcmFnKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignZHJhZ3N0YXJ0JywgZHJhZ1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnJywgZHJhZ01vdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2RyYWdlbmQnLCBkcmFnRW5kKTtcblxuICAgICAgICAgICAgLy9BZGQgbWlzc2luZyB2YWx1ZSBsaW5lIGF0IHRoZSBib3R0b20gb2YgdGhlIGNoYXJ0XG4gICAgICAgICAgICB2YXIgbWlzc2luZ1ZhbHVlc2xpbmUsIG1pc3NpbmdWYWx1ZXNsaW5lVGV4dDtcbiAgICAgICAgICAgIHZhciBzdGVwID0geC5yYW5nZSgpWzFdIC0geC5yYW5nZSgpWzBdO1xuICAgICAgICAgICAgc3RlcCA9IGlzTmFOKHN0ZXApID8geC5yYW5nZSgpWzBdIDogc3RlcDtcbiAgICAgICAgICAgIGlmICghaXNOYU4oc3RlcCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZURhdGEgPSBbMCArIHN0ZXAgLyAyLCBhdmFpbGFibGVIZWlnaHQgLSAxMiwgYXZhaWxhYmxlV2lkdGggLSBzdGVwIC8gMiwgYXZhaWxhYmxlSGVpZ2h0IC0gMTJdO1xuICAgICAgICAgICAgICAgIG1pc3NpbmdWYWx1ZXNsaW5lID0gd3JhcC5zZWxlY3QoJy5taXNzaW5nVmFsdWVzbGluZScpLnNlbGVjdEFsbCgnbGluZScpLmRhdGEoW2xpbmVEYXRhXSk7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1ZhbHVlc2xpbmUuZW50ZXIoKS5hcHBlbmQoJ2xpbmUnKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZS5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgbWlzc2luZ1ZhbHVlc2xpbmUuYXR0cihcIngxXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMF07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkxXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMV07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcIngyXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMl07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInkyXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbM107IH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vQWRkIHRoZSB0ZXh0IFwidW5kZWZpbmVkIHZhbHVlc1wiIHVuZGVyIHRoZSBtaXNzaW5nIHZhbHVlIGxpbmVcbiAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZVRleHQgPSB3cmFwLnNlbGVjdCgnLm1pc3NpbmdWYWx1ZXNsaW5lJykuc2VsZWN0QWxsKCd0ZXh0JykuZGF0YShbdW5kZWZpbmVkVmFsdWVzTGFiZWxdKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZVRleHQuYXBwZW5kKCd0ZXh0JykuZGF0YShbdW5kZWZpbmVkVmFsdWVzTGFiZWxdKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZVRleHQuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKTtcbiAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZVRleHQuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIG1pc3NpbmdWYWx1ZXNsaW5lVGV4dC5hdHRyKFwieVwiLCBhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RvIGhhdmUgdGhlIHRleHQgcmlnaHQgYWxpZ24gd2l0aCB0aGUgbWlzc2luZ1ZhbHVlcyBsaW5lLCBzdWJzdHJhY3QgOTIgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IHNpemUuXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcInhcIiwgYXZhaWxhYmxlV2lkdGggLSA5MiAtIHN0ZXAgLyAyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgZ3JleSBiYWNrZ3JvdW5kIGxpbmVzIGZvciBjb250ZXh0LlxuICAgICAgICAgICAgYmFja2dyb3VuZCA9IHdyYXAuc2VsZWN0KCcuYmFja2dyb3VuZCcpLnNlbGVjdEFsbCgncGF0aCcpLmRhdGEoZGF0YSk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmVudGVyKCkuYXBwZW5kKCdwYXRoJyk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGJhY2tncm91bmQuYXR0cignZCcsIHBhdGgpO1xuXG4gICAgICAgICAgICAvLyBBZGQgYmx1ZSBmb3JlZ3JvdW5kIGxpbmVzIGZvciBmb2N1cy5cbiAgICAgICAgICAgIGZvcmVncm91bmQgPSB3cmFwLnNlbGVjdCgnLmZvcmVncm91bmQnKS5zZWxlY3RBbGwoJ3BhdGgnKS5kYXRhKGRhdGEpO1xuICAgICAgICAgICAgZm9yZWdyb3VuZC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICBmb3JlZ3JvdW5kLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIGZvcmVncm91bmQuYXR0cignZCcsIHBhdGgpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKGQuc3Ryb2tlV2lkdGgpKSB7IGQuc3Ryb2tlV2lkdGggPSAxO30gcmV0dXJuIGQuc3Ryb2tlV2lkdGg7fSlcbiAgICAgICAgICAgICAgICAuYXR0cignc3Ryb2tlJywgZnVuY3Rpb24gKGQsIGkpIHsgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7IH0pO1xuICAgICAgICAgICAgZm9yZWdyb3VuZC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIGQuc3Ryb2tlV2lkdGggKyAyICsgXCJweFwiKS5zdHlsZShcInN0cm9rZS1vcGFjaXR5XCIsIDEpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW92ZXIoe1xuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogZC5jb2xvciB8fCBjb2xvcihkLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcyxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogZW5hYmxlZERpbWVuc2lvbnNcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kLm9uKFwibW91c2VvdXRcIiwgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSkuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgZC5zdHJva2VXaWR0aCArIFwicHhcIikuc3R5bGUoXCJzdHJva2Utb3BhY2l0eVwiLCAwLjcpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcmVncm91bmQub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kLm9uKCdjbGljaycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGQuaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIGEgZ3JvdXAgZWxlbWVudCBmb3IgZWFjaCBkaW1lbnNpb24uXG4gICAgICAgICAgICBkaW1lbnNpb25zID0gZy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKS5kYXRhKGVuYWJsZWREaW1lbnNpb25zKTtcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zRW50ZXIgPSBkaW1lbnNpb25zLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGFyYWxsZWxDb29yZGluYXRlcyBkaW1lbnNpb24nKTtcblxuICAgICAgICAgICAgZGltZW5zaW9ucy5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7IHJldHVybiAndHJhbnNsYXRlKCcgKyB4KGQua2V5KSArICcsMCknOyB9KTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1heGlzJyk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhbiBheGlzIGFuZCB0aXRsZS5cbiAgICAgICAgICAgIGRpbWVuc2lvbnNFbnRlci5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1sYWJlbCcpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiY3Vyc29yXCIsIFwibW92ZVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICctMWVtJylcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkLnRvb2x0aXAgfHwgZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZC5jb2xvciBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW91dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogZC50b29sdGlwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2FsbChheGlzRHJhZyk7XG5cbiAgICAgICAgICAgIGRpbWVuc2lvbnNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1icnVzaEJhY2tncm91bmQnKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgZGltZW5zaW9ucy5zZWxlY3QoJy5udi1sYWJlbCcpLnRleHQoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2V5IH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cbiAgICAgICAgICAgIHJlc3RvcmVCcnVzaChkaXNwbGF5QnJ1c2gpO1xuXG4gICAgICAgICAgICB2YXIgYWN0aXZlcyA9IGRpbWVuc2lvbk5hbWVzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIXlbcF0uYnJ1c2guZW1wdHkoKTsgfSksXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudHMgPSBhY3RpdmVzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4geVtwXS5icnVzaC5leHRlbnQoKTsgfSk7XG4gICAgICAgICAgICB2YXIgZm9ybWVyQWN0aXZlID0gYWN0aXZlLnNsaWNlKDApO1xuXG4gICAgICAgICAgICAvL1Jlc3RvcmUgYWN0aXZlIHZhbHVlc1xuICAgICAgICAgICAgYWN0aXZlID0gW107XG4gICAgICAgICAgICBmb3JlZ3JvdW5kLnN0eWxlKFwiZGlzcGxheVwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChpc05hTihkLnZhbHVlc1twXSkgfHwgaXNOYU4ocGFyc2VGbG9hdChkLnZhbHVlc1twXSkpKSAmJiBleHRlbnRzW2ldWzBdID09IHlbcF0uYnJ1c2gueSgpLmRvbWFpbigpWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGV4dGVudHNbaV1bMF0gPD0gZC52YWx1ZXNbcF0gJiYgZC52YWx1ZXNbcF0gPD0gZXh0ZW50c1tpXVsxXSkgJiYgIWlzTmFOKHBhcnNlRmxvYXQoZC52YWx1ZXNbcF0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNBY3RpdmUgPyBcIm5vbmVcIiA6IG51bGw7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAwIHx8ICFudi51dGlscy5hcnJheUVxdWFscyhhY3RpdmUsIGZvcm1lckFjdGl2ZSkpIHtcbiAgICAgICAgICAgICAgIGRpc3BhdGNoLmFjdGl2ZUNoYW5nZWQoYWN0aXZlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgcGF0aCBmb3IgYSBnaXZlbiBkYXRhIHBvaW50LlxuICAgICAgICAgICAgZnVuY3Rpb24gcGF0aChkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpbmUoZW5hYmxlZERpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vSWYgdmFsdWUgaWYgbWlzc2luZywgcHV0IHRoZSB2YWx1ZSBvbiB0aGUgbWlzc2luZyB2YWx1ZSBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkLnZhbHVlc1twLmtleV0pIHx8IGlzTmFOKHBhcnNlRmxvYXQoZC52YWx1ZXNbcC5rZXldKSkgfHwgZGlzcGxheU1pc3NpbmdWYWx1ZXNsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0geVtwLmtleV0uZG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSB5W3Aua2V5XS5yYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IGRvbWFpblswXSAtIChkb21haW5bMV0gLSBkb21haW5bMF0pIC8gOTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBpdCdzIG5vdCBhbHJlYWR5IHRoZSBjYXNlLCBhbGxvdyBicnVzaCB0byBzZWxlY3QgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF4aXNXaXRoVW5kZWZpbmVkVmFsdWVzLmluZGV4T2YocC5rZXkpIDwgMCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld3NjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFttaW4sIGRvbWFpblsxXV0pLnJhbmdlKFthdmFpbGFibGVIZWlnaHQgLSAxMiwgcmFuZ2VbMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5W3Aua2V5XS5icnVzaC55KG5ld3NjYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzV2l0aFVuZGVmaW5lZFZhbHVlcy5wdXNoKHAua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihkLnZhbHVlc1twLmtleV0pIHx8IGlzTmFOKHBhcnNlRmxvYXQoZC52YWx1ZXNbcC5rZXldKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3gocC5rZXkpLCB5W3Aua2V5XShtaW4pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vSWYgcGFyYWxsZWxDb29yZGluYXRlIGNvbnRhaW4gbWlzc2luZyB2YWx1ZXMgc2hvdyB0aGUgbWlzc2luZyB2YWx1ZXMgbGluZSBvdGhlcndpc2UsIGhpZGUgaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nVmFsdWVzbGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXhpc1dpdGhVbmRlZmluZWRWYWx1ZXMubGVuZ3RoID4gMCB8fCBkaXNwbGF5TWlzc2luZ1ZhbHVlc2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZS5zdHlsZShcImRpc3BsYXlcIiwgXCJpbmxpbmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1ZhbHVlc2xpbmVUZXh0LnN0eWxlKFwiZGlzcGxheVwiLCBcImlubGluZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ1ZhbHVlc2xpbmUuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nVmFsdWVzbGluZVRleHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3gocC5rZXkpLCB5W3Aua2V5XShkLnZhbHVlc1twLmtleV0pXTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc3RvcmVCcnVzaCh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vSWYgZmlsdGVyIGJydXNoZWQgTmFOIHZhbHVlcywga2VlcCB0aGUgYnJ1c2ggb24gdGhlIGJvdHRvbSBvZiB0aGUgYXhpcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJydXNoRG9tYWluID0geVtmLmRpbWVuc2lvbl0uYnJ1c2gueSgpLmRvbWFpbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5oYXNPbmx5TmFOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmV4dGVudFsxXSA9ICh5W2YuZGltZW5zaW9uXS5kb21haW4oKVsxXSAtIGJydXNoRG9tYWluWzBdKSAqIChmLmV4dGVudFsxXSAtIGYuZXh0ZW50WzBdKSAvIChvbGREb21haW5NYXhWYWx1ZVtmLmRpbWVuc2lvbl0gLSBmLmV4dGVudFswXSkgKyBicnVzaERvbWFpblswXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZi5oYXNOYU4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuZXh0ZW50WzBdID0gYnJ1c2hEb21haW5bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2libGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB5W2YuZGltZW5zaW9uXS5icnVzaC5leHRlbnQoZi5leHRlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc2VsZWN0KCcubnYtYnJ1c2hCYWNrZ3JvdW5kJylcbiAgICAgICAgICAgICAgICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKHlbZC5rZXldLmJydXNoKTtcblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdyZWN0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtOClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTYpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEhhbmRsZXMgYSBicnVzaCBldmVudCwgdG9nZ2xpbmcgdGhlIGRpc3BsYXkgb2YgZm9yZWdyb3VuZCBsaW5lcy5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGJydXNoc3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgLy9JZiBicnVzaCBhcmVuJ3QgdmlzaWJsZSwgc2hvdyBpdCBiZWZvcmUgYnJ1c2hpbmcgYWdhaW4uXG4gICAgICAgICAgICAgICAgaWYgKGRpc3BsYXlCcnVzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUJydXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdG9yZUJydXNoKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlcyBhIGJydXNoIGV2ZW50LCB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiBmb3JlZ3JvdW5kIGxpbmVzLlxuICAgICAgICAgICAgZnVuY3Rpb24gYnJ1c2goKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlcyA9IGRpbWVuc2lvbk5hbWVzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIXlbcF0uYnJ1c2guZW1wdHkoKTsgfSk7XG4gICAgICAgICAgICAgICAgZXh0ZW50cyA9IGFjdGl2ZXMubWFwKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHlbcF0uYnJ1c2guZXh0ZW50KCk7IH0pO1xuXG4gICAgICAgICAgICAgICAgZmlsdGVycyA9IFtdOyAvL2VyYXNlIGN1cnJlbnQgZmlsdGVyc1xuICAgICAgICAgICAgICAgIGFjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyc1tpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogZXh0ZW50c1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05hTjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPbmx5TmFOOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBbXTsgLy9lcmFzZSBjdXJyZW50IGFjdGl2ZSBsaXN0XG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZC5zdHlsZSgnZGlzcGxheScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gYWN0aXZlcy5ldmVyeShmdW5jdGlvbihwLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGlzTmFOKGQudmFsdWVzW3BdKSB8fCBpc05hTihwYXJzZUZsb2F0KGQudmFsdWVzW3BdKSkpICYmIGV4dGVudHNbaV1bMF0gPT0geVtwXS5icnVzaC55KCkuZG9tYWluKClbMF0pIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChleHRlbnRzW2ldWzBdIDw9IGQudmFsdWVzW3BdICYmIGQudmFsdWVzW3BdIDw9IGV4dGVudHNbaV1bMV0pICYmICFpc05hTihwYXJzZUZsb2F0KGQudmFsdWVzW3BdKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBY3RpdmUpIGFjdGl2ZS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBY3RpdmUgPyBudWxsIDogJ25vbmUnO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHVwZGF0ZVRpY2tzKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYnJ1c2goe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzOiBmaWx0ZXJzLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYnJ1c2hlbmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0FjdGl2ZUJydXNoID0gYWN0aXZlcy5sZW5ndGggPiAwID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5leHRlbnRbMF0gPT09IHlbZi5kaW1lbnNpb25dLmJydXNoLnkoKS5kb21haW4oKVswXSAmJiBheGlzV2l0aFVuZGVmaW5lZFZhbHVlcy5pbmRleE9mKGYuZGltZW5zaW9uKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZi5oYXNOYU4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5leHRlbnRbMV0gPCB5W2YuZGltZW5zaW9uXS5kb21haW4oKVswXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGYuaGFzT25seU5hTiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guYnJ1c2hFbmQoYWN0aXZlLCBoYXNBY3RpdmVCcnVzaCk7XG4gICAgICAgICAgICB9ICAgICAgICAgICBcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRpY2tzKCkge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuc2VsZWN0KCcubnYtYXhpcycpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZpbHRlcnMuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiBrLmRpbWVuc2lvbiA9PSBkLmtleTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGlja3NbZC5rZXldID0geVtkLmtleV0uZG9tYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgYnJ1c2ggYXJlIGF2YWlsYWJsZSwgZGlzcGxheSBicnVzaCBleHRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmLmxlbmd0aCAhPSAwICYmIGRpc3BsYXlCcnVzaClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGlja3NbZC5rZXldID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZbMF0uZXh0ZW50WzFdID4geVtkLmtleV0uZG9tYWluKClbMF0pIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGlja3NbZC5rZXldID0gW2ZbMF0uZXh0ZW50WzFdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZlswXS5leHRlbnRbMF0gPj0geVtkLmtleV0uZG9tYWluKClbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaWNrc1tkLmtleV0ucHVzaChmWzBdLmV4dGVudFswXSk7ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5W2Qua2V5XSkudGlja0Zvcm1hdChkLmZvcm1hdCkudGlja1ZhbHVlcyhjdXJyZW50VGlja3NbZC5rZXldKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFnU3RhcnQoZCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nW2Qua2V5XSA9IHRoaXMucGFyZW50Tm9kZS5fX29yaWdpbl9fID0geChkLmtleSk7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC5hdHRyKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYWdNb3ZlKGQpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ1tkLmtleV0gPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgTWF0aC5tYXgoMCwgdGhpcy5wYXJlbnROb2RlLl9fb3JpZ2luX18gKz0gZDMuZXZlbnQueCkpO1xuICAgICAgICAgICAgICAgIGZvcmVncm91bmQuYXR0cihcImRcIiwgcGF0aCk7XG4gICAgICAgICAgICAgICAgZW5hYmxlZERpbWVuc2lvbnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gZGltZW5zaW9uUG9zaXRpb24oYS5rZXkpIC0gZGltZW5zaW9uUG9zaXRpb24oYi5rZXkpOyB9KTtcbiAgICAgICAgICAgICAgICBlbmFibGVkRGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBkLmN1cnJlbnRQb3NpdGlvbiA9IGk7IH0pO1xuICAgICAgICAgICAgICAgIHguZG9tYWluKGVuYWJsZWREaW1lbnNpb25zLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5rZXk7IH0pKTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyBkaW1lbnNpb25Qb3NpdGlvbihkLmtleSkgKyBcIilcIjsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFnRW5kKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnROb2RlLl9fb3JpZ2luX187XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRyYWdnaW5nW2Qua2V5XTtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgeChkLmtleSkgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZFxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBwYXRoKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ2aXNpYmlsaXR5XCIsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZGltZW5zaW9uc09yZGVyKGVuYWJsZWREaW1lbnNpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRpbWVuc2lvblBvc2l0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IGRyYWdnaW5nW2RdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2ID09IG51bGwgPyB4KGQpIDogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgICAgICAgICAgIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9IF87fX0sXG4gICAgICAgIGhlaWdodDogICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD0gXzt9fSxcbiAgICAgICAgZGltZW5zaW9uRGF0YTogeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpbWVuc2lvbkRhdGE7IH0sIHNldDogZnVuY3Rpb24gKF8pIHsgZGltZW5zaW9uRGF0YSA9IF87IH0gfSxcbiAgICAgICAgZGlzcGxheUJydXNoOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheUJydXNoOyB9LCBzZXQ6IGZ1bmN0aW9uIChfKSB7IGRpc3BsYXlCcnVzaCA9IF87IH0gfSxcbiAgICAgICAgZmlsdGVyczogeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcnM7IH0sIHNldDogZnVuY3Rpb24gKF8pIHsgZmlsdGVycyA9IF87IH0gfSxcbiAgICAgICAgYWN0aXZlOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWN0aXZlOyB9LCBzZXQ6IGZ1bmN0aW9uIChfKSB7IGFjdGl2ZSA9IF87IH0gfSxcbiAgICAgICAgbGluZVRlbnNpb246ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGluZVRlbnNpb247fSwgICAgIHNldDogZnVuY3Rpb24oXyl7bGluZVRlbnNpb24gPSBfO319LFxuICAgICAgICB1bmRlZmluZWRWYWx1ZXNMYWJlbCA6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVuZGVmaW5lZFZhbHVlc0xhYmVsO30sIHNldDogZnVuY3Rpb24oXyl7dW5kZWZpbmVkVmFsdWVzTGFiZWw9Xzt9fSxcbiAgICAgICAgXG4gICAgICAgIC8vIGRlcHJlY2F0ZWQgb3B0aW9uc1xuICAgICAgICBkaW1lbnNpb25zOiB7Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaW1lbnNpb25EYXRhLm1hcChmdW5jdGlvbiAoZCl7cmV0dXJuIGQua2V5fSk7IH0sIHNldDogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgYWZ0ZXIgMS44LjFcbiAgICAgICAgICAgIG52LmRlcHJlY2F0ZWQoJ2RpbWVuc2lvbnMnLCAndXNlIGRpbWVuc2lvbkRhdGEgaW5zdGVhZCcpO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgXy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IGRpbWVuc2lvbkRhdGEucHVzaCh7IGtleTogayB9KSB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZnVuY3Rpb24gKGssIGkpIHsgZGltZW5zaW9uRGF0YVtpXS5rZXk9IGsgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX0sXG4gICAgICAgIGRpbWVuc2lvbk5hbWVzOiB7Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaW1lbnNpb25EYXRhLm1hcChmdW5jdGlvbiAoZCl7cmV0dXJuIGQua2V5fSk7IH0sIHNldDogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQgYWZ0ZXIgMS44LjFcbiAgICAgICAgICAgIG52LmRlcHJlY2F0ZWQoJ2RpbWVuc2lvbk5hbWVzJywgJ3VzZSBkaW1lbnNpb25EYXRhIGluc3RlYWQnKTtcbiAgICAgICAgICAgIGRpbWVuc2lvbk5hbWVzID0gW107XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZnVuY3Rpb24gKGspIHsgZGltZW5zaW9uRGF0YS5wdXNoKHsga2V5OiBrIH0pIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChmdW5jdGlvbiAoaywgaSkgeyBkaW1lbnNpb25EYXRhW2ldLmtleSA9IGsgfSlcbiAgICAgICAgICAgIH1cbiBcbiAgICAgICAgfX0sXG4gICAgICAgIGRpbWVuc2lvbkZvcm1hdHM6IHtnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRpbWVuc2lvbkRhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmZvcm1hdCB9KTsgfSwgc2V0OiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgLy8gZGVwcmVjYXRlZCBhZnRlciAxLjguMVxuICAgICAgICAgICAgbnYuZGVwcmVjYXRlZCgnZGltZW5zaW9uRm9ybWF0cycsICd1c2UgZGltZW5zaW9uRGF0YSBpbnN0ZWFkJyk7XG4gICAgICAgICAgICBpZiAoZGltZW5zaW9uRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBfLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgZGltZW5zaW9uRGF0YS5wdXNoKHsgZm9ybWF0OiBmIH0pIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF8uZm9yRWFjaChmdW5jdGlvbiAoZiwgaSkgeyBkaW1lbnNpb25EYXRhW2ldLmZvcm1hdCA9IGYgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9fSxcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9ICBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9ICBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gIF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gIF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xufTtcbm52Lm1vZGVscy5wYXJhbGxlbENvb3JkaW5hdGVzQ2hhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgIHZhciBwYXJhbGxlbENvb3JkaW5hdGVzID0gbnYubW9kZWxzLnBhcmFsbGVsQ29vcmRpbmF0ZXMoKVxuICAgICAgICB2YXIgbGVnZW5kID0gbnYubW9kZWxzLmxlZ2VuZCgpXG4gICAgICAgIHZhciB0b29sdGlwID0gbnYubW9kZWxzLnRvb2x0aXAoKTtcbiAgICAgICAgdmFyIGRpbWVuc2lvblRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpO1xuXG4gICAgICAgIHZhciBtYXJnaW4gPSB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9XG4gICAgICAgICwgbWFyZ2luVG9wID0gbnVsbFxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCBzdGF0ZSA9IG52LnV0aWxzLnN0YXRlKClcbiAgICAgICAgLCBkaW1lbnNpb25EYXRhID0gW11cbiAgICAgICAgLCBkaXNwbGF5QnJ1c2ggPSB0cnVlXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBuYW5WYWx1ZSA9IFwidW5kZWZpbmVkXCJcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdkaW1lbnNpb25zT3JkZXInLCAnYnJ1c2hFbmQnLCAnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgLCBjb250cm9sV2lkdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzaG93Q29udHJvbHMgPyAxODAgOiAwIH1cbiAgICAgICAgO1xuXG5cdCAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cdFx0Ly89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG5cbiAgICAgICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZTogZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9ICFzdGF0ZS5hY3RpdmVbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0b29sdGlwLmNvbnRlbnRHZW5lcmF0b3IoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIHN0ciA9ICc8dGFibGU+PHRoZWFkPjx0cj48dGQgY2xhc3M9XCJsZWdlbmQtY29sb3ItZ3VpZGVcIj48ZGl2IHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjonICsgZGF0YS5jb2xvciArICdcIj48L2Rpdj48L3RkPjx0ZD48c3Ryb25nPicgKyBkYXRhLmtleSArICc8L3N0cm9uZz48L3RkPjwvdHI+PC90aGVhZD4nO1xuICAgICAgICAgICAgaWYoZGF0YS5zZXJpZXMubGVuZ3RoICE9PSAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArICc8dGJvZHk+PHRyPjx0ZCBoZWlnaHQgPVwiMTBweFwiPjwvdGQ+PC90cj4nO1xuICAgICAgICAgICAgICAgIGRhdGEuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArICc8dHI+PHRkIGNsYXNzPVwibGVnZW5kLWNvbG9yLWd1aWRlXCI+PGRpdiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGQuY29sb3IgKyAnXCI+PC9kaXY+PC90ZD48dGQgY2xhc3M9XCJrZXlcIj4nICsgZC5rZXkgKyAnPC90ZD48dGQgY2xhc3M9XCJ2YWx1ZVwiPicgKyBkLnZhbHVlICsgJzwvdGQ+PC90cj4nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ciArICc8L3Rib2R5Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIgKyAnPC90YWJsZT4nO1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLy8gQ2hhcnQgZnVuY3Rpb25cbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMocGFyYWxsZWxDb29yZGluYXRlcyk7XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSA9IGZ1bmN0aW9uKCkgeyBjb250YWluZXIuY2FsbChjaGFydCk7IH07XG4gICAgICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHN0YXRlLnNldHRlcihzdGF0ZVNldHRlcihkaW1lbnNpb25EYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRpbWVuc2lvbkRhdGEpKVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICAvL3NldCBzdGF0ZS5kaXNhYmxlZFxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGltZW5zaW9uRGF0YS5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgICAgIC8vS2VlcCBkaW1lbnNpb25zIHBvc2l0aW9uIGluIG1lbW9yeVxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbkRhdGEgPSBkaW1lbnNpb25EYXRhLm1hcChmdW5jdGlvbiAoZCkge2QuZGlzYWJsZWQgPSAhIWQuZGlzYWJsZWQ7IHJldHVybiBkfSk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQub3JpZ2luYWxQb3NpdGlvbiA9IGlzTmFOKGQub3JpZ2luYWxQb3NpdGlvbikgPyBpIDogZC5vcmlnaW5hbFBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgICBkLmN1cnJlbnRQb3NpdGlvbiA9IGlzTmFOKGQuY3VycmVudFBvc2l0aW9uKSA/IGkgOiBkLmN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvcihrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICAgICAgaWYoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG5cbiAgICAgICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3RBbGwoJ2cubnYtd3JhcC5udi1wYXJhbGxlbENvb3JkaW5hdGVzQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtcGFyYWxsZWxDb29yZGluYXRlc0NoYXJ0JykuYXBwZW5kKCdnJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG5cbiAgICAgICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGFyYWxsZWxDb29yZGluYXRlc1dyYXAnKTtcbiAgICAgICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtbGVnZW5kV3JhcCcpO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoXCJyZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgYXZhaWxhYmxlV2lkdGgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIChhdmFpbGFibGVIZWlnaHQgPiAwKSA/IGF2YWlsYWJsZUhlaWdodCA6IDApO1xuXG4gICAgICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICAgICAgaWYgKCFzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb2xvcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJyZ2IoMTg4LDE5MCwxOTIpXCI7IH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGltZW5zaW9uRGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLm9yaWdpbmFsUG9zaXRpb24gLSBiLm9yaWdpbmFsUG9zaXRpb247IH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoIDAgLCcgKyAoLW1hcmdpbi50b3ApICsgJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFpbiBDaGFydCBDb21wb25lbnQocylcbiAgICAgICAgICAgICAgICBwYXJhbGxlbENvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5kaW1lbnNpb25EYXRhKGRpbWVuc2lvbkRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5kaXNwbGF5QnJ1c2goZGlzcGxheUJydXNoKTtcblxuXHRcdCAgICAgICAgdmFyIHBhcmFsbGVsQ29vcmRpbmF0ZXNXcmFwID0gZy5zZWxlY3QoJy5udi1wYXJhbGxlbENvb3JkaW5hdGVzV3JhcCAnKVxuICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpO1xuXG5cdFx0ICAgICAgICBwYXJhbGxlbENvb3JkaW5hdGVzV3JhcC50cmFuc2l0aW9uKCkuY2FsbChwYXJhbGxlbENvb3JkaW5hdGVzKTtcblxuXHRcdFx0XHQvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChpbiBjaGFydCdzIHNjb3BlKVxuICAgICAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgLy9EaXNwbGF5IHJlc2V0IGJydXNoIGJ1dHRvblxuXHRcdCAgICAgICAgcGFyYWxsZWxDb29yZGluYXRlcy5kaXNwYXRjaC5vbignYnJ1c2hFbmQnLCBmdW5jdGlvbiAoYWN0aXZlLCBoYXNBY3RpdmVCcnVzaCkge1xuXHRcdCAgICAgICAgICAgIGlmIChoYXNBY3RpdmVCcnVzaCkge1xuXHRcdCAgICAgICAgICAgICAgICBkaXNwbGF5QnJ1c2ggPSB0cnVlO1xuXHRcdCAgICAgICAgICAgICAgICBkaXNwYXRjaC5icnVzaEVuZChhY3RpdmUpO1xuXHRcdCAgICAgICAgICAgIH0gZWxzZSB7XG5cblx0XHQgICAgICAgICAgICAgICAgZGlzcGxheUJydXNoID0gZmFsc2U7XG5cdFx0ICAgICAgICAgICAgfVxuXHRcdCAgICAgICAgfSk7XG5cblx0XHQgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuXHRcdCAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG5ld1N0YXRlKSB7XG5cdFx0ICAgICAgICAgICAgICAgIHN0YXRlW2tleV0gPSBuZXdTdGF0ZVtrZXldO1xuXHRcdCAgICAgICAgICAgIH1cblx0XHQgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG5cdFx0ICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG5cdFx0ICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vVXBkYXRlIGRpbWVuc2lvbnMgb3JkZXIgYW5kIGRpc3BsYXkgcmVzZXQgc29ydGluZyBidXR0b25cblx0XHQgICAgICAgIHBhcmFsbGVsQ29vcmRpbmF0ZXMuZGlzcGF0Y2gub24oJ2RpbWVuc2lvbnNPcmRlcicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0ICAgICAgICAgICAgZGltZW5zaW9uRGF0YS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmN1cnJlbnRQb3NpdGlvbiAtIGIuY3VycmVudFBvc2l0aW9uOyB9KTtcblx0XHQgICAgICAgICAgICB2YXIgaXNTb3J0ZWQgPSBmYWxzZTtcblx0XHQgICAgICAgICAgICBkaW1lbnNpb25EYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcblx0XHQgICAgICAgICAgICAgICAgZC5jdXJyZW50UG9zaXRpb24gPSBpO1xuXHRcdCAgICAgICAgICAgICAgICBpZiAoZC5jdXJyZW50UG9zaXRpb24gIT09IGQub3JpZ2luYWxQb3NpdGlvbilcblx0XHQgICAgICAgICAgICAgICAgICAgIGlzU29ydGVkID0gdHJ1ZTtcblx0XHQgICAgICAgICAgICB9KTtcblx0XHQgICAgICAgICAgICBkaXNwYXRjaC5kaW1lbnNpb25zT3JkZXIoZGltZW5zaW9uRGF0YSwgaXNTb3J0ZWQpO1xuXHRcdCAgICAgICAgfSk7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIGNoYXJ0IGZyb20gYSBzdGF0ZSBvYmplY3QgcGFzc2VkIHRvIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbkRhdGEuZm9yRWFjaChmdW5jdGlvbiAoc2VyaWVzLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gZS5kaXNhYmxlZFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgncGFycmFsZWxlQ29vcmRpbmF0ZUNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgICAgICB9XG5cblx0XHQvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgcGFyYWxsZWxDb29yZGluYXRlcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgdmFyIHRwID0ge1xuICAgICAgICAgICAgICAgIGtleTogZXZ0LmxhYmVsLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBldnQuY29sb3IsXG4gICAgICAgICAgICAgICAgc2VyaWVzOiBbXVxuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGV2dC52YWx1ZXMpe1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV2dC52YWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGV2dC5kaW1lbnNpb25zLmZpbHRlcihmdW5jdGlvbiAoZGQpIHtyZXR1cm4gZGQua2V5ID09PSBkO30pWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZihkaW0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZXZ0LnZhbHVlc1tkXSkgfHwgaXNOYU4ocGFyc2VGbG9hdChldnQudmFsdWVzW2RdKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gbmFuVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBkaW0uZm9ybWF0KGV2dC52YWx1ZXNbZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHAuc2VyaWVzLnB1c2goeyBpZHg6IGRpbS5jdXJyZW50UG9zaXRpb24sIGtleTogZCwgdmFsdWU6IHYsIGNvbG9yOiBkaW0uY29sb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cC5zZXJpZXMuc29ydChmdW5jdGlvbihhLGIpIHtyZXR1cm4gYS5pZHggLSBiLmlkeH0pO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2x0aXAuZGF0YSh0cCkuaGlkZGVuKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGFyYWxsZWxDb29yZGluYXRlcy5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHBhcmFsbGVsQ29vcmRpbmF0ZXMuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRvb2x0aXAoKTtcbiAgICAgICAgfSk7XG5cdFx0IC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0XHQvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgICAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgICAgICBjaGFydC5wYXJhbGxlbENvb3JkaW5hdGVzID0gcGFyYWxsZWxDb29yZGluYXRlcztcbiAgICAgICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgICAgICBjaGFydC50b29sdGlwID0gdG9vbHRpcDtcbiAgICAgICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICAgICAgd2lkdGg6IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB3aWR0aDsgfSwgc2V0OiBmdW5jdGlvbiAoXykgeyB3aWR0aCA9IF87IH0gfSxcbiAgICAgICAgICAgIGhlaWdodDogeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlaWdodDsgfSwgc2V0OiBmdW5jdGlvbiAoXykgeyBoZWlnaHQgPSBfOyB9IH0sXG4gICAgICAgICAgICBzaG93TGVnZW5kOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2hvd0xlZ2VuZDsgfSwgc2V0OiBmdW5jdGlvbiAoXykgeyBzaG93TGVnZW5kID0gXzsgfSB9LFxuICAgICAgICAgICAgZGVmYXVsdFN0YXRlOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVmYXVsdFN0YXRlOyB9LCBzZXQ6IGZ1bmN0aW9uIChfKSB7IGRlZmF1bHRTdGF0ZSA9IF87IH0gfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbkRhdGE6IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaW1lbnNpb25EYXRhOyB9LCBzZXQ6IGZ1bmN0aW9uIChfKSB7IGRpbWVuc2lvbkRhdGEgPSBfOyB9IH0sXG4gICAgICAgICAgICBkaXNwbGF5QnJ1c2g6IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5QnJ1c2g7IH0sIHNldDogZnVuY3Rpb24gKF8pIHsgZGlzcGxheUJydXNoID0gXzsgfSB9LFxuICAgICAgICAgICAgbm9EYXRhOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9EYXRhOyB9LCBzZXQ6IGZ1bmN0aW9uIChfKSB7IG5vRGF0YSA9IF87IH0gfSxcbiAgICAgICAgICAgIG5hblZhbHVlOiB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFuVmFsdWU7IH0sIHNldDogZnVuY3Rpb24gKF8pIHsgbmFuVmFsdWUgPSBfOyB9IH0sXG5cbiAgICAgICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFyZ2luOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBfLnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IF8udG9wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5yaWdodCA9IF8ucmlnaHQgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW4ubGVmdCA9IF8ubGVmdCAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0IDogbWFyZ2luLmxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbENvb3JkaW5hdGVzLmNvbG9yKGNvbG9yKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICB9KTtcblxuICAgICAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgcGFyYWxsZWxDb29yZGluYXRlcyk7XG4gICAgICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfTtcbm52Lm1vZGVscy5waWUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA1MDBcbiAgICAgICAgLCBoZWlnaHQgPSA1MDBcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH1cbiAgICAgICAgLCBnZXRZID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH1cbiAgICAgICAgLCBpZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbiBjYXNlIHVzZXIgZG9lc24ndCBzZWxlY3Qgb25lXG4gICAgICAgICwgY29udGFpbmVyID0gbnVsbFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB2YWx1ZUZvcm1hdCA9IGQzLmZvcm1hdCgnLC4yZicpXG4gICAgICAgICwgc2hvd0xhYmVscyA9IHRydWVcbiAgICAgICAgLCBsYWJlbHNPdXRzaWRlID0gZmFsc2VcbiAgICAgICAgLCBsYWJlbFR5cGUgPSBcImtleVwiXG4gICAgICAgICwgbGFiZWxUaHJlc2hvbGQgPSAuMDIgLy9pZiBzbGljZSBwZXJjZW50YWdlIGlzIHVuZGVyIHRoaXMsIGRvbid0IHNob3cgbGFiZWxcbiAgICAgICAgLCBkb251dCA9IGZhbHNlXG4gICAgICAgICwgdGl0bGUgPSBmYWxzZVxuICAgICAgICAsIGdyb3dPbkhvdmVyID0gdHJ1ZVxuICAgICAgICAsIHRpdGxlT2Zmc2V0ID0gMFxuICAgICAgICAsIGxhYmVsU3VuYmVhbUxheW91dCA9IGZhbHNlXG4gICAgICAgICwgc3RhcnRBbmdsZSA9IGZhbHNlXG4gICAgICAgICwgcGFkQW5nbGUgPSBmYWxzZVxuICAgICAgICAsIGVuZEFuZ2xlID0gZmFsc2VcbiAgICAgICAgLCBjb3JuZXJSYWRpdXMgPSAwXG4gICAgICAgICwgZG9udXRSYXRpbyA9IDAuNVxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgYXJjc1JhZGl1cyA9IFtdXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnY2hhcnRDbGljaycsICdlbGVtZW50Q2xpY2snLCAnZWxlbWVudERibENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JywgJ2VsZW1lbnRNb3VzZW1vdmUnLCAncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgdmFyIGFyY3MgPSBbXTtcbiAgICB2YXIgYXJjc092ZXIgPSBbXTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY2hhcnQgZnVuY3Rpb25cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHRcbiAgICAgICAgICAgICAgICAsIGF2YWlsYWJsZUhlaWdodCA9IGhlaWdodCAtIG1hcmdpbi50b3AgLSBtYXJnaW4uYm90dG9tXG4gICAgICAgICAgICAgICAgLCByYWRpdXMgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0KSAvIDJcbiAgICAgICAgICAgICAgICAsIGFyY3NSYWRpdXNPdXRlciA9IFtdXG4gICAgICAgICAgICAgICAgLCBhcmNzUmFkaXVzSW5uZXIgPSBbXVxuICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICBpZiAoYXJjc1JhZGl1cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ZXIgPSByYWRpdXMgLSByYWRpdXMgLyA1O1xuICAgICAgICAgICAgICAgIHZhciBpbm5lciA9IGRvbnV0UmF0aW8gKiByYWRpdXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyY3NSYWRpdXNPdXRlci5wdXNoKG91dGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYXJjc1JhZGl1c0lubmVyLnB1c2goaW5uZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoZ3Jvd09uSG92ZXIpe1xuICAgICAgICAgICAgICAgICAgICBhcmNzUmFkaXVzT3V0ZXIgPSBhcmNzUmFkaXVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQub3V0ZXIgLSBkLm91dGVyIC8gNSkgKiByYWRpdXM7IH0pO1xuICAgICAgICAgICAgICAgICAgICBhcmNzUmFkaXVzSW5uZXIgPSBhcmNzUmFkaXVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gKGQuaW5uZXIgLSBkLmlubmVyIC8gNSkgKiByYWRpdXM7IH0pO1xuICAgICAgICAgICAgICAgICAgICBkb251dFJhdGlvID0gZDMubWluKGFyY3NSYWRpdXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiAoZC5pbm5lciAtIGQuaW5uZXIgLyA1KTsgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyY3NSYWRpdXNPdXRlciA9IGFyY3NSYWRpdXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm91dGVyICogcmFkaXVzOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXJjc1JhZGl1c0lubmVyID0gYXJjc1JhZGl1cy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuaW5uZXIgKiByYWRpdXM7IH0pO1xuICAgICAgICAgICAgICAgICAgICBkb251dFJhdGlvID0gZDMubWluKGFyY3NSYWRpdXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmlubmVyOyB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCcubnYtd3JhcC5udi1waWUnKS5kYXRhKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsJ252ZDMgbnYtd3JhcCBudi1waWUgbnYtY2hhcnQtJyArIGlkKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdnJyk7XG4gICAgICAgICAgICB2YXIgZyA9IHdyYXAuc2VsZWN0KCdnJyk7XG4gICAgICAgICAgICB2YXIgZ19waWUgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllTGFiZWxzJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcbiAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtcGllJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgYXZhaWxhYmxlV2lkdGggLyAyICsgJywnICsgYXZhaWxhYmxlSGVpZ2h0IC8gMiArICcpJyk7XG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LXBpZUxhYmVscycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGF2YWlsYWJsZVdpZHRoIC8gMiArICcsJyArIGF2YWlsYWJsZUhlaWdodCAvIDIgKyAnKScpO1xuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29udGFpbmVyLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLmNoYXJ0Q2xpY2soe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgcG9zOiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYXJjcyA9IFtdO1xuICAgICAgICAgICAgYXJjc092ZXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVswXS5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGFyYyA9IGQzLnN2Zy5hcmMoKS5vdXRlclJhZGl1cyhhcmNzUmFkaXVzT3V0ZXJbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBhcmNPdmVyID0gZDMuc3ZnLmFyYygpLm91dGVyUmFkaXVzKGFyY3NSYWRpdXNPdXRlcltpXSArIDUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0QW5nbGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyYy5zdGFydEFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICBhcmNPdmVyLnN0YXJ0QW5nbGUoc3RhcnRBbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbmRBbmdsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJjLmVuZEFuZ2xlKGVuZEFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJjT3Zlci5lbmRBbmdsZShlbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb251dCkge1xuICAgICAgICAgICAgICAgICAgICBhcmMuaW5uZXJSYWRpdXMoYXJjc1JhZGl1c0lubmVyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgYXJjT3Zlci5pbm5lclJhZGl1cyhhcmNzUmFkaXVzSW5uZXJbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhcmMuY29ybmVyUmFkaXVzICYmIGNvcm5lclJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBhcmMuY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgICAgIGFyY092ZXIuY29ybmVyUmFkaXVzKGNvcm5lclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICAgICAgYXJjc092ZXIucHVzaChhcmNPdmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgdGhlIFBpZSBjaGFydCBhbmQgY2hvb3NlIHRoZSBkYXRhIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBwaWUgPSBkMy5sYXlvdXQucGllKClcbiAgICAgICAgICAgICAgICAuc29ydChudWxsKVxuICAgICAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbihkKSB7IHJldHVybiBkLmRpc2FibGVkID8gMCA6IGdldFkoZCkgfSk7XG5cbiAgICAgICAgICAgIC8vIHBhZEFuZ2xlIGFkZGVkIGluIGQzIDMuNVxuICAgICAgICAgICAgaWYgKHBpZS5wYWRBbmdsZSAmJiBwYWRBbmdsZSkge1xuICAgICAgICAgICAgICAgIHBpZS5wYWRBbmdsZShwYWRBbmdsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRpdGxlIGlzIHNwZWNpZmllZCBhbmQgZG9udXQsIHB1dCBpdCBpbiB0aGUgbWlkZGxlXG4gICAgICAgICAgICBpZiAoZG9udXQgJiYgdGl0bGUpIHtcbiAgICAgICAgICAgICAgICBnX3BpZS5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoJ2NsYXNzJywgJ252LXBpZS10aXRsZScpO1xuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1waWUtdGl0bGUnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJmb250LXNpemVcIiwgKE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpKSAqIGRvbnV0UmF0aW8gKiAyIC8gKHRpdGxlLmxlbmd0aCArIDIpICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImR5XCIsIFwiMC4zNWVtXCIpIC8vIHRyaWNrIHRvIHZlcnRpY2FsbHkgY2VudGVyIHRleHRcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKDAsICcrIHRpdGxlT2Zmc2V0ICsgJyknO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNsaWNlcyA9IHdyYXAuc2VsZWN0KCcubnYtcGllJykuc2VsZWN0QWxsKCcubnYtc2xpY2UnKS5kYXRhKHBpZSk7XG4gICAgICAgICAgICB2YXIgcGllTGFiZWxzID0gd3JhcC5zZWxlY3QoJy5udi1waWVMYWJlbHMnKS5zZWxlY3RBbGwoJy5udi1sYWJlbCcpLmRhdGEocGllKTtcblxuICAgICAgICAgICAgc2xpY2VzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIHBpZUxhYmVscy5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHZhciBhZSA9IHNsaWNlcy5lbnRlcigpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgYWUuYXR0cignY2xhc3MnLCAnbnYtc2xpY2UnKTtcbiAgICAgICAgICAgIGFlLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3dPbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoXCJwYXRoXCIpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDcwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyY3NPdmVyW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBkMy5zZWxlY3QodGhpcykuc3R5bGUoXCJmaWxsXCIpLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50OiAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFlLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3dPbkhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3QoXCJwYXRoXCIpLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGFyY3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe2RhdGE6IGQuZGF0YSwgaW5kZXg6IGl9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWUub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2Vtb3ZlKHtkYXRhOiBkLmRhdGEsIGluZGV4OiBpfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFlLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIiksXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZS5vbignZGJsY2xpY2snLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGQzLnNlbGVjdCh0aGlzKS5zdHlsZShcImZpbGxcIilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzbGljZXMuYXR0cignZmlsbCcsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gY29sb3IoZC5kYXRhLCBpKTsgfSk7XG4gICAgICAgICAgICBzbGljZXMuYXR0cignc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBjb2xvcihkLmRhdGEsIGkpOyB9KTtcblxuICAgICAgICAgICAgdmFyIHBhdGhzID0gYWUuYXBwZW5kKCdwYXRoJykuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudCA9IGQ7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2xpY2VzLnNlbGVjdCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIGZ1bmN0aW9uIChkLCBpKSB7IHJldHVybiBhcmNzW2ldKGQpOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyVHdlZW4oJ2QnLCBhcmNUd2Vlbik7XG5cbiAgICAgICAgICAgIGlmIChzaG93TGFiZWxzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBkb2VzIHRoZSBub3JtYWwgbGFiZWxcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxzQXJjID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsc0FyYy5wdXNoKGFyY3NbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbHNPdXRzaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9udXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHNBcmNbaV0gPSBkMy5zdmcuYXJjKCkub3V0ZXJSYWRpdXMoYXJjc1tpXS5vdXRlclJhZGl1cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRBbmdsZSAhPT0gZmFsc2UpIGxhYmVsc0FyY1tpXS5zdGFydEFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmRBbmdsZSAhPT0gZmFsc2UpIGxhYmVsc0FyY1tpXS5lbmRBbmdsZShlbmRBbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRvbnV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzQXJjW2ldLmlubmVyUmFkaXVzKDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcGllTGFiZWxzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5jbGFzc2VkKFwibnYtbGFiZWxcIix0cnVlKS5lYWNoKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFN1bmJlYW1MYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLm91dGVyUmFkaXVzID0gYXJjc1JhZGl1c091dGVyW2ldICsgMTA7IC8vIFNldCBPdXRlciBDb29yZGluYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5pbm5lclJhZGl1cyA9IGFyY3NSYWRpdXNPdXRlcltpXSArIDE1OyAvLyBTZXQgSW5uZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVBbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgPCBNYXRoLlBJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlIC09IDkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZUFuZ2xlICs9IDkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbGFiZWxzQXJjW2ldLmNlbnRyb2lkKGQpICsgJykgcm90YXRlKCcgKyByb3RhdGVBbmdsZSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5vdXRlclJhZGl1cyA9IHJhZGl1cyArIDEwOyAvLyBTZXQgT3V0ZXIgQ29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQuaW5uZXJSYWRpdXMgPSByYWRpdXMgKyAxNTsgLy8gU2V0IElubmVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbGFiZWxzQXJjW2ldLmNlbnRyb2lkKGQpICsgJyknXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsICcjZmZmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICcjZmZmJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnhcIiwgMylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwicnlcIiwgMyk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCBsYWJlbFN1bmJlYW1MYXlvdXQgPyAoKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiA8IE1hdGguUEkgPyAnc3RhcnQnIDogJ2VuZCcpIDogJ21pZGRsZScpIC8vY2VudGVyIHRoZSB0ZXh0IG9uIGl0J3Mgb3JpZ2luIG9yIGJlZ2luL2VuZCBpZiBvcnRob2dvbmFsIGFsaWduZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbCcsICcjMDAwJylcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBsYWJlbExvY2F0aW9uSGFzaCA9IHt9O1xuICAgICAgICAgICAgICAgIHZhciBhdmdIZWlnaHQgPSAxNDtcbiAgICAgICAgICAgICAgICB2YXIgYXZnV2lkdGggPSAxNDA7XG4gICAgICAgICAgICAgICAgdmFyIGNyZWF0ZUhhc2hLZXkgPSBmdW5jdGlvbihjb29yZGluYXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihjb29yZGluYXRlc1swXS9hdmdXaWR0aCkgKiBhdmdXaWR0aCArICcsJyArIE1hdGguZmxvb3IoY29vcmRpbmF0ZXNbMV0vYXZnSGVpZ2h0KSAqIGF2Z0hlaWdodDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBnZXRTbGljZVBlcmNlbnRhZ2UgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBwaWVMYWJlbHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAncGllIGxhYmVscycpLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFN1bmJlYW1MYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSBhcmNzUmFkaXVzT3V0ZXJbaV0gKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuaW5uZXJSYWRpdXMgPSBhcmNzUmFkaXVzT3V0ZXJbaV0gKyAxNTsgLy8gU2V0IElubmVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVBbmdsZSA9IChkLnN0YXJ0QW5nbGUgKyBkLmVuZEFuZ2xlKSAvIDIgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpIC8gMiA8IE1hdGguUEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSAtPSA5MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlQW5nbGUgKz0gOTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbGFiZWxzQXJjW2ldLmNlbnRyb2lkKGQpICsgJykgcm90YXRlKCcgKyByb3RhdGVBbmdsZSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQub3V0ZXJSYWRpdXMgPSByYWRpdXMgKyAxMDsgLy8gU2V0IE91dGVyIENvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuaW5uZXJSYWRpdXMgPSByYWRpdXMgKyAxNTsgLy8gU2V0IElubmVyIENvb3JkaW5hdGVcblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgIE92ZXJsYXBwaW5nIHBpZSBsYWJlbHMgYXJlIG5vdCBnb29kLiBXaGF0IHRoaXMgYXR0ZW1wdHMgdG8gZG8gaXMsIHByZXZlbnQgb3ZlcmxhcHBpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBFYWNoIGxhYmVsIGxvY2F0aW9uIGlzIGhhc2hlZCwgYW5kIGlmIGEgaGFzaCBjb2xsaXNpb24gb2NjdXJzLCB3ZSBhc3N1bWUgYW4gb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIEFkanVzdCB0aGUgbGFiZWwncyB5LXBvc2l0aW9uIHRvIHJlbW92ZSB0aGUgb3ZlcmxhcC5cbiAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyID0gbGFiZWxzQXJjW2ldLmNlbnRyb2lkKGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBnZXRTbGljZVBlcmNlbnRhZ2UoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC52YWx1ZSAmJiBwZXJjZW50ID49IGxhYmVsVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hLZXkgPSBjcmVhdGVIYXNoS2V5KGNlbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsTG9jYXRpb25IYXNoW2hhc2hLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclsxXSAtPSBhdmdIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsTG9jYXRpb25IYXNoW2NyZWF0ZUhhc2hLZXkoY2VudGVyKV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGNlbnRlciArICcpJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBwaWVMYWJlbHMuc2VsZWN0KFwiLm52LWxhYmVsIHRleHRcIilcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCd0ZXh0LWFuY2hvcicsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jZW50ZXIgdGhlIHRleHQgb24gaXQncyBvcmlnaW4gb3IgYmVnaW4vZW5kIGlmIG9ydGhvZ29uYWwgYWxpZ25lZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsU3VuYmVhbUxheW91dCA/ICgoZC5zdGFydEFuZ2xlICsgZC5lbmRBbmdsZSkgLyAyIDwgTWF0aC5QSSA/ICdzdGFydCcgOiAnZW5kJykgOiAnbWlkZGxlJztcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBnZXRTbGljZVBlcmNlbnRhZ2UoZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZC52YWx1ZSB8fCBwZXJjZW50IDwgbGFiZWxUaHJlc2hvbGQpIHJldHVybiAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGxhYmVsVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gbGFiZWxUeXBlKGQsIGksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2tleSc6IGdldFgoZC5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ZhbHVlJzogZ2V0WShkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGVyY2VudCc6IHZhbHVlRm9ybWF0KHBlcmNlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobGFiZWxUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGdldFgoZC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHZhbHVlRm9ybWF0KGdldFkoZC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncGVyY2VudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IGQzLmZvcm1hdCgnJScpKHBlcmNlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBDb21wdXRlcyB0aGUgYW5nbGUgb2YgYW4gYXJjLCBjb252ZXJ0aW5nIGZyb20gcmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAgICAgICAgZnVuY3Rpb24gYW5nbGUoZCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gKGQuc3RhcnRBbmdsZSArIGQuZW5kQW5nbGUpICogOTAgLyBNYXRoLlBJIC0gOTA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgPiA5MCA/IGEgLSAxODAgOiBhO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBhcmNUd2VlbihhLCBpZHgpIHtcbiAgICAgICAgICAgICAgICBhLmVuZEFuZ2xlID0gaXNOYU4oYS5lbmRBbmdsZSkgPyAwIDogYS5lbmRBbmdsZTtcbiAgICAgICAgICAgICAgICBhLnN0YXJ0QW5nbGUgPSBpc05hTihhLnN0YXJ0QW5nbGUpID8gMCA6IGEuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbnV0KSBhLmlubmVyUmFkaXVzID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IGQzLmludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnQgPSBpKDApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJjc1tpZHhdKGkodCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgncGllIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIGFyY3NSYWRpdXM6IHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcmNzUmFkaXVzOyB9LCBzZXQ6IGZ1bmN0aW9uIChfKSB7IGFyY3NSYWRpdXMgPSBfOyB9IH0sXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMYWJlbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGFiZWxzPV87fX0sXG4gICAgICAgIHRpdGxlOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpdGxlO30sIHNldDogZnVuY3Rpb24oXyl7dGl0bGU9Xzt9fSxcbiAgICAgICAgdGl0bGVPZmZzZXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRpdGxlT2Zmc2V0O30sIHNldDogZnVuY3Rpb24oXyl7dGl0bGVPZmZzZXQ9Xzt9fSxcbiAgICAgICAgbGFiZWxUaHJlc2hvbGQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxhYmVsVGhyZXNob2xkO30sIHNldDogZnVuY3Rpb24oXyl7bGFiZWxUaHJlc2hvbGQ9Xzt9fSxcbiAgICAgICAgdmFsdWVGb3JtYXQ6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHZhbHVlRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7dmFsdWVGb3JtYXQ9Xzt9fSxcbiAgICAgICAgeDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFg9Xzt9fSxcbiAgICAgICAgaWQ6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICBlbmRBbmdsZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBlbmRBbmdsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2VuZEFuZ2xlPV87fX0sXG4gICAgICAgIHN0YXJ0QW5nbGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXJ0QW5nbGU7fSwgc2V0OiBmdW5jdGlvbihfKXtzdGFydEFuZ2xlPV87fX0sXG4gICAgICAgIHBhZEFuZ2xlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZEFuZ2xlO30sIHNldDogZnVuY3Rpb24oXyl7cGFkQW5nbGU9Xzt9fSxcbiAgICAgICAgY29ybmVyUmFkaXVzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb3JuZXJSYWRpdXM7fSwgc2V0OiBmdW5jdGlvbihfKXtjb3JuZXJSYWRpdXM9Xzt9fSxcbiAgICAgICAgZG9udXRSYXRpbzogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkb251dFJhdGlvO30sIHNldDogZnVuY3Rpb24oXyl7ZG9udXRSYXRpbz1fO319LFxuICAgICAgICBsYWJlbHNPdXRzaWRlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsYWJlbHNPdXRzaWRlO30sIHNldDogZnVuY3Rpb24oXyl7bGFiZWxzT3V0c2lkZT1fO319LFxuICAgICAgICBsYWJlbFN1bmJlYW1MYXlvdXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxhYmVsU3VuYmVhbUxheW91dDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xhYmVsU3VuYmVhbUxheW91dD1fO319LFxuICAgICAgICBkb251dDogICAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRvbnV0O30sIHNldDogZnVuY3Rpb24oXyl7ZG9udXQ9Xzt9fSxcbiAgICAgICAgZ3Jvd09uSG92ZXI6ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBncm93T25Ib3Zlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dyb3dPbkhvdmVyPV87fX0sXG5cbiAgICAgICAgLy8gZGVwcmVjaWF0ZWQgYWZ0ZXIgMS43LjFcbiAgICAgICAgcGllTGFiZWxzT3V0c2lkZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGFiZWxzT3V0c2lkZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbGFiZWxzT3V0c2lkZT1fO1xuICAgICAgICAgICAgbnYuZGVwcmVjYXRlZCgncGllTGFiZWxzT3V0c2lkZScsICd1c2UgbGFiZWxzT3V0c2lkZSBpbnN0ZWFkJyk7XG4gICAgICAgIH19LFxuICAgICAgICAvLyBkZXByZWNpYXRlZCBhZnRlciAxLjcuMVxuICAgICAgICBkb251dExhYmVsc091dHNpZGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxhYmVsc091dHNpZGU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGxhYmVsc091dHNpZGU9XztcbiAgICAgICAgICAgIG52LmRlcHJlY2F0ZWQoJ2RvbnV0TGFiZWxzT3V0c2lkZScsICd1c2UgbGFiZWxzT3V0c2lkZSBpbnN0ZWFkJyk7XG4gICAgICAgIH19LFxuICAgICAgICAvLyBkZXByZWNhdGVkIGFmdGVyIDEuNy4xXG4gICAgICAgIGxhYmVsRm9ybWF0OiB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdmFsdWVGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICB2YWx1ZUZvcm1hdD1fO1xuICAgICAgICAgICAgbnYuZGVwcmVjYXRlZCgnbGFiZWxGb3JtYXQnLCd1c2UgdmFsdWVGb3JtYXQgaW5zdGVhZCcpO1xuICAgICAgICB9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gdHlwZW9mIF8udG9wICAgICE9ICd1bmRlZmluZWQnID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IHR5cGVvZiBfLnJpZ2h0ICAhPSAndW5kZWZpbmVkJyA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IHR5cGVvZiBfLmJvdHRvbSAhPSAndW5kZWZpbmVkJyA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSB0eXBlb2YgXy5sZWZ0ICAgIT0gJ3VuZGVmaW5lZCcgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgIH19LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBnZXRZPWQzLmZ1bmN0b3IoXyk7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yPW52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgbGFiZWxUeXBlOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsYWJlbFR5cGU7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGxhYmVsVHlwZT0gXyB8fCAna2V5JztcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLnBpZUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBwaWUgPSBudi5tb2RlbHMucGllKCk7XG4gICAgdmFyIGxlZ2VuZCA9IG52Lm1vZGVscy5sZWdlbmQoKTtcbiAgICB2YXIgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKCk7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMzAsIHJpZ2h0OiAyMCwgYm90dG9tOiAyMCwgbGVmdDogMjB9XG4gICAgICAgICwgbWFyZ2luVG9wID0gbnVsbFxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBzaG93VG9vbHRpcFBlcmNlbnQgPSBmYWxzZVxuICAgICAgICAsIHNob3dMZWdlbmQgPSB0cnVlXG4gICAgICAgICwgbGVnZW5kUG9zaXRpb24gPSBcInRvcFwiXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBub0RhdGEgPSBudWxsXG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsJ3JlbmRlckVuZCcpXG4gICAgICAgIDtcblxuICAgIHRvb2x0aXBcbiAgICAgICAgLmR1cmF0aW9uKDApXG4gICAgICAgIC5oZWFkZXJFbmFibGVkKGZhbHNlKVxuICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHBpZS52YWx1ZUZvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLmRpc2FibGVkID0gIXN0YXRlLmFjdGl2ZVtpXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIENoYXJ0IGZ1bmN0aW9uXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMocGllKTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBudi51dGlscy5hdmFpbGFibGVXaWR0aCh3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuY2FsbChjaGFydCk7IH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSB0aGlzO1xuXG4gICAgICAgICAgICBzdGF0ZS5zZXR0ZXIoc3RhdGVTZXR0ZXIoZGF0YSksIGNoYXJ0LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAuZ2V0dGVyKHN0YXRlR2V0dGVyKGRhdGEpKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy9zZXQgc3RhdGUuZGlzYWJsZWRcbiAgICAgICAgICAgIHN0YXRlLmRpc2FibGVkID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpc2FibGVkIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlW2tleV0gaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFN0YXRlW2tleV0gPSBzdGF0ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGlzcGxheSBObyBEYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbnYudXRpbHMubm9EYXRhKGNoYXJ0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtcGllQ2hhcnQnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1waWVDaGFydCcpLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtcGllV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcblxuICAgICAgICAgICAgLy8gTGVnZW5kXG4gICAgICAgICAgICBpZiAoIXNob3dMZWdlbmQpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKS5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlZ2VuZFBvc2l0aW9uID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aCggYXZhaWxhYmxlV2lkdGggKS5rZXkocGllLngoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBsZWdlbmQuaGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZ2VuZFBvc2l0aW9uID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZFdpZHRoID0gbnYubW9kZWxzLmxlZ2VuZCgpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGVXaWR0aCAvIDIgPCBsZWdlbmRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVnZW5kV2lkdGggPSAoYXZhaWxhYmxlV2lkdGggLyAyKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KS5rZXkocGllLngoKSk7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC53aWR0aChsZWdlbmRXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoIC09IGxlZ2VuZC53aWR0aCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoYXZhaWxhYmxlV2lkdGgpICsnLDApJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgcGllLndpZHRoKGF2YWlsYWJsZVdpZHRoKS5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBwaWVXcmFwID0gZy5zZWxlY3QoJy5udi1waWVXcmFwJykuZGF0dW0oW2RhdGFdKTtcbiAgICAgICAgICAgIGQzLnRyYW5zaXRpb24ocGllV3JhcCkuY2FsbChwaWUpO1xuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gRXZlbnQgSGFuZGxpbmcvRGlzcGF0Y2hpbmcgKGluIGNoYXJ0J3Mgc2NvcGUpXG4gICAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICBsZWdlbmQuZGlzcGF0Y2gub24oJ3N0YXRlQ2hhbmdlJywgZnVuY3Rpb24obmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZS5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBlLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3BpZUNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHBpZS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGV2dFsnc2VyaWVzJ10gPSB7XG4gICAgICAgICAgICBrZXk6IGNoYXJ0LngoKShldnQuZGF0YSksXG4gICAgICAgICAgICB2YWx1ZTogY2hhcnQueSgpKGV2dC5kYXRhKSxcbiAgICAgICAgICAgIGNvbG9yOiBldnQuY29sb3IsXG4gICAgICAgICAgICBwZXJjZW50OiBldnQucGVyY2VudFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXNob3dUb29sdGlwUGVyY2VudCkge1xuICAgICAgICAgICAgZGVsZXRlIGV2dC5wZXJjZW50O1xuICAgICAgICAgICAgZGVsZXRlIGV2dC5zZXJpZXMucGVyY2VudDtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgcGllLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwLmhpZGRlbih0cnVlKTtcbiAgICB9KTtcblxuICAgIHBpZS5kaXNwYXRjaC5vbignZWxlbWVudE1vdXNlbW92ZS50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAoKTtcbiAgICB9KTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLy8gZXhwb3NlIGNoYXJ0J3Mgc3ViLWNvbXBvbmVudHNcbiAgICBjaGFydC5sZWdlbmQgPSBsZWdlbmQ7XG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5waWUgPSBwaWU7XG4gICAgY2hhcnQudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgLy8gdXNlIE9iamVjdCBnZXQvc2V0IGZ1bmN0aW9uYWxpdHkgdG8gbWFwIGJldHdlZW4gdmFycyBhbmQgY2hhcnQgZnVuY3Rpb25zXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe25vRGF0YT1fO319LFxuICAgICAgICBzaG93VG9vbHRpcFBlcmNlbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dUb29sdGlwUGVyY2VudDt9LCAgIHNldDogZnVuY3Rpb24oXyl7c2hvd1Rvb2x0aXBQZXJjZW50PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIGxlZ2VuZFBvc2l0aW9uOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGVnZW5kUG9zaXRpb247fSwgICAgICAgc2V0OiBmdW5jdGlvbihfKXtsZWdlbmRQb3NpdGlvbj1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmF1bHRTdGF0ZTt9LCAgICAgICAgIHNldDogZnVuY3Rpb24oXyl7ZGVmYXVsdFN0YXRlPV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gXztcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBwaWUuY29sb3IoY29sb3IpO1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBwaWUuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGlmIChfLnRvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IF8udG9wO1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcCA9IF8udG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fVxuICAgIH0pO1xuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBwaWUpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLnNhbmtleSA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIFNvdXJjZXM6XG4gICAgLy8gLSBodHRwczovL2Jvc3Qub2Nrcy5vcmcvbWlrZS9zYW5rZXkvXG4gICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vc294b2ZhYW4vZDMtcGx1Z2luLWNhcHRhaW4tc2Fua2V5XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzYW5rZXkgPSB7fSxcbiAgICAgICAgbm9kZVdpZHRoID0gMjQsXG4gICAgICAgIG5vZGVQYWRkaW5nID0gOCxcbiAgICAgICAgc2l6ZSA9IFsxLCAxXSxcbiAgICAgICAgbm9kZXMgPSBbXSxcbiAgICAgICAgbGlua3MgPSBbXSxcbiAgICAgICAgc2lua3NSaWdodCA9IHRydWU7XG5cbiAgICB2YXIgbGF5b3V0ID0gZnVuY3Rpb24oaXRlcmF0aW9ucykge1xuICAgICAgICBjb21wdXRlTm9kZUxpbmtzKCk7XG4gICAgICAgIGNvbXB1dGVOb2RlVmFsdWVzKCk7XG4gICAgICAgIGNvbXB1dGVOb2RlQnJlYWR0aHMoKTtcbiAgICAgICAgY29tcHV0ZU5vZGVEZXB0aHMoaXRlcmF0aW9ucyk7XG4gICAgfTtcblxuICAgIHZhciByZWxheW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb21wdXRlTGlua0RlcHRocygpO1xuICAgIH07XG5cbiAgICAvLyBTVkcgcGF0aCBkYXRhIGdlbmVyYXRvciwgdG8gYmUgdXNlZCBhcyAnZCcgYXR0cmlidXRlIG9uICdwYXRoJyBlbGVtZW50IHNlbGVjdGlvbi5cbiAgICB2YXIgbGluayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VydmF0dXJlID0gLjU7XG5cbiAgICAgICAgZnVuY3Rpb24gbGluayhkKSB7XG5cbiAgICAgICAgICAgIHZhciB4MCA9IGQuc291cmNlLnggKyBkLnNvdXJjZS5keCxcbiAgICAgICAgICAgICAgICB4MSA9IGQudGFyZ2V0LngsXG4gICAgICAgICAgICAgICAgeGkgPSBkMy5pbnRlcnBvbGF0ZU51bWJlcih4MCwgeDEpLFxuICAgICAgICAgICAgICAgIHgyID0geGkoY3VydmF0dXJlKSxcbiAgICAgICAgICAgICAgICB4MyA9IHhpKDEgLSBjdXJ2YXR1cmUpLFxuICAgICAgICAgICAgICAgIHkwID0gZC5zb3VyY2UueSArIGQuc3kgKyBkLmR5IC8gMixcbiAgICAgICAgICAgICAgICB5MSA9IGQudGFyZ2V0LnkgKyBkLnR5ICsgZC5keSAvIDI7XG4gICAgICAgICAgICB2YXIgbGlua1BhdGggPSAnTScgKyB4MCArICcsJyArIHkwXG4gICAgICAgICAgICAgICAgKyAnQycgKyB4MiArICcsJyArIHkwXG4gICAgICAgICAgICAgICAgKyAnICcgKyB4MyArICcsJyArIHkxXG4gICAgICAgICAgICAgICAgKyAnICcgKyB4MSArICcsJyArIHkxO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmtQYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGluay5jdXJ2YXR1cmUgPSBmdW5jdGlvbihfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjdXJ2YXR1cmU7XG4gICAgICAgICAgICBjdXJ2YXR1cmUgPSArXztcbiAgICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBsaW5rO1xuICAgIH07XG5cbiAgICAvLyBZLXBvc2l0aW9uIG9mIHRoZSBtaWRkbGUgb2YgYSBub2RlLlxuICAgIHZhciBjZW50ZXIgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnkgKyBub2RlLmR5IC8gMjtcbiAgICB9O1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBQb3B1bGF0ZSB0aGUgc291cmNlTGlua3MgYW5kIHRhcmdldExpbmtzIGZvciBlYWNoIG5vZGUuXG4gICAgLy8gQWxzbywgaWYgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBub3Qgb2JqZWN0cywgYXNzdW1lIHRoZXkgYXJlIGluZGljZXMuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVMaW5rcygpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAvLyBMaW5rcyB0aGF0IGhhdmUgdGhpcyBub2RlIGFzIHNvdXJjZS5cbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MgPSBbXTtcbiAgICAgICAgICAgIC8vIExpbmtzIHRoYXQgaGF2ZSB0aGlzIG5vZGUgYXMgdGFyZ2V0LlxuICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcyA9IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gbGluay5zb3VyY2UsXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gbGluay50YXJnZXQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ251bWJlcicpIHNvdXJjZSA9IGxpbmsuc291cmNlID0gbm9kZXNbbGluay5zb3VyY2VdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSB0YXJnZXQgPSBsaW5rLnRhcmdldCA9IG5vZGVzW2xpbmsudGFyZ2V0XTtcbiAgICAgICAgICAgIHNvdXJjZS5zb3VyY2VMaW5rcy5wdXNoKGxpbmspO1xuICAgICAgICAgICAgdGFyZ2V0LnRhcmdldExpbmtzLnB1c2gobGluayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIHZhbHVlIChzaXplKSBvZiBlYWNoIG5vZGUgYnkgc3VtbWluZyB0aGUgYXNzb2NpYXRlZCBsaW5rcy5cbiAgICBmdW5jdGlvbiBjb21wdXRlTm9kZVZhbHVlcygpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgZDMuc3VtKG5vZGUuc291cmNlTGlua3MsIHZhbHVlKSxcbiAgICAgICAgICAgICAgICBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgdmFsdWUpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRpdmVseSBhc3NpZ24gdGhlIGJyZWFkdGggKHgtcG9zaXRpb24pIGZvciBlYWNoIG5vZGUuXG4gICAgLy8gTm9kZXMgYXJlIGFzc2lnbmVkIHRoZSBtYXhpbXVtIGJyZWFkdGggb2YgaW5jb21pbmcgbmVpZ2hib3JzIHBsdXMgb25lO1xuICAgIC8vIG5vZGVzIHdpdGggbm8gaW5jb21pbmcgbGlua3MgYXJlIGFzc2lnbmVkIGJyZWFkdGggemVybywgd2hpbGVcbiAgICAvLyBub2RlcyB3aXRoIG5vIG91dGdvaW5nIGxpbmtzIGFyZSBhc3NpZ25lZCB0aGUgbWF4aW11bSBicmVhZHRoLlxuICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlQnJlYWR0aHMoKSB7XG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZW1haW5pbmdOb2RlcyA9IG5vZGVzLFxuICAgICAgICAgICAgbmV4dE5vZGVzLFxuICAgICAgICAgICAgeCA9IDA7XG5cbiAgICAgICAgLy8gV29yayBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIC8vIEtlZXAgdXBkYXRpbmcgdGhlIGJyZWF0aCAoeC1wb3NpdGlvbikgb2Ygbm9kZXMgdGhhdCBhcmUgdGFyZ2V0IG9mIHJlY2VudGx5IHVwZGF0ZWQgbm9kZXMuXG4gICAgICAgIC8vXG4gICAgICAgIHdoaWxlIChyZW1haW5pbmdOb2Rlcy5sZW5ndGggJiYgeCA8IG5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dE5vZGVzID0gW107XG4gICAgICAgICAgICByZW1haW5pbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSB4O1xuICAgICAgICAgICAgICAgIG5vZGUuZHggPSBub2RlV2lkdGg7XG4gICAgICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHROb2Rlcy5pbmRleE9mKGxpbmsudGFyZ2V0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHROb2Rlcy5wdXNoKGxpbmsudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZW1haW5pbmdOb2RlcyA9IG5leHROb2RlcztcbiAgICAgICAgICAgICsreDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbGx5IG1vdmUgcHVyZSBzaW5rcyBhbHdheXMgdG8gdGhlIHJpZ2h0LlxuICAgICAgICBpZiAoc2lua3NSaWdodCkge1xuICAgICAgICAgICAgbW92ZVNpbmtzUmlnaHQoeCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2FsZU5vZGVCcmVhZHRocygoc2l6ZVswXSAtIG5vZGVXaWR0aCkgLyAoeCAtIDEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlU291cmNlc1JpZ2h0KCkge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS50YXJnZXRMaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSBkMy5taW4obm9kZS5zb3VyY2VMaW5rcywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50YXJnZXQueDsgfSkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3ZlU2lua3NSaWdodCh4KSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlLnNvdXJjZUxpbmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5vZGUueCA9IHggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZU5vZGVCcmVhZHRocyhreCkge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUueCAqPSBreDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgZGVwdGggKHktcG9zaXRpb24pIGZvciBlYWNoIG5vZGUuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVEZXB0aHMoaXRlcmF0aW9ucykge1xuICAgICAgICAvLyBHcm91cCBub2RlcyBieSBicmVhdGguXG4gICAgICAgIHZhciBub2Rlc0J5QnJlYWR0aCA9IGQzLm5lc3QoKVxuICAgICAgICAgICAgLmtleShmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pXG4gICAgICAgICAgICAuc29ydEtleXMoZDMuYXNjZW5kaW5nKVxuICAgICAgICAgICAgLmVudHJpZXMobm9kZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzOyB9KTtcblxuICAgICAgICAvL1xuICAgICAgICBpbml0aWFsaXplTm9kZURlcHRoKCk7XG4gICAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgICAgIGNvbXB1dGVMaW5rRGVwdGhzKCk7XG4gICAgICAgIGZvciAodmFyIGFscGhhID0gMTsgaXRlcmF0aW9ucyA+IDA7IC0taXRlcmF0aW9ucykge1xuICAgICAgICAgICAgcmVsYXhSaWdodFRvTGVmdChhbHBoYSAqPSAuOTkpO1xuICAgICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbnMoKTtcbiAgICAgICAgICAgIGNvbXB1dGVMaW5rRGVwdGhzKCk7XG4gICAgICAgICAgICByZWxheExlZnRUb1JpZ2h0KGFscGhhKTtcbiAgICAgICAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgICAgICAgICBjb21wdXRlTGlua0RlcHRocygpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVEZXB0aCgpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB2ZXJ0aWNhbCBzY2FsaW5nIGZhY3Rvci5cbiAgICAgICAgICAgIHZhciBreSA9IGQzLm1pbihub2Rlc0J5QnJlYWR0aCwgZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNpemVbMV0gLSAobm9kZXMubGVuZ3RoIC0gMSkgKiBub2RlUGFkZGluZykgLyBkMy5zdW0obm9kZXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBub2Rlc0J5QnJlYWR0aC5mb3JFYWNoKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUueSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZHkgPSBub2RlLnZhbHVlICoga3k7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICAgICAgbGluay5keSA9IGxpbmsudmFsdWUgKiBreTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVsYXhMZWZ0VG9SaWdodChhbHBoYSkge1xuICAgICAgICAgICAgbm9kZXNCeUJyZWFkdGguZm9yRWFjaChmdW5jdGlvbihub2RlcywgYnJlYWR0aCkge1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50YXJnZXRMaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbHVlLXdlaWdodGVkIGF2ZXJhZ2Ugb2YgdGhlIHktcG9zaXRpb24gb2Ygc291cmNlIG5vZGUgY2VudGVycyBsaW5rZWQgdG8gdGhpcyBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBkMy5zdW0obm9kZS50YXJnZXRMaW5rcywgd2VpZ2h0ZWRTb3VyY2UpIC8gZDMuc3VtKG5vZGUudGFyZ2V0TGlua3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUueSArPSAoeSAtIGNlbnRlcihub2RlKSkgKiBhbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHdlaWdodGVkU291cmNlKGxpbmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxpbmsuc291cmNlLnkgKyBsaW5rLnN5ICsgbGluay5keSAvIDIpICogbGluay52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJlbGF4UmlnaHRUb0xlZnQoYWxwaGEpIHtcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLnNsaWNlKCkucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc291cmNlTGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWx1ZS13ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSB5LXBvc2l0aW9ucyBvZiB0YXJnZXQgbm9kZXMgbGlua2VkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gZDMuc3VtKG5vZGUuc291cmNlTGlua3MsIHdlaWdodGVkVGFyZ2V0KSAvIGQzLnN1bShub2RlLnNvdXJjZUxpbmtzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnkgKz0gKHkgLSBjZW50ZXIobm9kZSkpICogYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3ZWlnaHRlZFRhcmdldChsaW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsaW5rLnRhcmdldC55ICsgbGluay50eSArIGxpbmsuZHkgLyAyKSAqIGxpbmsudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9ucygpIHtcbiAgICAgICAgICAgIG5vZGVzQnlCcmVhZHRoLmZvckVhY2goZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgZHksXG4gICAgICAgICAgICAgICAgICAgIHkwID0gMCxcbiAgICAgICAgICAgICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgICAgIC8vIFB1c2ggYW55IG92ZXJsYXBwaW5nIG5vZGVzIGRvd24uXG4gICAgICAgICAgICAgICAgbm9kZXMuc29ydChhc2NlbmRpbmdEZXB0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGR5ID0geTAgLSBub2RlLnk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkeSA+IDApIG5vZGUueSArPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBub2RlLnkgKyBub2RlLmR5ICsgbm9kZVBhZGRpbmc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJvdHRvbW1vc3Qgbm9kZSBnb2VzIG91dHNpZGUgdGhlIGJvdW5kcywgcHVzaCBpdCBiYWNrIHVwLlxuICAgICAgICAgICAgICAgIGR5ID0geTAgLSBub2RlUGFkZGluZyAtIHNpemVbMV07XG4gICAgICAgICAgICAgICAgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB5MCA9IG5vZGUueSAtPSBkeTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIGFueSBvdmVybGFwcGluZyBub2RlcyBiYWNrIHVwLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gbm9kZS55ICsgbm9kZS5keSArIG5vZGVQYWRkaW5nIC0geTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKSBub2RlLnkgLT0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5MCA9IG5vZGUueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nRGVwdGgoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgeS1vZmZzZXQgb2YgdGhlIHNvdXJjZSBlbmRwb2ludCAoc3kpIGFuZCB0YXJnZXQgZW5kcG9pbnRzICh0eSkgb2YgbGlua3MsXG4gICAgLy8gcmVsYXRpdmUgdG8gdGhlIHNvdXJjZS90YXJnZXQgbm9kZSdzIHktcG9zaXRpb24uXG4gICAgZnVuY3Rpb24gY29tcHV0ZUxpbmtEZXB0aHMoKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgbm9kZS5zb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldERlcHRoKTtcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3Muc29ydChhc2NlbmRpbmdTb3VyY2VEZXB0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBzeSA9IDAsIHR5ID0gMDtcbiAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICAgICAgbGluay5zeSA9IHN5O1xuICAgICAgICAgICAgICAgIHN5ICs9IGxpbmsuZHk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaChmdW5jdGlvbihsaW5rKSB7XG4gICAgICAgICAgICAgICAgbGluay50eSA9IHR5O1xuICAgICAgICAgICAgICAgIHR5ICs9IGxpbmsuZHk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nU291cmNlRGVwdGgoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuc291cmNlLnkgLSBiLnNvdXJjZS55O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYXNjZW5kaW5nVGFyZ2V0RGVwdGgoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEudGFyZ2V0LnkgLSBiLnRhcmdldC55O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsdWUgcHJvcGVydHkgYWNjZXNzb3IuXG4gICAgZnVuY3Rpb24gdmFsdWUoeCkge1xuICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICB9XG5cbiAgICBzYW5rZXkub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoc2Fua2V5KTtcbiAgICBzYW5rZXkuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIG5vZGVXaWR0aDogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9kZVdpZHRoO30sICAgc2V0OiBmdW5jdGlvbihfKXtub2RlV2lkdGg9K187fX0sXG4gICAgICAgIG5vZGVQYWRkaW5nOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9kZVBhZGRpbmc7fSwgc2V0OiBmdW5jdGlvbihfKXtub2RlUGFkZGluZz1fO319LFxuICAgICAgICBub2RlczogICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vZGVzO30sICAgICAgIHNldDogZnVuY3Rpb24oXyl7bm9kZXM9Xzt9fSxcbiAgICAgICAgbGlua3M6ICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5rcyA7fSwgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe2xpbmtzPV87fX0sXG4gICAgICAgIHNpemU6ICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2l6ZTt9LCAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtzaXplPV87fX0sXG4gICAgICAgIHNpbmtzUmlnaHQ6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2lua3NSaWdodDt9LCAgc2V0OiBmdW5jdGlvbihfKXtzaW5rc1JpZ2h0PV87fX0sXG5cbiAgICAgICAgbGF5b3V0OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe2xheW91dCgzMik7fSwgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe2xheW91dChfKTt9fSxcbiAgICAgICAgcmVsYXlvdXQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JlbGF5b3V0KCk7fSwgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe319LFxuICAgICAgICBjZW50ZXI6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNlbnRlcigpO30sICAgIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBpZih0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICAgICAgY2VudGVyPV87XG4gICAgICAgICAgICB9XG4gICAgICAgIH19LFxuICAgICAgICBsaW5rOiAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxpbmsoKTt9LCAgICAgIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBpZih0eXBlb2YgXyA9PT0gJ2Z1bmN0aW9uJyl7XG4gICAgICAgICAgICAgICAgbGluaz1fO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmsoKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKHNhbmtleSk7XG5cbiAgICByZXR1cm4gc2Fua2V5O1xufTtcbm52Lm1vZGVscy5zYW5rZXlDaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU291cmNlczpcbiAgICAvLyAtIGh0dHBzOi8vYm9zdC5vY2tzLm9yZy9taWtlL3NhbmtleS9cbiAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9zb3hvZmFhbi9kMy1wbHVnaW4tY2FwdGFpbi1zYW5rZXlcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDUsIHJpZ2h0OiAwLCBib3R0b206IDUsIGxlZnQ6IDB9XG4gICAgICAgICwgc2Fua2V5ID0gbnYubW9kZWxzLnNhbmtleSgpXG4gICAgICAgICwgd2lkdGggPSA2MDBcbiAgICAgICAgLCBoZWlnaHQgPSA0MDBcbiAgICAgICAgLCBub2RlV2lkdGggPSAzNlxuICAgICAgICAsIG5vZGVQYWRkaW5nID0gIDQwXG4gICAgICAgICwgdW5pdHMgPSAndW5pdHMnXG4gICAgICAgICwgY2VudGVyID0gdW5kZWZpbmVkXG4gICAgICAgIDtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIGZvcm1hdE51bWJlciA9IGQzLmZvcm1hdCgnLC4wZicpOyAgICAvLyB6ZXJvIGRlY2ltYWwgcGxhY2VzXG4gICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcihkKSArICcgJyArIHVuaXRzO1xuICAgIH07XG4gICAgdmFyIGNvbG9yID0gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpO1xuICAgIHZhciBsaW5rVGl0bGUgPSBmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuc291cmNlLm5hbWUgKyAnIOKGkiAnICsgZC50YXJnZXQubmFtZSArICdcXG4nICsgZm9ybWF0KGQudmFsdWUpO1xuICAgIH07XG4gICAgdmFyIG5vZGVGaWxsQ29sb3IgPSBmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQuY29sb3IgPSBjb2xvcihkLm5hbWUucmVwbGFjZSgvIC4qLywgJycpKTtcbiAgICB9O1xuICAgIHZhciBub2RlU3Ryb2tlQ29sb3IgPSBmdW5jdGlvbihkKXtcbiAgICAgICAgcmV0dXJuIGQzLnJnYihkLmNvbG9yKS5kYXJrZXIoMik7XG4gICAgfTtcbiAgICB2YXIgbm9kZVRpdGxlID0gZnVuY3Rpb24oZCl7XG4gICAgICAgIHJldHVybiBkLm5hbWUgKyAnXFxuJyArIGZvcm1hdChkLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgdmFyIHNob3dFcnJvciA9IGZ1bmN0aW9uKGVsZW1lbnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ3knLCAwKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMtc2Fua2V5LWNoYXJ0LWVycm9yJylcbiAgICAgICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgICAgICAgLnRleHQobWVzc2FnZSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgICAgIHZhciB0ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgICAgICBub2RlczpcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgeydub2RlJzogMSwgJ25hbWUnOiAnVGVzdCAxJ30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7J25vZGUnOiAyLCAnbmFtZSc6ICdUZXN0IDInfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsnbm9kZSc6IDMsICduYW1lJzogJ1Rlc3QgMyd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeydub2RlJzogNCwgJ25hbWUnOiAnVGVzdCA0J30sXG4gICAgICAgICAgICAgICAgICAgICAgICB7J25vZGUnOiA1LCAnbmFtZSc6ICdUZXN0IDUnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsnbm9kZSc6IDYsICduYW1lJzogJ1Rlc3QgNid9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgbGlua3M6XG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsnc291cmNlJzogMCwgJ3RhcmdldCc6IDEsICd2YWx1ZSc6IDIyOTV9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeydzb3VyY2UnOiAwLCAndGFyZ2V0JzogNSwgJ3ZhbHVlJzogMTE5OX0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7J3NvdXJjZSc6IDEsICd0YXJnZXQnOiAyLCAndmFsdWUnOiAxMTE5fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsnc291cmNlJzogMSwgJ3RhcmdldCc6IDUsICd2YWx1ZSc6IDExNzZ9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeydzb3VyY2UnOiAyLCAndGFyZ2V0JzogMywgJ3ZhbHVlJzogNDg3fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsnc291cmNlJzogMiwgJ3RhcmdldCc6IDUsICd2YWx1ZSc6IDYzMn0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7J3NvdXJjZSc6IDMsICd0YXJnZXQnOiA0LCAndmFsdWUnOiAzMDF9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeydzb3VyY2UnOiAzLCAndGFyZ2V0JzogNSwgJ3ZhbHVlJzogMTg2fVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBFcnJvciBoYW5kbGluZ1xuICAgICAgICAgICAgdmFyIGlzRGF0YVZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgZGF0YUF2YWlsYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGlzIHZhbGlkXG4gICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICAodHlwZW9mIGRhdGFbJ25vZGVzJ10gPT09ICdvYmplY3QnICYmIGRhdGFbJ25vZGVzJ10ubGVuZ3RoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBkYXRhWydsaW5rcyddID09PSAnb2JqZWN0JyAmJiBkYXRhWydsaW5rcyddLmxlbmd0aCkgPj0gMFxuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICBpc0RhdGFWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICBkYXRhWydub2RlcyddICYmIGRhdGFbJ25vZGVzJ10ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIGRhdGFbJ2xpbmtzJ10gJiYgZGF0YVsnbGlua3MnXS5sZW5ndGggPiAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkYXRhQXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2hvdyBlcnJvclxuICAgICAgICAgICAgaWYoIWlzRGF0YVZhbGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTlZEMyBTYW5rZXkgY2hhcnQgZXJyb3I6JywgJ2ludmFsaWQgZGF0YSBmb3JtYXQgZm9yJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdWYWxpZCBkYXRhIGZvcm1hdCBpczogJywgdGVzdERhdGEsIEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKSk7XG4gICAgICAgICAgICAgICAgc2hvd0Vycm9yKHNlbGVjdGlvbiwgJ0Vycm9yIGxvYWRpbmcgY2hhcnQsIGRhdGEgaXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETyB1c2UgbnYudXRpbHMubm9EYXRhXG4gICAgICAgICAgICBpZighZGF0YUF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHNob3dFcnJvcihzZWxlY3Rpb24sICdObyBkYXRhIGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm8gZXJyb3JzLCBjb250aW51ZVxuXG4gICAgICAgICAgICAvLyBhcHBlbmQgdGhlIHN2ZyBjYW52YXMgdG8gdGhlIHBhZ2VcbiAgICAgICAgICAgIHZhciBzdmcgPSBzZWxlY3Rpb24uYXBwZW5kKCdzdmcnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zYW5rZXlDaGFydCcpO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHNhbmtleSBkaWFncmFtIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHNhbmtleVxuICAgICAgICAgICAgICAgIC5ub2RlV2lkdGgobm9kZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5ub2RlUGFkZGluZyhub2RlUGFkZGluZylcbiAgICAgICAgICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pO1xuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IHNhbmtleS5saW5rKCk7XG5cbiAgICAgICAgICAgIHNhbmtleVxuICAgICAgICAgICAgICAgIC5ub2RlcyhkYXRhLm5vZGVzKVxuICAgICAgICAgICAgICAgIC5saW5rcyhkYXRhLmxpbmtzKVxuICAgICAgICAgICAgICAgIC5sYXlvdXQoMzIpXG4gICAgICAgICAgICAgICAgLmNlbnRlcihjZW50ZXIpO1xuXG4gICAgICAgICAgICAvLyBhZGQgaW4gdGhlIGxpbmtzXG4gICAgICAgICAgICB2YXIgbGluayA9IHN2Zy5hcHBlbmQoJ2cnKS5zZWxlY3RBbGwoJy5saW5rJylcbiAgICAgICAgICAgICAgICAuZGF0YShkYXRhLmxpbmtzKVxuICAgICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmsnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgcGF0aClcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS13aWR0aCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIE1hdGgubWF4KDEsIGQuZHkpOyB9KVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiBiLmR5IC0gYS5keTsgfSk7XG5cbiAgICAgICAgICAgIC8vIGFkZCB0aGUgbGluayB0aXRsZXNcbiAgICAgICAgICAgIGxpbmsuYXBwZW5kKCd0aXRsZScpXG4gICAgICAgICAgICAgICAgLnRleHQobGlua1RpdGxlKTtcblxuICAgICAgICAgICAgLy8gYWRkIGluIHRoZSBub2Rlc1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdmcuYXBwZW5kKCdnJykuc2VsZWN0QWxsKCcubm9kZScpXG4gICAgICAgICAgICAgICAgLmRhdGEoZGF0YS5ub2RlcylcbiAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdub2RlJylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknOyB9KVxuICAgICAgICAgICAgICAgIC5jYWxsKFxuICAgICAgICAgICAgICAgICAgICBkMy5iZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmRyYWcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9yaWdpbihmdW5jdGlvbihkKSB7IHJldHVybiBkOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdkcmFnJywgZHJhZ21vdmUpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSByZWN0YW5nbGVzIGZvciB0aGUgbm9kZXNcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5keTsgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBzYW5rZXkubm9kZVdpZHRoKCkpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgbm9kZUZpbGxDb2xvcilcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIG5vZGVTdHJva2VDb2xvcilcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCd0aXRsZScpXG4gICAgICAgICAgICAgICAgLnRleHQobm9kZVRpdGxlKTtcblxuICAgICAgICAgICAgLy8gYWRkIGluIHRoZSB0aXRsZSBmb3IgdGhlIG5vZGVzXG4gICAgICAgICAgICBub2RlLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtNilcbiAgICAgICAgICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuZHkgLyAyOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkeScsICcuMzVlbScpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ2VuZCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIG51bGwpXG4gICAgICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5uYW1lOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IDwgd2lkdGggLyAyOyB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgNiArIHNhbmtleS5ub2RlV2lkdGgoKSlcbiAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnc3RhcnQnKTtcblxuICAgICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGZvciBtb3ZpbmcgdGhlIG5vZGVzXG4gICAgICAgICAgICBmdW5jdGlvbiBkcmFnbW92ZShkKSB7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsXG4gICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgKFxuICAgICAgICAgICAgICAgICAgICBkLnkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihoZWlnaHQgLSBkLmR5LCBkMy5ldmVudC55KSlcbiAgICAgICAgICAgICAgICApICsgJyknKTtcbiAgICAgICAgICAgICAgICBzYW5rZXkucmVsYXlvdXQoKTtcbiAgICAgICAgICAgICAgICBsaW5rLmF0dHIoJ2QnLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgdW5pdHM6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB1bml0czt9LCAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe3VuaXRzPV87fX0sXG4gICAgICAgIHdpZHRoOiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgICAgICAgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCAgICAgIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGZvcm1hdDogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9ybWF0O30sICAgICAgc2V0OiBmdW5jdGlvbihfKXtmb3JtYXQ9Xzt9fSxcbiAgICAgICAgbGlua1RpdGxlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsaW5rVGl0bGU7fSwgICBzZXQ6IGZ1bmN0aW9uKF8pe2xpbmtUaXRsZT1fO319LFxuICAgICAgICBub2RlV2lkdGg6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG5vZGVXaWR0aDt9LCAgIHNldDogZnVuY3Rpb24oXyl7bm9kZVdpZHRoPV87fX0sXG4gICAgICAgIG5vZGVQYWRkaW5nOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9kZVBhZGRpbmc7fSwgc2V0OiBmdW5jdGlvbihfKXtub2RlUGFkZGluZz1fO319LFxuICAgICAgICBjZW50ZXI6ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNlbnRlcn0sICAgICAgIHNldDogZnVuY3Rpb24oXyl7Y2VudGVyPV99fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIG5vZGVTdHlsZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4ge307fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG5vZGVGaWxsQ29sb3IgICA9IF8uZmlsbENvbG9yICAgIT09IHVuZGVmaW5lZCA/IF8uZmlsbENvbG9yICAgOiBub2RlRmlsbENvbG9yO1xuICAgICAgICAgICAgbm9kZVN0cm9rZUNvbG9yID0gXy5zdHJva2VDb2xvciAhPT0gdW5kZWZpbmVkID8gXy5zdHJva2VDb2xvciA6IG5vZGVTdHJva2VDb2xvcjtcbiAgICAgICAgICAgIG5vZGVUaXRsZSAgICAgICA9IF8udGl0bGUgICAgICAgIT09IHVuZGVmaW5lZCA/IF8udGl0bGUgICAgICAgOiBub2RlVGl0bGU7XG4gICAgICAgIH19XG5cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zY2F0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBtYXJnaW4gICAgICAgPSB7dG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwfVxuICAgICAgICAsIHdpZHRoICAgICAgICA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgICAgICAgPSBudWxsXG4gICAgICAgICwgY29sb3IgICAgICAgID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKCkgLy8gY2hvb3NlcyBjb2xvclxuICAgICAgICAsIHBvaW50Qm9yZGVyQ29sb3IgPSBudWxsXG4gICAgICAgICwgaWQgICAgICAgICAgID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbmNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCBjb250YWluZXIgICAgPSBudWxsXG4gICAgICAgICwgeCAgICAgICAgICAgID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgLCB5ICAgICAgICAgICAgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHogICAgICAgICAgICA9IGQzLnNjYWxlLmxpbmVhcigpIC8vbGluZWFyIGJlY2F1c2UgZDMuc3ZnLnNoYXBlLnNpemUgaXMgdHJlYXRlZCBhcyBhcmVhXG4gICAgICAgICwgZ2V0WCAgICAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB4IHZhbHVlXG4gICAgICAgICwgZ2V0WSAgICAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB5IHZhbHVlXG4gICAgICAgICwgZ2V0U2l6ZSAgICAgID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5zaXplIHx8IDF9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgcG9pbnQgc2l6ZVxuICAgICAgICAsIGdldFNoYXBlICAgICA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc2hhcGUgfHwgJ2NpcmNsZScgfSAvLyBhY2Nlc3NvciB0byBnZXQgcG9pbnQgc2hhcGVcbiAgICAgICAgLCBmb3JjZVggICAgICAgPSBbXSAvLyBMaXN0IG9mIG51bWJlcnMgdG8gRm9yY2UgaW50byB0aGUgWCBzY2FsZSAoaWUuIDAsIG9yIGEgbWF4IC8gbWluLCBldGMuKVxuICAgICAgICAsIGZvcmNlWSAgICAgICA9IFtdIC8vIExpc3Qgb2YgbnVtYmVycyB0byBGb3JjZSBpbnRvIHRoZSBZIHNjYWxlXG4gICAgICAgICwgZm9yY2VTaXplICAgID0gW10gLy8gTGlzdCBvZiBudW1iZXJzIHRvIEZvcmNlIGludG8gdGhlIFNpemUgc2NhbGVcbiAgICAgICAgLCBpbnRlcmFjdGl2ZSAgPSB0cnVlIC8vIElmIHRydWUsIHBsb3RzIGEgdm9yb25vaSBvdmVybGF5IGZvciBhZHZhbmNlZCBwb2ludCBpbnRlcnNlY3Rpb25cbiAgICAgICAgLCBwb2ludEFjdGl2ZSAgPSBmdW5jdGlvbihkKSB7IHJldHVybiAhZC5ub3RBY3RpdmUgfSAvLyBhbnkgcG9pbnRzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgYmUgZmlsdGVyZWQgb3V0XG4gICAgICAgICwgcGFkRGF0YSAgICAgID0gZmFsc2UgLy8gSWYgdHJ1ZSwgYWRkcyBoYWxmIGEgZGF0YSBwb2ludHMgd2lkdGggdG8gZnJvbnQgYW5kIGJhY2ssIGZvciBsaW5pbmcgdXAgYSBsaW5lIGNoYXJ0IHdpdGggYSBiYXIgY2hhcnRcbiAgICAgICAgLCBwYWREYXRhT3V0ZXIgPSAuMSAvL291dGVyUGFkZGluZyB0byBpbWl0YXRlIG9yZGluYWwgc2NhbGUgb3V0ZXIgcGFkZGluZ1xuICAgICAgICAsIGNsaXBFZGdlICAgICA9IGZhbHNlIC8vIGlmIHRydWUsIG1hc2tzIHBvaW50cyB3aXRoaW4geCBhbmQgeSBzY2FsZVxuICAgICAgICAsIGNsaXBWb3Jvbm9pICA9IHRydWUgLy8gaWYgdHJ1ZSwgbWFza3MgZWFjaCBwb2ludCB3aXRoIGEgY2lyY2xlLi4uIGNhbiB0dXJuIG9mZiB0byBzbGlnaHRseSBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAgICAgICAsIHNob3dWb3Jvbm9pICA9IGZhbHNlIC8vIGRpc3BsYXkgdGhlIHZvcm9ub2kgYXJlYXNcbiAgICAgICAgLCBjbGlwUmFkaXVzICAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDI1IH0gLy8gZnVuY3Rpb24gdG8gZ2V0IHRoZSByYWRpdXMgZm9yIHZvcm9ub2kgcG9pbnQgY2xpcHNcbiAgICAgICAgLCB4RG9tYWluICAgICAgPSBudWxsIC8vIE92ZXJyaWRlIHggZG9tYWluIChza2lwcyB0aGUgY2FsY3VsYXRpb24gZnJvbSBkYXRhKVxuICAgICAgICAsIHlEb21haW4gICAgICA9IG51bGwgLy8gT3ZlcnJpZGUgeSBkb21haW5cbiAgICAgICAgLCB4UmFuZ2UgICAgICAgPSBudWxsIC8vIE92ZXJyaWRlIHggcmFuZ2VcbiAgICAgICAgLCB5UmFuZ2UgICAgICAgPSBudWxsIC8vIE92ZXJyaWRlIHkgcmFuZ2VcbiAgICAgICAgLCBzaXplRG9tYWluICAgPSBudWxsIC8vIE92ZXJyaWRlIHBvaW50IHNpemUgZG9tYWluXG4gICAgICAgICwgc2l6ZVJhbmdlICAgID0gbnVsbFxuICAgICAgICAsIHNpbmdsZVBvaW50ICA9IGZhbHNlXG4gICAgICAgICwgZGlzcGF0Y2ggICAgID0gZDMuZGlzcGF0Y2goJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlb3ZlcicsICdlbGVtZW50TW91c2VvdXQnLCAncmVuZGVyRW5kJylcbiAgICAgICAgLCB1c2VWb3Jvbm9pICAgPSB0cnVlXG4gICAgICAgICwgZHVyYXRpb24gICAgID0gMjUwXG4gICAgICAgICwgaW50ZXJhY3RpdmVVcGRhdGVEZWxheSA9IDMwMFxuICAgICAgICAsIHNob3dMYWJlbHMgICAgPSBmYWxzZVxuICAgICAgICA7XG5cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHgwLCB5MCwgejAgLy8gdXNlZCB0byBzdG9yZSBwcmV2aW91cyBzY2FsZXNcbiAgICAgICAgLCB3aWR0aDBcbiAgICAgICAgLCBoZWlnaHQwXG4gICAgICAgICwgdGltZW91dElEXG4gICAgICAgICwgbmVlZHNVcGRhdGUgPSBmYWxzZSAvLyBGbGFnIGZvciB3aGVuIHRoZSBwb2ludHMgYXJlIHZpc3VhbGx5IHVwZGF0aW5nLCBidXQgdGhlIGludGVyYWN0aXZlIGxheWVyIGlzIGJlaGluZCwgdG8gZGlzYWJsZSB0b29sdGlwc1xuICAgICAgICAsIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gsIGR1cmF0aW9uKVxuICAgICAgICAsIF9zaXplUmFuZ2VfZGVmID0gWzE2LCAyNTZdXG4gICAgICAgICwgX2NhY2hlID0ge31cbiAgICAgICAgO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FjaGUoZCkge1xuICAgICAgICB2YXIga2V5LCB2YWw7XG4gICAgICAgIGtleSA9IGRbMF0uc2VyaWVzICsgJzonICsgZFsxXTtcbiAgICAgICAgdmFsID0gX2NhY2hlW2tleV0gPSBfY2FjaGVba2V5XSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxDYWNoZShkKSB7XG4gICAgICAgIHZhciBrZXksIHZhbDtcbiAgICAgICAga2V5ID0gZFswXS5zZXJpZXMgKyAnOicgKyBkWzFdO1xuICAgICAgICBkZWxldGUgX2NhY2hlW2tleV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGlmZnMoZCkge1xuICAgICAgICB2YXIgaSwga2V5LCB2YWwsXG4gICAgICAgICAgICBjYWNoZSA9IGdldENhY2hlKGQpLFxuICAgICAgICAgICAgZGlmZnMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgdmFsID0gYXJndW1lbnRzW2kgKyAxXShkWzBdLCBkWzFdKTtcbiAgICAgICAgICAgIGlmIChjYWNoZVtrZXldICE9PSB2YWwgfHwgIWNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIGRpZmZzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIC8vYWRkIHNlcmllcyBpbmRleCB0byBlYWNoIGRhdGEgcG9pbnQgZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgIHNlcmllcy52YWx1ZXMuZm9yRWFjaChmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5zZXJpZXMgPSBpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIFNjYWxlc1xuICAgICAgICAgICAgdmFyIGxvZ1NjYWxlID0gY2hhcnQueVNjYWxlKCkubmFtZSA9PT0gZDMuc2NhbGUubG9nKCkubmFtZSA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgIC8vIHJlbWFwIGFuZCBmbGF0dGVuIHRoZSBkYXRhIGZvciB1c2UgaW4gY2FsY3VsYXRpbmcgdGhlIHNjYWxlcycgZG9tYWluc1xuICAgICAgICAgICAgdmFyIHNlcmllc0RhdGEgPSAoeERvbWFpbiAmJiB5RG9tYWluICYmIHNpemVEb21haW4pID8gW10gOiAvLyBpZiB3ZSBrbm93IHhEb21haW4gYW5kIHlEb21haW4gYW5kIHNpemVEb21haW4sIG5vIG5lZWQgdG8gY2FsY3VsYXRlLi4uLiBpZiBTaXplIGlzIGNvbnN0YW50IHJlbWVtYmVyIHRvIHNldCBzaXplRG9tYWluIHRvIHNwZWVkIHVwIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgZDMubWVyZ2UoXG4gICAgICAgICAgICAgICAgICAgIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogZ2V0WChkLGkpLCB5OiBnZXRZKGQsaSksIHNpemU6IGdldFNpemUoZCxpKSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHggICAuZG9tYWluKHhEb21haW4gfHwgZDMuZXh0ZW50KHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueDsgfSkuY29uY2F0KGZvcmNlWCkpKVxuXG4gICAgICAgICAgICBpZiAocGFkRGF0YSAmJiBkYXRhWzBdKVxuICAgICAgICAgICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFsoYXZhaWxhYmxlV2lkdGggKiBwYWREYXRhT3V0ZXIgKyAgYXZhaWxhYmxlV2lkdGgpIC8gKDIgKmRhdGFbMF0udmFsdWVzLmxlbmd0aCksIGF2YWlsYWJsZVdpZHRoIC0gYXZhaWxhYmxlV2lkdGggKiAoMSArIHBhZERhdGFPdXRlcikgLyAoMiAqIGRhdGFbMF0udmFsdWVzLmxlbmd0aCkgIF0pO1xuICAgICAgICAgICAgLy94LnJhbmdlKFthdmFpbGFibGVXaWR0aCAqIC41IC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoLCBhdmFpbGFibGVXaWR0aCAqIChkYXRhWzBdLnZhbHVlcy5sZW5ndGggLSAuNSkgIC8gZGF0YVswXS52YWx1ZXMubGVuZ3RoIF0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHgucmFuZ2UoeFJhbmdlIHx8IFswLCBhdmFpbGFibGVXaWR0aF0pO1xuXG4gICAgICAgICAgICAgaWYgKGxvZ1NjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW4gPSBkMy5taW4oc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24oZCkgeyBpZiAoZC55ICE9PSAwKSByZXR1cm4gZC55OyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHkuY2xhbXAodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoc2VyaWVzRGF0YS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkLnkgIT09IDApIHJldHVybiBkLnk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gbWluICogMC4xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY29uY2F0KGZvcmNlWSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuZG9tYWluKHlEb21haW4gfHwgZDMuZXh0ZW50KHNlcmllc0RhdGEubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnk7fSkuY29uY2F0KGZvcmNlWSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJhbmdlKHlSYW5nZSB8fCBbYXZhaWxhYmxlSGVpZ2h0LCAwXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB6ICAgLmRvbWFpbihzaXplRG9tYWluIHx8IGQzLmV4dGVudChzZXJpZXNEYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnNpemUgfSkuY29uY2F0KGZvcmNlU2l6ZSkpKVxuICAgICAgICAgICAgICAgIC5yYW5nZShzaXplUmFuZ2UgfHwgX3NpemVSYW5nZV9kZWYpO1xuXG4gICAgICAgICAgICAvLyBJZiBzY2FsZSdzIGRvbWFpbiBkb24ndCBoYXZlIGEgcmFuZ2UsIHNsaWdodGx5IGFkanVzdCB0byBtYWtlIG9uZS4uLiBzbyBhIGNoYXJ0IGNhbiBzaG93IGEgc2luZ2xlIGRhdGEgcG9pbnRcbiAgICAgICAgICAgIHNpbmdsZVBvaW50ID0geC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSB8fCB5LmRvbWFpbigpWzBdID09PSB5LmRvbWFpbigpWzFdO1xuXG4gICAgICAgICAgICBpZiAoeC5kb21haW4oKVswXSA9PT0geC5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB4LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeC5kb21haW4oW3guZG9tYWluKClbMF0gLSB4LmRvbWFpbigpWzBdICogMC4wMSwgeC5kb21haW4oKVsxXSArIHguZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB4LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICBpZiAoeS5kb21haW4oKVswXSA9PT0geS5kb21haW4oKVsxXSlcbiAgICAgICAgICAgICAgICB5LmRvbWFpbigpWzBdID9cbiAgICAgICAgICAgICAgICAgICAgeS5kb21haW4oW3kuZG9tYWluKClbMF0gLSB5LmRvbWFpbigpWzBdICogMC4wMSwgeS5kb21haW4oKVsxXSArIHkuZG9tYWluKClbMV0gKiAwLjAxXSlcbiAgICAgICAgICAgICAgICAgICAgOiB5LmRvbWFpbihbLTEsMV0pO1xuXG4gICAgICAgICAgICBpZiAoIGlzTmFOKHguZG9tYWluKClbMF0pKSB7XG4gICAgICAgICAgICAgICAgeC5kb21haW4oWy0xLDFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBpc05hTih5LmRvbWFpbigpWzBdKSkge1xuICAgICAgICAgICAgICAgIHkuZG9tYWluKFstMSwxXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHgwID0geDAgfHwgeDtcbiAgICAgICAgICAgIHkwID0geTAgfHwgeTtcbiAgICAgICAgICAgIHowID0gejAgfHwgejtcblxuICAgICAgICAgICAgdmFyIHNjYWxlRGlmZiA9IHgoMSkgIT09IHgwKDEpIHx8IHkoMSkgIT09IHkwKDEpIHx8IHooMSkgIT09IHowKDEpO1xuXG4gICAgICAgICAgICB3aWR0aDAgPSB3aWR0aDAgfHwgd2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQwID0gaGVpZ2h0MCB8fCBoZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciBzaXplRGlmZiA9IHdpZHRoMCAhPT0gd2lkdGggfHwgaGVpZ2h0MCAhPT0gaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc2NhdHRlcicpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciB3cmFwRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXNjYXR0ZXIgbnYtY2hhcnQtJyArIGlkKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICB3cmFwLmNsYXNzZWQoJ252LXNpbmdsZS1wb2ludCcsIHNpbmdsZVBvaW50KTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1ncm91cHMnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1wb2ludC1wYXRocycpO1xuICAgICAgICAgICAgd3JhcEVudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXBvaW50LWNsaXBzJyk7XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1lZGdlLWNsaXAtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCAtMTAsIC0xMCknKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcjbnYtZWRnZS1jbGlwLScgKyBpZCArICcgcmVjdCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgYXZhaWxhYmxlV2lkdGggKyAyMClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgKGF2YWlsYWJsZUhlaWdodCA+IDApID8gYXZhaWxhYmxlSGVpZ2h0ICsgMjAgOiAwKTtcblxuICAgICAgICAgICAgZy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUludGVyYWN0aXZlTGF5ZXIoKSB7XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGNsZWFyIG5lZWRzLXVwZGF0ZSBmbGFnIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3RcbiAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIGFjdHVhbGx5IGRvIGFueXRoaW5nIChhdm9pZHMgbmVlZGxlc3MgaW52b2NhdGlvbnMpLlxuICAgICAgICAgICAgICAgIG5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWludGVyYWN0aXZlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBpbmplY3Qgc2VyaWVzIGFuZCBwb2ludCBpbmRleCBmb3IgcmVmZXJlbmNlIGludG8gdm9yb25vaVxuICAgICAgICAgICAgICAgIGlmICh1c2VWb3Jvbm9pID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IGQzLm1lcmdlKGRhdGEubWFwKGZ1bmN0aW9uKGdyb3VwLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwLnZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHBvaW50LCBwb2ludEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAqQWRkaW5nIG5vaXNlIHRvIG1ha2UgZHVwbGljYXRlcyB2ZXJ5IHVubGlrZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAqSW5qZWN0aW5nIHNlcmllcyBhbmQgcG9pbnQgaW5kZXggZm9yIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogKkFkZGluZyBhICdqaXR0ZXInIHRvIHRoZSBwb2ludHMsIGJlY2F1c2UgdGhlcmUncyBhbiBpc3N1ZSBpbiBkMy5nZW9tLnZvcm9ub2kuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwWCA9IGdldFgocG9pbnQscG9pbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcFkgPSBnZXRZKHBvaW50LHBvaW50SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW252LnV0aWxzLk5hTnRvWmVybyh4KHBYKSkrIE1hdGgucmFuZG9tKCkgKiAxZS00LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudi51dGlscy5OYU50b1plcm8oeShwWSkpKyBNYXRoLnJhbmRvbSgpICogMWUtNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXgsIHBvaW50XTsgLy90ZW1wIGhhY2sgdG8gYWRkIG5vaXNlIHVudGlsIEkgdGhpbmsgb2YgYSBiZXR0ZXIgd2F5IHNvIHRoZXJlIGFyZSBubyBkdXBsaWNhdGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocG9pbnRBcnJheSwgcG9pbnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50QWN0aXZlKHBvaW50QXJyYXlbNF0sIHBvaW50SW5kZXgpOyAvLyBJc3N1ZSAjMjM3Li4gbW92ZSBmaWx0ZXIgdG8gYWZ0ZXIgbWFwLCBzbyBwb2ludEluZGV4IGlzIGNvcnJlY3QhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPT0gMCkgcmV0dXJuIGZhbHNlOyAgLy8gTm8gYWN0aXZlIHBvaW50cywgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXNzdWUgIzI4MyAtIEFkZGluZyAyIGR1bW15IHBvaW50cyB0byB0aGUgdm9yb25vaSBiL2Mgdm9yb25vaSByZXF1aXJlcyBtaW4gMyBwb2ludHMgdG8gd29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChbeC5yYW5nZSgpWzBdIC0gMjAsIHkucmFuZ2UoKVswXSAtIDIwLCBudWxsLCBudWxsXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4LnJhbmdlKClbMV0gKyAyMCwgeS5yYW5nZSgpWzFdICsgMjAsIG51bGwsIG51bGxdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3gucmFuZ2UoKVswXSAtIDIwLCB5LnJhbmdlKClbMF0gKyAyMCwgbnVsbCwgbnVsbF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaChbeC5yYW5nZSgpWzFdICsgMjAsIHkucmFuZ2UoKVsxXSAtIDIwLCBudWxsLCBudWxsXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHZvcm9ub2kgc2VjdGlvbnMgZnJvbSBnb2luZyBtb3JlIHRoYW4gMTAgb3V0c2lkZSBvZiBncmFwaFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBvdmVybGFwIHdpdGggb3RoZXIgdGhpbmdzIGxpa2UgbGVnZW5kIGV0Y1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRzID0gZDMuZ2VvbS5wb2x5Z29uKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFstMTAsLTEwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFstMTAsaGVpZ2h0ICsgMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3dpZHRoICsgMTAsaGVpZ2h0ICsgMTBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3dpZHRoICsgMTAsLTEwXVxuICAgICAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdm9yb25vaSA9IGQzLmdlb20udm9yb25vaSh2ZXJ0aWNlcykubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RhdGEnOiBib3VuZHMuY2xpcChkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VyaWVzJzogdmVydGljZXNbaV1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3BvaW50JzogdmVydGljZXNbaV1bM11cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gbnVrZSBhbGwgdm9yb25vaSBwYXRocyBvbiByZWxvYWQgYW5kIHJlY3JlYXRlIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1wb2ludC1wYXRocycpLnNlbGVjdEFsbCgncGF0aCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnRQYXRocyA9IHdyYXAuc2VsZWN0KCcubnYtcG9pbnQtcGF0aHMnKS5zZWxlY3RBbGwoJ3BhdGgnKS5kYXRhKHZvcm9ub2kpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdlBvaW50UGF0aHMgPSBwb2ludFBhdGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJzdmc6cGF0aFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWQgfHwgIWQuZGF0YSB8fCBkLmRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ00gMCAwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1cIiArIGQuZGF0YS5qb2luKFwiLFwiKSArIFwiWlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwiaWRcIiwgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnYtcGF0aC1cIitpOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJjbGlwLXBhdGhcIiwgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBcInVybCgjbnYtY2xpcC1cIitpZCtcIi1cIitpK1wiKVwiOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGdvb2QgZm9yIGRlYnVnZ2luZyBwb2ludCBob3ZlciBpc3N1ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dWb3Jvbm9pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2UG9pbnRQYXRocy5zdHlsZShcImZpbGxcIiwgZDMucmdiKDIzMCwgMjMwLCAyMzApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMC40KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkMy5yZ2IoMjAwLDIwMCwyMDApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGlwVm9yb25vaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdm9yb25vaSBzZWN0aW9ucyBhcmUgYWxyZWFkeSBzZXQgdG8gY2xpcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgY3JlYXRlIHRoZSBjaXJjbGVzIHdpdGggdGhlIElEcyB0aGV5IGV4cGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1wb2ludC1jbGlwcycpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpOyAvLyBtdXN0IGRvICogc2luY2UgaXQgaGFzIHN1Yi1kb21cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb2ludENsaXBzID0gd3JhcC5zZWxlY3QoJy5udi1wb2ludC1jbGlwcycpLnNlbGVjdEFsbCgnY2xpcFBhdGgnKS5kYXRhKHZlcnRpY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2UG9pbnRDbGlwcyA9IHBvaW50Q2xpcHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJzdmc6Y2xpcFBhdGhcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImlkXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwibnYtY2xpcC1cIitpZCtcIi1cIitpO30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcInN2ZzpjaXJjbGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY3gnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkWzBdOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbMV07IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3InLCBjbGlwUmFkaXVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbihlbCwgZCwgbURpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUpIHJldHVybiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmllcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgID0gc2VyaWVzLnZhbHVlc1tkLnBvaW50XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50Wydjb2xvciddID0gY29sb3Ioc2VyaWVzLCBkLnNlcmllcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplIGF0dHJpYnV0ZXMgZm9yIHRvb2x0aXAuXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFsneCddID0gZ2V0WChwb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludFsneSddID0gZ2V0WShwb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbid0IGp1c3QgZ2V0IGJveCBvZiBldmVudCBub2RlIHNpbmNlIGl0J3MgYWN0dWFsbHkgYSB2b3Jvbm9pIHBvbHlnb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSBjb250YWluZXIubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCAgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHgoZ2V0WChwb2ludCwgZC5wb2ludCkpICsgYm94LmxlZnQgKyBzY3JvbGxMZWZ0ICsgbWFyZ2luLmxlZnQgKyAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHkoZ2V0WShwb2ludCwgZC5wb2ludCkpICsgYm94LnRvcCArIHNjcm9sbFRvcCArIG1hcmdpbi50b3AgKyAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbURpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQb3M6IFt4KGdldFgocG9pbnQsIGQucG9pbnQpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGQucG9pbnQpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBkLnBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBkMy5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQYXRoc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZUV2ZW50Q2FsbGJhY2sodGhpcywgZCwgZGlzcGF0Y2guZWxlbWVudENsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayh0aGlzLCBkLCBkaXNwYXRjaC5lbGVtZW50RGJsQ2xpY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayh0aGlzLCBkLCBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRXZlbnRDYWxsYmFjayh0aGlzLCBkLCBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZXZlbnQgaGFuZGxlcnMgdG8gcG9pbnRzIGluc3RlYWQgdm9yb25vaSBwYXRoc1xuICAgICAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdCgnLm52LWdyb3VwcycpLnNlbGVjdEFsbCgnLm52LWdyb3VwJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJy5udi1wb2ludCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLy5kYXRhKGRhdGFXaXRoUG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8uc3R5bGUoJ3BvaW50ZXItZXZlbnRzJywgJ2F1dG8nKSAvLyByZWNhdGl2YXRlIGV2ZW50cywgZGlzYWJsZWQgYnkgY3NzXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9udi5sb2coJ3Rlc3QnLCBkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUgfHwgIWRhdGFbZC5zZXJpZXNdKSByZXR1cm4gMDsgLy9jaGVjayBpZiB0aGlzIGlzIGEgZHVtbXkgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ICA9IHNlcmllcy52YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChwb2ludCwgaSkpICsgbWFyZ2luLmxlZnQsIHkoZ2V0WShwb2ludCwgaSkpICsgbWFyZ2luLnRvcF0sIC8vVE9ETzogbWFrZSB0aGlzIHBvcyBiYXNlIG9uIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUG9zOiBbeChnZXRYKHBvaW50LCBpKSkgKyBtYXJnaW4ubGVmdCwgeShnZXRZKHBvaW50LCBpKSkgKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oJ2RibGNsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlIHx8ICFkYXRhW2Quc2VyaWVzXSkgcmV0dXJuIDA7IC8vY2hlY2sgaWYgdGhpcyBpcyBhIGR1bW15IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudERibENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IHNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbeChnZXRYKHBvaW50LCBpKSkgKyBtYXJnaW4ubGVmdCwgeShnZXRZKHBvaW50LCBpKSkgKyBtYXJnaW4udG9wXSwvL1RPRE86IG1ha2UgdGhpcyBwb3MgYmFzZSBvbiB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBvczogW3goZ2V0WChwb2ludCwgaSkpICsgbWFyZ2luLmxlZnQsIHkoZ2V0WShwb2ludCwgaSkpICsgbWFyZ2luLnRvcF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzVXBkYXRlIHx8ICFkYXRhW2Quc2VyaWVzXSkgcmV0dXJuIDA7IC8vY2hlY2sgaWYgdGhpcyBpcyBhIGR1bW15IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNlcmllcyA9IGRhdGFbZC5zZXJpZXNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludCAgPSBzZXJpZXMudmFsdWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBzZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW3goZ2V0WChwb2ludCwgaSkpICsgbWFyZ2luLmxlZnQsIHkoZ2V0WShwb2ludCwgaSkpICsgbWFyZ2luLnRvcF0sLy9UT0RPOiBtYWtlIHRoaXMgcG9zIGJhc2Ugb24gdGhlIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQb3M6IFt4KGdldFgocG9pbnQsIGkpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGkpKSArIG1hcmdpbi50b3BdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcihkLCBpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmVlZHNVcGRhdGUgfHwgIWRhdGFbZC5zZXJpZXNdKSByZXR1cm4gMDsgLy9jaGVjayBpZiB0aGlzIGlzIGEgZHVtbXkgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWVzID0gZGF0YVtkLnNlcmllc10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ICA9IHNlcmllcy52YWx1ZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFt4KGdldFgocG9pbnQsIGkpKSArIG1hcmdpbi5sZWZ0LCB5KGdldFkocG9pbnQsIGkpKSArIG1hcmdpbi50b3BdLC8vVE9ETzogbWFrZSB0aGlzIHBvcyBiYXNlIG9uIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUG9zOiBbeChnZXRYKHBvaW50LCBpKSkgKyBtYXJnaW4ubGVmdCwgeShnZXRZKHBvaW50LCBpKSkgKyBtYXJnaW4udG9wXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IoZCwgaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHdyYXAuc2VsZWN0KCcubnYtZ3JvdXBzJykuc2VsZWN0QWxsKCcubnYtZ3JvdXAnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5rZXkgfSk7XG4gICAgICAgICAgICBncm91cHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAxZS02KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMWUtNik7XG4gICAgICAgICAgICBncm91cHMuZXhpdCgpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgZ3JvdXBzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC5jbGFzc2VkIHx8ICcnKSArICcgbnYtZ3JvdXAgbnYtc2VyaWVzLScgKyBpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNsYXNzZWQoJ252LW5vbmludGVyYWN0aXZlJywgIWludGVyYWN0aXZlKVxuICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaG92ZXIgfSk7XG4gICAgICAgICAgICBncm91cHMud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnc2NhdHRlcjogZ3JvdXBzJylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbihkLGkpIHsgcmV0dXJuIGQucG9pbnRCb3JkZXJDb2xvciB8fCBwb2ludEJvcmRlckNvbG9yIHx8IGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDEpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAuNSk7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgcG9pbnRzLCBtYWludGFpbmluZyB0aGVpciBJRHMgZnJvbSB0aGUgb3JpZ2luYWwgZGF0YSBzZXRcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSBncm91cHMuc2VsZWN0QWxsKCdwYXRoLm52LXBvaW50JylcbiAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnZhbHVlcy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocG9pbnQsIHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BvaW50LCBwb2ludEluZGV4XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHBvaW50QXJyYXksIHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50QWN0aXZlKHBvaW50QXJyYXlbMF0sIHBvaW50SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2ludHMuZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnbnYtcG9pbnQgbnYtcG9pbnQtJyArIGRbMV07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5jb2xvciB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQuY29sb3IgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbnYudXRpbHMuTmFOdG9aZXJvKHgwKGdldFgoZFswXSxkWzFdKSkpICsgJywnICsgbnYudXRpbHMuTmFOdG9aZXJvKHkwKGdldFkoZFswXSxkWzFdKSkpICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsXG4gICAgICAgICAgICAgICAgICAgIG52LnV0aWxzLnN5bWJvbCgpXG4gICAgICAgICAgICAgICAgICAgIC50eXBlKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGdldFNoYXBlKGRbMF0pOyB9KVxuICAgICAgICAgICAgICAgICAgICAuc2l6ZShmdW5jdGlvbihkKSB7IHJldHVybiB6KGdldFNpemUoZFswXSxkWzFdKSkgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwb2ludHMuZXhpdCgpLmVhY2goZGVsQ2FjaGUpLnJlbW92ZSgpO1xuICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3BhdGgubnYtcG9pbnQnKVxuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdzY2F0dGVyIGV4aXQnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBudi51dGlscy5OYU50b1plcm8oeChnZXRYKGRbMF0sZFsxXSkpKSArICcsJyArIG52LnV0aWxzLk5hTnRvWmVybyh5KGdldFkoZFswXSxkWzFdKSkpICsgJyknXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgcG9pbnRzIHBvc2l0aW9uIG9ubHkgaWYgXCJ4XCIgb3IgXCJ5XCIgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICBwb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBzY2FsZURpZmYgfHwgc2l6ZURpZmYgfHwgZ2V0RGlmZnMoZCwgJ3gnLCBnZXRYLCAneScsIGdldFkpOyB9KVxuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdzY2F0dGVyIHBvaW50cycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9udi5sb2coZCwgZ2V0WChkWzBdLGRbMV0pLCB4KGdldFgoZFswXSxkWzFdKSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgbnYudXRpbHMuTmFOdG9aZXJvKHgoZ2V0WChkWzBdLGRbMV0pKSkgKyAnLCcgKyBudi51dGlscy5OYU50b1plcm8oeShnZXRZKGRbMF0sZFsxXSkpKSArICcpJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBvaW50cyBhcHBlYXJhbmNlIG9ubHkgaWYgXCJzaGFwZVwiIG9yIFwic2l6ZVwiIGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgcG9pbnRzLmZpbHRlcihmdW5jdGlvbiAoZCkgeyByZXR1cm4gc2NhbGVEaWZmIHx8IHNpemVEaWZmIHx8IGdldERpZmZzKGQsICdzaGFwZScsIGdldFNoYXBlLCAnc2l6ZScsIGdldFNpemUpOyB9KVxuICAgICAgICAgICAgICAgIC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdzY2F0dGVyIHBvaW50cycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLFxuICAgICAgICAgICAgICAgICAgICBudi51dGlscy5zeW1ib2woKVxuICAgICAgICAgICAgICAgICAgICAudHlwZShmdW5jdGlvbihkKSB7IHJldHVybiBnZXRTaGFwZShkWzBdKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNpemUoZnVuY3Rpb24oZCkgeyByZXR1cm4geihnZXRTaXplKGRbMF0sZFsxXSkpIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBhZGQgbGFiZWwgYSBsYWJlbCB0byBzY2F0dGVyIGNoYXJ0XG4gICAgICAgICAgICBpZihzaG93TGFiZWxzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0aXRsZXMgPSAgZ3JvdXBzLnNlbGVjdEFsbCgnLm52LWxhYmVsJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocG9pbnQsIHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwb2ludCwgcG9pbnRJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHBvaW50QXJyYXksIHBvaW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludEFjdGl2ZShwb2ludEFycmF5WzBdLCBwb2ludEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aXRsZXMuZW50ZXIoKS5hcHBlbmQoJ3RleHQnKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB9KVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMClcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gbnYudXRpbHMuTmFOdG9aZXJvKHgwKGdldFgoZFswXSxkWzFdKSkpICsgTWF0aC5zcXJ0KHooZ2V0U2l6ZShkWzBdLGRbMV0pKS9NYXRoLlBJKSArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZHggKyAnLCcgKyBudi51dGlscy5OYU50b1plcm8oeTAoZ2V0WShkWzBdLGRbMV0pKSkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFswXS5sYWJlbDt9KTtcblxuICAgICAgICAgICAgICAgIHRpdGxlcy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZ3JvdXBzLmV4aXQoKS5zZWxlY3RBbGwoJ3BhdGgubnYtbGFiZWwnKVxuICAgICAgICAgICAgICAgICAgICAud2F0Y2hUcmFuc2l0aW9uKHJlbmRlcldhdGNoLCAnc2NhdHRlciBleGl0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IG52LnV0aWxzLk5hTnRvWmVybyh4KGdldFgoZFswXSxkWzFdKSkpKyBNYXRoLnNxcnQoeihnZXRTaXplKGRbMF0sZFsxXSkpL01hdGguUEkpKzI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZHggKyAnLCcgKyBudi51dGlscy5OYU50b1plcm8oeShnZXRZKGRbMF0sZFsxXSkpKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgdGl0bGVzLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdudi1sYWJlbCcsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdudi1sYWJlbC0nICsgZFsxXSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdob3ZlcicsZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRpdGxlcy53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsICdzY2F0dGVyIGxhYmVscycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSBudi51dGlscy5OYU50b1plcm8oeChnZXRYKGRbMF0sZFsxXSkpKSsgTWF0aC5zcXJ0KHooZ2V0U2l6ZShkWzBdLGRbMV0pKS9NYXRoLlBJKSsyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIGR4ICsgJywnICsgbnYudXRpbHMuTmFOdG9aZXJvKHkoZ2V0WShkWzBdLGRbMV0pKSkgKyAnKSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlbGF5IHVwZGF0aW5nIHRoZSBpbnZpc2libGUgaW50ZXJhY3RpdmUgbGF5ZXIgZm9yIHNtb290aGVyIGFuaW1hdGlvblxuICAgICAgICAgICAgaWYoIGludGVyYWN0aXZlVXBkYXRlRGVsYXkgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpOyAvLyBzdG9wIHJlcGVhdCBjYWxscyB0byB1cGRhdGVJbnRlcmFjdGl2ZUxheWVyXG4gICAgICAgICAgICAgICAgdGltZW91dElEID0gc2V0VGltZW91dCh1cGRhdGVJbnRlcmFjdGl2ZUxheWVyLCBpbnRlcmFjdGl2ZVVwZGF0ZURlbGF5ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXBkYXRlSW50ZXJhY3RpdmVMYXllcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3N0b3JlIG9sZCBzY2FsZXMgZm9yIHVzZSBpbiB0cmFuc2l0aW9ucyBvbiB1cGRhdGVcbiAgICAgICAgICAgIHgwID0geC5jb3B5KCk7XG4gICAgICAgICAgICB5MCA9IHkuY29weSgpO1xuICAgICAgICAgICAgejAgPSB6LmNvcHkoKTtcblxuICAgICAgICAgICAgd2lkdGgwID0gd2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQwID0gaGVpZ2h0O1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3NjYXR0ZXIgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQub3B0aW9ucyA9IG52LnV0aWxzLm9wdGlvbnNGdW5jLmJpbmQoY2hhcnQpO1xuXG4gICAgLy8gdXRpbGl0eSBmdW5jdGlvbiBjYWxscyBwcm92aWRlZCBieSB0aGlzIGNoYXJ0XG4gICAgY2hhcnQuX2NhbGxzID0gbmV3IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNsZWFySGlnaGxpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG52LmRvbS53cml0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0QWxsKFwiLm52LXBvaW50LmhvdmVyXCIpLmNsYXNzZWQoXCJob3ZlclwiLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhpZ2hsaWdodFBvaW50ID0gZnVuY3Rpb24gKHNlcmllc0luZGV4LCBwb2ludEluZGV4LCBpc0hvdmVyT3Zlcikge1xuICAgICAgICAgICAgbnYuZG9tLndyaXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3QoJy5udi1ncm91cHMnKVxuICAgICAgICAgICAgICAgICAgLnNlbGVjdEFsbChcIi5udi1zZXJpZXMtXCIgKyBzZXJpZXNJbmRleClcbiAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubnYtcG9pbnQtXCIgKyBwb2ludEluZGV4KVxuICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoXCJob3ZlclwiLCBpc0hvdmVyT3Zlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZ2dlciBjYWxscyBmcm9tIGV2ZW50cyB0b29cbiAgICBkaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3Zlci5wb2ludCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaWYgKGludGVyYWN0aXZlKSBjaGFydC5fY2FsbHMuaGlnaGxpZ2h0UG9pbnQoZC5zZXJpZXNJbmRleCxkLnBvaW50SW5kZXgsdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBkaXNwYXRjaC5vbignZWxlbWVudE1vdXNlb3V0LnBvaW50JywgZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIGNoYXJ0Ll9jYWxscy5oaWdobGlnaHRQb2ludChkLnNlcmllc0luZGV4LGQucG9pbnRJbmRleCxmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4O30sIHNldDogZnVuY3Rpb24oXyl7eD1fO319LFxuICAgICAgICB5U2NhbGU6ICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHk7fSwgc2V0OiBmdW5jdGlvbihfKXt5PV87fX0sXG4gICAgICAgIHBvaW50U2NhbGU6ICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gejt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3o9Xzt9fSxcbiAgICAgICAgeERvbWFpbjogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4RG9tYWluO30sIHNldDogZnVuY3Rpb24oXyl7eERvbWFpbj1fO319LFxuICAgICAgICB5RG9tYWluOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHBvaW50RG9tYWluOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2l6ZURvbWFpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3NpemVEb21haW49Xzt9fSxcbiAgICAgICAgeFJhbmdlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt4UmFuZ2U9Xzt9fSxcbiAgICAgICAgeVJhbmdlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgcG9pbnRSYW5nZTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaXplUmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtzaXplUmFuZ2U9Xzt9fSxcbiAgICAgICAgZm9yY2VYOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVg7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVg9Xzt9fSxcbiAgICAgICAgZm9yY2VZOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVk9Xzt9fSxcbiAgICAgICAgZm9yY2VQb2ludDogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb3JjZVNpemU7fSwgc2V0OiBmdW5jdGlvbihfKXtmb3JjZVNpemU9Xzt9fSxcbiAgICAgICAgaW50ZXJhY3RpdmU6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpbnRlcmFjdGl2ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ludGVyYWN0aXZlPV87fX0sXG4gICAgICAgIHBvaW50QWN0aXZlOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcG9pbnRBY3RpdmU7fSwgc2V0OiBmdW5jdGlvbihfKXtwb2ludEFjdGl2ZT1fO319LFxuICAgICAgICBwYWREYXRhT3V0ZXI6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZERhdGFPdXRlcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3BhZERhdGFPdXRlcj1fO319LFxuICAgICAgICBwYWREYXRhOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBhZERhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtwYWREYXRhPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY2xpcEVkZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXtjbGlwRWRnZT1fO319LFxuICAgICAgICBjbGlwVm9yb25vaTogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNsaXBWb3Jvbm9pO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcFZvcm9ub2k9Xzt9fSxcbiAgICAgICAgY2xpcFJhZGl1czogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwUmFkaXVzO30sIHNldDogZnVuY3Rpb24oXyl7Y2xpcFJhZGl1cz1fO319LFxuICAgICAgICBzaG93Vm9yb25vaTogICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93Vm9yb25vaTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dWb3Jvbm9pPV87fX0sXG4gICAgICAgIGlkOiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtpZD1fO319LFxuICAgICAgICBpbnRlcmFjdGl2ZVVwZGF0ZURlbGF5OiB7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGludGVyYWN0aXZlVXBkYXRlRGVsYXk7fSwgc2V0OiBmdW5jdGlvbihfKXtpbnRlcmFjdGl2ZVVwZGF0ZURlbGF5PV87fX0sXG4gICAgICAgIHNob3dMYWJlbHM6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMYWJlbHM7fSwgc2V0OiBmdW5jdGlvbihfKXsgc2hvd0xhYmVscyA9IF87fX0sXG4gICAgICAgIHBvaW50Qm9yZGVyQ29sb3I6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHBvaW50Qm9yZGVyQ29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtwb2ludEJvcmRlckNvbG9yPV87fX0sXG5cbiAgICAgICAgLy8gc2ltcGxlIGZ1bmN0b3Igb3B0aW9uc1xuICAgICAgICB4OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFggPSBkMy5mdW5jdG9yKF8pO319LFxuICAgICAgICB5OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0WTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2dldFkgPSBkMy5mdW5jdG9yKF8pO319LFxuICAgICAgICBwb2ludFNpemU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGdldFNpemU7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRTaXplID0gZDMuZnVuY3RvcihfKTt9fSxcbiAgICAgICAgcG9pbnRTaGFwZToge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZ2V0U2hhcGU7fSwgc2V0OiBmdW5jdGlvbihfKXtnZXRTaGFwZSA9IGQzLmZ1bmN0b3IoXyk7fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHVzZVZvcm9ub2k6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZVZvcm9ub2k7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHVzZVZvcm9ub2kgPSBfO1xuICAgICAgICAgICAgaWYgKHVzZVZvcm9ub2kgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2xpcFZvcm9ub2kgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuc2NhdHRlckNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzY2F0dGVyICAgICAgPSBudi5tb2RlbHMuc2NhdHRlcigpXG4gICAgICAgICwgeEF4aXMgICAgICAgID0gbnYubW9kZWxzLmF4aXMoKVxuICAgICAgICAsIHlBeGlzICAgICAgICA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgICAgICAgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBkaXN0WCAgICAgICAgPSBudi5tb2RlbHMuZGlzdHJpYnV0aW9uKClcbiAgICAgICAgLCBkaXN0WSAgICAgICAgPSBudi5tb2RlbHMuZGlzdHJpYnV0aW9uKClcbiAgICAgICAgLCB0b29sdGlwICAgICAgPSBudi5tb2RlbHMudG9vbHRpcCgpXG4gICAgICAgIDtcblxuICAgIHZhciBtYXJnaW4gICAgICAgPSB7dG9wOiAzMCwgcmlnaHQ6IDIwLCBib3R0b206IDUwLCBsZWZ0OiA3NX1cbiAgICAgICAgLCBtYXJnaW5Ub3AgPSBudWxsXG4gICAgICAgICwgd2lkdGggICAgICAgID0gbnVsbFxuICAgICAgICAsIGhlaWdodCAgICAgICA9IG51bGxcbiAgICAgICAgLCBjb250YWluZXIgICAgPSBudWxsXG4gICAgICAgICwgY29sb3IgICAgICAgID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKClcbiAgICAgICAgLCB4ICAgICAgICAgICAgPSBzY2F0dGVyLnhTY2FsZSgpXG4gICAgICAgICwgeSAgICAgICAgICAgID0gc2NhdHRlci55U2NhbGUoKVxuICAgICAgICAsIHNob3dEaXN0WCAgICA9IGZhbHNlXG4gICAgICAgICwgc2hvd0Rpc3RZICAgID0gZmFsc2VcbiAgICAgICAgLCBzaG93TGVnZW5kICAgPSB0cnVlXG4gICAgICAgICwgc2hvd1hBeGlzICAgID0gdHJ1ZVxuICAgICAgICAsIHNob3dZQXhpcyAgICA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduWUF4aXMgPSBmYWxzZVxuICAgICAgICAsIHN0YXRlID0gbnYudXRpbHMuc3RhdGUoKVxuICAgICAgICAsIGRlZmF1bHRTdGF0ZSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsICdyZW5kZXJFbmQnKVxuICAgICAgICAsIG5vRGF0YSAgICAgICA9IG51bGxcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIHNob3dMYWJlbHMgICAgPSBmYWxzZVxuICAgICAgICA7XG5cbiAgICBzY2F0dGVyLnhTY2FsZSh4KS55U2NhbGUoeSk7XG4gICAgeEF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZygxMCk7XG4gICAgeUF4aXNcbiAgICAgICAgLm9yaWVudCgocmlnaHRBbGlnbllBeGlzKSA/ICdyaWdodCcgOiAnbGVmdCcpXG4gICAgICAgIC50aWNrUGFkZGluZygxMClcbiAgICA7XG4gICAgZGlzdFguYXhpcygneCcpO1xuICAgIGRpc3RZLmF4aXMoJ3knKTtcbiAgICB0b29sdGlwXG4gICAgICAgIC5oZWFkZXJGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHhBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB5QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgeDAsIHkwXG4gICAgICAgICwgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc3RhdGVTZXR0ZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuICAgICAgICByZW5kZXJXYXRjaC5tb2RlbHMoc2NhdHRlcik7XG4gICAgICAgIGlmIChzaG93WEF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh4QXhpcyk7XG4gICAgICAgIGlmIChzaG93WUF4aXMpIHJlbmRlcldhdGNoLm1vZGVscyh5QXhpcyk7XG4gICAgICAgIGlmIChzaG93RGlzdFgpIHJlbmRlcldhdGNoLm1vZGVscyhkaXN0WCk7XG4gICAgICAgIGlmIChzaG93RGlzdFkpIHJlbmRlcldhdGNoLm1vZGVscyhkaXN0WSk7XG5cbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jYWxsKGNoYXJ0KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgICAgLnNldHRlcihzdGF0ZVNldHRlcihkYXRhKSwgY2hhcnQudXBkYXRlKVxuICAgICAgICAgICAgICAgIC5nZXR0ZXIoc3RhdGVHZXR0ZXIoZGF0YSkpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyBERVBSRUNBVEVEIHNldCBzdGF0ZS5kaXNhYmxlZGRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgbm9EYXRhIG1lc3NhZ2UgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNob3cuXG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoIHx8ICFkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlcy5sZW5ndGggfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbnYudXRpbHMubm9EYXRhKGNoYXJ0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnc2NhdHRlciBpbW1lZGlhdGUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc2NhdHRlci54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzY2F0dGVyLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc2NhdHRlckNoYXJ0JykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc2NhdHRlckNoYXJ0IG52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkpO1xuICAgICAgICAgICAgdmFyIGdFbnRlciA9IHdyYXBFbnRlci5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBmb3IgcG9pbnRlciBldmVudHNcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LWJhY2tncm91bmQnKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsXCJub25lXCIpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteCBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc2NhdHRlcldyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1yZWdyZXNzaW9uTGluZXNXcmFwJyk7XG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZGlzdFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1sZWdlbmRXcmFwJyk7XG5cbiAgICAgICAgICAgIGlmIChyaWdodEFsaWduWUF4aXMpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdChcIi5udi15Lm52LWF4aXNcIilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBhdmFpbGFibGVXaWR0aCArIFwiLDApXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMZWdlbmRcbiAgICAgICAgICAgIGlmICghc2hvd0xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpLnNlbGVjdEFsbCgnKicpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVnZW5kV2lkdGggPSBhdmFpbGFibGVXaWR0aDtcbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgobGVnZW5kV2lkdGgpO1xuXG4gICAgICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1hcmdpblRvcCAmJiBsZWdlbmQuaGVpZ2h0KCkgIT09IG1hcmdpbi50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luLnRvcCA9IGxlZ2VuZC5oZWlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAnICsgJywnICsgKC1tYXJnaW4udG9wKSArJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd3JhcC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXJnaW4ubGVmdCArICcsJyArIG1hcmdpbi50b3AgKyAnKScpO1xuXG4gICAgICAgICAgICAvLyBNYWluIENoYXJ0IENvbXBvbmVudChzKVxuICAgICAgICAgICAgc2NhdHRlclxuICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuaGVpZ2h0KGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuY29sb3IgPSBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvcjtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7IHJldHVybiAhZGF0YVtpXS5kaXNhYmxlZCB9KSlcbiAgICAgICAgICAgICAgICAuc2hvd0xhYmVscyhzaG93TGFiZWxzKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJy5udi1zY2F0dGVyV3JhcCcpXG4gICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgICAgIC5jYWxsKHNjYXR0ZXIpO1xuXG5cbiAgICAgICAgICAgIHdyYXAuc2VsZWN0KCcubnYtcmVncmVzc2lvbkxpbmVzV3JhcCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsaXAtcGF0aCcsICd1cmwoI252LWVkZ2UtY2xpcC0nICsgc2NhdHRlci5pZCgpICsgJyknKTtcblxuICAgICAgICAgICAgdmFyIHJlZ1dyYXAgPSB3cmFwLnNlbGVjdCgnLm52LXJlZ3Jlc3Npb25MaW5lc1dyYXAnKS5zZWxlY3RBbGwoJy5udi1yZWdMaW5lcycpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlZ1dyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1yZWdMaW5lcycpO1xuXG4gICAgICAgICAgICB2YXIgcmVnTGluZSA9IHJlZ1dyYXAuc2VsZWN0QWxsKCcubnYtcmVnTGluZScpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtkXVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZWdMaW5lLmVudGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCdsaW5lJykuYXR0cignY2xhc3MnLCAnbnYtcmVnTGluZScpXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2Utb3BhY2l0eScsIDApO1xuXG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgbGluZXMgdW5sZXNzIHdlIGhhdmUgc2xvcGUgYW5kIGludGVyY2VwdCB0byB1c2VcbiAgICAgICAgICAgIHJlZ0xpbmUuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZC5pbnRlcmNlcHQgJiYgZC5zbG9wZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLndhdGNoVHJhbnNpdGlvbihyZW5kZXJXYXRjaCwgJ3NjYXR0ZXJQbHVzTGluZUNoYXJ0OiByZWdsaW5lJylcbiAgICAgICAgICAgICAgICAuYXR0cigneDEnLCB4LnJhbmdlKClbMF0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgeC5yYW5nZSgpWzFdKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5KHguZG9tYWluKClbMF0gKiBkLnNsb3BlICsgZC5pbnRlcmNlcHQpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigneTInLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geSh4LmRvbWFpbigpWzFdICogZC5zbG9wZSArIGQuaW50ZXJjZXB0KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnN0eWxlKCdzdHJva2UnLCBmdW5jdGlvbiAoZCwgaSwgaikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IoZCwgailcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGQuZGlzYWJsZWQgfHwgdHlwZW9mIGQuc2xvcGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkLmludGVyY2VwdCA9PT0gJ3VuZGVmaW5lZCcpID8gMCA6IDFcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgQXhlc1xuICAgICAgICAgICAgaWYgKHNob3dYQXhpcykge1xuICAgICAgICAgICAgICAgIHhBeGlzXG4gICAgICAgICAgICAgICAgICAgIC5zY2FsZSh4KVxuICAgICAgICAgICAgICAgICAgICAuX3RpY2tzKCBudi51dGlscy5jYWxjVGlja3NYKGF2YWlsYWJsZVdpZHRoLzEwMCwgZGF0YSkgKVxuICAgICAgICAgICAgICAgICAgICAudGlja1NpemUoIC1hdmFpbGFibGVIZWlnaHQgLCAwKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh4QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzaG93WUF4aXMpIHtcbiAgICAgICAgICAgICAgICB5QXhpc1xuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWShhdmFpbGFibGVIZWlnaHQvMzYsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlV2lkdGgsIDApO1xuXG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbCh5QXhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldHVwIERpc3RyaWJ1dGlvblxuICAgICAgICAgICAgaWYgKHNob3dEaXN0WCkge1xuICAgICAgICAgICAgICAgIGRpc3RYXG4gICAgICAgICAgICAgICAgICAgIC5nZXREYXRhKHNjYXR0ZXIueCgpKVxuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBjb2xvcihkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQgfSkpO1xuICAgICAgICAgICAgICAgIGdFbnRlci5zZWxlY3QoJy5udi1kaXN0V3JhcCcpLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdudi1kaXN0cmlidXRpb25YJyk7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1kaXN0cmlidXRpb25YJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgeS5yYW5nZSgpWzBdICsgJyknKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gIWQuZGlzYWJsZWQgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGRpc3RYKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dEaXN0WSkge1xuICAgICAgICAgICAgICAgIGRpc3RZXG4gICAgICAgICAgICAgICAgICAgIC5nZXREYXRhKHNjYXR0ZXIueSgpKVxuICAgICAgICAgICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZUhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgLmNvbG9yKGRhdGEubWFwKGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFkYXRhW2ldLmRpc2FibGVkIH0pKTtcbiAgICAgICAgICAgICAgICBnRW50ZXIuc2VsZWN0KCcubnYtZGlzdFdyYXAnKS5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnYtZGlzdHJpYnV0aW9uWScpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtZGlzdHJpYnV0aW9uWScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAocmlnaHRBbGlnbllBeGlzID8gYXZhaWxhYmxlV2lkdGggOiAtZGlzdFkuc2l6ZSgpICkgKyAnLDApJylcbiAgICAgICAgICAgICAgICAgICAgLmRhdHVtKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pKVxuICAgICAgICAgICAgICAgICAgICAuY2FsbChkaXN0WSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIGxlZ2VuZC5kaXNwYXRjaC5vbignc3RhdGVDaGFuZ2UnLCBmdW5jdGlvbihuZXdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVba2V5XSA9IG5ld1N0YXRlW2tleV07XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBjaGFydCBmcm9tIGEgc3RhdGUgb2JqZWN0IHBhc3NlZCB0byBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICBkaXNwYXRjaC5vbignY2hhbmdlU3RhdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllcy5kaXNhYmxlZCA9IGUuZGlzYWJsZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIG1vdXNlb3ZlciBuZWVkcyBhdmFpbGFibGVIZWlnaHQgc28gd2UganVzdCBrZWVwIHNjYXR0ZXIgbW91c2UgZXZlbnRzIGluc2lkZSB0aGUgY2hhcnQgYmxvY2tcbiAgICAgICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5oaWRkZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkgKyAnIC5udi1zZXJpZXMtJyArIGV2dC5zZXJpZXNJbmRleCArICcgLm52LWRpc3R4LScgKyBldnQucG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kxJywgMCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBzY2F0dGVyLmlkKCkgKyAnIC5udi1zZXJpZXMtJyArIGV2dC5zZXJpZXNJbmRleCArICcgLm52LWRpc3R5LScgKyBldnQucG9pbnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gyJywgZGlzdFkuc2l6ZSgpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyLnRvb2x0aXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuc2VsZWN0KCcubnYtc2VyaWVzLScgKyBldnQuc2VyaWVzSW5kZXggKyAnIC5udi1kaXN0eC0nICsgZXZ0LnBvaW50SW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIGV2dC5yZWxhdGl2ZVBvc1sxXSAtIGF2YWlsYWJsZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdCgnLm52LXNlcmllcy0nICsgZXZ0LnNlcmllc0luZGV4ICsgJyAubnYtZGlzdHktJyArIGV2dC5wb2ludEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCBldnQucmVsYXRpdmVQb3NbMF0gKyBkaXN0WC5zaXplKCkpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXAuZGF0YShldnQpLmhpZGRlbihmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9zdG9yZSBvbGQgc2NhbGVzIGZvciB1c2UgaW4gdHJhbnNpdGlvbnMgb24gdXBkYXRlXG4gICAgICAgICAgICB4MCA9IHguY29weSgpO1xuICAgICAgICAgICAgeTAgPSB5LmNvcHkoKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3NjYXR0ZXIgd2l0aCBsaW5lIGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuc2NhdHRlciA9IHNjYXR0ZXI7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LnhBeGlzID0geEF4aXM7XG4gICAgY2hhcnQueUF4aXMgPSB5QXhpcztcbiAgICBjaGFydC5kaXN0WCA9IGRpc3RYO1xuICAgIGNoYXJ0LmRpc3RZID0gZGlzdFk7XG4gICAgY2hhcnQudG9vbHRpcCA9IHRvb2x0aXA7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG4gICAgY2hhcnQuX29wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHt9LCB7XG4gICAgICAgIC8vIHNpbXBsZSBvcHRpb25zLCBqdXN0IGdldC9zZXQgdGhlIG5lY2Vzc2FyeSB2YWx1ZXNcbiAgICAgICAgd2lkdGg6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gd2lkdGg7fSwgc2V0OiBmdW5jdGlvbihfKXt3aWR0aD1fO319LFxuICAgICAgICBoZWlnaHQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgY29udGFpbmVyOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udGFpbmVyO30sIHNldDogZnVuY3Rpb24oXyl7Y29udGFpbmVyPV87fX0sXG4gICAgICAgIHNob3dEaXN0WDogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dEaXN0WDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dEaXN0WD1fO319LFxuICAgICAgICBzaG93RGlzdFk6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93RGlzdFk7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93RGlzdFk9Xzt9fSxcbiAgICAgICAgc2hvd0xlZ2VuZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xlZ2VuZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMZWdlbmQ9Xzt9fSxcbiAgICAgICAgc2hvd1hBeGlzOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd1hBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd1hBeGlzPV87fX0sXG4gICAgICAgIHNob3dZQXhpczogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dZQXhpczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dZQXhpcz1fO319LFxuICAgICAgICBkZWZhdWx0U3RhdGU6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sIHNldDogZnVuY3Rpb24oXyl7bm9EYXRhPV87fX0sXG4gICAgICAgIGR1cmF0aW9uOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7ZHVyYXRpb249Xzt9fSxcbiAgICAgICAgc2hvd0xhYmVsczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0xhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dMYWJlbHM9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBpZiAoXy50b3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSBfLnRvcDtcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfLnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX0sXG4gICAgICAgIHJpZ2h0QWxpZ25ZQXhpczoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gcmlnaHRBbGlnbllBeGlzO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICByaWdodEFsaWduWUF4aXMgPSBfO1xuICAgICAgICAgICAgeUF4aXMub3JpZW50KCAoXykgPyAncmlnaHQnIDogJ2xlZnQnKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgICAgIGxlZ2VuZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBkaXN0WC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBkaXN0WS5jb2xvcihjb2xvcik7XG4gICAgICAgIH19XG4gICAgfSk7XG5cbiAgICBudi51dGlscy5pbmhlcml0T3B0aW9ucyhjaGFydCwgc2NhdHRlcik7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zcGFya2xpbmUgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDIsIHJpZ2h0OiAwLCBib3R0b206IDIsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA0MDBcbiAgICAgICAgLCBoZWlnaHQgPSAzMlxuICAgICAgICAsIGNvbnRhaW5lciA9IG51bGxcbiAgICAgICAgLCBhbmltYXRlID0gdHJ1ZVxuICAgICAgICAsIHggPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIHkgPSBkMy5zY2FsZS5saW5lYXIoKVxuICAgICAgICAsIGdldFggPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnggfVxuICAgICAgICAsIGdldFkgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgfVxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoWycjMDAwJ10pXG4gICAgICAgICwgeERvbWFpblxuICAgICAgICAsIHlEb21haW5cbiAgICAgICAgLCB4UmFuZ2VcbiAgICAgICAgLCB5UmFuZ2VcbiAgICAgICAgLCBzaG93TWluTWF4UG9pbnRzID0gdHJ1ZVxuICAgICAgICAsIHNob3dDdXJyZW50UG9pbnQgPSB0cnVlXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgncmVuZGVyRW5kJylcbiAgICAgICAgO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG4gICAgXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHdpZHRoIC0gbWFyZ2luLmxlZnQgLSBtYXJnaW4ucmlnaHQsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gaGVpZ2h0IC0gbWFyZ2luLnRvcCAtIG1hcmdpbi5ib3R0b207XG5cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIG52LnV0aWxzLmluaXRTVkcoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ICAgLmRvbWFpbih4RG9tYWluIHx8IGQzLmV4dGVudChkYXRhLCBnZXRYICkpXG4gICAgICAgICAgICAgICAgLnJhbmdlKHhSYW5nZSB8fCBbMCwgYXZhaWxhYmxlV2lkdGhdKTtcblxuICAgICAgICAgICAgeSAgIC5kb21haW4oeURvbWFpbiB8fCBkMy5leHRlbnQoZGF0YSwgZ2V0WSApKVxuICAgICAgICAgICAgICAgIC5yYW5nZSh5UmFuZ2UgfHwgW2F2YWlsYWJsZUhlaWdodCwgMF0pO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc3BhcmtsaW5lJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3BhcmtsaW5lJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJylcblxuICAgICAgICAgICAgdmFyIHBhdGhzID0gd3JhcC5zZWxlY3RBbGwoJ3BhdGgnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFtkXSB9KTtcbiAgICAgICAgICAgIHBhdGhzLmVudGVyKCkuYXBwZW5kKCdwYXRoJyk7XG4gICAgICAgICAgICBwYXRocy5leGl0KCkucmVtb3ZlKCk7XG4gICAgICAgICAgICBwYXRoc1xuICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlJywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGkpIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2QnLCBkMy5zdmcubGluZSgpXG4gICAgICAgICAgICAgICAgICAgIC54KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geChnZXRYKGQsaSkpIH0pXG4gICAgICAgICAgICAgICAgICAgIC55KGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geShnZXRZKGQsaSkpIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBBZGQgQ1VSUkVOVCBkYXRhIHBvaW50IChOZWVkIE1pbiwgTWFjLCBDdXJyZW50IC8gTW9zdCByZWNlbnQpXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gd3JhcC5zZWxlY3RBbGwoJ2NpcmNsZS5udi1wb2ludCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbHVlcyA9IGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIGdldFkoZCxpKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucG9pbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb2ludCA9IHBvaW50SW5kZXgoeVZhbHVlcy5sYXN0SW5kZXhPZih5LmRvbWFpbigpWzFdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5Qb2ludCA9IHBvaW50SW5kZXgoeVZhbHVlcy5pbmRleE9mKHkuZG9tYWluKClbMF0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50SW5kZXgoeVZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsoc2hvd01pbk1heFBvaW50cyA/IG1pblBvaW50IDogbnVsbCksIChzaG93TWluTWF4UG9pbnRzID8gbWF4UG9pbnQgOiBudWxsKSwgKHNob3dDdXJyZW50UG9pbnQgPyBjdXJyZW50UG9pbnQgOiBudWxsKV0uZmlsdGVyKGZ1bmN0aW9uIChkKSB7cmV0dXJuIGQgIT0gbnVsbDt9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50cy5lbnRlcigpLmFwcGVuZCgnY2lyY2xlJyk7XG4gICAgICAgICAgICBwb2ludHMuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcG9pbnRzXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2N4JywgZnVuY3Rpb24oZCxpKSB7IHJldHVybiB4KGdldFgoZCxkLnBvaW50SW5kZXgpKSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4geShnZXRZKGQsZC5wb2ludEluZGV4KSkgfSlcbiAgICAgICAgICAgICAgICAuYXR0cigncicsIDIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRYKGQsIGQucG9pbnRJbmRleCkgPT0geC5kb21haW4oKVsxXSA/ICdudi1wb2ludCBudi1jdXJyZW50VmFsdWUnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRZKGQsIGQucG9pbnRJbmRleCkgPT0geS5kb21haW4oKVswXSA/ICdudi1wb2ludCBudi1taW5WYWx1ZScgOiAnbnYtcG9pbnQgbnYtbWF4VmFsdWUnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzcGFya2xpbmUgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHhEb21haW46ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt4RG9tYWluPV87fX0sXG4gICAgICAgIHlEb21haW46ICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHlEb21haW47fSwgc2V0OiBmdW5jdGlvbihfKXt5RG9tYWluPV87fX0sXG4gICAgICAgIHhSYW5nZTogICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHhSYW5nZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hSYW5nZT1fO319LFxuICAgICAgICB5UmFuZ2U6ICAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB5UmFuZ2U7fSwgc2V0OiBmdW5jdGlvbihfKXt5UmFuZ2U9Xzt9fSxcbiAgICAgICAgeFNjYWxlOiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3g9Xzt9fSxcbiAgICAgICAgeVNjYWxlOiAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3k9Xzt9fSxcbiAgICAgICAgYW5pbWF0ZTogICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYW5pbWF0ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2FuaW1hdGU9Xzt9fSxcbiAgICAgICAgc2hvd01pbk1heFBvaW50czoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd01pbk1heFBvaW50czt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dNaW5NYXhQb2ludHM9Xzt9fSxcbiAgICAgICAgc2hvd0N1cnJlbnRQb2ludDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gc2hvd0N1cnJlbnRQb2ludDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dDdXJyZW50UG9pbnQ9Xzt9fSxcblxuICAgICAgICAvL2Z1bmN0b3Igb3B0aW9uc1xuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WD1kMy5mdW5jdG9yKF8pO319LFxuICAgICAgICB5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WT1kMy5mdW5jdG9yKF8pO319LFxuXG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCByZXF1aXJlIGV4dHJhIGxvZ2ljIGluIHRoZSBzZXR0ZXJcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6ICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjb2xvcjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgY29sb3IgPSBudi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgbnYudXRpbHMuaW5pdE9wdGlvbnMoY2hhcnQpO1xuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zcGFya2xpbmVQbHVzID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzcGFya2xpbmUgPSBudi5tb2RlbHMuc3BhcmtsaW5lKCk7XG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMTUsIHJpZ2h0OiAxMDAsIGJvdHRvbTogMTAsIGxlZnQ6IDUwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCB4XG4gICAgICAgICwgeVxuICAgICAgICAsIGluZGV4ID0gW11cbiAgICAgICAgLCBwYXVzZWQgPSBmYWxzZVxuICAgICAgICAsIHhUaWNrRm9ybWF0ID0gZDMuZm9ybWF0KCcscicpXG4gICAgICAgICwgeVRpY2tGb3JtYXQgPSBkMy5mb3JtYXQoJywuMmYnKVxuICAgICAgICAsIHNob3dMYXN0VmFsdWUgPSB0cnVlXG4gICAgICAgICwgYWxpZ25WYWx1ZSA9IHRydWVcbiAgICAgICAgLCByaWdodEFsaWduVmFsdWUgPSBmYWxzZVxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdyZW5kZXJFbmQnKVxuICAgICAgICA7XG4gICAgICAgIFxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJpdmF0ZSBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHJlbmRlcldhdGNoID0gbnYudXRpbHMucmVuZGVyV2F0Y2goZGlzcGF0Y2gpO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhzcGFya2xpbmUpO1xuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlV2lkdGggPSBudi51dGlscy5hdmFpbGFibGVXaWR0aCh3aWR0aCwgY29udGFpbmVyLCBtYXJnaW4pLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci5jYWxsKGNoYXJ0KTsgfTtcbiAgICAgICAgICAgIGNoYXJ0LmNvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gc3BhcmtsaW5lLnkoKShkYXRhW2RhdGEubGVuZ3RoLTFdLCBkYXRhLmxlbmd0aC0xKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc3BhcmtsaW5lLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IHNwYXJrbGluZS55U2NhbGUoKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXNwYXJrbGluZXBsdXMnKS5kYXRhKFtkYXRhXSk7XG4gICAgICAgICAgICB2YXIgd3JhcEVudGVyID0gd3JhcC5lbnRlcigpLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252ZDMgbnYtd3JhcCBudi1zcGFya2xpbmVwbHVzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtc3BhcmtsaW5lV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXZhbHVlV3JhcCcpO1xuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWhvdmVyQXJlYScpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG5cbiAgICAgICAgICAgIC8vIE1haW4gQ2hhcnQgQ29tcG9uZW50KHMpXG4gICAgICAgICAgICB2YXIgc3BhcmtsaW5lV3JhcCA9IGcuc2VsZWN0KCcubnYtc3BhcmtsaW5lV3JhcCcpO1xuXG4gICAgICAgICAgICBzcGFya2xpbmUud2lkdGgoYXZhaWxhYmxlV2lkdGgpLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICAgICAgc3BhcmtsaW5lV3JhcC5jYWxsKHNwYXJrbGluZSk7XG5cbiAgICAgICAgICAgIGlmIChzaG93TGFzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlV3JhcCA9IGcuc2VsZWN0KCcubnYtdmFsdWVXcmFwJyk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVXcmFwLnNlbGVjdEFsbCgnLm52LWN1cnJlbnRWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5kYXRhKFtjdXJyZW50VmFsdWVdKTtcblxuICAgICAgICAgICAgICAgIHZhbHVlLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCAnbnYtY3VycmVudFZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R4JywgcmlnaHRBbGlnblZhbHVlID8gLTggOiA4KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignZHknLCAnLjllbScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCByaWdodEFsaWduVmFsdWUgPyAnZW5kJyA6ICdzdGFydCcpO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCBhdmFpbGFibGVXaWR0aCArIChyaWdodEFsaWduVmFsdWUgPyBtYXJnaW4ucmlnaHQgOiAwKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBhbGlnblZhbHVlID8gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5KGQpXG4gICAgICAgICAgICAgICAgICAgIH0gOiAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBzcGFya2xpbmUuY29sb3IoKShkYXRhW2RhdGEubGVuZ3RoIC0gMV0sIGRhdGEubGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHlUaWNrRm9ybWF0KGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnRW50ZXIuc2VsZWN0KCcubnYtaG92ZXJBcmVhJykuYXBwZW5kKCdyZWN0JylcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIHNwYXJrbGluZUhvdmVyKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbigpIHsgcGF1c2VkID0gIXBhdXNlZCB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbigpIHsgaW5kZXggPSBbXTsgdXBkYXRlVmFsdWVMaW5lKCk7IH0pO1xuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWhvdmVyQXJlYSByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgLW1hcmdpbi5sZWZ0ICsgJywnICsgLW1hcmdpbi50b3AgKyAnKScgfSlcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQgKyBtYXJnaW4udG9wKTtcblxuICAgICAgICAgICAgLy9pbmRleCBpcyBjdXJyZW50bHkgZ2xvYmFsICh3aXRoaW4gdGhlIGNoYXJ0KSwgbWF5IG9yIG1heSBub3Qga2VlcCBpdCB0aGF0IHdheVxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVmFsdWVMaW5lKCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXVzZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBob3ZlclZhbHVlID0gZy5zZWxlY3RBbGwoJy5udi1ob3ZlclZhbHVlJykuZGF0YShpbmRleCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaG92ZXJFbnRlciA9IGhvdmVyVmFsdWUuZW50ZXIoKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtaG92ZXJWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDApO1xuXG4gICAgICAgICAgICAgICAgaG92ZXJWYWx1ZS5leGl0KClcbiAgICAgICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKS5kdXJhdGlvbigyNTApXG4gICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnc3Ryb2tlLW9wYWNpdHknLCAwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgICAgIGhvdmVyVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICd0cmFuc2xhdGUoJyArIHgoc3BhcmtsaW5lLngoKShkYXRhW2RdLGQpKSArICcsMCknIH0pXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMjUwKVxuICAgICAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JywgMSlcbiAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsLW9wYWNpdHknLCAxKTtcblxuICAgICAgICAgICAgICAgIGlmICghaW5kZXgubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBob3ZlckVudGVyLmFwcGVuZCgnbGluZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MScsIDApXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIC1tYXJnaW4udG9wKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneDInLCAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneTInLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgaG92ZXJFbnRlci5hcHBlbmQoJ3RleHQnKS5hdHRyKCdjbGFzcycsICdudi14VmFsdWUnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIC02KVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIC1tYXJnaW4udG9wKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnZW5kJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy45ZW0nKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJWYWx1ZSAubnYteFZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoeFRpY2tGb3JtYXQoc3BhcmtsaW5lLngoKShkYXRhW2luZGV4WzBdXSwgaW5kZXhbMF0pKSk7XG5cbiAgICAgICAgICAgICAgICBob3ZlckVudGVyLmFwcGVuZCgndGV4dCcpLmF0dHIoJ2NsYXNzJywgJ252LXlWYWx1ZScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgNilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtbWFyZ2luLnRvcClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2R5JywgJy45ZW0nKTtcblxuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtaG92ZXJWYWx1ZSAubnYteVZhbHVlJylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoeVRpY2tGb3JtYXQoc3BhcmtsaW5lLnkoKShkYXRhW2luZGV4WzBdXSwgaW5kZXhbMF0pKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNwYXJrbGluZUhvdmVyKCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXVzZWQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBkMy5tb3VzZSh0aGlzKVswXSAtIG1hcmdpbi5sZWZ0O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEluZGV4KGRhdGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5hYnMoc3BhcmtsaW5lLngoKShkYXRhWzBdLCAwKSAtIHgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvc2VzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzcGFya2xpbmUueCgpKGRhdGFbaV0sIGkpIC0geCkgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoc3BhcmtsaW5lLngoKShkYXRhW2ldLCBpKSAtIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbmRleCA9IFtnZXRDbG9zZXN0SW5kZXgoZGF0YSwgTWF0aC5yb3VuZCh4LmludmVydChwb3MpKSldO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVZhbHVlTGluZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3NwYXJrbGluZVBsdXMgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5zcGFya2xpbmUgPSBzcGFya2xpbmU7XG5cbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBoZWlnaHQ7fSwgc2V0OiBmdW5jdGlvbihfKXtoZWlnaHQ9Xzt9fSxcbiAgICAgICAgeFRpY2tGb3JtYXQ6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB4VGlja0Zvcm1hdDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3hUaWNrRm9ybWF0PV87fX0sXG4gICAgICAgIHlUaWNrRm9ybWF0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4geVRpY2tGb3JtYXQ7fSwgc2V0OiBmdW5jdGlvbihfKXt5VGlja0Zvcm1hdD1fO319LFxuICAgICAgICBzaG93TGFzdFZhbHVlOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMYXN0VmFsdWU7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGFzdFZhbHVlPV87fX0sXG4gICAgICAgIGFsaWduVmFsdWU6ICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gYWxpZ25WYWx1ZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2FsaWduVmFsdWU9Xzt9fSxcbiAgICAgICAgcmlnaHRBbGlnblZhbHVlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduVmFsdWU7fSwgc2V0OiBmdW5jdGlvbihfKXtyaWdodEFsaWduVmFsdWU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcblxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT09IHVuZGVmaW5lZCA/IF8udG9wICAgIDogbWFyZ2luLnRvcDtcbiAgICAgICAgICAgIG1hcmdpbi5yaWdodCAgPSBfLnJpZ2h0ICAhPT0gdW5kZWZpbmVkID8gXy5yaWdodCAgOiBtYXJnaW4ucmlnaHQ7XG4gICAgICAgICAgICBtYXJnaW4uYm90dG9tID0gXy5ib3R0b20gIT09IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPT0gdW5kZWZpbmVkID8gXy5sZWZ0ICAgOiBtYXJnaW4ubGVmdDtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBzcGFya2xpbmUpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zdGFja2VkQXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQdWJsaWMgVmFyaWFibGVzIHdpdGggRGVmYXVsdCBTZXR0aW5nc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgbWFyZ2luID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH1cbiAgICAgICAgLCB3aWR0aCA9IDk2MFxuICAgICAgICAsIGhlaWdodCA9IDUwMFxuICAgICAgICAsIGNvbG9yID0gbnYudXRpbHMuZGVmYXVsdENvbG9yKCkgLy8gYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZSBjb2xvclxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwKSAvL0NyZWF0ZSBzZW1pLXVuaXF1ZSBJRCBpbmNhc2UgdXNlciBkb2Vzbid0IHNlbGV0IG9uZVxuICAgICAgICAsIGNvbnRhaW5lciA9IG51bGxcbiAgICAgICAgLCBnZXRYID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54IH0gLy8gYWNjZXNzb3IgdG8gZ2V0IHRoZSB4IHZhbHVlIGZyb20gYSBkYXRhIHBvaW50XG4gICAgICAgICwgZ2V0WSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSB9IC8vIGFjY2Vzc29yIHRvIGdldCB0aGUgeSB2YWx1ZSBmcm9tIGEgZGF0YSBwb2ludFxuICAgICAgICAsIGRlZmluZWQgPSBmdW5jdGlvbihkLGkpIHsgcmV0dXJuICFpc05hTihnZXRZKGQsaSkpICYmIGdldFkoZCxpKSAhPT0gbnVsbCB9IC8vIGFsbG93cyBhIGxpbmUgdG8gYmUgbm90IGNvbnRpbnVvdXMgd2hlbiBpdCBpcyBub3QgZGVmaW5lZFxuICAgICAgICAsIHN0eWxlID0gJ3N0YWNrJ1xuICAgICAgICAsIG9mZnNldCA9ICd6ZXJvJ1xuICAgICAgICAsIG9yZGVyID0gJ2RlZmF1bHQnXG4gICAgICAgICwgaW50ZXJwb2xhdGUgPSAnbGluZWFyJyAgLy8gY29udHJvbHMgdGhlIGxpbmUgaW50ZXJwb2xhdGlvblxuICAgICAgICAsIGNsaXBFZGdlID0gZmFsc2UgLy8gaWYgdHJ1ZSwgbWFza3MgbGluZXMgd2l0aGluIHggYW5kIHkgc2NhbGVcbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgc2NhdHRlciA9IG52Lm1vZGVscy5zY2F0dGVyKClcbiAgICAgICAgLCBkdXJhdGlvbiA9IDI1MFxuICAgICAgICAsIGRpc3BhdGNoID0gIGQzLmRpc3BhdGNoKCdhcmVhQ2xpY2snLCAnYXJlYU1vdXNlb3ZlcicsICdhcmVhTW91c2VvdXQnLCdyZW5kZXJFbmQnLCAnZWxlbWVudENsaWNrJywgJ2VsZW1lbnRNb3VzZW92ZXInLCAnZWxlbWVudE1vdXNlb3V0JylcbiAgICAgICAgO1xuXG4gICAgc2NhdHRlclxuICAgICAgICAucG9pbnRTaXplKDIuMikgLy8gZGVmYXVsdCBzaXplXG4gICAgICAgIC5wb2ludERvbWFpbihbMi4yLCAyLjJdKSAvLyBhbGwgdGhlIHNhbWUgc2l6ZSBieSBkZWZhdWx0XG4gICAgO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIG9mZnNldDpcbiAgICAgKiAgICd3aWdnbGUnIChzdHJlYW0pXG4gICAgICogICAnemVybycgKHN0YWNrZWQpXG4gICAgICogICAnZXhwYW5kJyAobm9ybWFsaXplIHRvIDEwMCUpXG4gICAgICogICAnc2lsaG91ZXR0ZScgKHNpbXBsZSBjZW50ZXJlZClcbiAgICAgKlxuICAgICAqIG9yZGVyOlxuICAgICAqICAgJ2luc2lkZS1vdXQnIChzdHJlYW0pXG4gICAgICogICAnZGVmYXVsdCcgKGlucHV0IG9yZGVyKVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCwgZHVyYXRpb24pO1xuXG4gICAgZnVuY3Rpb24gY2hhcnQoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KCk7XG4gICAgICAgIHJlbmRlcldhdGNoLm1vZGVscyhzY2F0dGVyKTtcbiAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodCxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuICAgICAgICAgICAgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuICAgICAgICAgICAgbnYudXRpbHMuaW5pdFNWRyhjb250YWluZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBTY2FsZXNcbiAgICAgICAgICAgIHggPSBzY2F0dGVyLnhTY2FsZSgpO1xuICAgICAgICAgICAgeSA9IHNjYXR0ZXIueVNjYWxlKCk7XG5cbiAgICAgICAgICAgIHZhciBkYXRhUmF3ID0gZGF0YTtcbiAgICAgICAgICAgIC8vIEluamVjdGluZyBwb2ludCBpbmRleCBpbnRvIGVhY2ggcG9pbnQgYmVjYXVzZSBkMy5sYXlvdXQuc3RhY2soKS5vdXQgZG9lcyBub3QgZ2l2ZSBpbmRleFxuICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGFzZXJpZXMsIGkpIHtcbiAgICAgICAgICAgICAgICBhc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBhc2VyaWVzLnZhbHVlcyA9IGFzZXJpZXMudmFsdWVzLm1hcChmdW5jdGlvbihkLCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuaW5kZXggPSBqO1xuICAgICAgICAgICAgICAgICAgICBkLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGRhdGFGaWx0ZXJlZCA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRhdGEgPSBkMy5sYXlvdXQuc3RhY2soKVxuICAgICAgICAgICAgICAgIC5vcmRlcihvcmRlcilcbiAgICAgICAgICAgICAgICAub2Zmc2V0KG9mZnNldClcbiAgICAgICAgICAgICAgICAudmFsdWVzKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudmFsdWVzIH0pICAvL1RPRE86IG1ha2UgdmFsdWVzIGN1c3RvbWl6ZWFibGUgaW4gRVZFUlkgbW9kZWwgaW4gdGhpcyBmYXNoaW9uXG4gICAgICAgICAgICAgICAgLngoZ2V0WClcbiAgICAgICAgICAgICAgICAueShnZXRZKVxuICAgICAgICAgICAgICAgIC5vdXQoZnVuY3Rpb24oZCwgeTAsIHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5kaXNwbGF5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHkwOiB5MFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAoZGF0YUZpbHRlcmVkKTtcblxuICAgICAgICAgICAgLy8gU2V0dXAgY29udGFpbmVycyBhbmQgc2tlbGV0b24gb2YgY2hhcnRcbiAgICAgICAgICAgIHZhciB3cmFwID0gY29udGFpbmVyLnNlbGVjdEFsbCgnZy5udi13cmFwLm52LXN0YWNrZWRhcmVhJykuZGF0YShbZGF0YV0pO1xuICAgICAgICAgICAgdmFyIHdyYXBFbnRlciA9IHdyYXAuZW50ZXIoKS5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudmQzIG52LXdyYXAgbnYtc3RhY2tlZGFyZWEnKTtcbiAgICAgICAgICAgIHZhciBkZWZzRW50ZXIgPSB3cmFwRW50ZXIuYXBwZW5kKCdkZWZzJyk7XG4gICAgICAgICAgICB2YXIgZ0VudGVyID0gd3JhcEVudGVyLmFwcGVuZCgnZycpO1xuICAgICAgICAgICAgdmFyIGcgPSB3cmFwLnNlbGVjdCgnZycpO1xuXG4gICAgICAgICAgICBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYXJlYVdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1zY2F0dGVyV3JhcCcpO1xuXG4gICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIG1hcmdpbi5sZWZ0ICsgJywnICsgbWFyZ2luLnRvcCArICcpJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBub3Qgc3BlY2lmaWVkIGZvcmNlWSwgbWFrZSBzdXJlIDAgaXMgaW5jbHVkZWQgaW4gdGhlIGRvbWFpblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdXNlci1zcGVjaWZpZWQgdmFsdWVzIGZvciBmb3JjZVlcbiAgICAgICAgICAgIGlmIChzY2F0dGVyLmZvcmNlWSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgc2NhdHRlci5mb3JjZVkoKS5wdXNoKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzY2F0dGVyXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC54KGdldFgpXG4gICAgICAgICAgICAgICAgLnkoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZC5kaXNwbGF5ICE9PSB1bmRlZmluZWQpIHsgcmV0dXJuIGQuZGlzcGxheS55ICsgZC5kaXNwbGF5LnkwOyB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY29sb3IoZGF0YS5tYXAoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQuY29sb3IgPSBkLmNvbG9yIHx8IGNvbG9yKGQsIGQuc2VyaWVzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvcjtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHZhciBzY2F0dGVyV3JhcCA9IGcuc2VsZWN0KCcubnYtc2NhdHRlcldyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhKTtcblxuICAgICAgICAgICAgc2NhdHRlcldyYXAuY2FsbChzY2F0dGVyKTtcblxuICAgICAgICAgICAgZGVmc0VudGVyLmFwcGVuZCgnY2xpcFBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsICdudi1lZGdlLWNsaXAtJyArIGlkKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKTtcblxuICAgICAgICAgICAgd3JhcC5zZWxlY3QoJyNudi1lZGdlLWNsaXAtJyArIGlkICsgJyByZWN0JylcbiAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgYXZhaWxhYmxlSGVpZ2h0KTtcblxuICAgICAgICAgICAgZy5hdHRyKCdjbGlwLXBhdGgnLCBjbGlwRWRnZSA/ICd1cmwoI252LWVkZ2UtY2xpcC0nICsgaWQgKyAnKScgOiAnJyk7XG5cbiAgICAgICAgICAgIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgICAgICAgICAgICAgIC5kZWZpbmVkKGRlZmluZWQpXG4gICAgICAgICAgICAgICAgLngoZnVuY3Rpb24oZCxpKSAgeyByZXR1cm4geChnZXRYKGQsaSkpIH0pXG4gICAgICAgICAgICAgICAgLnkwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoZC5kaXNwbGF5LnkwKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHkoZC5kaXNwbGF5LnkgKyBkLmRpc3BsYXkueTApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUpO1xuXG4gICAgICAgICAgICB2YXIgemVyb0FyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgICAgICAgICAgICAgLmRlZmluZWQoZGVmaW5lZClcbiAgICAgICAgICAgICAgICAueChmdW5jdGlvbihkLGkpICB7IHJldHVybiB4KGdldFgoZCxpKSkgfSlcbiAgICAgICAgICAgICAgICAueTAoZnVuY3Rpb24oZCkgeyByZXR1cm4geShkLmRpc3BsYXkueTApIH0pXG4gICAgICAgICAgICAgICAgLnkxKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHkoZC5kaXNwbGF5LnkwKSB9KTtcblxuICAgICAgICAgICAgdmFyIHBhdGggPSBnLnNlbGVjdCgnLm52LWFyZWFXcmFwJykuc2VsZWN0QWxsKCdwYXRoLm52LWFyZWEnKVxuICAgICAgICAgICAgICAgIC5kYXRhKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgfSk7XG5cbiAgICAgICAgICAgIHBhdGguZW50ZXIoKS5hcHBlbmQoJ3BhdGgnKS5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gJ252LWFyZWEgbnYtYXJlYS0nICsgaSB9KVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHplcm9BcmVhKGQudmFsdWVzLCBkLnNlcmllc0luZGV4KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jbGFzc2VkKCdob3ZlcicsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5hcmVhTW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50OiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzOiBkLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczogW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNJbmRleDogZC5zZXJpZXNJbmRleFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5hcmVhTW91c2VvdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXM6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0luZGV4OiBkLnNlcmllc0luZGV4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKGQsaSkge1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmFyZWFDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogZC5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3M6IFtkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzSW5kZXg6IGQuc2VyaWVzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhdGguZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgcGF0aC5zdHlsZSgnZmlsbCcsIGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGQuc2VyaWVzSW5kZXgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3N0cm9rZScsIGZ1bmN0aW9uKGQsaSl7IHJldHVybiBkLmNvbG9yIHx8IGNvbG9yKGQsIGQuc2VyaWVzSW5kZXgpIH0pO1xuICAgICAgICAgICAgcGF0aC53YXRjaFRyYW5zaXRpb24ocmVuZGVyV2F0Y2gsJ3N0YWNrZWRBcmVhIHBhdGgnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmVhKGQudmFsdWVzLGkpXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIuYXJlYScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNoYXJ0LScgKyBpZCArICcgLm52LWFyZWEtJyArIGUuc2VyaWVzSW5kZXgpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC5hcmVhJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY2hhcnQtJyArIGlkICsgJyAubnYtYXJlYS0nICsgZS5zZXJpZXNJbmRleCkuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9TcGVjaWFsIG9mZnNldCBmdW5jdGlvbnNcbiAgICAgICAgICAgIGNoYXJ0LmQzX3N0YWNrZWRPZmZzZXRfc3RhY2tQZXJjZW50ID0gZnVuY3Rpb24oc3RhY2tEYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBzdGFja0RhdGEubGVuZ3RoLCAgICAvL0hvdyBtYW55IHNlcmllc1xuICAgICAgICAgICAgICAgICAgICBtID0gc3RhY2tEYXRhWzBdLmxlbmd0aCwgICAgIC8vaG93IG1hbnkgcG9pbnRzIHBlciBzZXJpZXNcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICAgICAgbyxcbiAgICAgICAgICAgICAgICAgICAgeTAgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHsgLy9Mb29waW5nIHRocm91Z2ggYWxsIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBvID0gMDsgaSA8IGRhdGFSYXcubGVuZ3RoOyBpKyspIHsgLy9sb29waW5nIHRocm91Z2ggYWxsIHNlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgbyArPSBnZXRZKGRhdGFSYXdbaV0udmFsdWVzW2pdKTsgLy90b3RhbCB5IHZhbHVlIG9mIGFsbCBzZXJpZXMgYXQgYSBjZXJ0aWFuIHBvaW50IGluIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobykgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeyAvLyh0b3RhbCB5IHZhbHVlIG9mIGFsbCBzZXJpZXMgYXQgcG9pbnQgaW4gdGltZSBpKSAhPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFja0RhdGFbaV1bal1bMV0gLz0gbztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8odG90YWwgeSB2YWx1ZSBvZiBhbGwgc2VyaWVzIGF0IHBvaW50IGluIHRpbWUgaSkgPT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrRGF0YVtpXVtqXVsxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikgeTBbal0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB5MDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzdGFja2VkQXJlYSBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gR2xvYmFsIGdldHRlcnMgYW5kIHNldHRlcnNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5zY2F0dGVyID0gc2NhdHRlcjtcblxuICAgIHNjYXR0ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRDbGljaycsIGZ1bmN0aW9uKCl7IGRpc3BhdGNoLmVsZW1lbnRDbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KTtcbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdmVyJywgZnVuY3Rpb24oKXsgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3Zlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9KTtcbiAgICBzY2F0dGVyLmRpc3BhdGNoLm9uKCdlbGVtZW50TW91c2VvdXQnLCBmdW5jdGlvbigpeyBkaXNwYXRjaC5lbGVtZW50TW91c2VvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSk7XG5cbiAgICBjaGFydC5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW50ZXJwb2xhdGU7XG4gICAgICAgIGludGVycG9sYXRlID0gXztcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5kdXJhdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZHVyYXRpb247XG4gICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICBzY2F0dGVyLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH07XG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0LnNjYXR0ZXIgPSBzY2F0dGVyO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIGRlZmluZWQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGRlZmluZWQ7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZpbmVkPV87fX0sXG4gICAgICAgIGNsaXBFZGdlOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBjbGlwRWRnZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NsaXBFZGdlPV87fX0sXG4gICAgICAgIG9mZnNldDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBvZmZzZXQ7fSwgc2V0OiBmdW5jdGlvbihfKXtvZmZzZXQ9Xzt9fSxcbiAgICAgICAgb3JkZXI6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG9yZGVyO30sIHNldDogZnVuY3Rpb24oXyl7b3JkZXI9Xzt9fSxcbiAgICAgICAgaW50ZXJwb2xhdGU6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGludGVycG9sYXRlO30sIHNldDogZnVuY3Rpb24oXyl7aW50ZXJwb2xhdGU9Xzt9fSxcblxuICAgICAgICAvLyBzaW1wbGUgZnVuY3RvciBvcHRpb25zXG4gICAgICAgIHg6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRYO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WCA9IGQzLmZ1bmN0b3IoXyk7fX0sXG4gICAgICAgIHk6ICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBnZXRZO30sIHNldDogZnVuY3Rpb24oXyl7Z2V0WSA9IGQzLmZ1bmN0b3IoXyk7fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgbWFyZ2luLnRvcCAgICA9IF8udG9wICAgICE9PSB1bmRlZmluZWQgPyBfLnRvcCAgICA6IG1hcmdpbi50b3A7XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBjb2xvcjogIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvciA9IG52LnV0aWxzLmdldENvbG9yKF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgc3R5bGU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0eWxlO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBzdHlsZSA9IF87XG4gICAgICAgICAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RhY2snOlxuICAgICAgICAgICAgICAgICAgICBjaGFydC5vZmZzZXQoJ3plcm8nKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub3JkZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub2Zmc2V0KCd3aWdnbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub3JkZXIoJ2luc2lkZS1vdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyZWFtLWNlbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0Lm9mZnNldCgnc2lsaG91ZXR0ZScpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5vcmRlcignaW5zaWRlLW91dCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHBhbmQnOlxuICAgICAgICAgICAgICAgICAgICBjaGFydC5vZmZzZXQoJ2V4cGFuZCcpO1xuICAgICAgICAgICAgICAgICAgICBjaGFydC5vcmRlcignZGVmYXVsdCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzdGFja19wZXJjZW50JzpcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub2Zmc2V0KGNoYXJ0LmQzX3N0YWNrZWRPZmZzZXRfc3RhY2tQZXJjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnQub3JkZXIoJ2RlZmF1bHQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH19LFxuICAgICAgICBkdXJhdGlvbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZHVyYXRpb247fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gXztcbiAgICAgICAgICAgIHJlbmRlcldhdGNoLnJlc2V0KGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHNjYXR0ZXIuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fVxuICAgIH0pO1xuXG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHNjYXR0ZXIpO1xuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcblxuICAgIHJldHVybiBjaGFydDtcbn07XG5cbm52Lm1vZGVscy5zdGFja2VkQXJlYUNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFB1YmxpYyBWYXJpYWJsZXMgd2l0aCBEZWZhdWx0IFNldHRpbmdzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHZhciBzdGFja2VkID0gbnYubW9kZWxzLnN0YWNrZWRBcmVhKClcbiAgICAgICAgLCB4QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCB5QXhpcyA9IG52Lm1vZGVscy5heGlzKClcbiAgICAgICAgLCBsZWdlbmQgPSBudi5tb2RlbHMubGVnZW5kKClcbiAgICAgICAgLCBjb250cm9scyA9IG52Lm1vZGVscy5sZWdlbmQoKVxuICAgICAgICAsIGludGVyYWN0aXZlTGF5ZXIgPSBudi5pbnRlcmFjdGl2ZUd1aWRlbGluZSgpXG4gICAgICAgICwgdG9vbHRpcCA9IG52Lm1vZGVscy50b29sdGlwKClcbiAgICAgICAgLCBmb2N1cyA9IG52Lm1vZGVscy5mb2N1cyhudi5tb2RlbHMuc3RhY2tlZEFyZWEoKSlcbiAgICAgICAgO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDEwLCByaWdodDogMjUsIGJvdHRvbTogNTAsIGxlZnQ6IDYwfVxuICAgICAgICAsIG1hcmdpblRvcCA9IG51bGxcbiAgICAgICAgLCB3aWR0aCA9IG51bGxcbiAgICAgICAgLCBoZWlnaHQgPSBudWxsXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNob3dDb250cm9scyA9IHRydWVcbiAgICAgICAgLCBzaG93TGVnZW5kID0gdHJ1ZVxuICAgICAgICAsIGxlZ2VuZFBvc2l0aW9uID0gJ3RvcCdcbiAgICAgICAgLCBzaG93WEF4aXMgPSB0cnVlXG4gICAgICAgICwgc2hvd1lBeGlzID0gdHJ1ZVxuICAgICAgICAsIHJpZ2h0QWxpZ25ZQXhpcyA9IGZhbHNlXG4gICAgICAgICwgZm9jdXNFbmFibGUgPSBmYWxzZVxuICAgICAgICAsIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lID0gZmFsc2VcbiAgICAgICAgLCBzaG93VG90YWxJblRvb2x0aXAgPSB0cnVlXG4gICAgICAgICwgdG90YWxMYWJlbCA9ICdUT1RBTCdcbiAgICAgICAgLCB4IC8vY2FuIGJlIGFjY2Vzc2VkIHZpYSBjaGFydC54U2NhbGUoKVxuICAgICAgICAsIHkgLy9jYW4gYmUgYWNjZXNzZWQgdmlhIGNoYXJ0LnlTY2FsZSgpXG4gICAgICAgICwgc3RhdGUgPSBudi51dGlscy5zdGF0ZSgpXG4gICAgICAgICwgZGVmYXVsdFN0YXRlID0gbnVsbFxuICAgICAgICAsIG5vRGF0YSA9IG51bGxcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdzdGF0ZUNoYW5nZScsICdjaGFuZ2VTdGF0ZScsJ3JlbmRlckVuZCcpXG4gICAgICAgICwgY29udHJvbFdpZHRoID0gMjUwXG4gICAgICAgICwgY29udHJvbE9wdGlvbnMgPSBbJ1N0YWNrZWQnLCdTdHJlYW0nLCdFeHBhbmRlZCddXG4gICAgICAgICwgY29udHJvbExhYmVscyA9IHt9XG4gICAgICAgICwgZHVyYXRpb24gPSAyNTBcbiAgICAgICAgO1xuXG4gICAgc3RhdGUuc3R5bGUgPSBzdGFja2VkLnN0eWxlKCk7XG4gICAgeEF4aXMub3JpZW50KCdib3R0b20nKS50aWNrUGFkZGluZyg3KTtcbiAgICB5QXhpcy5vcmllbnQoKHJpZ2h0QWxpZ25ZQXhpcykgPyAncmlnaHQnIDogJ2xlZnQnKTtcblxuICAgIHRvb2x0aXBcbiAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KVxuICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHlBeGlzLnRpY2tGb3JtYXQoKShkLCBpKTtcbiAgICAgICAgfSk7XG5cbiAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgLmhlYWRlckZvcm1hdHRlcihmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4geEF4aXMudGlja0Zvcm1hdCgpKGQsIGkpO1xuICAgICAgICB9KVxuICAgICAgICAudmFsdWVGb3JtYXR0ZXIoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGQgPT0gbnVsbCA/IFwiTi9BXCIgOiB5QXhpcy50aWNrRm9ybWF0KCkoZCwgaSk7XG4gICAgICAgIH0pO1xuXG4gICAgdmFyIG9sZFlUaWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgICAgb2xkVmFsdWVGb3JtYXR0ZXIgPSBudWxsO1xuXG4gICAgY29udHJvbHMudXBkYXRlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG4gICAgdmFyIHN0eWxlID0gc3RhY2tlZC5zdHlsZSgpO1xuXG4gICAgdmFyIHN0YXRlR2V0dGVyID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlOiBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZCB9KSxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3RhY2tlZC5zdHlsZSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBzdGF0ZVNldHRlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3R5bGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzdHlsZSA9IHN0YXRlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmFjdGl2ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSAhc3RhdGUuYWN0aXZlW2ldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBwZXJjZW50Rm9ybWF0dGVyID0gZDMuZm9ybWF0KCclJyk7XG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHN0YWNrZWQpO1xuICAgICAgICBpZiAoc2hvd1hBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeEF4aXMpO1xuICAgICAgICBpZiAoc2hvd1lBeGlzKSByZW5kZXJXYXRjaC5tb2RlbHMoeUF4aXMpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QodGhpcyksXG4gICAgICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbiksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIC0gKGZvY3VzRW5hYmxlID8gZm9jdXMuaGVpZ2h0KCkgOiAwKTtcblxuICAgICAgICAgICAgY2hhcnQudXBkYXRlID0gZnVuY3Rpb24oKSB7IGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpOyB9O1xuICAgICAgICAgICAgY2hhcnQuY29udGFpbmVyID0gdGhpcztcblxuICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAuc2V0dGVyKHN0YXRlU2V0dGVyKGRhdGEpLCBjaGFydC51cGRhdGUpXG4gICAgICAgICAgICAgICAgLmdldHRlcihzdGF0ZUdldHRlcihkYXRhKSlcbiAgICAgICAgICAgICAgICAudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIERFUFJFQ0FURUQgc2V0IHN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhZC5kaXNhYmxlZCB9KTtcblxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZVtrZXldIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGVba2V5XSA9IHN0YXRlW2tleV0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdGF0ZVtrZXldID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCB8fCAhZGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC52YWx1ZXMubGVuZ3RoIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFydDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNlbGVjdEFsbCgnLm52LW5vRGF0YScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0dXAgU2NhbGVzXG4gICAgICAgICAgICB4ID0gc3RhY2tlZC54U2NhbGUoKTtcbiAgICAgICAgICAgIHkgPSBzdGFja2VkLnlTY2FsZSgpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBjb250YWluZXJzIGFuZCBza2VsZXRvbiBvZiBjaGFydFxuICAgICAgICAgICAgdmFyIHdyYXAgPSBjb250YWluZXIuc2VsZWN0QWxsKCdnLm52LXdyYXAubnYtc3RhY2tlZEFyZWFDaGFydCcpLmRhdGEoW2RhdGFdKTtcbiAgICAgICAgICAgIHZhciBnRW50ZXIgPSB3cmFwLmVudGVyKCkuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXN0YWNrZWRBcmVhQ2hhcnQnKS5hcHBlbmQoJ2cnKTtcbiAgICAgICAgICAgIHZhciBnID0gd3JhcC5zZWxlY3QoJ2cnKTtcblxuICAgICAgICAgICAgZ0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWxlZ2VuZFdyYXAnKTtcbiAgICAgICAgICAgIGdFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi1jb250cm9sc1dyYXAnKTtcblxuICAgICAgICAgICAgdmFyIGZvY3VzRW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZm9jdXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtYmFja2dyb3VuZCcpLmFwcGVuZCgncmVjdCcpO1xuICAgICAgICAgICAgZm9jdXNFbnRlci5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsICdudi14IG52LWF4aXMnKTtcbiAgICAgICAgICAgIGZvY3VzRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYteSBudi1heGlzJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LXN0YWNrZWRXcmFwJyk7XG4gICAgICAgICAgICBmb2N1c0VudGVyLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywgJ252LWludGVyYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIC8vIGcuc2VsZWN0KFwicmVjdFwiKS5hdHRyKFwid2lkdGhcIixhdmFpbGFibGVXaWR0aCkuYXR0cihcImhlaWdodFwiLGF2YWlsYWJsZUhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBjb250ZXh0RW50ZXIgPSBnRW50ZXIuYXBwZW5kKCdnJykuYXR0cignY2xhc3MnLCAnbnYtZm9jdXNXcmFwJyk7XG5cbiAgICAgICAgICAgIC8vIExlZ2VuZFxuICAgICAgICAgICAgaWYgKCFzaG93TGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1sZWdlbmRXcmFwJykuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsZWdlbmRXaWR0aCA9IChzaG93Q29udHJvbHMgJiYgbGVnZW5kUG9zaXRpb24gPT09ICd0b3AnKSA/IGF2YWlsYWJsZVdpZHRoIC0gY29udHJvbFdpZHRoIDogYXZhaWxhYmxlV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBsZWdlbmQud2lkdGgobGVnZW5kV2lkdGgpO1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpLmRhdHVtKGRhdGEpLmNhbGwobGVnZW5kKTtcblxuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICBcdC8vIGNvbnN0YW50IGZyb20gYXhpcy5qcywgcGx1cyBzb21lIG1hcmdpbiBmb3IgYmV0dGVyIGxheW91dFxuICAgICAgICAgICAgICAgIFx0dmFyIHhBeGlzSGVpZ2h0ID0gKHNob3dYQXhpcyA/IDEyIDogMCkgKyAxMDtcbiAgICAgICAgICAgICAgICAgICBcdG1hcmdpbi5ib3R0b20gPSBNYXRoLm1heChsZWdlbmQuaGVpZ2h0KCkgKyB4QXhpc0hlaWdodCwgbWFyZ2luLmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgICAgXHRhdmFpbGFibGVIZWlnaHQgPSBudi51dGlscy5hdmFpbGFibGVIZWlnaHQoaGVpZ2h0LCBjb250YWluZXIsIG1hcmdpbikgLSAoZm9jdXNFbmFibGUgPyBmb2N1cy5oZWlnaHQoKSA6IDApO1xuICAgICAgICAgICAgICAgIFx0dmFyIGxlZ2VuZFRvcCA9IGF2YWlsYWJsZUhlaWdodCArIHhBeGlzSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWxlZ2VuZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwnICsgbGVnZW5kVG9wICsnKScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVnZW5kUG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFyZ2luVG9wICYmIG1hcmdpbi50b3AgIT0gbGVnZW5kLmhlaWdodCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gbGVnZW5kLmhlaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIC0gKGZvY3VzRW5hYmxlID8gZm9jdXMuaGVpZ2h0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtbGVnZW5kV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIFx0LmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIChhdmFpbGFibGVXaWR0aC1sZWdlbmRXaWR0aCkgKyAnLCcgKyAoLW1hcmdpbi50b3ApICsnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udHJvbHNcbiAgICAgICAgICAgIGlmICghc2hvd0NvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgIGcuc2VsZWN0KCcubnYtY29udHJvbHNXcmFwJykuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sc0RhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29udHJvbExhYmVscy5zdGFja2VkIHx8ICdTdGFja2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFLZXk6ICdTdGFja2VkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBzdGFja2VkLnN0eWxlKCkgIT0gJ3N0YWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc3RhY2snXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogY29udHJvbExhYmVscy5zdHJlYW0gfHwgJ1N0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnU3RyZWFtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkOiBzdGFja2VkLnN0eWxlKCkgIT0gJ3N0cmVhbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ3N0cmVhbSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBjb250cm9sTGFiZWxzLmV4cGFuZGVkIHx8ICdFeHBhbmRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnRXhwYW5kZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6IHN0YWNrZWQuc3R5bGUoKSAhPSAnZXhwYW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnZXhwYW5kJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGNvbnRyb2xMYWJlbHMuc3RhY2tfcGVyY2VudCB8fCAnU3RhY2sgJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiAnU3RhY2tfUGVyY2VudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogc3RhY2tlZC5zdHlsZSgpICE9ICdzdGFja19wZXJjZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiAnc3RhY2tfcGVyY2VudCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICBjb250cm9sV2lkdGggPSAoY29udHJvbE9wdGlvbnMubGVuZ3RoLzMpICogMjYwO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzRGF0YSA9IGNvbnRyb2xzRGF0YS5maWx0ZXIoZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbE9wdGlvbnMuaW5kZXhPZihkLm1ldGFLZXkpICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aCggY29udHJvbFdpZHRoIClcbiAgICAgICAgICAgICAgICAgICAgLmNvbG9yKFsnIzQ0NCcsICcjNDQ0JywgJyM0NDQnXSk7XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShjb250cm9sc0RhdGEpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGNvbnRyb2xzKTtcblxuICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZFRvcCA9IE1hdGgubWF4KGNvbnRyb2xzLmhlaWdodCgpLCBzaG93TGVnZW5kICYmIChsZWdlbmRQb3NpdGlvbiA9PT0gJ3RvcCcpID8gbGVnZW5kLmhlaWdodCgpIDogMCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIG1hcmdpbi50b3AgIT0gcmVxdWlyZWRUb3AgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbi50b3AgPSByZXF1aXJlZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pIC0gKGZvY3VzRW5hYmxlID8gZm9jdXMuaGVpZ2h0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWNvbnRyb2xzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICgtbWFyZ2luLnRvcCkgKycpJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdyYXAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWFyZ2luLmxlZnQgKyAnLCcgKyBtYXJnaW4udG9wICsgJyknKTtcblxuICAgICAgICAgICAgaWYgKHJpZ2h0QWxpZ25ZQXhpcykge1xuICAgICAgICAgICAgICAgIGcuc2VsZWN0KFwiLm52LXkubnYtYXhpc1wiKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIGF2YWlsYWJsZVdpZHRoICsgXCIsMClcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vU2V0IHVwIGludGVyYWN0aXZlIGxheWVyXG4gICAgICAgICAgICBpZiAodXNlSW50ZXJhY3RpdmVHdWlkZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aChhdmFpbGFibGVXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmhlaWdodChhdmFpbGFibGVIZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXJnaW4oe2xlZnQ6IG1hcmdpbi5sZWZ0LCB0b3A6IG1hcmdpbi50b3B9KVxuICAgICAgICAgICAgICAgICAgICAuc3ZnQ29udGFpbmVyKGNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgLnhTY2FsZSh4KTtcbiAgICAgICAgICAgICAgICB3cmFwLnNlbGVjdChcIi5udi1pbnRlcmFjdGl2ZVwiKS5jYWxsKGludGVyYWN0aXZlTGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi1iYWNrZ3JvdW5kIHJlY3QnKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBhdmFpbGFibGVIZWlnaHQpO1xuXG4gICAgICAgICAgICBzdGFja2VkXG4gICAgICAgICAgICAgICAgLndpZHRoKGF2YWlsYWJsZVdpZHRoKVxuICAgICAgICAgICAgICAgIC5oZWlnaHQoYXZhaWxhYmxlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIC5jb2xvcihkYXRhLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3IgfHwgY29sb3IoZCwgaSk7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGQsaSkgeyByZXR1cm4gIWRhdGFbaV0uZGlzYWJsZWQ7IH0pKTtcblxuICAgICAgICAgICAgdmFyIHN0YWNrZWRXcmFwID0gZy5zZWxlY3QoJy5udi1mb2N1cyAubnYtc3RhY2tlZFdyYXAnKVxuICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZDsgfSkpO1xuXG4gICAgICAgICAgICAvLyBTZXR1cCBBeGVzXG4gICAgICAgICAgICBpZiAoc2hvd1hBeGlzKSB7XG4gICAgICAgICAgICAgICAgeEF4aXMuc2NhbGUoeClcbiAgICAgICAgICAgICAgICAgICAgLl90aWNrcyggbnYudXRpbHMuY2FsY1RpY2tzWChhdmFpbGFibGVXaWR0aC8xMDAsIGRhdGEpIClcbiAgICAgICAgICAgICAgICAgICAgLnRpY2tTaXplKCAtYXZhaWxhYmxlSGVpZ2h0LCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNob3dZQXhpcykge1xuICAgICAgICAgICAgICAgIHZhciB0aWNrcztcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZC5vZmZzZXQoKSA9PT0gJ3dpZ2dsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlja3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGlja3MgPSBudi51dGlscy5jYWxjVGlja3NZKGF2YWlsYWJsZUhlaWdodC8zNiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlBeGlzLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgICAgIC5fdGlja3ModGlja3MpXG4gICAgICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtYXZhaWxhYmxlV2lkdGgsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLy8gVXBkYXRlIEF4ZXNcbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVYQXhpcygpIHtcbiAgICAgICAgICAgICAgICBpZihzaG93WEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZy5zZWxlY3QoJy5udi1mb2N1cyAubnYteC5udi1heGlzJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArIGF2YWlsYWJsZUhlaWdodCArICcpJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsKHhBeGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlWUF4aXMoKSB7XG4gICAgICAgICAgICAgICAgaWYoc2hvd1lBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja2VkLnN0eWxlKCkgPT09ICdleHBhbmQnIHx8IHN0YWNrZWQuc3R5bGUoKSA9PT0gJ3N0YWNrX3BlcmNlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZvcm1hdCA9IHlBeGlzLnRpY2tGb3JtYXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhb2xkWVRpY2tGb3JtYXQgfHwgY3VycmVudEZvcm1hdCAhPT0gcGVyY2VudEZvcm1hdHRlciApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkWVRpY2tGb3JtYXQgPSBjdXJyZW50Rm9ybWF0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZvcmNlcyB0aGUgeUF4aXMgdG8gdXNlIHBlcmNlbnRhZ2UgaW4gJ2V4cGFuZCcgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHlBeGlzLnRpY2tGb3JtYXQocGVyY2VudEZvcm1hdHRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkWVRpY2tGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5QXhpcy50aWNrRm9ybWF0KG9sZFlUaWNrRm9ybWF0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRZVGlja0Zvcm1hdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzIC5udi15Lm52LWF4aXMnKVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpLmR1cmF0aW9uKDApXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKHlBeGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBVcGRhdGUgRm9jdXNcbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICBpZighZm9jdXNFbmFibGUpIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkV3JhcC50cmFuc2l0aW9uKCkuY2FsbChzdGFja2VkKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVYQXhpcygpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVlBeGlzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvY3VzLndpZHRoKGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgICAgICAgICBnLnNlbGVjdCgnLm52LWZvY3VzV3JhcCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsJyArICggYXZhaWxhYmxlSGVpZ2h0ICsgbWFyZ2luLmJvdHRvbSArIGZvY3VzLm1hcmdpbigpLnRvcCkgKyAnKScpXG4gICAgICAgICAgICAgICAgICAgIC5kYXR1bShkYXRhLmZpbHRlcihmdW5jdGlvbihkKSB7IHJldHVybiAhZC5kaXNhYmxlZDsgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5jYWxsKGZvY3VzKTtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW50ID0gZm9jdXMuYnJ1c2guZW1wdHkoKSA/IGZvY3VzLnhEb21haW4oKSA6IGZvY3VzLmJydXNoLmV4dGVudCgpO1xuICAgICAgICAgICAgICAgIGlmKGV4dGVudCAhPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIG9uQnJ1c2goZXh0ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAoaW4gY2hhcnQncyBzY29wZSlcbiAgICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgIHN0YWNrZWQuZGlzcGF0Y2gub24oJ2FyZWFDbGljay50b2dnbGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkIH0pLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkLmRpc2FibGVkID0gKGkgIT0gZS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc3RhdGUuZGlzYWJsZWQgPSBkYXRhLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiAhIWQuZGlzYWJsZWQgfSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2guc3RhdGVDaGFuZ2Uoc3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGVnZW5kLmRpc3BhdGNoLm9uKCdzdGF0ZUNoYW5nZScsIGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG5ld1N0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtrZXldID0gbmV3U3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5zdGF0ZUNoYW5nZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29udHJvbHMuZGlzcGF0Y2gub24oJ2xlZ2VuZENsaWNrJywgZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkLmRpc2FibGVkKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjb250cm9sc0RhdGEgPSBjb250cm9sc0RhdGEubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGQuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIHN0YWNrZWQuc3R5bGUoZC5zdHlsZSk7XG5cblxuICAgICAgICAgICAgICAgIHN0YXRlLnN0eWxlID0gc3RhY2tlZC5zdHlsZSgpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoLnN0YXRlQ2hhbmdlKHN0YXRlKTtcblxuICAgICAgICAgICAgICAgIGNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGludGVyYWN0aXZlTGF5ZXIuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgc3RhY2tlZC5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2luZ2xlUG9pbnQsIHBvaW50SW5kZXgsIHBvaW50WExvY2F0aW9uLCBhbGxEYXRhID0gW10sIHZhbHVlU3VtID0gMCwgYWxsTnVsbFZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHNlcmllcywgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnNlcmllc0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc2VyaWVzLmRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbihzZXJpZXMsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmRleCA9IG52LmludGVyYWN0aXZlQmlzZWN0KHNlcmllcy52YWx1ZXMsIGUucG9pbnRYVmFsdWUsIGNoYXJ0LngoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBzZXJpZXMudmFsdWVzW3BvaW50SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50WVZhbHVlID0gY2hhcnQueSgpKHBvaW50LCBwb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludFlWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tlZC5oaWdobGlnaHRQb2ludChpLCBwb2ludEluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNpbmdsZVBvaW50ID09PSAndW5kZWZpbmVkJykgc2luZ2xlUG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRYTG9jYXRpb24gPT09ICd1bmRlZmluZWQnKSBwb2ludFhMb2NhdGlvbiA9IGNoYXJ0LnhTY2FsZSgpKGNoYXJ0LngoKShwb2ludCxwb2ludEluZGV4KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgd2UgYXJlIGluICdleHBhbmQnIG1vZGUsIHVzZSB0aGUgc3RhY2tlZCBwZXJjZW50IHZhbHVlIGluc3RlYWQgb2YgcmF3IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvb2x0aXBWYWx1ZSA9IChzdGFja2VkLnN0eWxlKCkgPT0gJ2V4cGFuZCcpID8gcG9pbnQuZGlzcGxheS55IDogY2hhcnQueSgpKHBvaW50LHBvaW50SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlcmllcy5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvb2x0aXBWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3Ioc2VyaWVzLHNlcmllcy5zZXJpZXNJbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dUb3RhbEluVG9vbHRpcCAmJiBzdGFja2VkLnN0eWxlKCkgIT0gJ2V4cGFuZCcgJiYgdG9vbHRpcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVTdW0gKz0gdG9vbHRpcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxOdWxsVmFsdWVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGFsbERhdGEucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgLy9IaWdobGlnaHQgdGhlIHRvb2x0aXAgZW50cnkgYmFzZWQgb24gd2hpY2ggc3RhY2sgdGhlIG1vdXNlIGlzIGNsb3Nlc3QgdG8uXG4gICAgICAgICAgICAgICAgaWYgKGFsbERhdGEubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVZhbHVlID0gY2hhcnQueVNjYWxlKCkuaW52ZXJ0KGUubW91c2VZKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlEaXN0TWF4ID0gSW5maW5pdHksIGluZGV4VG9IaWdobGlnaHQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhLmZvckVhY2goZnVuY3Rpb24oc2VyaWVzLGkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UbyBoYW5kbGUgc2l0dWF0aW9uIHdoZXJlIHRoZSBzdGFja2VkIGFyZWEgY2hhcnQgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gdXNlIGFic29sdXRlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy93aGVuIGNoZWNraW5nIGlmIHRoZSBtb3VzZSBZIHZhbHVlIGlzIHdpdGhpbiB0aGUgc3RhY2sgYXJlYS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHlWYWx1ZSA9IE1hdGguYWJzKHlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tlZFkwID0gTWF0aC5hYnMoc2VyaWVzLnBvaW50LmRpc3BsYXkueTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRZID0gTWF0aC5hYnMoc2VyaWVzLnBvaW50LmRpc3BsYXkueSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHlWYWx1ZSA+PSBzdGFja2VkWTAgJiYgeVZhbHVlIDw9IChzdGFja2VkWSArIHN0YWNrZWRZMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhUb0hpZ2hsaWdodCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4VG9IaWdobGlnaHQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbERhdGFbaW5kZXhUb0hpZ2hsaWdodF0uaGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL0lmIHdlIGFyZSBub3QgaW4gJ2V4cGFuZCcgbW9kZSwgYWRkIGEgJ1RvdGFsJyByb3cgdG8gdGhlIHRvb2x0aXAuXG4gICAgICAgICAgICAgICAgaWYgKHNob3dUb3RhbEluVG9vbHRpcCAmJiBzdGFja2VkLnN0eWxlKCkgIT0gJ2V4cGFuZCcgJiYgYWxsRGF0YS5sZW5ndGggPj0gMiAmJiAhYWxsTnVsbFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXRhLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0b3RhbExhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlU3VtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHhWYWx1ZSA9IGNoYXJ0LngoKShzaW5nbGVQb2ludCxwb2ludEluZGV4KTtcblxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlciA9IGludGVyYWN0aXZlTGF5ZXIudG9vbHRpcC52YWx1ZUZvcm1hdHRlcigpO1xuICAgICAgICAgICAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSB0b29sdGlwIHZhbHVlRm9ybWF0dGVyIGlmIHRoZSBjaGFydCBjaGFuZ2VzIHRvIGV4cGFuZGVkIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAoc3RhY2tlZC5zdHlsZSgpID09PSAnZXhwYW5kJyB8fCBzdGFja2VkLnN0eWxlKCkgPT09ICdzdGFja19wZXJjZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoICFvbGRWYWx1ZUZvcm1hdHRlciApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlRm9ybWF0dGVyID0gdmFsdWVGb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9Gb3JjZXMgdGhlIHRvb2x0aXAgdG8gdXNlIHBlcmNlbnRhZ2UgaW4gJ2V4cGFuZCcgbW9kZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVGb3JtYXR0ZXIgPSBkMy5mb3JtYXQoXCIuMSVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWVGb3JtYXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlRm9ybWF0dGVyID0gb2xkVmFsdWVGb3JtYXR0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZUZvcm1hdHRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZUxheWVyLnRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgLnZhbHVlRm9ybWF0dGVyKHZhbHVlRm9ybWF0dGVyKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YShcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHhWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllczogYWxsRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKSgpO1xuXG4gICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5yZW5kZXJHdWlkZUxpbmUocG9pbnRYTG9jYXRpb24pO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW50ZXJhY3RpdmVMYXllci5kaXNwYXRjaC5vbihcImVsZW1lbnRNb3VzZW91dFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBzdGFja2VkLmNsZWFySGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8qIFVwZGF0ZSBgbWFpbicgZ3JhcGggb24gYnJ1c2ggdXBkYXRlLiAqL1xuICAgICAgICAgICAgZm9jdXMuZGlzcGF0Y2gub24oXCJvbkJydXNoXCIsIGZ1bmN0aW9uKGV4dGVudCkge1xuICAgICAgICAgICAgICAgIG9uQnJ1c2goZXh0ZW50KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgY2hhcnQgZnJvbSBhIHN0YXRlIG9iamVjdCBwYXNzZWQgdG8gZXZlbnQgaGFuZGxlclxuICAgICAgICAgICAgZGlzcGF0Y2gub24oJ2NoYW5nZVN0YXRlJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJyAmJiBkYXRhLmxlbmd0aCA9PT0gZS5kaXNhYmxlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNlcmllcyxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXMuZGlzYWJsZWQgPSBlLmRpc2FibGVkW2ldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5kaXNhYmxlZCA9IGUuZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlLnN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFja2VkLnN0eWxlKGUuc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZSA9IGUuc3R5bGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgIC8vIEZ1bmN0aW9uc1xuICAgICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgICAgZnVuY3Rpb24gb25CcnVzaChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgTWFpbiAoRm9jdXMpXG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrZWRXcmFwID0gZy5zZWxlY3QoJy5udi1mb2N1cyAubnYtc3RhY2tlZFdyYXAnKVxuICAgICAgICAgICAgICAgICAgICAuZGF0dW0oXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZmlsdGVyKGZ1bmN0aW9uKGQpIHsgcmV0dXJuICFkLmRpc2FibGVkOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGQua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmVhOiBkLmFyZWEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZWQ6IGQuY2xhc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBkLnZhbHVlcy5maWx0ZXIoZnVuY3Rpb24oZCxpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2tlZC54KCkoZCxpKSA+PSBleHRlbnRbMF0gJiYgc3RhY2tlZC54KCkoZCxpKSA8PSBleHRlbnRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlVG9vbHRpcDogZC5kaXNhYmxlVG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgc3RhY2tlZFdyYXAudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHN0YWNrZWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIE1haW4gKEZvY3VzKSBBeGVzXG4gICAgICAgICAgICAgICAgdXBkYXRlWEF4aXMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVZQXhpcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlbmRlcldhdGNoLnJlbmRlckVuZCgnc3RhY2tlZCBBcmVhIGNoYXJ0IGltbWVkaWF0ZScpO1xuICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFdmVudCBIYW5kbGluZy9EaXNwYXRjaGluZyAob3V0IG9mIGNoYXJ0J3Mgc2NvcGUpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIHN0YWNrZWQuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBldnQucG9pbnRbJ3gnXSA9IHN0YWNrZWQueCgpKGV2dC5wb2ludCk7XG4gICAgICAgIGV2dC5wb2ludFsneSddID0gc3RhY2tlZC55KCkoZXZ0LnBvaW50KTtcbiAgICAgICAgdG9vbHRpcC5kYXRhKGV2dCkuaGlkZGVuKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIHN0YWNrZWQuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpXG4gICAgfSk7XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBFeHBvc2UgUHVibGljIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvLyBleHBvc2UgY2hhcnQncyBzdWItY29tcG9uZW50c1xuICAgIGNoYXJ0LmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gICAgY2hhcnQuc3RhY2tlZCA9IHN0YWNrZWQ7XG4gICAgY2hhcnQubGVnZW5kID0gbGVnZW5kO1xuICAgIGNoYXJ0LmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgY2hhcnQueEF4aXMgPSB4QXhpcztcbiAgICBjaGFydC54MkF4aXMgPSBmb2N1cy54QXhpcztcbiAgICBjaGFydC55QXhpcyA9IHlBeGlzO1xuICAgIGNoYXJ0LnkyQXhpcyA9IGZvY3VzLnlBeGlzO1xuICAgIGNoYXJ0LmludGVyYWN0aXZlTGF5ZXIgPSBpbnRlcmFjdGl2ZUxheWVyO1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIGNoYXJ0LmZvY3VzID0gZm9jdXM7XG5cbiAgICBjaGFydC5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIHdpZHRoOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHdpZHRoO30sIHNldDogZnVuY3Rpb24oXyl7d2lkdGg9Xzt9fSxcbiAgICAgICAgaGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gaGVpZ2h0O30sIHNldDogZnVuY3Rpb24oXyl7aGVpZ2h0PV87fX0sXG4gICAgICAgIHNob3dMZWdlbmQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dMZWdlbmQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93TGVnZW5kPV87fX0sXG4gICAgICAgIGxlZ2VuZFBvc2l0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBsZWdlbmRQb3NpdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2xlZ2VuZFBvc2l0aW9uPV87fX0sXG4gICAgICAgIHNob3dYQXhpczogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WEF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WEF4aXM9Xzt9fSxcbiAgICAgICAgc2hvd1lBeGlzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93WUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93WUF4aXM9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgc2V0OiBmdW5jdGlvbihfKXtkZWZhdWx0U3RhdGU9Xzt9fSxcbiAgICAgICAgbm9EYXRhOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBub0RhdGE7fSwgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgc2hvd0NvbnRyb2xzOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93Q29udHJvbHM7fSwgc2V0OiBmdW5jdGlvbihfKXtzaG93Q29udHJvbHM9Xzt9fSxcbiAgICAgICAgY29udHJvbExhYmVsczogICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29udHJvbExhYmVsczt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2NvbnRyb2xMYWJlbHM9Xzt9fSxcbiAgICAgICAgY29udHJvbE9wdGlvbnM6ICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbnRyb2xPcHRpb25zO30sIHNldDogZnVuY3Rpb24oXyl7Y29udHJvbE9wdGlvbnM9Xzt9fSxcbiAgICAgICAgc2hvd1RvdGFsSW5Ub29sdGlwOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dUb3RhbEluVG9vbHRpcDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3Nob3dUb3RhbEluVG9vbHRpcD1fO319LFxuICAgICAgICB0b3RhbExhYmVsOiAgICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRvdGFsTGFiZWw7fSwgc2V0OiBmdW5jdGlvbihfKXt0b3RhbExhYmVsPV87fX0sXG4gICAgICAgIGZvY3VzRW5hYmxlOiAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb2N1c0VuYWJsZTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2ZvY3VzRW5hYmxlPV87fX0sXG4gICAgICAgIGZvY3VzSGVpZ2h0OiAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXMuaGVpZ2h0KCk7fSwgc2V0OiBmdW5jdGlvbihfKXtmb2N1cy5oZWlnaHQoXyk7fX0sXG4gICAgICAgIGJydXNoRXh0ZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBmb2N1cy5icnVzaEV4dGVudCgpO30sIHNldDogZnVuY3Rpb24oXyl7Zm9jdXMuYnJ1c2hFeHRlbnQoXyk7fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBtYXJnaW46IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIG1hcmdpbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgaWYgKF8udG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXJnaW4udG9wID0gXy50b3A7XG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wID0gXy50b3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJnaW4ucmlnaHQgID0gXy5yaWdodCAgIT09IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9PSB1bmRlZmluZWQgPyBfLmJvdHRvbSA6IG1hcmdpbi5ib3R0b207XG4gICAgICAgICAgICBtYXJnaW4ubGVmdCAgID0gXy5sZWZ0ICAgIT09IHVuZGVmaW5lZCA/IF8ubGVmdCAgIDogbWFyZ2luLmxlZnQ7XG4gICAgICAgIH19LFxuICAgICAgICBmb2N1c01hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gZm9jdXMubWFyZ2lufSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGZvY3VzLm1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBmb2N1cy5tYXJnaW4udG9wO1xuICAgICAgICAgICAgZm9jdXMubWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IGZvY3VzLm1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIGZvY3VzLm1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBmb2N1cy5tYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgZm9jdXMubWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IGZvY3VzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgZHVyYXRpb246IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IF87XG4gICAgICAgICAgICByZW5kZXJXYXRjaC5yZXNldChkdXJhdGlvbik7XG4gICAgICAgICAgICBzdGFja2VkLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHhBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHlBeGlzLmR1cmF0aW9uKGR1cmF0aW9uKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGNvbG9yOiAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gbnYudXRpbHMuZ2V0Q29sb3IoXyk7XG4gICAgICAgICAgICBsZWdlbmQuY29sb3IoY29sb3IpO1xuICAgICAgICAgICAgc3RhY2tlZC5jb2xvcihjb2xvcik7XG4gICAgICAgICAgICBmb2N1cy5jb2xvcihjb2xvcik7XG4gICAgICAgIH19LFxuICAgICAgICB4OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzdGFja2VkLngoKTt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgc3RhY2tlZC54KF8pO1xuICAgICAgICAgICAgZm9jdXMueChfKTtcbiAgICAgICAgfX0sXG4gICAgICAgIHk6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHN0YWNrZWQueSgpO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBzdGFja2VkLnkoXyk7XG4gICAgICAgICAgICBmb2N1cy55KF8pO1xuICAgICAgICB9fSxcbiAgICAgICAgcmlnaHRBbGlnbllBeGlzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiByaWdodEFsaWduWUF4aXM7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIHJpZ2h0QWxpZ25ZQXhpcyA9IF87XG4gICAgICAgICAgICB5QXhpcy5vcmllbnQoIHJpZ2h0QWxpZ25ZQXhpcyA/ICdyaWdodCcgOiAnbGVmdCcpO1xuICAgICAgICB9fSxcbiAgICAgICAgdXNlSW50ZXJhY3RpdmVHdWlkZWxpbmU6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHVzZUludGVyYWN0aXZlR3VpZGVsaW5lO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICB1c2VJbnRlcmFjdGl2ZUd1aWRlbGluZSA9ICEhXztcbiAgICAgICAgICAgIGNoYXJ0LmludGVyYWN0aXZlKCFfKTtcbiAgICAgICAgICAgIGNoYXJ0LnVzZVZvcm9ub2koIV8pO1xuICAgICAgICAgICAgc3RhY2tlZC5zY2F0dGVyLmludGVyYWN0aXZlKCFfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaGVyaXRPcHRpb25zKGNoYXJ0LCBzdGFja2VkKTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG5cbiAgICByZXR1cm4gY2hhcnQ7XG59O1xuXG5udi5tb2RlbHMuc3RhY2tlZEFyZWFXaXRoRm9jdXNDaGFydCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbnYubW9kZWxzLnN0YWNrZWRBcmVhQ2hhcnQoKVxuICAgIC5tYXJnaW4oeyBib3R0b206IDMwIH0pXG4gICAgLmZvY3VzRW5hYmxlKCB0cnVlICk7XG59O1xuLy8gYmFzZWQgb24gaHR0cDovL2JsLm9ja3Mub3JnL2tlcnJ5cm9kZGVuLzQ3N2MxYmZiMDgxYjc4M2Y4MGFkXG5udi5tb2RlbHMuc3VuYnVyc3QgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDB9XG4gICAgICAgICwgd2lkdGggPSA2MDBcbiAgICAgICAgLCBoZWlnaHQgPSA2MDBcbiAgICAgICAgLCBtb2RlID0gXCJjb3VudFwiXG4gICAgICAgICwgbW9kZXMgPSB7Y291bnQ6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIDE7IH0sIHZhbHVlOiBmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlIHx8IGQuc2l6ZSB9LCBzaXplOiBmdW5jdGlvbihkKSB7IHJldHVybiBkLnZhbHVlIHx8IGQuc2l6ZSB9fVxuICAgICAgICAsIGlkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApIC8vQ3JlYXRlIHNlbWktdW5pcXVlIElEIGluIGNhc2UgdXNlciBkb2Vzbid0IHNlbGVjdCBvbmVcbiAgICAgICAgLCBjb250YWluZXIgPSBudWxsXG4gICAgICAgICwgY29sb3IgPSBudi51dGlscy5kZWZhdWx0Q29sb3IoKVxuICAgICAgICAsIHNob3dMYWJlbHMgPSBmYWxzZVxuICAgICAgICAsIGxhYmVsRm9ybWF0ID0gZnVuY3Rpb24oZCl7aWYobW9kZSA9PT0gJ2NvdW50Jyl7cmV0dXJuIGQubmFtZSArICcgIycgKyBkLnZhbHVlfWVsc2V7cmV0dXJuIGQubmFtZSArICcgJyArIChkLnZhbHVlIHx8IGQuc2l6ZSl9fVxuICAgICAgICAsIGxhYmVsVGhyZXNob2xkID0gMC4wMlxuICAgICAgICAsIHNvcnQgPSBmdW5jdGlvbihkMSwgZDIpe3JldHVybiBkMS5uYW1lID4gZDIubmFtZTt9XG4gICAgICAgICwga2V5ID0gZnVuY3Rpb24oZCxpKXtyZXR1cm4gZC5uYW1lO31cbiAgICAgICAgLCBncm91cENvbG9yQnlQYXJlbnQgPSB0cnVlXG4gICAgICAgICwgZHVyYXRpb24gPSA1MDBcbiAgICAgICAgLCBkaXNwYXRjaCA9IGQzLmRpc3BhdGNoKCdjaGFydENsaWNrJywgJ2VsZW1lbnRDbGljaycsICdlbGVtZW50RGJsQ2xpY2snLCAnZWxlbWVudE1vdXNlbW92ZScsICdlbGVtZW50TW91c2VvdmVyJywgJ2VsZW1lbnRNb3VzZW91dCcsICdyZW5kZXJFbmQnKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gYXV4IGZ1bmN0aW9ucyBhbmQgc2V0dXBcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHggPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbMCwgMiAqIE1hdGguUEldKTtcbiAgICB2YXIgeSA9IGQzLnNjYWxlLnNxcnQoKTtcblxuICAgIHZhciBwYXJ0aXRpb24gPSBkMy5sYXlvdXQucGFydGl0aW9uKCkuc29ydChzb3J0KTtcblxuICAgIHZhciBub2RlLCBhdmFpbGFibGVXaWR0aCwgYXZhaWxhYmxlSGVpZ2h0LCByYWRpdXM7XG4gICAgdmFyIHByZXZQb3NpdGlvbnMgPSB7fTtcblxuICAgIHZhciBhcmMgPSBkMy5zdmcuYXJjKClcbiAgICAgICAgLnN0YXJ0QW5nbGUoZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigyICogTWF0aC5QSSwgeChkLngpKSkgfSlcbiAgICAgICAgLmVuZEFuZ2xlKGZ1bmN0aW9uKGQpIHtyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMiAqIE1hdGguUEksIHgoZC54ICsgZC5keCkpKSB9KVxuICAgICAgICAuaW5uZXJSYWRpdXMoZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLm1heCgwLCB5KGQueSkpIH0pXG4gICAgICAgIC5vdXRlclJhZGl1cyhmdW5jdGlvbihkKSB7cmV0dXJuIE1hdGgubWF4KDAsIHkoZC55ICsgZC5keSkpIH0pO1xuXG4gICAgZnVuY3Rpb24gcm90YXRpb25Ub0F2b2lkVXBzaWRlRG93bihkKSB7XG4gICAgICAgIHZhciBjZW50ZXJBbmdsZSA9IGNvbXB1dGVDZW50ZXJBbmdsZShkKTtcbiAgICAgICAgaWYoY2VudGVyQW5nbGUgPiA5MCl7XG4gICAgICAgICAgICByZXR1cm4gMTgwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlQ2VudGVyQW5nbGUoZCkge1xuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDIgKiBNYXRoLlBJLCB4KGQueCkpKTtcbiAgICAgICAgdmFyIGVuZEFuZ2xlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMiAqIE1hdGguUEksIHgoZC54ICsgZC5keCkpKTtcbiAgICAgICAgdmFyIGNlbnRlckFuZ2xlID0gKCgoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDIpICogKDE4MCAvIE1hdGguUEkpKSAtIDkwO1xuICAgICAgICByZXR1cm4gY2VudGVyQW5nbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVQZXJjZW50YWdlKGQpIHtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyICogTWF0aC5QSSwgeChkLngpKSk7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDIgKiBNYXRoLlBJLCB4KGQueCArIGQuZHgpKSk7XG4gICAgICAgIHJldHVybiAoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGFiZWxUaHJlc2hvbGRNYXRjaGVkKGQpIHtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyICogTWF0aC5QSSwgeChkLngpKSk7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDIgKiBNYXRoLlBJLCB4KGQueCArIGQuZHgpKSk7XG5cbiAgICAgICAgdmFyIHNpemUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICAgIHJldHVybiBzaXplID4gbGFiZWxUaHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgLy8gV2hlbiB6b29taW5nOiBpbnRlcnBvbGF0ZSB0aGUgc2NhbGVzLlxuICAgIGZ1bmN0aW9uIGFyY1R3ZWVuWm9vbShlLGkpIHtcbiAgICAgICAgdmFyIHhkID0gZDMuaW50ZXJwb2xhdGUoeC5kb21haW4oKSwgW25vZGUueCwgbm9kZS54ICsgbm9kZS5keF0pLFxuICAgICAgICB5ZCA9IGQzLmludGVycG9sYXRlKHkuZG9tYWluKCksIFtub2RlLnksIDFdKSxcbiAgICAgICAgeXIgPSBkMy5pbnRlcnBvbGF0ZSh5LnJhbmdlKCksIFtub2RlLnkgPyAyMCA6IDAsIHJhZGl1c10pO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIGFyYyhlKTt9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB4LmRvbWFpbih4ZCh0KSk7XG4gICAgICAgICAgICAgICAgeS5kb21haW4oeWQodCkpLnJhbmdlKHlyKHQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJjKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFyY1R3ZWVuVXBkYXRlKGQpIHtcbiAgICAgICAgdmFyIGlwbyA9IGQzLmludGVycG9sYXRlKHt4OiBkLngwLCBkeDogZC5keDAsIHk6IGQueTAsIGR5OiBkLmR5MH0sIGQpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdmFyIGIgPSBpcG8odCk7XG5cbiAgICAgICAgICAgIGQueDAgPSBiLng7XG4gICAgICAgICAgICBkLmR4MCA9IGIuZHg7XG4gICAgICAgICAgICBkLnkwID0gYi55O1xuICAgICAgICAgICAgZC5keTAgPSBiLmR5O1xuXG4gICAgICAgICAgICByZXR1cm4gYXJjKGIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVByZXZQb3NpdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBrID0ga2V5KG5vZGUpO1xuICAgICAgICBpZighIHByZXZQb3NpdGlvbnNba10pIHByZXZQb3NpdGlvbnNba10gPSB7fTtcbiAgICAgICAgdmFyIHBQID0gcHJldlBvc2l0aW9uc1trXTtcbiAgICAgICAgcFAuZHggPSBub2RlLmR4O1xuICAgICAgICBwUC54ID0gbm9kZS54O1xuICAgICAgICBwUC5keSA9IG5vZGUuZHk7XG4gICAgICAgIHBQLnkgPSBub2RlLnk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RvcmVSZXRyaWV2ZVByZXZQb3NpdGlvbnMobm9kZXMpIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihuKXtcbiAgICAgICAgICAgIHZhciBrID0ga2V5KG4pO1xuICAgICAgICAgICAgdmFyIHBQID0gcHJldlBvc2l0aW9uc1trXTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coayxuLHBQKTtcbiAgICAgICAgICAgIGlmKCBwUCApe1xuICAgICAgICAgICAgICAgIG4uZHgwID0gcFAuZHg7XG4gICAgICAgICAgICAgICAgbi54MCA9IHBQLng7XG4gICAgICAgICAgICAgICAgbi5keTAgPSBwUC5keTtcbiAgICAgICAgICAgICAgICBuLnkwID0gcFAueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG4uZHgwID0gbi5keDtcbiAgICAgICAgICAgICAgICBuLngwID0gbi54O1xuICAgICAgICAgICAgICAgIG4uZHkwID0gbi5keTtcbiAgICAgICAgICAgICAgICBuLnkwID0gbi55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUHJldlBvc2l0aW9uKG4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6b29tQ2xpY2soZCkge1xuICAgICAgICB2YXIgbGFiZWxzID0gY29udGFpbmVyLnNlbGVjdEFsbCgndGV4dCcpXG4gICAgICAgIHZhciBwYXRoID0gY29udGFpbmVyLnNlbGVjdEFsbCgncGF0aCcpXG5cbiAgICAgICAgLy8gZmFkZSBvdXQgYWxsIHRleHQgZWxlbWVudHNcbiAgICAgICAgbGFiZWxzLnRyYW5zaXRpb24oKS5hdHRyKFwib3BhY2l0eVwiLDApO1xuXG4gICAgICAgIC8vIHRvIGFsbG93IHJlZmVyZW5jZSB0byB0aGUgbmV3IGNlbnRlciBub2RlXG4gICAgICAgIG5vZGUgPSBkO1xuXG4gICAgICAgIHBhdGgudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oZHVyYXRpb24pXG4gICAgICAgICAgICAuYXR0clR3ZWVuKFwiZFwiLCBhcmNUd2Vlblpvb20pXG4gICAgICAgICAgICAuZWFjaCgnZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIC8vIHBhcnRpYWxseSB0YWtlbiBmcm9tIGhlcmU6IGh0dHA6Ly9ibC5vY2tzLm9yZy9tZXRtYWplci81NDgwMzA3XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGFuaW1hdGVkIGVsZW1lbnQncyBkYXRhIGUgbGllcyB3aXRoaW4gdGhlIHZpc2libGUgYW5nbGUgc3BhbiBnaXZlbiBpbiBkXG4gICAgICAgICAgICAgICAgaWYoZS54ID49IGQueCAmJiBlLnggPCAoZC54ICsgZC5keCkgKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoZS5kZXB0aCA+PSBkLmRlcHRoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBhIHNlbGVjdGlvbiBvZiB0aGUgYXNzb2NpYXRlZCB0ZXh0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZDMuc2VsZWN0KHRoaXMucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJjVGV4dCA9IHBhcmVudE5vZGUuc2VsZWN0KCd0ZXh0Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhZGUgaW4gdGhlIHRleHQgZWxlbWVudCBhbmQgcmVjYWxjdWxhdGUgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmNUZXh0LnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIC50ZXh0KCBmdW5jdGlvbihlKXtyZXR1cm4gbGFiZWxGb3JtYXQoZSkgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKFwib3BhY2l0eVwiLCBmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsYWJlbFRocmVzaG9sZE1hdGNoZWQoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZS5kZXB0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAod2lkdGggLyAyICogLSAxKSArIFwiLDApXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlLmRlcHRoID09PSBkLmRlcHRoKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHkoZS55KSArIDUpICsgXCIsMClcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJBbmdsZSA9IGNvbXB1dGVDZW50ZXJBbmdsZShlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvdGF0aW9uID0gcm90YXRpb25Ub0F2b2lkVXBzaWRlRG93bihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSgnKyBjZW50ZXJBbmdsZSArJyl0cmFuc2xhdGUoJyArICh5KGUueSkgKyA1KSArICcsMCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyb3RhdGUoJysgY2VudGVyQW5nbGUgKycpdHJhbnNsYXRlKCcgKyAoeShlLnkpICsgd2lkdGggKyA1KSArICcsMClyb3RhdGUoJyArIHJvdGF0aW9uICsgJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY2hhcnQgZnVuY3Rpb25cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHZhciByZW5kZXJXYXRjaCA9IG52LnV0aWxzLnJlbmRlcldhdGNoKGRpc3BhdGNoKTtcblxuICAgIGZ1bmN0aW9uIGNoYXJ0KHNlbGVjdGlvbikge1xuICAgICAgICByZW5kZXJXYXRjaC5yZXNldCgpO1xuXG4gICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGQzLnNlbGVjdCh0aGlzKTtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoID0gbnYudXRpbHMuYXZhaWxhYmxlV2lkdGgod2lkdGgsIGNvbnRhaW5lciwgbWFyZ2luKTtcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IG52LnV0aWxzLmF2YWlsYWJsZUhlaWdodChoZWlnaHQsIGNvbnRhaW5lciwgbWFyZ2luKTtcbiAgICAgICAgICAgIHJhZGl1cyA9IE1hdGgubWluKGF2YWlsYWJsZVdpZHRoLCBhdmFpbGFibGVIZWlnaHQpIC8gMjtcblxuICAgICAgICAgICAgeS5yYW5nZShbMCwgcmFkaXVzXSk7XG5cbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhaW5lcnMgYW5kIHNrZWxldG9uIG9mIGNoYXJ0XG4gICAgICAgICAgICB2YXIgd3JhcCA9IGNvbnRhaW5lci5zZWxlY3QoJ2cubnZkMy5udi13cmFwLm52LXN1bmJ1cnN0Jyk7XG4gICAgICAgICAgICBpZiggIXdyYXBbMF1bMF0gKSB7XG4gICAgICAgICAgICAgICAgd3JhcCA9IGNvbnRhaW5lci5hcHBlbmQoJ2cnKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCAnbnZkMyBudi13cmFwIG52LXN1bmJ1cnN0IG52LWNoYXJ0LScgKyBpZClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICgoYXZhaWxhYmxlV2lkdGggLyAyKSArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSArICcsJyArICgoYXZhaWxhYmxlSGVpZ2h0IC8gMikgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSkgKyAnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cmFwLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArICgoYXZhaWxhYmxlV2lkdGggLyAyKSArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KSArICcsJyArICgoYXZhaWxhYmxlSGVpZ2h0IC8gMikgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSkgKyAnKScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIub24oJ2NsaWNrJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaC5jaGFydENsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIHBvczogZDMuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhcnRpdGlvbi52YWx1ZShtb2Rlc1ttb2RlXSB8fCBtb2Rlc1tcImNvdW50XCJdKTtcblxuICAgICAgICAgICAgLy9yZXZlcnNlIHRoZSBkcmF3aW5nIG9yZGVyIHNvIHRoYXQgdGhlIGxhYmVscyBvZiBpbm5lclxuICAgICAgICAgICAgLy9hcmNzIGFyZSBkcmF3biBvbiB0b3Agb2YgdGhlIG91dGVyIGFyY3MuXG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBwYXJ0aXRpb24ubm9kZXMoZGF0YVswXSkucmV2ZXJzZSgpXG5cbiAgICAgICAgICAgIHN0b3JlUmV0cmlldmVQcmV2UG9zaXRpb25zKG5vZGVzKTtcbiAgICAgICAgICAgIHZhciBjRyA9IHdyYXAuc2VsZWN0QWxsKCcuYXJjLWNvbnRhaW5lcicpLmRhdGEobm9kZXMsIGtleSlcblxuICAgICAgICAgICAgLy9oYW5kbGUgbmV3IGRhdGFwb2ludHNcbiAgICAgICAgICAgIHZhciBjR0UgPSBjRy5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsJ2FyYy1jb250YWluZXInKVxuXG4gICAgICAgICAgICBjR0UuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBhcmMpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZC5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZ3JvdXBDb2xvckJ5UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sb3IoKGQuY2hpbGRyZW4gPyBkIDogZC5wYXJlbnQpLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yKGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiNGRkZcIilcbiAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgICAgICB6b29tQ2xpY2soZCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoJ2hvdmVyJywgdHJ1ZSkuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaC5lbGVtZW50TW91c2VvdmVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwiZmlsbFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGNvbXB1dGVOb2RlUGVyY2VudGFnZShkKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbignbW91c2VvdXQnLCBmdW5jdGlvbihkLGkpe1xuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZCgnaG92ZXInLCBmYWxzZSkuc3R5bGUoJ29wYWNpdHknLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2guZWxlbWVudE1vdXNlb3V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGQsaSl7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoLmVsZW1lbnRNb3VzZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8vSXRlcmF0aW5nIHZpYSBlYWNoIGFuZCBzZWxlY3RpbmcgYmFzZWQgb24gdGhlIHRoaXNcbiAgICAgICAgICAgIC8vL21ha2VzIGl0IHdvcmsgLi4uIGEgY0cuc2VsZWN0QWxsKCdwYXRoJykgZG9lc24ndC5cbiAgICAgICAgICAgIC8vL1dpdGhvdXQgaXRlcmF0aW9uIHRoZSBkYXRhIChpbiB0aGUgZWxlbWVudCkgZGlkbid0IHVwZGF0ZS5cbiAgICAgICAgICAgIGNHLmVhY2goZnVuY3Rpb24oZCl7XG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnNlbGVjdCgncGF0aCcpXG4gICAgICAgICAgICAgICAgICAgIC50cmFuc2l0aW9uKClcbiAgICAgICAgICAgICAgICAgICAgLmR1cmF0aW9uKGR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICAuYXR0clR3ZWVuKCdkJywgYXJjVHdlZW5VcGRhdGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmKHNob3dMYWJlbHMpe1xuICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGxhYmVscyBmaXJzdCBhbmQgYWRkIHRoZW0gYmFja1xuICAgICAgICAgICAgICAgIGNHLnNlbGVjdEFsbCgndGV4dCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy90aGlzIHdheSBsYWJlbHMgYXJlIG9uIHRvcCBvZiBuZXdseSBhZGRlZCBhcmNzXG4gICAgICAgICAgICAgICAgY0cuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgICAgICAgICAgLnRleHQoIGZ1bmN0aW9uKGUpeyByZXR1cm4gbGFiZWxGb3JtYXQoZSl9KVxuICAgICAgICAgICAgICAgICAgICAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGFiZWxUaHJlc2hvbGRNYXRjaGVkKGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRCQm94KCkud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkLmRlcHRoID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJyb3RhdGUoMCl0cmFuc2xhdGUoXCIgKyAod2lkdGggLyAyICogLTEpICsgXCIsMClcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJBbmdsZSA9IGNvbXB1dGVDZW50ZXJBbmdsZShkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm90YXRpb24gPSByb3RhdGlvblRvQXZvaWRVcHNpZGVEb3duKGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3JvdGF0ZSgnKyBjZW50ZXJBbmdsZSArJyl0cmFuc2xhdGUoJyArICh5KGQueSkgKyA1KSArICcsMCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdyb3RhdGUoJysgY2VudGVyQW5nbGUgKycpdHJhbnNsYXRlKCcgKyAoeShkLnkpICsgd2lkdGggKyA1KSArICcsMClyb3RhdGUoJyArIHJvdGF0aW9uICsgJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vem9vbSBvdXQgdG8gdGhlIGNlbnRlciB3aGVuIHRoZSBkYXRhIGlzIHVwZGF0ZWQuXG4gICAgICAgICAgICB6b29tQ2xpY2sobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0pXG5cblxuICAgICAgICAgICAgLy9yZW1vdmUgdW5tYXRjaGVkIGVsZW1lbnRzIC4uLlxuICAgICAgICAgICAgY0cuZXhpdCgpXG4gICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5kdXJhdGlvbihkdXJhdGlvbilcbiAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsMClcbiAgICAgICAgICAgICAgICAuZWFjaCgnZW5kJyxmdW5jdGlvbihkKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBrZXkoZCk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb3NpdGlvbnNba10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgcmVuZGVyV2F0Y2gucmVuZGVyRW5kKCdzdW5idXJzdCBpbW1lZGlhdGUnKTtcbiAgICAgICAgcmV0dXJuIGNoYXJ0O1xuICAgIH1cblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRXhwb3NlIFB1YmxpYyBWYXJpYWJsZXNcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5vcHRpb25zID0gbnYudXRpbHMub3B0aW9uc0Z1bmMuYmluZChjaGFydCk7XG5cbiAgICBjaGFydC5fb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoe30sIHtcbiAgICAgICAgLy8gc2ltcGxlIG9wdGlvbnMsIGp1c3QgZ2V0L3NldCB0aGUgbmVjZXNzYXJ5IHZhbHVlc1xuICAgICAgICB3aWR0aDogICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiB3aWR0aDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe3dpZHRoPV87fX0sXG4gICAgICAgIGhlaWdodDogICAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGhlaWdodDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2hlaWdodD1fO319LFxuICAgICAgICBtb2RlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtb2RlO30sIHNldDogZnVuY3Rpb24oXyl7bW9kZT1fO319LFxuICAgICAgICBpZDogICAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBpZDt9LCBzZXQ6IGZ1bmN0aW9uKF8pe2lkPV87fX0sXG4gICAgICAgIGR1cmF0aW9uOiAgIHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGR1cmF0aW9uO30sIHNldDogZnVuY3Rpb24oXyl7ZHVyYXRpb249Xzt9fSxcbiAgICAgICAgZ3JvdXBDb2xvckJ5UGFyZW50OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBncm91cENvbG9yQnlQYXJlbnQ7fSwgc2V0OiBmdW5jdGlvbihfKXtncm91cENvbG9yQnlQYXJlbnQ9ISFfO319LFxuICAgICAgICBzaG93TGFiZWxzOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBzaG93TGFiZWxzO30sIHNldDogZnVuY3Rpb24oXyl7c2hvd0xhYmVscz0hIV99fSxcbiAgICAgICAgbGFiZWxGb3JtYXQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGxhYmVsRm9ybWF0O30sIHNldDogZnVuY3Rpb24oXyl7bGFiZWxGb3JtYXQ9X319LFxuICAgICAgICBsYWJlbFRocmVzaG9sZDoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbGFiZWxUaHJlc2hvbGQ7fSwgc2V0OiBmdW5jdGlvbihfKXtsYWJlbFRocmVzaG9sZD1ffX0sXG4gICAgICAgIHNvcnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNvcnQ7fSwgc2V0OiBmdW5jdGlvbihfKXtzb3J0PV99fSxcbiAgICAgICAga2V5OiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBrZXk7fSwgc2V0OiBmdW5jdGlvbihfKXtrZXk9X319LFxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgcmVxdWlyZSBleHRyYSBsb2dpYyBpbiB0aGUgc2V0dGVyXG4gICAgICAgIG1hcmdpbjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbWFyZ2luO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBtYXJnaW4udG9wICAgID0gXy50b3AgICAgIT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9IHVuZGVmaW5lZCA/IF8ucmlnaHQgIDogbWFyZ2luLnJpZ2h0O1xuICAgICAgICAgICAgbWFyZ2luLmJvdHRvbSA9IF8uYm90dG9tICE9IHVuZGVmaW5lZCA/IF8uYm90dG9tIDogbWFyZ2luLmJvdHRvbTtcbiAgICAgICAgICAgIG1hcmdpbi5sZWZ0ICAgPSBfLmxlZnQgICAhPSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICB9fSxcbiAgICAgICAgY29sb3I6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIGNvbG9yO30sIHNldDogZnVuY3Rpb24oXyl7XG4gICAgICAgICAgICBjb2xvcj1udi51dGlscy5nZXRDb2xvcihfKTtcbiAgICAgICAgfX1cbiAgICB9KTtcblxuICAgIG52LnV0aWxzLmluaXRPcHRpb25zKGNoYXJ0KTtcbiAgICByZXR1cm4gY2hhcnQ7XG59O1xubnYubW9kZWxzLnN1bmJ1cnN0Q2hhcnQgPSBmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHVibGljIFZhcmlhYmxlcyB3aXRoIERlZmF1bHQgU2V0dGluZ3NcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgdmFyIHN1bmJ1cnN0ID0gbnYubW9kZWxzLnN1bmJ1cnN0KCk7XG4gICAgdmFyIHRvb2x0aXAgPSBudi5tb2RlbHMudG9vbHRpcCgpO1xuXG4gICAgdmFyIG1hcmdpbiA9IHt0b3A6IDMwLCByaWdodDogMjAsIGJvdHRvbTogMjAsIGxlZnQ6IDIwfVxuICAgICAgICAsIHdpZHRoID0gbnVsbFxuICAgICAgICAsIGhlaWdodCA9IG51bGxcbiAgICAgICAgLCBjb2xvciA9IG52LnV0aWxzLmRlZmF1bHRDb2xvcigpXG4gICAgICAgICwgc2hvd1Rvb2x0aXBQZXJjZW50ID0gZmFsc2VcbiAgICAgICAgLCBpZCA9IE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMClcbiAgICAgICAgLCBkZWZhdWx0U3RhdGUgPSBudWxsXG4gICAgICAgICwgbm9EYXRhID0gbnVsbFxuICAgICAgICAsIGR1cmF0aW9uID0gMjUwXG4gICAgICAgICwgZGlzcGF0Y2ggPSBkMy5kaXNwYXRjaCgnc3RhdGVDaGFuZ2UnLCAnY2hhbmdlU3RhdGUnLCdyZW5kZXJFbmQnKTtcblxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBQcml2YXRlIFZhcmlhYmxlc1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB2YXIgcmVuZGVyV2F0Y2ggPSBudi51dGlscy5yZW5kZXJXYXRjaChkaXNwYXRjaCk7XG5cbiAgICB0b29sdGlwXG4gICAgICAgIC5kdXJhdGlvbigwKVxuICAgICAgICAuaGVhZGVyRW5hYmxlZChmYWxzZSlcbiAgICAgICAgLnZhbHVlRm9ybWF0dGVyKGZ1bmN0aW9uKGQpe3JldHVybiBkO30pO1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBDaGFydCBmdW5jdGlvblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICBmdW5jdGlvbiBjaGFydChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoKTtcbiAgICAgICAgcmVuZGVyV2F0Y2gubW9kZWxzKHN1bmJ1cnN0KTtcblxuICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICBudi51dGlscy5pbml0U1ZHKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IG52LnV0aWxzLmF2YWlsYWJsZVdpZHRoKHdpZHRoLCBjb250YWluZXIsIG1hcmdpbik7XG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlSGVpZ2h0ID0gbnYudXRpbHMuYXZhaWxhYmxlSGVpZ2h0KGhlaWdodCwgY29udGFpbmVyLCBtYXJnaW4pO1xuXG4gICAgICAgICAgICBjaGFydC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pLmNhbGwoY2hhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydC5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAgICAgICAgIC8vIERpc3BsYXkgTm8gRGF0YSBtZXNzYWdlIGlmIHRoZXJlJ3Mgbm90aGluZyB0byBzaG93LlxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG52LnV0aWxzLm5vRGF0YShjaGFydCwgY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZWxlY3RBbGwoJy5udi1ub0RhdGEnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3VuYnVyc3Qud2lkdGgoYXZhaWxhYmxlV2lkdGgpLmhlaWdodChhdmFpbGFibGVIZWlnaHQpLm1hcmdpbihtYXJnaW4pO1xuICAgICAgICAgICAgY29udGFpbmVyLmNhbGwoc3VuYnVyc3QpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW5kZXJXYXRjaC5yZW5kZXJFbmQoJ3N1bmJ1cnN0Q2hhcnQgaW1tZWRpYXRlJyk7XG4gICAgICAgIHJldHVybiBjaGFydDtcbiAgICB9XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV2ZW50IEhhbmRsaW5nL0Rpc3BhdGNoaW5nIChvdXQgb2YgY2hhcnQncyBzY29wZSlcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgc3VuYnVyc3QuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW92ZXIudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBldnQuc2VyaWVzID0ge1xuICAgICAgICAgICAga2V5OiBldnQuZGF0YS5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IChldnQuZGF0YS52YWx1ZSB8fCBldnQuZGF0YS5zaXplKSxcbiAgICAgICAgICAgIGNvbG9yOiBldnQuY29sb3IsXG4gICAgICAgICAgICBwZXJjZW50OiBldnQucGVyY2VudFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXNob3dUb29sdGlwUGVyY2VudCkge1xuICAgICAgICAgICAgZGVsZXRlIGV2dC5wZXJjZW50O1xuICAgICAgICAgICAgZGVsZXRlIGV2dC5zZXJpZXMucGVyY2VudDtcbiAgICAgICAgfVxuICAgICAgICB0b29sdGlwLmRhdGEoZXZ0KS5oaWRkZW4oZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgc3VuYnVyc3QuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW91dC50b29sdGlwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvb2x0aXAuaGlkZGVuKHRydWUpO1xuICAgIH0pO1xuXG4gICAgc3VuYnVyc3QuZGlzcGF0Y2gub24oJ2VsZW1lbnRNb3VzZW1vdmUudG9vbHRpcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB0b29sdGlwKCk7XG4gICAgfSk7XG5cbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIEV4cG9zZSBQdWJsaWMgVmFyaWFibGVzXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8vIGV4cG9zZSBjaGFydCdzIHN1Yi1jb21wb25lbnRzXG4gICAgY2hhcnQuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgICBjaGFydC5zdW5idXJzdCA9IHN1bmJ1cnN0O1xuICAgIGNoYXJ0LnRvb2x0aXAgPSB0b29sdGlwO1xuICAgIGNoYXJ0Lm9wdGlvbnMgPSBudi51dGlscy5vcHRpb25zRnVuYy5iaW5kKGNoYXJ0KTtcblxuICAgIC8vIHVzZSBPYmplY3QgZ2V0L3NldCBmdW5jdGlvbmFsaXR5IHRvIG1hcCBiZXR3ZWVuIHZhcnMgYW5kIGNoYXJ0IGZ1bmN0aW9uc1xuICAgIGNoYXJ0Ll9vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh7fSwge1xuICAgICAgICAvLyBzaW1wbGUgb3B0aW9ucywganVzdCBnZXQvc2V0IHRoZSBuZWNlc3NhcnkgdmFsdWVzXG4gICAgICAgIG5vRGF0YTogICAgICAgICAgICAge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gbm9EYXRhO30sICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbihfKXtub0RhdGE9Xzt9fSxcbiAgICAgICAgZGVmYXVsdFN0YXRlOiAgICAgICB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkZWZhdWx0U3RhdGU7fSwgICAgICAgICBzZXQ6IGZ1bmN0aW9uKF8pe2RlZmF1bHRTdGF0ZT1fO319LFxuICAgICAgICBzaG93VG9vbHRpcFBlcmNlbnQ6IHtnZXQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHNob3dUb29sdGlwUGVyY2VudDt9LCAgIHNldDogZnVuY3Rpb24oXyl7c2hvd1Rvb2x0aXBQZXJjZW50PV87fX0sXG5cbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IHJlcXVpcmUgZXh0cmEgbG9naWMgaW4gdGhlIHNldHRlclxuICAgICAgICBjb2xvcjoge2dldDogZnVuY3Rpb24oKXtyZXR1cm4gY29sb3I7fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIGNvbG9yID0gXztcbiAgICAgICAgICAgIHN1bmJ1cnN0LmNvbG9yKGNvbG9yKTtcbiAgICAgICAgfX0sXG4gICAgICAgIGR1cmF0aW9uOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBkdXJhdGlvbjt9LCBzZXQ6IGZ1bmN0aW9uKF8pe1xuICAgICAgICAgICAgZHVyYXRpb24gPSBfO1xuICAgICAgICAgICAgcmVuZGVyV2F0Y2gucmVzZXQoZHVyYXRpb24pO1xuICAgICAgICAgICAgc3VuYnVyc3QuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgICB9fSxcbiAgICAgICAgbWFyZ2luOiB7Z2V0OiBmdW5jdGlvbigpe3JldHVybiBtYXJnaW47fSwgc2V0OiBmdW5jdGlvbihfKXtcbiAgICAgICAgICAgIG1hcmdpbi50b3AgICAgPSBfLnRvcCAgICAhPT0gdW5kZWZpbmVkID8gXy50b3AgICAgOiBtYXJnaW4udG9wO1xuICAgICAgICAgICAgbWFyZ2luLnJpZ2h0ICA9IF8ucmlnaHQgICE9PSB1bmRlZmluZWQgPyBfLnJpZ2h0ICA6IG1hcmdpbi5yaWdodDtcbiAgICAgICAgICAgIG1hcmdpbi5ib3R0b20gPSBfLmJvdHRvbSAhPT0gdW5kZWZpbmVkID8gXy5ib3R0b20gOiBtYXJnaW4uYm90dG9tO1xuICAgICAgICAgICAgbWFyZ2luLmxlZnQgICA9IF8ubGVmdCAgICE9PSB1bmRlZmluZWQgPyBfLmxlZnQgICA6IG1hcmdpbi5sZWZ0O1xuICAgICAgICAgICAgc3VuYnVyc3QubWFyZ2luKG1hcmdpbik7XG4gICAgICAgIH19XG4gICAgfSk7XG4gICAgbnYudXRpbHMuaW5oZXJpdE9wdGlvbnMoY2hhcnQsIHN1bmJ1cnN0KTtcbiAgICBudi51dGlscy5pbml0T3B0aW9ucyhjaGFydCk7XG4gICAgcmV0dXJuIGNoYXJ0O1xuXG59O1xuXG5udi52ZXJzaW9uID0gXCIxLjguNVwiO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW52LmQzLmpzLm1hcCJdfQ=="}